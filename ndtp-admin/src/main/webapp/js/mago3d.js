/* eslint-env jquery */
'use strict';

/**
 * An API that interacts with the on-screen UI. Class name to be modified by APIGateWay or API class
 * @class MagoFacade
 */
/**
 * mago3d 활성화/비활성화
 * @param {ManagerFactory} managerFactoryInstance 
 * @param {Boolean} isShow true = show, false = hide
 */
function changeMagoStateAPI(managerFactoryInstance, isShow) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeMagoState");
	api.setMagoEnable(isShow);
	managerFactoryInstance.callAPI(api);
};

/**
 * Label show/hide
 * @param {ManagerFactory} managerFactoryInstance 
 * @param {Boolean} isShow true = show, false = hide
 */
function changeLabelAPI(managerFactoryInstance, isShow) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeLabel");
	api.setShowLabelInfo(isShow);
	managerFactoryInstance.callAPI(api);
}

/**
 * Origin show/hide
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} isShow true = show, false = hide
 */
function changeOriginAPI(managerFactoryInstance, isShow)
{
	if (managerFactoryInstance === null) { return; }

	var api = new Mago3D.API("changeOrigin");
	api.setShowOrigin(isShow);
	managerFactoryInstance.callAPI(api);
}

/**
 * boundingBox show/hide
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} isShow true = show, false = hide
 */
function changeBoundingBoxAPI(managerFactoryInstance, isShow) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeBoundingBox");
	api.setShowBoundingBox(isShow);
	managerFactoryInstance.callAPI(api);
}

/**
 * 속성값에 의한 가시화 유무설정
 * 삭제 예정
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} isShow true = 표시, false = 비표시
 */
function changePropertyRenderingAPI(managerFactoryInstance, isShow, projectId, property) 
{
	if (managerFactoryInstance === null) { return; } 
		
	var api = new Mago3D.API("changePropertyRendering");
	api.setShowShadow(isShow);
	api.setProjectId(projectId);
	api.setProperty(property);
	managerFactoryInstance.callAPI(api);
}

/**
 * 그림자 표시/비표시
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} isShow true = 활성화, false = 비활성화
 */
function changeShadowAPI(managerFactoryInstance, isShow) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeShadow");
	api.setShowShadow(isShow);
	managerFactoryInstance.callAPI(api);
}

/**
 * color 변경
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId 프로젝트 아이디
 * @param {string} dataKey data key
 * @param {string} objectIds object id. 복수개의 경우 , 로 입력
 * @param {string} property 속성값 예)isMain=true
 * @param {string} color R, G, B 색깔을 ',' 로 연결한 string 값을 받음.
 */
function changeColorAPI(managerFactoryInstance, projectId, dataKey, objectIds, property, color) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeColor");
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	api.setObjectIds(objectIds);
	api.setProperty(property);
	api.setColor(color);
	managerFactoryInstance.callAPI(api);
}

/**
 * Object literal with change Location And Rotation animation option.
 * @typedef {Object} animationOption
 * @property {string} dutaion optional. 
 * @property {Boolean} autoChangeRotation optional. If this option is true, your heading, pitch will be ignore, Heading and pitch changes according to the direction.
 */

/**
 * location and rotation 변경
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId
 * @param {string} dataKey
 * @param {string} latitude 위도
 * @param {string} longitude 경도
 * @param {string} height 높이
 * @param {string} heading 좌, 우
 * @param {string} pitch 위, 아래
 * @param {string} roll 좌, 우 기울기
 * @param {animationOption} animationOption animation option
 */
function changeLocationAndRotationAPI(managerFactoryInstance, projectId, dataKey, latitude, longitude, height, heading, pitch, roll, animationOption) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeLocationAndRotation");
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	api.setLatitude(latitude);
	api.setLongitude(longitude);
	api.setElevation(height);
	api.setHeading(heading);
	api.setPitch(pitch);
	api.setRoll(roll);
	api.setAnimationOption(animationOption);
	managerFactoryInstance.callAPI(api);
}

/**
 * 마우스 클릭 객체 이동 대상 변경
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} objectMoveMode 0 = All, 1 = object, 2 = None
 */
function changeObjectMoveAPI(managerFactoryInstance, objectMoveMode) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeObjectMove");
	api.setObjectMoveMode(objectMoveMode);
	managerFactoryInstance.callAPI(api);
}

/**
 * 마우스로 이동한 객체 정보를 브라우저내 저장
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} objectMoveMode 0 = All, 1 = object, 2 = None
 */
function saveObjectMoveAPI(managerFactoryInstance, objectMoveMode) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("saveObjectMove");
	api.setObjectMoveMode(objectMoveMode);
	managerFactoryInstance.callAPI(api);
}

/**
 * 브라우저내 모든 마우스 이동 정보를 삭제
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} objectMoveMode 0 = All, 1 = object, 2 = None
 */
function deleteAllObjectMoveAPI(managerFactoryInstance, objectMoveMode) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("deleteAllObjectMove");
	api.setObjectMoveMode(objectMoveMode);
	managerFactoryInstance.callAPI(api);
}

/**
 * 브라우저내 모든 색깔 변경 이력을 삭제
 * @param {ManagerFactory} managerFactoryInstance
 */
function deleteAllChangeColorAPI(managerFactoryInstance) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("deleteAllChangeColor");
	managerFactoryInstance.callAPI(api);
}

/**
 * 이슈 등록 활성화 유무
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} flag true = 활성화, false = 비활성화
 */
function changeInsertIssueModeAPI(managerFactoryInstance, flag) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeInsertIssueMode");
	api.setIssueInsertEnable(flag);
	managerFactoryInstance.callAPI(api);
}

/**
 * object 정보 표시 활성화 유무
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} flag true = 활성화, false = 비활성화
 */
function changeObjectInfoViewModeAPI(managerFactoryInstance, flag) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeObjectInfoViewMode");
	api.setObjectInfoViewEnable(flag);
	managerFactoryInstance.callAPI(api);
}

/**
 * Object Occlusion culling
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} flag true = 활성화, false = 비활성화
 * @param {string} dataKey
 */
function changeOcclusionCullingAPI(managerFactoryInstance, flag, dataKey) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeOcclusionCulling");
	api.setOcclusionCullingEnable(flag);
	api.setDataKey(dataKey);
	managerFactoryInstance.callAPI(api);
}

/**
 * 1인칭, 3인칭 모드 개발중...
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} flag true = 활성화, false = 비활성화
 */
function changeFPVModeAPI(managerFactoryInstance, flag)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeFPVMode");
	api.setFPVMode(flag);
	managerFactoryInstance.callAPI(api);
}

/**
 * 1인칭, 3인칭 모드 개발중...
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} flag true = 활성화, false = 비활성화
 */
function changeMagoModeAPI(managerFactoryInstance, flag)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeMagoMode");
	api.setMagoMode(flag);
	managerFactoryInstance.callAPI(api);
}

/**
 * 현재 위치 근처 issue list. false인 경우 clear
 * 삭제 예정
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} flag true = 활성화, false = 비활성화
 */
function changeNearGeoIssueListViewModeAPI(managerFactoryInstance, flag) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeNearGeoIssueListViewMode");
	api.setNearGeoIssueListEnable(flag);
	managerFactoryInstance.callAPI(api);
}

/**
 * TODO 이건 위에 이슈 등록 활성화, 비활성화 api로 통합이 가능할거 같음
 * issue 등록 geo 정보 관련 상태 변경
 * 확인 필요
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} insertIssueState 이슈 등록 좌표 상태
 */
function changeInsertIssueStateAPI(managerFactoryInstance, insertIssueState) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeInsertIssueState");
	api.setInsertIssueState(insertIssueState);
	managerFactoryInstance.callAPI(api);
}

/**
 * LOD 설정을 변경
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} lod0DistInMeters
 * @param {string} lod1DistInMeters
 * @param {string} lod2DistInMeters
 * @param {string} lod3DistInMeters
 * @param {string} lod4DistInMeters
 * @param {string} lod5DistInMeters
 */
function changeLodAPI(managerFactoryInstance, lod0DistInMeters, lod1DistInMeters, lod2DistInMeters, lod3DistInMeters, lod4DistInMeters, lod5DistInMeters)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeLod");
	api.setLod0DistInMeters(lod0DistInMeters);
	api.setLod1DistInMeters(lod1DistInMeters);
	api.setLod2DistInMeters(lod2DistInMeters);
	api.setLod3DistInMeters(lod3DistInMeters);
	api.setLod4DistInMeters(lod4DistInMeters);
	api.setLod5DistInMeters(lod5DistInMeters);
	managerFactoryInstance.callAPI(api);
}

/**
 * Lighting 설정
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} ambientReflectionCoef
 * @param {string} diffuseReflectionCoef
 * @param {string} specularReflectionCoef
 * @param {string} ambientColor
 * @param {string} specularColor
 */
function changeLightingAPI(managerFactoryInstance, ambientReflectionCoef, diffuseReflectionCoef, specularReflectionCoef, ambientColor, specularColor)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeLighting");
	api.setAmbientReflectionCoef(ambientReflectionCoef);
	api.setDiffuseReflectionCoef(diffuseReflectionCoef);
	api.setSpecularReflectionCoef(specularReflectionCoef);
	api.setAmbientColor(ambientColor);
	api.setSpecularColor(specularColor);
	managerFactoryInstance.callAPI(api);
}

/**
 * SSAO Radius 설정
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} ssaoRadius
 */
function changeSsaoRadiusAPI(managerFactoryInstance, ssaoRadius)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeSsaoRadius");
	api.setSsaoRadius(ssaoRadius);
	managerFactoryInstance.callAPI(api);
}

/**
 * 모든 f4d 데이터를 삭제, 비표시
 * @param {ManagerFactory} managerFactoryInstance
 */
function clearAllDataAPI(managerFactoryInstance)
{	
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("clearAllData");
	Mago3D.MagoConfig.clearAllData();
	managerFactoryInstance.callAPI(api);
}

/**
 * pin image를 그림
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} drawType 이미지를 그리는 유형 0 : DB, 1 : 이슈등록
 * @param {string} issue_id 이슈 고유키
 * @param {string} issue_type 이슈 고유키
 * @param {string} data_key 데이터 고유키
 * @param {string} latitude 데이터 고유키
 * @param {string} longitude 데이터 고유키
 * @param {string} height 데이터 고유키
 */
function drawInsertIssueImageAPI(managerFactoryInstance, drawType, issue_id, issue_type, data_key, latitude, longitude, height) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("drawInsertIssueImage");
	api.setDrawType(drawType);
	api.setIssueId(issue_id);
	api.setIssueId(issue_type);
	api.setDataKey(data_key);
	api.setLatitude(latitude);
	api.setLongitude(longitude);
	api.setElevation(height);
	managerFactoryInstance.callAPI(api);
}

/**
 * 해당 프로젝트를 로딩하고 이동하기
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project id
 * @param {string} latitude 데이터 고유키
 * @param {string} longitude 데이터 고유키
 * @param {string} height 데이터 고유키
 * @param {string} duration 이동하는 시간
 */
function gotoProjectAPI(managerFactoryInstance, projectId, projectData, projectDataFolder, longitude, latitude, height, duration) 
{
	if (managerFactoryInstance === null) { return; } 
	
	Mago3D.MagoConfig.setData(Mago3D.CODE.PROJECT_ID_PREFIX + projectId, projectData);
	Mago3D.MagoConfig.setProjectDataFolder(Mago3D.CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder, projectDataFolder);
	
	var api = new Mago3D.API("gotoProject");
	api.setProjectId(projectId);
	api.setProjectDataFolder(projectDataFolder);
	api.setLatitude(latitude);
	api.setLongitude(longitude);
	api.setElevation(height);
	api.setDuration(duration);
	managerFactoryInstance.callAPI(api);
}

/**
 * 해당 프로젝트를 로딩하고 Issue 등록 지점으로 이동하기
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project id
 * @param {string} issueId issue id
 * @param {string} issueType issue type
 * @param {string} latitude 데이터 고유키
 * @param {string} longitude 데이터 고유키
 * @param {string} height 데이터 고유키
 * @param {string} duration 이동하는 시간
 */
function gotoIssueAPI(managerFactoryInstance, projectId, projectData, projectDataFolder, issueId, issueType, longitude, latitude, height, duration)
{
	if (managerFactoryInstance === null) { return; } 
	
	Mago3D.MagoConfig.setData(Mago3D.CODE.PROJECT_ID_PREFIX + projectId, projectData);
	Mago3D.MagoConfig.setProjectDataFolder(Mago3D.CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder, projectDataFolder);
	
	var api = new Mago3D.API("gotoIssue");
	api.setProjectId(projectId);
	api.setProjectDataFolder(projectDataFolder);
	api.setIssueId(issueId);
	api.setIssueType(issueType);
	api.setLatitude(latitude);
	api.setLongitude(longitude);
	api.setElevation(height);
	api.setDuration(duration);
	managerFactoryInstance.callAPI(api);
}

/**
 * 고려 소프트웨어: 바로가기
 */
function gotoFlyAPI(managerFactoryInstance, longitude, latitude, height, duration)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("gotoFly");
	api.setLongitude(longitude);
	api.setLatitude(latitude);
	api.setElevation(height);
	api.setDuration(duration);
	managerFactoryInstance.callAPI(api);
}

/**
 * 마우스를 사용할 수 없는 환경에서 버튼 이벤트로 대체
 * 삭제 예정
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} eventType 어떤 마우스 동작을 원하는지를 구분
 */
function mouseMoveAPI(managerFactoryInstance, eventType) 
{
	if (managerFactoryInstance === null) { return; } 
	
	managerFactoryInstance.mouseMove(eventType);
}

/**
 * 데이터 검색
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId 데이터 고유키
 * @param {string} dataKey 데이터 고유키
 */
function searchDataAPI(managerFactoryInstance, projectId, dataKey) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("searchData");
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	managerFactoryInstance.callAPI(api);
}

/**
 * 환경 설정 data Object에 key 값의 존재 유무를 판별
 * @param {string} key 검색 키
 * @param 
 */
function isDataExistAPI(key) 
{
	if (Mago3D.MagoConfig.isDataExist(key)) { return true; }
	else { return false; }
}

/**
 * 환경 설정 data map에서 key 값을 취득
 * @param {string} key 검색 키
 * @param 
 */
function getDataAPI(key) 
{
	return Mago3D.MagoConfig.getData(key);
}

/**
 * Data Key 를 이용하여 Geo Spatial Info를 취득
 * @param {ManagerFactory} managerFactoryInstance
 * @param {String} projectId 고유키
 * @param {String} dataKey Data 고유키
 * @param
 */
function getDataInfoByDataKeyAPI(managerFactoryInstance, projectId, dataKey)
{
	if (managerFactoryInstance === null) { return; }

	var api = new Mago3D.API("getDataInfoByDataKey");
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	managerFactoryInstance.callAPI(api);
}

/**
 * 데이터를 Rendering
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Object[]} projectIdArray 프로젝트 이름들
 * @param {Object[]} projectDataArray 프로젝트 데이터들
 * @param {Object[]} projectDataFolderArray 프로젝트 f4d 파일 경로
 * @param 
 */
function drawAppendDataAPI(managerFactoryInstance, projectIdArray, projectDataArray, projectDataFolderArray) 
{
	if (managerFactoryInstance === null) { return; } 
	
	if (projectIdArray.length <= 0) { return; }
	
	var api = new Mago3D.API("drawAppendData");
	projectIdArray.forEach(function(dataName, index) 
	{
			
		Mago3D.MagoConfig.setData(Mago3D.CODE.PROJECT_ID_PREFIX + dataName, projectDataArray[index]);
		Mago3D.MagoConfig.setProjectDataFolder(Mago3D.CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolderArray[index], projectDataFolderArray[index]);
		
		api.setProjectId(dataName);
		api.setProjectDataFolder(projectDataFolderArray[index]);
		managerFactoryInstance.callAPI(api);
	});
}

/**
 * get coodinate relative to building
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project primary key
 * @param {string} dataKey data key
 * @param {string} inputPoint input x, y, z
 * @param {string} resultPoint return point
 */
function getCoordinateRelativeToBuildingAPI(managerFactoryInstance, projectId, dataKey, inputPoint, resultPoint)
{
	if (managerFactoryInstance === null) { return; }

	var api = new Mago3D.API("getCoordinateRelativeToBuilding");
	api.setReturnable(true);
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	api.setInputPoint(inputPoint);
	api.setResultPoint(resultPoint);

	return managerFactoryInstance.callAPI(api);
}

/**
 * get absolte coodinate of building point
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project primary key
 * @param {string} dataKey data key
 * @param {string} inputPoint input x, y, z
 * @param {string} resultPoint return point
 */
function getAbsoluteCoodinateOfBuildingPointAPI(managerFactoryInstance, projectId, dataKey, inputPoint, resultPoint)
{
	if (managerFactoryInstance === null) { return; }

	var api = new Mago3D.API("getAbsoluteCoodinateOfBuildingPoint");
	api.setReturnable(true);
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	api.setInputPoint(inputPoint);
	api.setResultPoint(resultPoint);

	return managerFactoryInstance.callAPI(api);
}

/**
 * get current camera position
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Number} unit position unit. if not define, default value is Mago3D.CODE.units.DEGREE. 0 : Mago3D.CODE.units.METRE, 1 : Mago3D.CODE.units.DEGREE, 2 : Mago3D.CODE.units.RADIAN
 * @returns {Object|Cartesian3|Cartographic}
 */
function getCameraCurrentPositionAPI(managerFactoryInstance, unit)
{
	var api = new Mago3D.API("getCameraCurrentPosition");
	
	api.setReturnable(true);
	api.setUnit(unit);
	
	return managerFactoryInstance.callAPI(api);
}

/**
 * get current camera orientaion
 * @param {ManagerFactory} managerFactoryInstance
 * @returns {Object}
 */
function getCameraCurrentOrientaionAPI(managerFactoryInstance)
{
	var api = new Mago3D.API("getCameraCurrentOrientaion");
	
	api.setReturnable(true);
	return managerFactoryInstance.callAPI(api);
}

/**
 * change camera orientation
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string|undefined|null} heading 좌, 우. needs degree. default value is current camera's heading value.
 * @param {string|undefined|null} pitch 위, 아래. needs degree. default value is current camera's pitch value.
 * @param {string|undefined|null} roll 좌, 우 기울기. needs degree. default value is current camera's roll value.
 * @param {string|undefined|null} duration 이동하는 시간. default value is 0.
 */
function changeCameraOrientationAPI(managerFactoryInstance, heading, pitch, roll, duration)
{
	var api = new Mago3D.API("changeCameraOrientation");

	api.setHeading(heading);
	api.setPitch(pitch);
	api.setRoll(roll);
	api.setDuration(duration);

	managerFactoryInstance.callAPI(api);
}


/**
 * Object literal with config options for instantiate static model.
 * @typedef {Object} instantiateOption
 * @property {string} projectId Required. projectId. static model key.
 * @property {string} instanceId Required. instance Id.
 * @property {number} longitude Required. initial longitude.
 * @property {number} latitude Required. initial latitude.
 * @property {number} height Optional. Default value is 0.
 * @property {number} heading Optional. Default value is 0.
 * @property {number} pitch Optional. Default value is 0.
 * @property {number} roll Optional. Default value is 0.
 */

/**
 * instantiate static model
 * @param {ManagerFactory} managerFactoryInstance
 * @param {instantiateOption} attributes
 */
function instantiateStaticModelAPI(managerFactoryInstance, attributes)
{
	var api = new Mago3D.API("instantiateStaticModel");
	
	api.setInstantiateObj(attributes);
	managerFactoryInstance.callAPI(api);
}

/**
 * Object literal with config options for add static model.
 * @typedef {Object} staticModelOption
 * @property {string} projectId Required. projectId. Static model key.
 * @property {string} projectFolderName Required. Static Model Folder Name.
 * @property {string} buildingFolderName Required. Static Model data Folder Name.
 */

/**
 * add static model
 * @param {ManagerFactory} managerFactoryInstance
 * @param {staticModelOption} attributes
 */
function addStaticModelAPI(managerFactoryInstance, attributes)
{
	var api = new Mago3D.API("addStaticModel");
	
	api.setStaticModelAttributeObj(attributes);
	managerFactoryInstance.callAPI(api);
}

/**
 * set track target node.
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project primary key
 * @param {string} dataKey data key
 */
function setTrackNodeAPI(managerFactoryInstance, projectId, dataKey)
{
	var api = new Mago3D.API("setTrackNode");
	
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	managerFactoryInstance.callAPI(api);
}

/**
 * set track target node.
 * @param {ManagerFactory} managerFactoryInstance
 */
function stopTrackAPI(managerFactoryInstance)
{
	var api = new Mago3D.API("stopTrack");
	
	managerFactoryInstance.callAPI(api);
}

/**
 * check static model is exist
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId
 * @returns {Boolean} isExist
 */
function isExistStaticModelAPI(managerFactoryInstance, projectId)
{
	var api = new Mago3D.API("isExistStaticModel");
	api.setReturnable(true);
	api.setProjectId(projectId);
	return managerFactoryInstance.callAPI(api);
}

/**
 * check data is exist
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project primary key
 * @param {string} dataKey data key
 * @returns {Boolean} isExist
 */
function isExistDataAPI(managerFactoryInstance, projectId, dataKey)
{
	var api = new Mago3D.API("isExistData");
	api.setReturnable(true);
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	return managerFactoryInstance.callAPI(api);
}
'use strict';

/**
 * api 처리 결과를 담당하는 callback function
 * @param functionName policy json의 geo_callback_apiresult 속성값
 * @param apiName 호출한 api 이름
 * @param result 결과값
 */
function apiResultCallback(functionName, apiName, result) 
{
	window[functionName](apiName, result);
}

/**
 * 선택한 object 정보를 화면에 표시
 * @param functionName callback
 * @param projectId
 * @param data_key
 * @param objectId
 * @param latitude
 * @param longitude
 * @param elevation
 * @param heading
 * @param pitch
 * @param roll
 * @param
 */
function selectedObjectCallback(functionName, projectId, dataKey, objectId, latitude, longitude, elevation, heading, pitch, roll)
{
	window[functionName](projectId, dataKey, objectId, latitude, longitude, elevation, heading, pitch, roll);
}

/**
 * 이동한 data 정보를 화면에 표시
 * @param functionName callback
 * @param projectId
 * @param data_key
 * @param objectId
 * @param latitude
 * @param longitude
 * @param elevation
 * @param heading
 * @param pitch
 * @param roll
 * @param
 */
function movedDataCallback(functionName, projectId, dataKey, objectId, latitude, longitude, elevation, heading, pitch, roll)
{
	window[functionName](projectId, dataKey, objectId, latitude, longitude, elevation, heading, pitch, roll);
}

/**
 * Data Key 를 이용하여 Geo Spatial Info를 획득하여 화면에 표시
 * @param functionName callback
 * @param projectId
 * @param data_key
 * @param dataName
 * @param latitude
 * @param longitude
 * @param elevation
 * @param heading
 * @param pitch
 * @param roll
 * @param
 */
function dataInfoCallback(functionName, projectId, dataKey, dataName, latitude, longitude, elevation, heading, pitch, roll)
{
	window[functionName](projectId, dataKey, dataName, latitude, longitude, elevation, heading, pitch, roll);
}

/**
 * 선택한 object 정보를 화면에 표시
 * @param functionName
 * @param projectId
 * @param data_key
 * @param objectId
 * @param latitude
 * @param longitude
 * @param elevation
 */
function insertIssueCallback(functionName, projectId, dataKey, objectId, latitude, longitude, elevation)
{
	window[functionName](projectId, dataKey, objectId, latitude, longitude, elevation);
}

/**
 * mouse click 위치 정보를 화면에 표시
 * @param functionName
 * @param position
 */
function clickPositionCallback(functionName, position) 
{
	window[functionName](position);
}

/**
  DataStream reads scalars, arrays and structs of data from an ArrayBuffer.
  It's like a file-like DataView on steroids.

  @param {ArrayBuffer} arrayBuffer ArrayBuffer to read from.
  @param {?Number} byteOffset Offset from arrayBuffer beginning for the DataStream.
  @param {?Boolean} endianness DataStream.BIG_ENDIAN or DataStream.LITTLE_ENDIAN (the default).
  */
var DataStream = function(arrayBuffer, byteOffset, endianness) {
  this._byteOffset = byteOffset || 0;
  if (arrayBuffer instanceof ArrayBuffer) {
    this.buffer = arrayBuffer;
  } else if (typeof arrayBuffer == "object") {
    this.dataView = arrayBuffer;
    if (byteOffset) {
      this._byteOffset += byteOffset;
    }
  } else {
    this.buffer = new ArrayBuffer(arrayBuffer || 1);
  }
  this.position = 0;
  this.endianness = endianness == null ? DataStream.LITTLE_ENDIAN : endianness;
};
DataStream.prototype = {};

/* Fix for Opera 12 not defining BYTES_PER_ELEMENT in typed array prototypes. */
if (Uint8Array.prototype.BYTES_PER_ELEMENT === undefined) {
    Uint8Array.prototype.BYTES_PER_ELEMENT = Uint8Array.BYTES_PER_ELEMENT; 
    Int8Array.prototype.BYTES_PER_ELEMENT = Int8Array.BYTES_PER_ELEMENT; 
    Uint8ClampedArray.prototype.BYTES_PER_ELEMENT = Uint8ClampedArray.BYTES_PER_ELEMENT; 
    Uint16Array.prototype.BYTES_PER_ELEMENT = Uint16Array.BYTES_PER_ELEMENT; 
    Int16Array.prototype.BYTES_PER_ELEMENT = Int16Array.BYTES_PER_ELEMENT; 
    Uint32Array.prototype.BYTES_PER_ELEMENT = Uint32Array.BYTES_PER_ELEMENT; 
    Int32Array.prototype.BYTES_PER_ELEMENT = Int32Array.BYTES_PER_ELEMENT; 
    Float64Array.prototype.BYTES_PER_ELEMENT = Float64Array.BYTES_PER_ELEMENT; 
}

/**
  Saves the DataStream contents to the given filename.
  Uses Chrome's anchor download property to initiate download.

  @param {string} filename Filename to save as.
  @return {null}
  */
DataStream.prototype.save = function(filename) {
  var blob = new Blob(this.buffer);
  var URL = (window.webkitURL || window.URL);
  if (URL && URL.createObjectURL) {
      var url = URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.setAttribute('href', url);
      a.setAttribute('download', filename);
      a.click();
      URL.revokeObjectURL(url);
  } else {
      throw("DataStream.save: Can't create object URL.");
  }
};

/**
  Big-endian const to use as default endianness.
  @type {boolean}
  */
DataStream.BIG_ENDIAN = false;

/**
  Little-endian const to use as default endianness.
  @type {boolean}
  */
DataStream.LITTLE_ENDIAN = true;

/**
  Whether to extend DataStream buffer when trying to write beyond its size.
  If set, the buffer is reallocated to twice its current size until the
  requested write fits the buffer.
  @type {boolean}
  */
DataStream.prototype._dynamicSize = true;
Object.defineProperty(DataStream.prototype, 'dynamicSize',
  { get: function() {
      return this._dynamicSize;
    },
    set: function(v) {
      if (!v) {
        this._trimAlloc();
      }
      this._dynamicSize = v;
    } });

/**
  Virtual byte length of the DataStream backing buffer.
  Updated to be max of original buffer size and last written size.
  If dynamicSize is false is set to buffer size.
  @type {number}
  */
DataStream.prototype._byteLength = 0;

/**
  Returns the byte length of the DataStream object.
  @type {number}
  */
Object.defineProperty(DataStream.prototype, 'byteLength',
  { get: function() {
    return this._byteLength - this._byteOffset;
  }});

/**
  Set/get the backing ArrayBuffer of the DataStream object.
  The setter updates the DataView to point to the new buffer.
  @type {Object}
  */
Object.defineProperty(DataStream.prototype, 'buffer',
  { get: function() {
      this._trimAlloc();
      return this._buffer;
    },
    set: function(v) {
      this._buffer = v;
      this._dataView = new DataView(this._buffer, this._byteOffset);
      this._byteLength = this._buffer.byteLength;
    } });

/**
  Set/get the byteOffset of the DataStream object.
  The setter updates the DataView to point to the new byteOffset.
  @type {number}
  */
Object.defineProperty(DataStream.prototype, 'byteOffset',
  { get: function() {
      return this._byteOffset;
    },
    set: function(v) {
      this._byteOffset = v;
      this._dataView = new DataView(this._buffer, this._byteOffset);
      this._byteLength = this._buffer.byteLength;
    } });

/**
  Set/get the backing DataView of the DataStream object.
  The setter updates the buffer and byteOffset to point to the DataView values.
  @type {Object}
  */
Object.defineProperty(DataStream.prototype, 'dataView',
  { get: function() {
      return this._dataView;
    },
    set: function(v) {
      this._byteOffset = v.byteOffset;
      this._buffer = v.buffer;
      this._dataView = new DataView(this._buffer, this._byteOffset);
      this._byteLength = this._byteOffset + v.byteLength;
    } });

/**
  Internal function to resize the DataStream buffer when required.
  @param {number} extra Number of bytes to add to the buffer allocation.
  @return {null}
  */
DataStream.prototype._realloc = function(extra) {
  if (!this._dynamicSize) {
    return;
  }
  var req = this._byteOffset + this.position + extra;
  var blen = this._buffer.byteLength;
  if (req <= blen) {
    if (req > this._byteLength) {
      this._byteLength = req;
    }
    return;
  }
  if (blen < 1) {
    blen = 1;
  }
  while (req > blen) {
    blen *= 2;
  }
  var buf = new ArrayBuffer(blen);
  var src = new Uint8Array(this._buffer);
  var dst = new Uint8Array(buf, 0, src.length);
  dst.set(src);
  this.buffer = buf;
  this._byteLength = req;
};

/**
  Internal function to trim the DataStream buffer when required.
  Used for stripping out the extra bytes from the backing buffer when
  the virtual byteLength is smaller than the buffer byteLength (happens after
  growing the buffer with writes and not filling the extra space completely).

  @return {null}
  */
DataStream.prototype._trimAlloc = function() {
  if (this._byteLength == this._buffer.byteLength) {
    return;
  }
  var buf = new ArrayBuffer(this._byteLength);
  var dst = new Uint8Array(buf);
  var src = new Uint8Array(this._buffer, 0, dst.length);
  dst.set(src);
  this.buffer = buf;
};

/**
  Sets the DataStream read/write position to given position.
  Clamps between 0 and DataStream length.

  @param {number} pos Position to seek to.
  @return {null}
  */
DataStream.prototype.seek = function(pos) {
  var npos = Math.max(0, Math.min(this.byteLength, pos));
  this.position = (isNaN(npos) || !isFinite(npos)) ? 0 : npos;
};

/**
  Returns true if the DataStream seek pointer is at the end of buffer and
  there's no more data to read.

  @return {boolean} True if the seek pointer is at the end of the buffer.
  */
DataStream.prototype.isEof = function() {
  return (this.position >= this.byteLength);
};

/**
  Maps an Int32Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Int32Array to the DataStream backing buffer.
  */
DataStream.prototype.mapInt32Array = function(length, e) {
  this._realloc(length * 4);
  var arr = new Int32Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 4;
  return arr;
};

/**
  Maps an Int16Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Int16Array to the DataStream backing buffer.
  */
DataStream.prototype.mapInt16Array = function(length, e) {
  this._realloc(length * 2);
  var arr = new Int16Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 2;
  return arr;
};

/**
  Maps an Int8Array into the DataStream buffer.

  Nice for quickly reading in data.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Int8Array to the DataStream backing buffer.
  */
DataStream.prototype.mapInt8Array = function(length) {
  this._realloc(length * 1);
  var arr = new Int8Array(this._buffer, this.byteOffset+this.position, length);
  this.position += length * 1;
  return arr;
};

/**
  Maps a Uint32Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Uint32Array to the DataStream backing buffer.
  */
DataStream.prototype.mapUint32Array = function(length, e) {
  this._realloc(length * 4);
  var arr = new Uint32Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 4;
  return arr;
};

/**
  Maps a Uint16Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Uint16Array to the DataStream backing buffer.
  */
DataStream.prototype.mapUint16Array = function(length, e) {
  this._realloc(length * 2);
  var arr = new Uint16Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 2;
  return arr;
};

/**
  Maps a Uint8Array into the DataStream buffer.

  Nice for quickly reading in data.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Uint8Array to the DataStream backing buffer.
  */
DataStream.prototype.mapUint8Array = function(length) {
  this._realloc(length * 1);
  var arr = new Uint8Array(this._buffer, this.byteOffset+this.position, length);
  this.position += length * 1;
  return arr;
};

/**
  Maps a Float64Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Float64Array to the DataStream backing buffer.
  */
DataStream.prototype.mapFloat64Array = function(length, e) {
  this._realloc(length * 8);
  var arr = new Float64Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 8;
  return arr;
};

/**
  Maps a Float32Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Float32Array to the DataStream backing buffer.
  */
DataStream.prototype.mapFloat32Array = function(length, e) {
  this._realloc(length * 4);
  var arr = new Float32Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 4;
  return arr;
};

/**
  Reads an Int32Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Int32Array.
 */
DataStream.prototype.readInt32Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 4) : length;
  var arr = new Int32Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads an Int16Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Int16Array.
 */
DataStream.prototype.readInt16Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 2) : length;
  var arr = new Int16Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads an Int8Array of desired length from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Int8Array.
 */
DataStream.prototype.readInt8Array = function(length) {
  length = length == null ? (this.byteLength-this.position) : length;
  var arr = new Int8Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Uint32Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Uint32Array.
 */
DataStream.prototype.readUint32Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 4) : length;
  var arr = new Uint32Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Uint16Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Uint16Array.
 */
DataStream.prototype.readUint16Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 2) : length;
  var arr = new Uint16Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Uint8Array of desired length from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Uint8Array.
 */
DataStream.prototype.readUint8Array = function(length) {
  length = length == null ? (this.byteLength-this.position) : length;
  var arr = new Uint8Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Float64Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Float64Array.
 */
DataStream.prototype.readFloat64Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 8) : length;
  var arr = new Float64Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Float32Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Float32Array.
 */
DataStream.prototype.readFloat32Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 4) : length;
  var arr = new Float32Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Writes an Int32Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeInt32Array = function(arr, e) {
  this._realloc(arr.length * 4);
  if (arr instanceof Int32Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapInt32Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeInt32(arr[i], e);
    }
  }
};

/**
  Writes an Int16Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeInt16Array = function(arr, e) {
  this._realloc(arr.length * 2);
  if (arr instanceof Int16Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapInt16Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeInt16(arr[i], e);
    }
  }
};

/**
  Writes an Int8Array to the DataStream.

  @param {Object} arr The array to write.
 */
DataStream.prototype.writeInt8Array = function(arr) {
  this._realloc(arr.length * 1);
  if (arr instanceof Int8Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapInt8Array(arr.length);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeInt8(arr[i]);
    }
  }
};

/**
  Writes a Uint32Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeUint32Array = function(arr, e) {
  this._realloc(arr.length * 4);
  if (arr instanceof Uint32Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapUint32Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeUint32(arr[i], e);
    }
  }
};

/**
  Writes a Uint16Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeUint16Array = function(arr, e) {
  this._realloc(arr.length * 2);
  if (arr instanceof Uint16Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapUint16Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeUint16(arr[i], e);
    }
  }
};

/**
  Writes a Uint8Array to the DataStream.

  @param {Object} arr The array to write.
 */
DataStream.prototype.writeUint8Array = function(arr) {
  this._realloc(arr.length * 1);
  if (arr instanceof Uint8Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapUint8Array(arr.length);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeUint8(arr[i]);
    }
  }
};

/**
  Writes a Float64Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeFloat64Array = function(arr, e) {
  this._realloc(arr.length * 8);
  if (arr instanceof Float64Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapFloat64Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeFloat64(arr[i], e);
    }
  }
};

/**
  Writes a Float32Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeFloat32Array = function(arr, e) {
  this._realloc(arr.length * 4);
  if (arr instanceof Float32Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapFloat32Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeFloat32(arr[i], e);
    }
  }
};


/**
  Reads a 32-bit int from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readInt32 = function(e) {
  var v = this._dataView.getInt32(this.position, e == null ? this.endianness : e);
  this.position += 4;
  return v;
};

/**
  Reads a 16-bit int from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readInt16 = function(e) {
  var v = this._dataView.getInt16(this.position, e == null ? this.endianness : e);
  this.position += 2;
  return v;
};

/**
  Reads an 8-bit int from the DataStream.

  @return {number} The read number.
 */
DataStream.prototype.readInt8 = function() {
  var v = this._dataView.getInt8(this.position);
  this.position += 1;
  return v;
};

/**
  Reads a 32-bit unsigned int from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readUint32 = function(e) {
  var v = this._dataView.getUint32(this.position, e == null ? this.endianness : e);
  this.position += 4;
  return v;
};

/**
  Reads a 16-bit unsigned int from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readUint16 = function(e) {
  var v = this._dataView.getUint16(this.position, e == null ? this.endianness : e);
  this.position += 2;
  return v;
};

/**
  Reads an 8-bit unsigned int from the DataStream.

  @return {number} The read number.
 */
DataStream.prototype.readUint8 = function() {
  var v = this._dataView.getUint8(this.position);
  this.position += 1;
  return v;
};

/**
  Reads a 32-bit float from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readFloat32 = function(e) {
  var v = this._dataView.getFloat32(this.position, e == null ? this.endianness : e);
  this.position += 4;
  return v;
};

/**
  Reads a 64-bit float from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readFloat64 = function(e) {
  var v = this._dataView.getFloat64(this.position, e == null ? this.endianness : e);
  this.position += 8;
  return v;
};


/**
  Writes a 32-bit int to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeInt32 = function(v, e) {
  this._realloc(4);
  this._dataView.setInt32(this.position, v, e == null ? this.endianness : e);
  this.position += 4;
};

/**
  Writes a 16-bit int to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeInt16 = function(v, e) {
  this._realloc(2);
  this._dataView.setInt16(this.position, v, e == null ? this.endianness : e);
  this.position += 2;
};

/**
  Writes an 8-bit int to the DataStream.

  @param {number} v Number to write.
 */
DataStream.prototype.writeInt8 = function(v) {
  this._realloc(1);
  this._dataView.setInt8(this.position, v);
  this.position += 1;
};

/**
  Writes a 32-bit unsigned int to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeUint32 = function(v, e) {
  this._realloc(4);
  this._dataView.setUint32(this.position, v, e == null ? this.endianness : e);
  this.position += 4;
};

/**
  Writes a 16-bit unsigned int to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeUint16 = function(v, e) {
  this._realloc(2);
  this._dataView.setUint16(this.position, v, e == null ? this.endianness : e);
  this.position += 2;
};

/**
  Writes an 8-bit unsigned  int to the DataStream.

  @param {number} v Number to write.
 */
DataStream.prototype.writeUint8 = function(v) {
  this._realloc(1);
  this._dataView.setUint8(this.position, v);
  this.position += 1;
};

/**
  Writes a 32-bit float to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeFloat32 = function(v, e) {
  this._realloc(4);
  this._dataView.setFloat32(this.position, v, e == null ? this.endianness : e);
  this.position += 4;
};

/**
  Writes a 64-bit float to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeFloat64 = function(v, e) {
  this._realloc(8);
  this._dataView.setFloat64(this.position, v, e == null ? this.endianness : e);
  this.position += 8;
};

/**
  Native endianness. Either DataStream.BIG_ENDIAN or DataStream.LITTLE_ENDIAN
  depending on the platform endianness.

  @type {boolean}
 */
DataStream.endianness = new Int8Array(new Int16Array([1]).buffer)[0] > 0;

/**
  Copies byteLength bytes from the src buffer at srcOffset to the
  dst buffer at dstOffset.

  @param {Object} dst Destination ArrayBuffer to write to.
  @param {number} dstOffset Offset to the destination ArrayBuffer.
  @param {Object} src Source ArrayBuffer to read from.
  @param {number} srcOffset Offset to the source ArrayBuffer.
  @param {number} byteLength Number of bytes to copy.
 */
DataStream.memcpy = function(dst, dstOffset, src, srcOffset, byteLength) {
  var dstU8 = new Uint8Array(dst, dstOffset, byteLength);
  var srcU8 = new Uint8Array(src, srcOffset, byteLength);
  dstU8.set(srcU8);
};

/**
  Converts array to native endianness in-place.

  @param {Object} array Typed array to convert.
  @param {boolean} arrayIsLittleEndian True if the data in the array is
                                       little-endian. Set false for big-endian.
  @return {Object} The converted typed array.
 */
DataStream.arrayToNative = function(array, arrayIsLittleEndian) {
  if (arrayIsLittleEndian == this.endianness) {
    return array;
  } else {
    return this.flipArrayEndianness(array);
  }
};

/**
  Converts native endianness array to desired endianness in-place.

  @param {Object} array Typed array to convert.
  @param {boolean} littleEndian True if the converted array should be
                                little-endian. Set false for big-endian.
  @return {Object} The converted typed array.
 */
DataStream.nativeToEndian = function(array, littleEndian) {
  if (this.endianness == littleEndian) {
    return array;
  } else {
    return this.flipArrayEndianness(array);
  }
};

/**
  Flips typed array endianness in-place.

  @param {Object} array Typed array to flip.
  @return {Object} The converted typed array.
 */
DataStream.flipArrayEndianness = function(array) {
  var u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
  for (var i=0; i<array.byteLength; i+=array.BYTES_PER_ELEMENT) {
    for (var j=i+array.BYTES_PER_ELEMENT-1, k=i; j>k; j--, k++) {
      var tmp = u8[k];
      u8[k] = u8[j];
      u8[j] = tmp;
    }
  }
  return array;
};

/**
  Creates an array from an array of character codes.
  Uses String.fromCharCode in chunks for memory efficiency and then concatenates
  the resulting string chunks.

  @param {array} array Array of character codes.
  @return {string} String created from the character codes.
**/
DataStream.createStringFromArray = function(array) {
  var chunk_size = 0x8000;
  var chunks = [];
  for (var i=0; i < array.length; i += chunk_size) {
    chunks.push(String.fromCharCode.apply(null, array.subarray(i, i + chunk_size)));
  }
  return chunks.join("");
};

/**
  Seek position where DataStream#readStruct ran into a problem.
  Useful for debugging struct parsing.

  @type {number}
 */
DataStream.prototype.failurePosition = 0;

/**
  Reads a struct of data from the DataStream. The struct is defined as
  a flat array of [name, type]-pairs. See the example below:

  ds.readStruct([
    'headerTag', 'uint32', // Uint32 in DataStream endianness.
    'headerTag2', 'uint32be', // Big-endian Uint32.
    'headerTag3', 'uint32le', // Little-endian Uint32.
    'array', ['[]', 'uint32', 16], // Uint32Array of length 16.
    'array2Length', 'uint32',
    'array2', ['[]', 'uint32', 'array2Length'] // Uint32Array of length array2Length
  ]);

  The possible values for the type are as follows:

  // Number types

  // Unsuffixed number types use DataStream endianness.
  // To explicitly specify endianness, suffix the type with
  // 'le' for little-endian or 'be' for big-endian,
  // e.g. 'int32be' for big-endian int32.

  'uint8' -- 8-bit unsigned int
  'uint16' -- 16-bit unsigned int
  'uint32' -- 32-bit unsigned int
  'int8' -- 8-bit int
  'int16' -- 16-bit int
  'int32' -- 32-bit int
  'float32' -- 32-bit float
  'float64' -- 64-bit float

  // String types
  'cstring' -- ASCII string terminated by a zero byte.
  'string:N' -- ASCII string of length N, where N is a literal integer.
  'string:variableName' -- ASCII string of length $variableName,
    where 'variableName' is a previously parsed number in the current struct.
  'string,CHARSET:N' -- String of byteLength N encoded with given CHARSET.
  'u16string:N' -- UCS-2 string of length N in DataStream endianness.
  'u16stringle:N' -- UCS-2 string of length N in little-endian.
  'u16stringbe:N' -- UCS-2 string of length N in big-endian.

  // Complex types
  [name, type, name_2, type_2, ..., name_N, type_N] -- Struct
  function(dataStream, struct) {} -- Callback function to read and return data.
  {get: function(dataStream, struct) {},
   set: function(dataStream, struct) {}}
  -- Getter/setter functions to read and return data, handy for using the same
     struct definition for reading and writing structs.
  ['[]', type, length] -- Array of given type and length. The length can be either
                        a number, a string that references a previously-read
                        field, or a callback function(struct, dataStream, type){}.
                        If length is '*', reads in as many elements as it can.

  @param {Object} structDefinition Struct definition object.
  @return {Object} The read struct. Null if failed to read struct.
 */
DataStream.prototype.readStruct = function(structDefinition) {
  var struct = {}, t, v, n;
  var p = this.position;
  for (var i=0; i<structDefinition.length; i+=2) {
    t = structDefinition[i+1];
    v = this.readType(t, struct);
    if (v == null) {
      if (this.failurePosition == 0) {
        this.failurePosition = this.position;
      }
      this.position = p;
      return null;
    }
    struct[structDefinition[i]] = v;
  }
  return struct;
};

/**
  Read UCS-2 string of desired length and endianness from the DataStream.

  @param {number} length The length of the string to read.
  @param {boolean} endianness The endianness of the string data in the DataStream.
  @return {string} The read string.
 */
DataStream.prototype.readUCS2String = function(length, endianness) {
  return DataStream.createStringFromArray(this.readUint16Array(length, endianness));
};

/**
  Write a UCS-2 string of desired endianness to the DataStream. The
  lengthOverride argument lets you define the number of characters to write.
  If the string is shorter than lengthOverride, the extra space is padded with
  zeroes.

  @param {string} str The string to write.
  @param {?boolean} endianness The endianness to use for the written string data.
  @param {?number} lengthOverride The number of characters to write.
 */
DataStream.prototype.writeUCS2String = function(str, endianness, lengthOverride) {
  if (lengthOverride == null) {
    lengthOverride = str.length;
  }
  for (var i = 0; i < str.length && i < lengthOverride; i++) {
    this.writeUint16(str.charCodeAt(i), endianness);
  }
  for (; i<lengthOverride; i++) {
    this.writeUint16(0);
  }
};

/**
  Read a string of desired length and encoding from the DataStream.

  @param {number} length The length of the string to read in bytes.
  @param {?string} encoding The encoding of the string data in the DataStream.
                            Defaults to ASCII.
  @return {string} The read string.
 */
DataStream.prototype.readString = function(length, encoding) {
  if (encoding == null || encoding == "ASCII") {
    return DataStream.createStringFromArray(this.mapUint8Array(length == null ? this.byteLength-this.position : length));
  } else {
    return (new TextDecoder(encoding)).decode(this.mapUint8Array(length));
  }
};

/**
  Writes a string of desired length and encoding to the DataStream.

  @param {string} s The string to write.
  @param {?string} encoding The encoding for the written string data.
                            Defaults to ASCII.
  @param {?number} length The number of characters to write.
 */
DataStream.prototype.writeString = function(s, encoding, length) {
  if (encoding == null || encoding == "ASCII") {
    if (length != null) {
      var i = 0;
      var len = Math.min(s.length, length);
      for (i=0; i<len; i++) {
        this.writeUint8(s.charCodeAt(i));
      }
      for (; i<length; i++) {
        this.writeUint8(0);
      }
    } else {
      for (var i=0; i<s.length; i++) {
        this.writeUint8(s.charCodeAt(i));
      }
    }
  } else {
    this.writeUint8Array((new TextEncoder(encoding)).encode(s.substring(0, length)));
  }
};


/**
  Read null-terminated string of desired length from the DataStream. Truncates
  the returned string so that the null byte is not a part of it.

  @param {?number} length The length of the string to read.
  @return {string} The read string.
 */
DataStream.prototype.readCString = function(length) {
  var blen = this.byteLength-this.position;
  var u8 = new Uint8Array(this._buffer, this._byteOffset + this.position);
  var len = blen;
  if (length != null) {
    len = Math.min(length, blen);
  }
  for (var i = 0; i < len && u8[i] != 0; i++); // find first zero byte
  var s = DataStream.createStringFromArray(this.mapUint8Array(i));
  if (length != null) {
    this.position += len-i;
  } else if (i != blen) {
    this.position += 1; // trailing zero if not at end of buffer
  }
  return s;
};

/**
  Writes a null-terminated string to DataStream and zero-pads it to length
  bytes. If length is not given, writes the string followed by a zero.
  If string is longer than length, the written part of the string does not have
  a trailing zero.

  @param {string} s The string to write.
  @param {?number} length The number of characters to write.
 */
DataStream.prototype.writeCString = function(s, length) {
  if (length != null) {
    var i = 0;
    var len = Math.min(s.length, length);
    for (i=0; i<len; i++) {
      this.writeUint8(s.charCodeAt(i));
    }
    for (; i<length; i++) {
      this.writeUint8(0);
    }
  } else {
    for (var i=0; i<s.length; i++) {
      this.writeUint8(s.charCodeAt(i));
    }
    this.writeUint8(0);
  }
};

/**
  Reads an object of type t from the DataStream, passing struct as the thus-far
  read struct to possible callbacks that refer to it. Used by readStruct for
  reading in the values, so the type is one of the readStruct types.

  @param {Object} t Type of the object to read.
  @param {?Object} struct Struct to refer to when resolving length references
                          and for calling callbacks.
  @return {?Object} Returns the object on successful read, null on unsuccessful.
 */
DataStream.prototype.readType = function(t, struct) {
  if (typeof t == "function") {
    return t(this, struct);
  } else if (typeof t == "object" && !(t instanceof Array)) {
    return t.get(this, struct);
  } else if (t instanceof Array && t.length != 3) {
    return this.readStruct(t, struct);
  }
  var v = null;
  var lengthOverride = null;
  var charset = "ASCII";
  var pos = this.position;
  var len;
  if (typeof t == 'string' && /:/.test(t)) {
    var tp = t.split(":");
    t = tp[0];
    len = tp[1];

    // allow length to be previously parsed variable
    // e.g. 'string:fieldLength', if `fieldLength` has
    // been parsed previously.
    if (struct[len] != null) {
      lengthOverride = parseInt(struct[len]);
    } else {
      // assume literal integer e.g., 'string:4'
      lengthOverride = parseInt(tp[1]);
    }
  }
  if (typeof t == 'string' && /,/.test(t)) {
    var tp = t.split(",");
    t = tp[0];
    charset = parseInt(tp[1]);
  }
  switch(t) {

    case 'uint8':
      v = this.readUint8(); break;
    case 'int8':
      v = this.readInt8(); break;

    case 'uint16':
      v = this.readUint16(this.endianness); break;
    case 'int16':
      v = this.readInt16(this.endianness); break;
    case 'uint32':
      v = this.readUint32(this.endianness); break;
    case 'int32':
      v = this.readInt32(this.endianness); break;
    case 'float32':
      v = this.readFloat32(this.endianness); break;
    case 'float64':
      v = this.readFloat64(this.endianness); break;

    case 'uint16be':
      v = this.readUint16(DataStream.BIG_ENDIAN); break;
    case 'int16be':
      v = this.readInt16(DataStream.BIG_ENDIAN); break;
    case 'uint32be':
      v = this.readUint32(DataStream.BIG_ENDIAN); break;
    case 'int32be':
      v = this.readInt32(DataStream.BIG_ENDIAN); break;
    case 'float32be':
      v = this.readFloat32(DataStream.BIG_ENDIAN); break;
    case 'float64be':
      v = this.readFloat64(DataStream.BIG_ENDIAN); break;

    case 'uint16le':
      v = this.readUint16(DataStream.LITTLE_ENDIAN); break;
    case 'int16le':
      v = this.readInt16(DataStream.LITTLE_ENDIAN); break;
    case 'uint32le':
      v = this.readUint32(DataStream.LITTLE_ENDIAN); break;
    case 'int32le':
      v = this.readInt32(DataStream.LITTLE_ENDIAN); break;
    case 'float32le':
      v = this.readFloat32(DataStream.LITTLE_ENDIAN); break;
    case 'float64le':
      v = this.readFloat64(DataStream.LITTLE_ENDIAN); break;

    case 'cstring':
      v = this.readCString(lengthOverride); break;

    case 'string':
      v = this.readString(lengthOverride, charset); break;

    case 'u16string':
      v = this.readUCS2String(lengthOverride, this.endianness); break;

    case 'u16stringle':
      v = this.readUCS2String(lengthOverride, DataStream.LITTLE_ENDIAN); break;

    case 'u16stringbe':
      v = this.readUCS2String(lengthOverride, DataStream.BIG_ENDIAN); break;

    default:
      if (t.length == 3) {
        var ta = t[1];
        var len = t[2];
        var length = 0;
        if (typeof len == 'function') {
          length = len(struct, this, t);
        } else if (typeof len == 'string' && struct[len] != null) {
          length = parseInt(struct[len]);
        } else {
          length = parseInt(len);
        }
        if (typeof ta == "string") {
          var tap = ta.replace(/(le|be)$/, '');
          var endianness = null;
          if (/le$/.test(ta)) {
            endianness = DataStream.LITTLE_ENDIAN;
          } else if (/be$/.test(ta)) {
            endianness = DataStream.BIG_ENDIAN;
          }
          if (len == '*') {
            length = null;
          }
          switch(tap) {
            case 'uint8':
              v = this.readUint8Array(length); break;
            case 'uint16':
              v = this.readUint16Array(length, endianness); break;
            case 'uint32':
              v = this.readUint32Array(length, endianness); break;
            case 'int8':
              v = this.readInt8Array(length); break;
            case 'int16':
              v = this.readInt16Array(length, endianness); break;
            case 'int32':
              v = this.readInt32Array(length, endianness); break;
            case 'float32':
              v = this.readFloat32Array(length, endianness); break;
            case 'float64':
              v = this.readFloat64Array(length, endianness); break;
            case 'cstring':
            case 'utf16string':
            case 'string':
              if (length == null) {
                v = [];
                while (!this.isEof()) {
                  var u = this.readType(ta, struct);
                  if (u == null) break;
                  v.push(u);
                }
              } else {
                v = new Array(length);
                for (var i=0; i<length; i++) {
                  v[i] = this.readType(ta, struct);
                }
              }
              break;
          }
        } else {
          if (len == '*') {
            v = [];
            this.buffer;
            while (true) {
              var p = this.position;
              try {
                var o = this.readType(ta, struct);
                if (o == null) {
                  this.position = p;
                  break;
                }
                v.push(o);
              } catch(e) {
                this.position = p;
                break;
              }
            }
          } else {
            v = new Array(length);
            for (var i=0; i<length; i++) {
              var u = this.readType(ta, struct);
              if (u == null) return null;
              v[i] = u;
            }
          }
        }
        break;
      }
  }
  if (lengthOverride != null) {
    this.position = pos + lengthOverride;
  }
  return v;
};

/**
  Writes a struct to the DataStream. Takes a structDefinition that gives the
  types and a struct object that gives the values. Refer to readStruct for the
  structure of structDefinition.

  @param {Object} structDefinition Type definition of the struct.
  @param {Object} struct The struct data object.
  */
DataStream.prototype.writeStruct = function(structDefinition, struct) {
  for (var i = 0; i < structDefinition.length; i+=2) {
    var t = structDefinition[i+1];
    this.writeType(t, struct[structDefinition[i]], struct);
  }
};

/**
  Writes object v of type t to the DataStream.

  @param {Object} t Type of data to write.
  @param {Object} v Value of data to write.
  @param {Object} struct Struct to pass to write callback functions.
  */
DataStream.prototype.writeType = function(t, v, struct) {
  if (typeof t == "function") {
    return t(this, v);
  } else if (typeof t == "object" && !(t instanceof Array)) {
    return t.set(this, v, struct);
  }
  var lengthOverride = null;
  var charset = "ASCII";
  var pos = this.position;
  if (typeof(t) == 'string' && /:/.test(t)) {
    var tp = t.split(":");
    t = tp[0];
    lengthOverride = parseInt(tp[1]);
  }
  if (typeof t == 'string' && /,/.test(t)) {
    var tp = t.split(",");
    t = tp[0];
    charset = parseInt(tp[1]);
  }

  switch(t) {
    case 'uint8':
      this.writeUint8(v);
      break;
    case 'int8':
      this.writeInt8(v);
      break;

    case 'uint16':
      this.writeUint16(v, this.endianness);
      break;
    case 'int16':
      this.writeInt16(v, this.endianness);
      break;
    case 'uint32':
      this.writeUint32(v, this.endianness);
      break;
    case 'int32':
      this.writeInt32(v, this.endianness);
      break;
    case 'float32':
      this.writeFloat32(v, this.endianness);
      break;
    case 'float64':
      this.writeFloat64(v, this.endianness);
      break;

    case 'uint16be':
      this.writeUint16(v, DataStream.BIG_ENDIAN);
      break;
    case 'int16be':
      this.writeInt16(v, DataStream.BIG_ENDIAN);
      break;
    case 'uint32be':
      this.writeUint32(v, DataStream.BIG_ENDIAN);
      break;
    case 'int32be':
      this.writeInt32(v, DataStream.BIG_ENDIAN);
      break;
    case 'float32be':
      this.writeFloat32(v, DataStream.BIG_ENDIAN);
      break;
    case 'float64be':
      this.writeFloat64(v, DataStream.BIG_ENDIAN);
      break;

    case 'uint16le':
      this.writeUint16(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'int16le':
      this.writeInt16(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'uint32le':
      this.writeUint32(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'int32le':
      this.writeInt32(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'float32le':
      this.writeFloat32(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'float64le':
      this.writeFloat64(v, DataStream.LITTLE_ENDIAN);
      break;

    case 'cstring':
      this.writeCString(v, lengthOverride);
      break;

    case 'string':
      this.writeString(v, charset, lengthOverride);
      break;

    case 'u16string':
      this.writeUCS2String(v, this.endianness, lengthOverride);
      break;

    case 'u16stringle':
      this.writeUCS2String(v, DataStream.LITTLE_ENDIAN, lengthOverride);
      break;

    case 'u16stringbe':
      this.writeUCS2String(v, DataStream.BIG_ENDIAN, lengthOverride);
      break;

    default:
      if (t.length == 3) {
        var ta = t[1];
        for (var i=0; i<v.length; i++) {
          this.writeType(ta, v[i]);
        }
        break;
      } else {
        this.writeStruct(t, v);
        break;
      }
  }
  if (lengthOverride != null) {
    this.position = pos;
    this._realloc(lengthOverride);
    this.position = pos + lengthOverride;
  }
};

// Export DataStream for amd environments
if (typeof define === 'function' && define.amd) {
    define('DataStream', [], function() {
      return DataStream;
    });
  }
  
// Export DataStream for CommonJS
if (typeof module === 'object' && module && module.exports) {
  module.exports = DataStream;
}


/*!
@fileoverview gl-matrix - High performance matrix and vector operations
@author Brandon Jones
@author Colin MacKenzie IV
@version 3.0.0-0

Copyright (c) 2015-2019, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.glMatrix = {})));
}(this, (function (exports) { 'use strict';

  /**
   * Common utilities
   * @module glMatrix
   */
  // Configuration Constants
  var EPSILON = 0.000001;
  var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
  var RANDOM = Math.random;
  /**
   * Sets the type of array used when creating new vectors and matrices
   *
   * @param {Type} type Array type, such as Float32Array or Array
   */

  function setMatrixArrayType(type) {
    ARRAY_TYPE = type;
  }
  var degree = Math.PI / 180;
  /**
   * Convert Degree To Radian
   *
   * @param {Number} a Angle in Degrees
   */

  function toRadian(a) {
    return a * degree;
  }
  /**
   * Tests whether or not the arguments have approximately the same value, within an absolute
   * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
   * than or equal to 1.0, and a relative tolerance is used for larger values)
   *
   * @param {Number} a The first number to test.
   * @param {Number} b The second number to test.
   * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
   */

  function equals(a, b) {
    return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
  }

  var common = /*#__PURE__*/Object.freeze({
    EPSILON: EPSILON,
    get ARRAY_TYPE () { return ARRAY_TYPE; },
    RANDOM: RANDOM,
    setMatrixArrayType: setMatrixArrayType,
    toRadian: toRadian,
    equals: equals
  });

  /**
   * 2x2 Matrix
   * @module mat2
   */

  /**
   * Creates a new identity mat2
   *
   * @returns {mat2} a new 2x2 matrix
   */

  function create() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
    }

    out[0] = 1;
    out[3] = 1;
    return out;
  }
  /**
   * Creates a new mat2 initialized with values from an existing matrix
   *
   * @param {mat2} a matrix to clone
   * @returns {mat2} a new 2x2 matrix
   */

  function clone(a) {
    var out = new ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Copy the values from one mat2 to another
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Set a mat2 to the identity matrix
   *
   * @param {mat2} out the receiving matrix
   * @returns {mat2} out
   */

  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  /**
   * Create a new mat2 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m10 Component in column 1, row 0 position (index 2)
   * @param {Number} m11 Component in column 1, row 1 position (index 3)
   * @returns {mat2} out A new 2x2 matrix
   */

  function fromValues(m00, m01, m10, m11) {
    var out = new ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
  }
  /**
   * Set the components of a mat2 to the given values
   *
   * @param {mat2} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m10 Component in column 1, row 0 position (index 2)
   * @param {Number} m11 Component in column 1, row 1 position (index 3)
   * @returns {mat2} out
   */

  function set(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
  }
  /**
   * Transpose the values of a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache
    // some values
    if (out === a) {
      var a1 = a[1];
      out[1] = a[2];
      out[2] = a1;
    } else {
      out[0] = a[0];
      out[1] = a[2];
      out[2] = a[1];
      out[3] = a[3];
    }

    return out;
  }
  /**
   * Inverts a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function invert(out, a) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3]; // Calculate the determinant

    var det = a0 * a3 - a2 * a1;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] = a0 * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function adjoint(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] = a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a0;
    return out;
  }
  /**
   * Calculates the determinant of a mat2
   *
   * @param {mat2} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant(a) {
    return a[0] * a[3] - a[2] * a[1];
  }
  /**
   * Multiplies two mat2's
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @returns {mat2} out
   */

  function multiply(out, a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
  }
  /**
   * Rotates a mat2 by the given angle
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2} out
   */

  function rotate(out, a, rad) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
  }
  /**
   * Scales the mat2 by the dimensions in the given vec2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the matrix to rotate
   * @param {vec2} v the vec2 to scale the matrix by
   * @returns {mat2} out
   **/

  function scale(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.rotate(dest, dest, rad);
   *
   * @param {mat2} out mat2 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2} out
   */

  function fromRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.scale(dest, dest, vec);
   *
   * @param {mat2} out mat2 receiving operation result
   * @param {vec2} v Scaling vector
   * @returns {mat2} out
   */

  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
  }
  /**
   * Returns a string representation of a mat2
   *
   * @param {mat2} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str(a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
  }
  /**
   * Returns Frobenius norm of a mat2
   *
   * @param {mat2} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
  }
  /**
   * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
   * @param {mat2} L the lower triangular matrix
   * @param {mat2} D the diagonal matrix
   * @param {mat2} U the upper triangular matrix
   * @param {mat2} a the input matrix to factorize
   */

  function LDU(L, D, U, a) {
    L[2] = a[2] / a[0];
    U[0] = a[0];
    U[1] = a[1];
    U[3] = a[3] - L[2] * U[1];
    return [L, D, U];
  }
  /**
   * Adds two mat2's
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @returns {mat2} out
   */

  function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @returns {mat2} out
   */

  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat2} a The first matrix.
   * @param {mat2} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat2} a The first matrix.
   * @param {mat2} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$1(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat2} out
   */

  function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  /**
   * Adds two mat2's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat2} out the receiving vector
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat2} out
   */

  function multiplyScalarAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    return out;
  }
  /**
   * Alias for {@link mat2.multiply}
   * @function
   */

  var mul = multiply;
  /**
   * Alias for {@link mat2.subtract}
   * @function
   */

  var sub = subtract;

  var mat2 = /*#__PURE__*/Object.freeze({
    create: create,
    clone: clone,
    copy: copy,
    identity: identity,
    fromValues: fromValues,
    set: set,
    transpose: transpose,
    invert: invert,
    adjoint: adjoint,
    determinant: determinant,
    multiply: multiply,
    rotate: rotate,
    scale: scale,
    fromRotation: fromRotation,
    fromScaling: fromScaling,
    str: str,
    frob: frob,
    LDU: LDU,
    add: add,
    subtract: subtract,
    exactEquals: exactEquals,
    equals: equals$1,
    multiplyScalar: multiplyScalar,
    multiplyScalarAndAdd: multiplyScalarAndAdd,
    mul: mul,
    sub: sub
  });

  /**
   * 2x3 Matrix
   * @module mat2d
   *
   * @description
   * A mat2d contains six elements defined as:
   * <pre>
   * [a, c, tx,
   *  b, d, ty]
   * </pre>
   * This is a short form for the 3x3 matrix:
   * <pre>
   * [a, c, tx,
   *  b, d, ty,
   *  0, 0, 1]
   * </pre>
   * The last row is ignored so the array is shorter and operations are faster.
   */

  /**
   * Creates a new identity mat2d
   *
   * @returns {mat2d} a new 2x3 matrix
   */

  function create$1() {
    var out = new ARRAY_TYPE(6);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[4] = 0;
      out[5] = 0;
    }

    out[0] = 1;
    out[3] = 1;
    return out;
  }
  /**
   * Creates a new mat2d initialized with values from an existing matrix
   *
   * @param {mat2d} a matrix to clone
   * @returns {mat2d} a new 2x3 matrix
   */

  function clone$1(a) {
    var out = new ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
  }
  /**
   * Copy the values from one mat2d to another
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the source matrix
   * @returns {mat2d} out
   */

  function copy$1(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
  }
  /**
   * Set a mat2d to the identity matrix
   *
   * @param {mat2d} out the receiving matrix
   * @returns {mat2d} out
   */

  function identity$1(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Create a new mat2d with the given values
   *
   * @param {Number} a Component A (index 0)
   * @param {Number} b Component B (index 1)
   * @param {Number} c Component C (index 2)
   * @param {Number} d Component D (index 3)
   * @param {Number} tx Component TX (index 4)
   * @param {Number} ty Component TY (index 5)
   * @returns {mat2d} A new mat2d
   */

  function fromValues$1(a, b, c, d, tx, ty) {
    var out = new ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
  }
  /**
   * Set the components of a mat2d to the given values
   *
   * @param {mat2d} out the receiving matrix
   * @param {Number} a Component A (index 0)
   * @param {Number} b Component B (index 1)
   * @param {Number} c Component C (index 2)
   * @param {Number} d Component D (index 3)
   * @param {Number} tx Component TX (index 4)
   * @param {Number} ty Component TY (index 5)
   * @returns {mat2d} out
   */

  function set$1(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
  }
  /**
   * Inverts a mat2d
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the source matrix
   * @returns {mat2d} out
   */

  function invert$1(out, a) {
    var aa = a[0],
        ab = a[1],
        ac = a[2],
        ad = a[3];
    var atx = a[4],
        aty = a[5];
    var det = aa * ad - ab * ac;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
  }
  /**
   * Calculates the determinant of a mat2d
   *
   * @param {mat2d} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$1(a) {
    return a[0] * a[3] - a[1] * a[2];
  }
  /**
   * Multiplies two mat2d's
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @returns {mat2d} out
   */

  function multiply$1(out, a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
  }
  /**
   * Rotates a mat2d by the given angle
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2d} out
   */

  function rotate$1(out, a, rad) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
  }
  /**
   * Scales the mat2d by the dimensions in the given vec2
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to translate
   * @param {vec2} v the vec2 to scale the matrix by
   * @returns {mat2d} out
   **/

  function scale$1(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
  }
  /**
   * Translates the mat2d by the dimensions in the given vec2
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to translate
   * @param {vec2} v the vec2 to translate the matrix by
   * @returns {mat2d} out
   **/

  function translate(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.rotate(dest, dest, rad);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2d} out
   */

  function fromRotation$1(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.scale(dest, dest, vec);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {vec2} v Scaling vector
   * @returns {mat2d} out
   */

  function fromScaling$1(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.translate(dest, dest, vec);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {vec2} v Translation vector
   * @returns {mat2d} out
   */

  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
  }
  /**
   * Returns a string representation of a mat2d
   *
   * @param {mat2d} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$1(a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
  }
  /**
   * Returns Frobenius norm of a mat2d
   *
   * @param {mat2d} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$1(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
  }
  /**
   * Adds two mat2d's
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @returns {mat2d} out
   */

  function add$1(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @returns {mat2d} out
   */

  function subtract$1(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat2d} out
   */

  function multiplyScalar$1(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
  }
  /**
   * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat2d} out the receiving vector
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat2d} out
   */

  function multiplyScalarAndAdd$1(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat2d} a The first matrix.
   * @param {mat2d} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$1(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat2d} a The first matrix.
   * @param {mat2d} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$2(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
  }
  /**
   * Alias for {@link mat2d.multiply}
   * @function
   */

  var mul$1 = multiply$1;
  /**
   * Alias for {@link mat2d.subtract}
   * @function
   */

  var sub$1 = subtract$1;

  var mat2d = /*#__PURE__*/Object.freeze({
    create: create$1,
    clone: clone$1,
    copy: copy$1,
    identity: identity$1,
    fromValues: fromValues$1,
    set: set$1,
    invert: invert$1,
    determinant: determinant$1,
    multiply: multiply$1,
    rotate: rotate$1,
    scale: scale$1,
    translate: translate,
    fromRotation: fromRotation$1,
    fromScaling: fromScaling$1,
    fromTranslation: fromTranslation,
    str: str$1,
    frob: frob$1,
    add: add$1,
    subtract: subtract$1,
    multiplyScalar: multiplyScalar$1,
    multiplyScalarAndAdd: multiplyScalarAndAdd$1,
    exactEquals: exactEquals$1,
    equals: equals$2,
    mul: mul$1,
    sub: sub$1
  });

  /**
   * 3x3 Matrix
   * @module mat3
   */

  /**
   * Creates a new identity mat3
   *
   * @returns {mat3} a new 3x3 matrix
   */

  function create$2() {
    var out = new ARRAY_TYPE(9);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }

    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  /**
   * Copies the upper-left 3x3 values into the given mat3.
   *
   * @param {mat3} out the receiving 3x3 matrix
   * @param {mat4} a   the source 4x4 matrix
   * @returns {mat3} out
   */

  function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
  }
  /**
   * Creates a new mat3 initialized with values from an existing matrix
   *
   * @param {mat3} a matrix to clone
   * @returns {mat3} a new 3x3 matrix
   */

  function clone$2(a) {
    var out = new ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Copy the values from one mat3 to another
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function copy$2(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Create a new mat3 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} A new mat3
   */

  function fromValues$2(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  /**
   * Set the components of a mat3 to the given values
   *
   * @param {mat3} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} out
   */

  function set$2(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  /**
   * Set a mat3 to the identity matrix
   *
   * @param {mat3} out the receiving matrix
   * @returns {mat3} out
   */

  function identity$2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function transpose$1(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a12 = a[5];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a01;
      out[5] = a[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a[0];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a[1];
      out[4] = a[4];
      out[5] = a[7];
      out[6] = a[2];
      out[7] = a[5];
      out[8] = a[8];
    }

    return out;
  }
  /**
   * Inverts a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function invert$2(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

    var det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function adjoint$1(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  /**
   * Calculates the determinant of a mat3
   *
   * @param {mat3} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$2(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  /**
   * Multiplies two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @returns {mat3} out
   */

  function multiply$2(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b00 = b[0],
        b01 = b[1],
        b02 = b[2];
    var b10 = b[3],
        b11 = b[4],
        b12 = b[5];
    var b20 = b[6],
        b21 = b[7],
        b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  /**
   * Translate a mat3 by the given vector
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to translate
   * @param {vec2} v vector to translate by
   * @returns {mat3} out
   */

  function translate$1(out, a, v) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a10 = a[3],
        a11 = a[4],
        a12 = a[5],
        a20 = a[6],
        a21 = a[7],
        a22 = a[8],
        x = v[0],
        y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
  }
  /**
   * Rotates a mat3 by the given angle
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */

  function rotate$2(out, a, rad) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a10 = a[3],
        a11 = a[4],
        a12 = a[5],
        a20 = a[6],
        a21 = a[7],
        a22 = a[8],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  /**
   * Scales the mat3 by the dimensions in the given vec2
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to rotate
   * @param {vec2} v the vec2 to scale the matrix by
   * @returns {mat3} out
   **/

  function scale$2(out, a, v) {
    var x = v[0],
        y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.translate(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {vec2} v Translation vector
   * @returns {mat3} out
   */

  function fromTranslation$1(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.rotate(dest, dest, rad);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */

  function fromRotation$2(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.scale(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {vec2} v Scaling vector
   * @returns {mat3} out
   */

  function fromScaling$2(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Copies the values from a mat2d into a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat2d} a the matrix to copy
   * @returns {mat3} out
   **/

  function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
  }
  /**
  * Calculates a 3x3 matrix from the given quaternion
  *
  * @param {mat3} out mat3 receiving operation result
  * @param {quat} q Quaternion to create matrix from
  *
  * @returns {mat3} out
  */

  function fromQuat(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }
  /**
  * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
  *
  * @param {mat3} out mat3 receiving operation result
  * @param {mat4} a Mat4 to derive the normal matrix from
  *
  * @returns {mat3} out
  */

  function normalFromMat4(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  }
  /**
   * Generates a 2D projection matrix with the given bounds
   *
   * @param {mat3} out mat3 frustum matrix will be written into
   * @param {number} width Width of your gl context
   * @param {number} height Height of gl context
   * @returns {mat3} out
   */

  function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
  }
  /**
   * Returns a string representation of a mat3
   *
   * @param {mat3} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$2(a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
  }
  /**
   * Returns Frobenius norm of a mat3
   *
   * @param {mat3} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$2(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
  }
  /**
   * Adds two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @returns {mat3} out
   */

  function add$2(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @returns {mat3} out
   */

  function subtract$2(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat3} out
   */

  function multiplyScalar$2(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
  }
  /**
   * Adds two mat3's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat3} out the receiving vector
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat3} out
   */

  function multiplyScalarAndAdd$2(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat3} a The first matrix.
   * @param {mat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$2(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat3} a The first matrix.
   * @param {mat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$3(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7],
        a8 = a[8];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7],
        b8 = b[8];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
  }
  /**
   * Alias for {@link mat3.multiply}
   * @function
   */

  var mul$2 = multiply$2;
  /**
   * Alias for {@link mat3.subtract}
   * @function
   */

  var sub$2 = subtract$2;

  var mat3 = /*#__PURE__*/Object.freeze({
    create: create$2,
    fromMat4: fromMat4,
    clone: clone$2,
    copy: copy$2,
    fromValues: fromValues$2,
    set: set$2,
    identity: identity$2,
    transpose: transpose$1,
    invert: invert$2,
    adjoint: adjoint$1,
    determinant: determinant$2,
    multiply: multiply$2,
    translate: translate$1,
    rotate: rotate$2,
    scale: scale$2,
    fromTranslation: fromTranslation$1,
    fromRotation: fromRotation$2,
    fromScaling: fromScaling$2,
    fromMat2d: fromMat2d,
    fromQuat: fromQuat,
    normalFromMat4: normalFromMat4,
    projection: projection,
    str: str$2,
    frob: frob$2,
    add: add$2,
    subtract: subtract$2,
    multiplyScalar: multiplyScalar$2,
    multiplyScalarAndAdd: multiplyScalarAndAdd$2,
    exactEquals: exactEquals$2,
    equals: equals$3,
    mul: mul$2,
    sub: sub$2
  });

  /**
   * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
   * @module mat4
   */

  /**
   * Creates a new identity mat4
   *
   * @returns {mat4} a new 4x4 matrix
   */

  function create$3() {
    var out = new ARRAY_TYPE(16);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }

    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 initialized with values from an existing matrix
   *
   * @param {mat4} a matrix to clone
   * @returns {mat4} a new 4x4 matrix
   */

  function clone$3(a) {
    var out = new ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Copy the values from one mat4 to another
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function copy$3(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Create a new mat4 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} A new mat4
   */

  function fromValues$3(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set the components of a mat4 to the given values
   *
   * @param {mat4} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} out
   */

  function set$3(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set a mat4 to the identity matrix
   *
   * @param {mat4} out the receiving matrix
   * @returns {mat4} out
   */

  function identity$3(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function transpose$2(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a03 = a[3];
      var a12 = a[6],
          a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Inverts a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function invert$3(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function adjoint$2(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
  }
  /**
   * Calculates the determinant of a mat4
   *
   * @param {mat4} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$3(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  /**
   * Multiplies two mat4s
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @returns {mat4} out
   */

  function multiply$3(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15]; // Cache only the current line of the second matrix

    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  /**
   * Translate a mat4 by the given vector
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to translate
   * @param {vec3} v vector to translate by
   * @returns {mat4} out
   */

  function translate$2(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;

    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
  }
  /**
   * Scales the mat4 by the dimensions in the given vec3 not using vectorization
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to scale
   * @param {vec3} v the vec3 to scale the matrix by
   * @returns {mat4} out
   **/

  function scale$3(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Rotates a mat4 by the given angle around the given axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @param {vec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function rotate$3(out, a, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.sqrt(x * x + y * y + z * z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11]; // Construct the elements of the rotation matrix

    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Y axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Z axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {vec3} v Translation vector
   * @returns {mat4} out
   */

  function fromTranslation$2(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {vec3} v Scaling vector
   * @returns {mat4} out
   */

  function fromScaling$3(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @param {vec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function fromRotation$3(out, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.sqrt(x * x + y * y + z * z);
    var s, c, t;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c; // Perform rotation-specific matrix multiplication

    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {vec3} v Translation vector
   * @returns {mat4} out
   */

  function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 from a dual quat.
   *
   * @param {mat4} out Matrix
   * @param {quat2} a Dual Quaternion
   * @returns {mat4} mat4 receiving operation result
   */

  function fromQuat2(out, a) {
    var translation = new ARRAY_TYPE(3);
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }

    fromRotationTranslation(out, a, translation);
    return out;
  }
  /**
   * Returns the translation vector component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslation,
   *  the returned vector will be the same as the translation vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive translation component
   * @param  {mat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  /**
   * Returns the scaling factor component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslationScale
   *  with a normalized Quaternion paramter, the returned vector will be
   *  the same as the scaling vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {mat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
  }
  /**
   * Returns a quaternion representing the rotational component
   *  of a transformation matrix. If a matrix is built with
   *  fromRotationTranslation, the returned quaternion will be the
   *  same as the quaternion originally supplied.
   * @param {quat} out Quaternion to receive the rotation component
   * @param {mat4} mat Matrix to be decomposed (input)
   * @return {quat} out
   */

  function getRotation(out, mat) {
    // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    var trace = mat[0] + mat[5] + mat[10];
    var S = 0;

    if (trace > 0) {
      S = Math.sqrt(trace + 1.0) * 2;
      out[3] = 0.25 * S;
      out[0] = (mat[6] - mat[9]) / S;
      out[1] = (mat[8] - mat[2]) / S;
      out[2] = (mat[1] - mat[4]) / S;
    } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
      S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
      out[3] = (mat[6] - mat[9]) / S;
      out[0] = 0.25 * S;
      out[1] = (mat[1] + mat[4]) / S;
      out[2] = (mat[8] + mat[2]) / S;
    } else if (mat[5] > mat[10]) {
      S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
      out[3] = (mat[8] - mat[2]) / S;
      out[0] = (mat[1] + mat[4]) / S;
      out[1] = 0.25 * S;
      out[2] = (mat[6] + mat[9]) / S;
    } else {
      S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
      out[3] = (mat[1] - mat[4]) / S;
      out[0] = (mat[8] + mat[2]) / S;
      out[1] = (mat[6] + mat[9]) / S;
      out[2] = 0.25 * S;
    }

    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {vec3} v Translation vector
   * @param {vec3} s Scaling vector
   * @returns {mat4} out
   */

  function fromRotationTranslationScale(out, q, v, s) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     mat4.translate(dest, origin);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *     mat4.translate(dest, negativeOrigin);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {vec3} v Translation vector
   * @param {vec3} s Scaling vector
   * @param {vec3} o The origin vector around which to scale and rotate
   * @returns {mat4} out
   */

  function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat} q Quaternion to create matrix from
   *
   * @returns {mat4} out
   */

  function fromQuat$1(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a frustum matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Number} left Left bound of the frustum
   * @param {Number} right Right bound of the frustum
   * @param {Number} bottom Bottom bound of the frustum
   * @param {Number} top Top bound of the frustum
   * @param {Number} near Near bound of the frustum
   * @param {Number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} fovy Vertical field of view in radians
   * @param {number} aspect Aspect ratio. typically viewport width/height
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum, can be null or Infinity
   * @returns {mat4} out
   */

  function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;

    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }

    return out;
  }
  /**
   * Generates a perspective projection matrix with the given field of view.
   * This is primarily useful for generating projection matrices to be used
   * with the still experiemental WebVR API.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
    var xScale = 2.0 / (leftTan + rightTan);
    var yScale = 2.0 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = far * near / (near - far);
    out[15] = 0.0;
    return out;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis.
   * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {vec3} eye Position of the viewer
   * @param {vec3} center Point the viewer is looking at
   * @param {vec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];

    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity$3(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);

    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);

    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  /**
   * Generates a matrix that makes something look at something else.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {vec3} eye Position of the viewer
   * @param {vec3} center Point the viewer is looking at
   * @param {vec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function targetTo(out, eye, target, up) {
    var eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2];
    var z0 = eyex - target[0],
        z1 = eyey - target[1],
        z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      z0 *= len;
      z1 *= len;
      z2 *= len;
    }

    var x0 = upy * z2 - upz * z1,
        x1 = upz * z0 - upx * z2,
        x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  /**
   * Returns a string representation of a mat4
   *
   * @param {mat4} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$3(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
  }
  /**
   * Returns Frobenius norm of a mat4
   *
   * @param {mat4} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$3(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
  }
  /**
   * Adds two mat4's
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @returns {mat4} out
   */

  function add$3(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @returns {mat4} out
   */

  function subtract$3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat4} out
   */

  function multiplyScalar$3(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
  }
  /**
   * Adds two mat4's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat4} out the receiving vector
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat4} out
   */

  function multiplyScalarAndAdd$3(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    out[9] = a[9] + b[9] * scale;
    out[10] = a[10] + b[10] * scale;
    out[11] = a[11] + b[11] * scale;
    out[12] = a[12] + b[12] * scale;
    out[13] = a[13] + b[13] * scale;
    out[14] = a[14] + b[14] * scale;
    out[15] = a[15] + b[15] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat4} a The first matrix.
   * @param {mat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$3(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat4} a The first matrix.
   * @param {mat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$4(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7];
    var a8 = a[8],
        a9 = a[9],
        a10 = a[10],
        a11 = a[11];
    var a12 = a[12],
        a13 = a[13],
        a14 = a[14],
        a15 = a[15];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    var b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7];
    var b8 = b[8],
        b9 = b[9],
        b10 = b[10],
        b11 = b[11];
    var b12 = b[12],
        b13 = b[13],
        b14 = b[14],
        b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
  }
  /**
   * Alias for {@link mat4.multiply}
   * @function
   */

  var mul$3 = multiply$3;
  /**
   * Alias for {@link mat4.subtract}
   * @function
   */

  var sub$3 = subtract$3;

  var mat4 = /*#__PURE__*/Object.freeze({
    create: create$3,
    clone: clone$3,
    copy: copy$3,
    fromValues: fromValues$3,
    set: set$3,
    identity: identity$3,
    transpose: transpose$2,
    invert: invert$3,
    adjoint: adjoint$2,
    determinant: determinant$3,
    multiply: multiply$3,
    translate: translate$2,
    scale: scale$3,
    rotate: rotate$3,
    rotateX: rotateX,
    rotateY: rotateY,
    rotateZ: rotateZ,
    fromTranslation: fromTranslation$2,
    fromScaling: fromScaling$3,
    fromRotation: fromRotation$3,
    fromXRotation: fromXRotation,
    fromYRotation: fromYRotation,
    fromZRotation: fromZRotation,
    fromRotationTranslation: fromRotationTranslation,
    fromQuat2: fromQuat2,
    getTranslation: getTranslation,
    getScaling: getScaling,
    getRotation: getRotation,
    fromRotationTranslationScale: fromRotationTranslationScale,
    fromRotationTranslationScaleOrigin: fromRotationTranslationScaleOrigin,
    fromQuat: fromQuat$1,
    frustum: frustum,
    perspective: perspective,
    perspectiveFromFieldOfView: perspectiveFromFieldOfView,
    ortho: ortho,
    lookAt: lookAt,
    targetTo: targetTo,
    str: str$3,
    frob: frob$3,
    add: add$3,
    subtract: subtract$3,
    multiplyScalar: multiplyScalar$3,
    multiplyScalarAndAdd: multiplyScalarAndAdd$3,
    exactEquals: exactEquals$3,
    equals: equals$4,
    mul: mul$3,
    sub: sub$3
  });

  /**
   * 3 Dimensional Vector
   * @module vec3
   */

  /**
   * Creates a new, empty vec3
   *
   * @returns {vec3} a new 3D vector
   */

  function create$4() {
    var out = new ARRAY_TYPE(3);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec3 initialized with values from an existing vector
   *
   * @param {vec3} a vector to clone
   * @returns {vec3} a new 3D vector
   */

  function clone$4(a) {
    var out = new ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  /**
   * Calculates the length of a vec3
   *
   * @param {vec3} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Creates a new vec3 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} a new 3D vector
   */

  function fromValues$4(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Copy the values from one vec3 to another
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the source vector
   * @returns {vec3} out
   */

  function copy$4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  /**
   * Set the components of a vec3 to the given values
   *
   * @param {vec3} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} out
   */

  function set$4(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Adds two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function add$4(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function subtract$4(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  /**
   * Multiplies two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function multiply$4(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  /**
   * Divides two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
  }
  /**
   * Math.ceil the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to ceil
   * @returns {vec3} out
   */

  function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
  }
  /**
   * Math.floor the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to floor
   * @returns {vec3} out
   */

  function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
  }
  /**
   * Returns the minimum of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
  }
  /**
   * Returns the maximum of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
  }
  /**
   * Math.round the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to round
   * @returns {vec3} out
   */

  function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
  }
  /**
   * Scales a vec3 by a scalar number
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec3} out
   */

  function scale$4(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
  }
  /**
   * Adds two vec3's after scaling the second operand by a scalar value
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec3} out
   */

  function scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Calculates the squared euclidian distance between two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Calculates the squared length of a vec3
   *
   * @param {vec3} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Negates the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to negate
   * @returns {vec3} out
   */

  function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to invert
   * @returns {vec3} out
   */

  function inverse(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    return out;
  }
  /**
   * Normalize a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to normalize
   * @returns {vec3} out
   */

  function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len = x * x + y * y + z * z;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  /**
   * Computes the cross product of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function cross(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    var bx = b[0],
        by = b[1],
        bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  /**
   * Performs a hermite interpolation with two control points
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {vec3} c the third operand
   * @param {vec3} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function hermite(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  /**
   * Performs a bezier interpolation with two control points
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {vec3} c the third operand
   * @param {vec3} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function bezier(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec3} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec3} out
   */

  function random(out, scale) {
    scale = scale || 1.0;
    var r = RANDOM() * 2.0 * Math.PI;
    var z = RANDOM() * 2.0 - 1.0;
    var zScale = Math.sqrt(1.0 - z * z) * scale;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
  }
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec3} out
   */

  function transformMat4(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  /**
   * Transforms the vec3 with a mat3.
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to transform
   * @param {mat3} m the 3x3 matrix to transform with
   * @returns {vec3} out
   */

  function transformMat3(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  /**
   * Transforms the vec3 with a quat
   * Can also be used for dual quaternions. (Multiply it with the real part)
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to transform
   * @param {quat} q quaternion to transform with
   * @returns {vec3} out
   */

  function transformQuat(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3];
    var x = a[0],
        y = a[1],
        z = a[2]; // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);

    var uvx = qy * z - qz * y,
        uvy = qz * x - qx * z,
        uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

    var uuvx = qy * uvz - qz * uvy,
        uuvy = qz * uvx - qx * uvz,
        uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2; // vec3.scale(uuv, uuv, 2);

    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  /**
   * Rotate a 3D vector around the x-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateX$1(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[0];
    r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
    r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Rotate a 3D vector around the y-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateY$1(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Rotate a 3D vector around the z-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateZ$1(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
    r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
    r[2] = p[2]; //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Get the angle between two 3D vectors
   * @param {vec3} a The first operand
   * @param {vec3} b The second operand
   * @returns {Number} The angle in radians
   */

  function angle(a, b) {
    var tempA = fromValues$4(a[0], a[1], a[2]);
    var tempB = fromValues$4(b[0], b[1], b[2]);
    normalize(tempA, tempA);
    normalize(tempB, tempB);
    var cosine = dot(tempA, tempB);

    if (cosine > 1.0) {
      return 0;
    } else if (cosine < -1.0) {
      return Math.PI;
    } else {
      return Math.acos(cosine);
    }
  }
  /**
   * Set the components of a vec3 to zero
   *
   * @param {vec3} out the receiving vector
   * @returns {vec3} out
   */

  function zero(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {vec3} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$4(a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   *
   * @param {vec3} a The first vector.
   * @param {vec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals$4(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {vec3} a The first vector.
   * @param {vec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$5(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
  }
  /**
   * Alias for {@link vec3.subtract}
   * @function
   */

  var sub$4 = subtract$4;
  /**
   * Alias for {@link vec3.multiply}
   * @function
   */

  var mul$4 = multiply$4;
  /**
   * Alias for {@link vec3.divide}
   * @function
   */

  var div = divide;
  /**
   * Alias for {@link vec3.distance}
   * @function
   */

  var dist = distance;
  /**
   * Alias for {@link vec3.squaredDistance}
   * @function
   */

  var sqrDist = squaredDistance;
  /**
   * Alias for {@link vec3.length}
   * @function
   */

  var len = length;
  /**
   * Alias for {@link vec3.squaredLength}
   * @function
   */

  var sqrLen = squaredLength;
  /**
   * Perform some operation over an array of vec3s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach = function () {
    var vec = create$4();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 3;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }

      return a;
    };
  }();

  var vec3 = /*#__PURE__*/Object.freeze({
    create: create$4,
    clone: clone$4,
    length: length,
    fromValues: fromValues$4,
    copy: copy$4,
    set: set$4,
    add: add$4,
    subtract: subtract$4,
    multiply: multiply$4,
    divide: divide,
    ceil: ceil,
    floor: floor,
    min: min,
    max: max,
    round: round,
    scale: scale$4,
    scaleAndAdd: scaleAndAdd,
    distance: distance,
    squaredDistance: squaredDistance,
    squaredLength: squaredLength,
    negate: negate,
    inverse: inverse,
    normalize: normalize,
    dot: dot,
    cross: cross,
    lerp: lerp,
    hermite: hermite,
    bezier: bezier,
    random: random,
    transformMat4: transformMat4,
    transformMat3: transformMat3,
    transformQuat: transformQuat,
    rotateX: rotateX$1,
    rotateY: rotateY$1,
    rotateZ: rotateZ$1,
    angle: angle,
    zero: zero,
    str: str$4,
    exactEquals: exactEquals$4,
    equals: equals$5,
    sub: sub$4,
    mul: mul$4,
    div: div,
    dist: dist,
    sqrDist: sqrDist,
    len: len,
    sqrLen: sqrLen,
    forEach: forEach
  });

  /**
   * 4 Dimensional Vector
   * @module vec4
   */

  /**
   * Creates a new, empty vec4
   *
   * @returns {vec4} a new 4D vector
   */

  function create$5() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec4 initialized with values from an existing vector
   *
   * @param {vec4} a vector to clone
   * @returns {vec4} a new 4D vector
   */

  function clone$5(a) {
    var out = new ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Creates a new vec4 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} a new 4D vector
   */

  function fromValues$5(x, y, z, w) {
    var out = new ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  /**
   * Copy the values from one vec4 to another
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the source vector
   * @returns {vec4} out
   */

  function copy$5(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Set the components of a vec4 to the given values
   *
   * @param {vec4} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} out
   */

  function set$5(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  /**
   * Adds two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function add$5(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function subtract$5(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
  }
  /**
   * Multiplies two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function multiply$5(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
  }
  /**
   * Divides two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function divide$1(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
  }
  /**
   * Math.ceil the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to ceil
   * @returns {vec4} out
   */

  function ceil$1(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
  }
  /**
   * Math.floor the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to floor
   * @returns {vec4} out
   */

  function floor$1(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
  }
  /**
   * Returns the minimum of two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function min$1(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
  }
  /**
   * Returns the maximum of two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function max$1(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
  }
  /**
   * Math.round the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to round
   * @returns {vec4} out
   */

  function round$1(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
  }
  /**
   * Scales a vec4 by a scalar number
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec4} out
   */

  function scale$5(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  /**
   * Adds two vec4's after scaling the second operand by a scalar value
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec4} out
   */

  function scaleAndAdd$1(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec4's
   *
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance$1(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
  }
  /**
   * Calculates the squared euclidian distance between two vec4's
   *
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance$1(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
  }
  /**
   * Calculates the length of a vec4
   *
   * @param {vec4} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length$1(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
  }
  /**
   * Calculates the squared length of a vec4
   *
   * @param {vec4} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength$1(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
  }
  /**
   * Negates the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to negate
   * @returns {vec4} out
   */

  function negate$1(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to invert
   * @returns {vec4} out
   */

  function inverse$1(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    out[3] = 1.0 / a[3];
    return out;
  }
  /**
   * Normalize a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to normalize
   * @returns {vec4} out
   */

  function normalize$1(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len = x * x + y * y + z * z + w * w;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
    }

    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec4's
   *
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$1(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  /**
   * Returns the cross-product of three vectors in a 4-dimensional space
   *
   * @param {vec4} result the receiving vector
   * @param {vec4} U the first vector
   * @param {vec4} V the second vector
   * @param {vec4} W the third vector
   * @returns {vec4} result
   */

  function cross$1(out, u, v, w) {
    var A = v[0] * w[1] - v[1] * w[0],
        B = v[0] * w[2] - v[2] * w[0],
        C = v[0] * w[3] - v[3] * w[0],
        D = v[1] * w[2] - v[2] * w[1],
        E = v[1] * w[3] - v[3] * w[1],
        F = v[2] * w[3] - v[3] * w[2];
    var G = u[0];
    var H = u[1];
    var I = u[2];
    var J = u[3];
    out[0] = H * F - I * E + J * D;
    out[1] = -(G * F) + I * C - J * B;
    out[2] = G * E - H * C + J * A;
    out[3] = -(G * D) + H * B - I * A;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec4} out
   */

  function lerp$1(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec4} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec4} out
   */

  function random$1(out, scale) {
    scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
    // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
    // http://projecteuclid.org/euclid.aoms/1177692644;

    var v1, v2, v3, v4;
    var s1, s2;

    do {
      v1 = RANDOM() * 2 - 1;
      v2 = RANDOM() * 2 - 1;
      s1 = v1 * v1 + v2 * v2;
    } while (s1 >= 1);

    do {
      v3 = RANDOM() * 2 - 1;
      v4 = RANDOM() * 2 - 1;
      s2 = v3 * v3 + v4 * v4;
    } while (s2 >= 1);

    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale * v1;
    out[1] = scale * v2;
    out[2] = scale * v3 * d;
    out[3] = scale * v4 * d;
    return out;
  }
  /**
   * Transforms the vec4 with a mat4.
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec4} out
   */

  function transformMat4$1(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  /**
   * Transforms the vec4 with a quat
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the vector to transform
   * @param {quat} q quaternion to transform with
   * @returns {vec4} out
   */

  function transformQuat$1(out, a, q) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3]; // calculate quat * vec

    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
  }
  /**
   * Set the components of a vec4 to zero
   *
   * @param {vec4} out the receiving vector
   * @returns {vec4} out
   */

  function zero$1(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {vec4} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$5(a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   *
   * @param {vec4} a The first vector.
   * @param {vec4} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals$5(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {vec4} a The first vector.
   * @param {vec4} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$6(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
  }
  /**
   * Alias for {@link vec4.subtract}
   * @function
   */

  var sub$5 = subtract$5;
  /**
   * Alias for {@link vec4.multiply}
   * @function
   */

  var mul$5 = multiply$5;
  /**
   * Alias for {@link vec4.divide}
   * @function
   */

  var div$1 = divide$1;
  /**
   * Alias for {@link vec4.distance}
   * @function
   */

  var dist$1 = distance$1;
  /**
   * Alias for {@link vec4.squaredDistance}
   * @function
   */

  var sqrDist$1 = squaredDistance$1;
  /**
   * Alias for {@link vec4.length}
   * @function
   */

  var len$1 = length$1;
  /**
   * Alias for {@link vec4.squaredLength}
   * @function
   */

  var sqrLen$1 = squaredLength$1;
  /**
   * Perform some operation over an array of vec4s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$1 = function () {
    var vec = create$5();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 4;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }

      return a;
    };
  }();

  var vec4 = /*#__PURE__*/Object.freeze({
    create: create$5,
    clone: clone$5,
    fromValues: fromValues$5,
    copy: copy$5,
    set: set$5,
    add: add$5,
    subtract: subtract$5,
    multiply: multiply$5,
    divide: divide$1,
    ceil: ceil$1,
    floor: floor$1,
    min: min$1,
    max: max$1,
    round: round$1,
    scale: scale$5,
    scaleAndAdd: scaleAndAdd$1,
    distance: distance$1,
    squaredDistance: squaredDistance$1,
    length: length$1,
    squaredLength: squaredLength$1,
    negate: negate$1,
    inverse: inverse$1,
    normalize: normalize$1,
    dot: dot$1,
    cross: cross$1,
    lerp: lerp$1,
    random: random$1,
    transformMat4: transformMat4$1,
    transformQuat: transformQuat$1,
    zero: zero$1,
    str: str$5,
    exactEquals: exactEquals$5,
    equals: equals$6,
    sub: sub$5,
    mul: mul$5,
    div: div$1,
    dist: dist$1,
    sqrDist: sqrDist$1,
    len: len$1,
    sqrLen: sqrLen$1,
    forEach: forEach$1
  });

  /**
   * Quaternion
   * @module quat
   */

  /**
   * Creates a new identity quat
   *
   * @returns {quat} a new quaternion
   */

  function create$6() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    out[3] = 1;
    return out;
  }
  /**
   * Set a quat to the identity quaternion
   *
   * @param {quat} out the receiving quaternion
   * @returns {quat} out
   */

  function identity$4(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  /**
   * Sets a quat from the given angle and rotation axis,
   * then returns it.
   *
   * @param {quat} out the receiving quaternion
   * @param {vec3} axis the axis around which to rotate
   * @param {Number} rad the angle in radians
   * @returns {quat} out
   **/

  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  /**
   * Gets the rotation axis and angle for a given
   *  quaternion. If a quaternion is created with
   *  setAxisAngle, this method will return the same
   *  values as providied in the original parameter list
   *  OR functionally equivalent values.
   * Example: The quaternion formed by axis [0, 0, 1] and
   *  angle -90 is the same as the quaternion formed by
   *  [0, 0, 1] and 270. This method favors the latter.
   * @param  {vec3} out_axis  Vector receiving the axis of rotation
   * @param  {quat} q     Quaternion to be decomposed
   * @return {Number}     Angle, in radians, of the rotation
   */

  function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);

    if (s > EPSILON) {
      out_axis[0] = q[0] / s;
      out_axis[1] = q[1] / s;
      out_axis[2] = q[2] / s;
    } else {
      // If s is zero, return any axis (no rotation - axis does not matter)
      out_axis[0] = 1;
      out_axis[1] = 0;
      out_axis[2] = 0;
    }

    return rad;
  }
  /**
   * Multiplies two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @returns {quat} out
   */

  function multiply$6(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the X axis
   *
   * @param {quat} out quat receiving operation result
   * @param {quat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateX$2(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the Y axis
   *
   * @param {quat} out quat receiving operation result
   * @param {quat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateY$2(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var by = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the Z axis
   *
   * @param {quat} out quat receiving operation result
   * @param {quat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateZ$2(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bz = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  /**
   * Calculates the W component of a quat from the X, Y, and Z components.
   * Assumes that quaternion is 1 unit in length.
   * Any existing W component will be ignored.
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate W component of
   * @returns {quat} out
   */

  function calculateW(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  function slerp(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    var omega, cosom, sinom, scale0, scale1; // calc cosine

    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    } // calculate coefficients


    if (1.0 - cosom > EPSILON) {
      // standard case (slerp)
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      // "from" and "to" quaternions are very close
      //  ... so we can do a linear interpolation
      scale0 = 1.0 - t;
      scale1 = t;
    } // calculate final values


    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  /**
   * Generates a random quaternion
   *
   * @param {quat} out the receiving quaternion
   * @returns {quat} out
   */

  function random$2(out) {
    // Implementation of http://planning.cs.uiuc.edu/node198.html
    // TODO: Calling random 3 times is probably not the fastest solution
    var u1 = RANDOM();
    var u2 = RANDOM();
    var u3 = RANDOM();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
    return out;
  }
  /**
   * Calculates the inverse of a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate inverse of
   * @returns {quat} out
   */

  function invert$4(out, a) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var dot$$1 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot$$1 ? 1.0 / dot$$1 : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
  }
  /**
   * Calculates the conjugate of a quat
   * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate conjugate of
   * @returns {quat} out
   */

  function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   *
   * @param {quat} out the receiving quaternion
   * @param {mat3} m rotation matrix
   * @returns {quat} out
   * @function
   */

  function fromMat3(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if (fTrace > 0.0) {
      // |w| > 1/2, may as well choose w > 1/2
      fRoot = Math.sqrt(fTrace + 1.0); // 2w

      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot; // 1/(4w)

      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      // |w| <= 1/2
      var i = 0;
      if (m[4] > m[0]) i = 1;
      if (m[8] > m[i * 3 + i]) i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }

    return out;
  }
  /**
   * Creates a quaternion from the given euler angle x, y, z.
   *
   * @param {quat} out the receiving quaternion
   * @param {x} Angle to rotate around X axis in degrees.
   * @param {y} Angle to rotate around Y axis in degrees.
   * @param {z} Angle to rotate around Z axis in degrees.
   * @returns {quat} out
   * @function
   */

  function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  /**
   * Returns a string representation of a quatenion
   *
   * @param {quat} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$6(a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
  }
  /**
   * Creates a new quat initialized with values from an existing quaternion
   *
   * @param {quat} a quaternion to clone
   * @returns {quat} a new quaternion
   * @function
   */

  var clone$6 = clone$5;
  /**
   * Creates a new quat initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} a new quaternion
   * @function
   */

  var fromValues$6 = fromValues$5;
  /**
   * Copy the values from one quat to another
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the source quaternion
   * @returns {quat} out
   * @function
   */

  var copy$6 = copy$5;
  /**
   * Set the components of a quat to the given values
   *
   * @param {quat} out the receiving quaternion
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} out
   * @function
   */

  var set$6 = set$5;
  /**
   * Adds two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @returns {quat} out
   * @function
   */

  var add$6 = add$5;
  /**
   * Alias for {@link quat.multiply}
   * @function
   */

  var mul$6 = multiply$6;
  /**
   * Scales a quat by a scalar number
   *
   * @param {quat} out the receiving vector
   * @param {quat} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {quat} out
   * @function
   */

  var scale$6 = scale$5;
  /**
   * Calculates the dot product of two quat's
   *
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @returns {Number} dot product of a and b
   * @function
   */

  var dot$2 = dot$1;
  /**
   * Performs a linear interpolation between two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   * @function
   */

  var lerp$2 = lerp$1;
  /**
   * Calculates the length of a quat
   *
   * @param {quat} a vector to calculate length of
   * @returns {Number} length of a
   */

  var length$2 = length$1;
  /**
   * Alias for {@link quat.length}
   * @function
   */

  var len$2 = length$2;
  /**
   * Calculates the squared length of a quat
   *
   * @param {quat} a vector to calculate squared length of
   * @returns {Number} squared length of a
   * @function
   */

  var squaredLength$2 = squaredLength$1;
  /**
   * Alias for {@link quat.squaredLength}
   * @function
   */

  var sqrLen$2 = squaredLength$2;
  /**
   * Normalize a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quaternion to normalize
   * @returns {quat} out
   * @function
   */

  var normalize$2 = normalize$1;
  /**
   * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
   *
   * @param {quat} a The first quaternion.
   * @param {quat} b The second quaternion.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  var exactEquals$6 = exactEquals$5;
  /**
   * Returns whether or not the quaternions have approximately the same elements in the same position.
   *
   * @param {quat} a The first vector.
   * @param {quat} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  var equals$7 = equals$6;
  /**
   * Sets a quaternion to represent the shortest rotation from one
   * vector to another.
   *
   * Both vectors are assumed to be unit length.
   *
   * @param {quat} out the receiving quaternion.
   * @param {vec3} a the initial vector
   * @param {vec3} b the destination vector
   * @returns {quat} out
   */

  var rotationTo = function () {
    var tmpvec3 = create$4();
    var xUnitVec3 = fromValues$4(1, 0, 0);
    var yUnitVec3 = fromValues$4(0, 1, 0);
    return function (out, a, b) {
      var dot$$1 = dot(a, b);

      if (dot$$1 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a);
        if (len(tmpvec3) < 0.000001) cross(tmpvec3, yUnitVec3, a);
        normalize(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot$$1 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot$$1;
        return normalize$2(out, out);
      }
    };
  }();
  /**
   * Performs a spherical linear interpolation with two control points
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @param {quat} c the third operand
   * @param {quat} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  var sqlerp = function () {
    var temp1 = create$6();
    var temp2 = create$6();
    return function (out, a, b, c, d, t) {
      slerp(temp1, a, d, t);
      slerp(temp2, b, c, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  }();
  /**
   * Sets the specified quaternion with values corresponding to the given
   * axes. Each axis is a vec3 and is expected to be unit length and
   * perpendicular to all other specified axes.
   *
   * @param {vec3} view  the vector representing the viewing direction
   * @param {vec3} right the vector representing the local "right" direction
   * @param {vec3} up    the vector representing the local "up" direction
   * @returns {quat} out
   */

  var setAxes = function () {
    var matr = create$2();
    return function (out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize$2(out, fromMat3(out, matr));
    };
  }();

  var quat = /*#__PURE__*/Object.freeze({
    create: create$6,
    identity: identity$4,
    setAxisAngle: setAxisAngle,
    getAxisAngle: getAxisAngle,
    multiply: multiply$6,
    rotateX: rotateX$2,
    rotateY: rotateY$2,
    rotateZ: rotateZ$2,
    calculateW: calculateW,
    slerp: slerp,
    random: random$2,
    invert: invert$4,
    conjugate: conjugate,
    fromMat3: fromMat3,
    fromEuler: fromEuler,
    str: str$6,
    clone: clone$6,
    fromValues: fromValues$6,
    copy: copy$6,
    set: set$6,
    add: add$6,
    mul: mul$6,
    scale: scale$6,
    dot: dot$2,
    lerp: lerp$2,
    length: length$2,
    len: len$2,
    squaredLength: squaredLength$2,
    sqrLen: sqrLen$2,
    normalize: normalize$2,
    exactEquals: exactEquals$6,
    equals: equals$7,
    rotationTo: rotationTo,
    sqlerp: sqlerp,
    setAxes: setAxes
  });

  /**
   * Dual Quaternion<br>
   * Format: [real, dual]<br>
   * Quaternion format: XYZW<br>
   * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
   * @module quat2
   */

  /**
   * Creates a new identity dual quat
   *
   * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
   */

  function create$7() {
    var dq = new ARRAY_TYPE(8);

    if (ARRAY_TYPE != Float32Array) {
      dq[0] = 0;
      dq[1] = 0;
      dq[2] = 0;
      dq[4] = 0;
      dq[5] = 0;
      dq[6] = 0;
      dq[7] = 0;
    }

    dq[3] = 1;
    return dq;
  }
  /**
   * Creates a new quat initialized with values from an existing quaternion
   *
   * @param {quat2} a dual quaternion to clone
   * @returns {quat2} new dual quaternion
   * @function
   */

  function clone$7(a) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = a[0];
    dq[1] = a[1];
    dq[2] = a[2];
    dq[3] = a[3];
    dq[4] = a[4];
    dq[5] = a[5];
    dq[6] = a[6];
    dq[7] = a[7];
    return dq;
  }
  /**
   * Creates a new dual quat initialized with the given values
   *
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component
   * @param {Number} y2 Y component
   * @param {Number} z2 Z component
   * @param {Number} w2 W component
   * @returns {quat2} new dual quaternion
   * @function
   */

  function fromValues$7(x1, y1, z1, w1, x2, y2, z2, w2) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    dq[4] = x2;
    dq[5] = y2;
    dq[6] = z2;
    dq[7] = w2;
    return dq;
  }
  /**
   * Creates a new dual quat from the given values (quat and translation)
   *
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component (translation)
   * @param {Number} y2 Y component (translation)
   * @param {Number} z2 Z component (translation)
   * @returns {quat2} new dual quaternion
   * @function
   */

  function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    var ax = x2 * 0.5,
        ay = y2 * 0.5,
        az = z2 * 0.5;
    dq[4] = ax * w1 + ay * z1 - az * y1;
    dq[5] = ay * w1 + az * x1 - ax * z1;
    dq[6] = az * w1 + ax * y1 - ay * x1;
    dq[7] = -ax * x1 - ay * y1 - az * z1;
    return dq;
  }
  /**
   * Creates a dual quat from a quaternion and a translation
   *
   * @param {quat2} dual quaternion receiving operation result
   * @param {quat} q quaternion
   * @param {vec3} t tranlation vector
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromRotationTranslation$1(out, q, t) {
    var ax = t[0] * 0.5,
        ay = t[1] * 0.5,
        az = t[2] * 0.5,
        bx = q[0],
        by = q[1],
        bz = q[2],
        bw = q[3];
    out[0] = bx;
    out[1] = by;
    out[2] = bz;
    out[3] = bw;
    out[4] = ax * bw + ay * bz - az * by;
    out[5] = ay * bw + az * bx - ax * bz;
    out[6] = az * bw + ax * by - ay * bx;
    out[7] = -ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Creates a dual quat from a translation
   *
   * @param {quat2} dual quaternion receiving operation result
   * @param {vec3} t translation vector
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromTranslation$3(out, t) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = t[0] * 0.5;
    out[5] = t[1] * 0.5;
    out[6] = t[2] * 0.5;
    out[7] = 0;
    return out;
  }
  /**
   * Creates a dual quat from a quaternion
   *
   * @param {quat2} dual quaternion receiving operation result
   * @param {quat} q the quaternion
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromRotation$4(out, q) {
    out[0] = q[0];
    out[1] = q[1];
    out[2] = q[2];
    out[3] = q[3];
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
  }
  /**
   * Creates a new dual quat from a matrix (4x4)
   *
   * @param {quat2} out the dual quaternion
   * @param {mat4} a the matrix
   * @returns {quat2} dual quat receiving operation result
   * @function
   */

  function fromMat4$1(out, a) {
    //TODO Optimize this
    var outer = create$6();
    getRotation(outer, a);
    var t = new ARRAY_TYPE(3);
    getTranslation(t, a);
    fromRotationTranslation$1(out, outer, t);
    return out;
  }
  /**
   * Copy the values from one dual quat to another
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the source dual quaternion
   * @returns {quat2} out
   * @function
   */

  function copy$7(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    return out;
  }
  /**
   * Set a dual quat to the identity dual quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @returns {quat2} out
   */

  function identity$5(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
  }
  /**
   * Set the components of a dual quat to the given values
   *
   * @param {quat2} out the receiving quaternion
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component
   * @param {Number} y2 Y component
   * @param {Number} z2 Z component
   * @param {Number} w2 W component
   * @returns {quat2} out
   * @function
   */

  function set$7(out, x1, y1, z1, w1, x2, y2, z2, w2) {
    out[0] = x1;
    out[1] = y1;
    out[2] = z1;
    out[3] = w1;
    out[4] = x2;
    out[5] = y2;
    out[6] = z2;
    out[7] = w2;
    return out;
  }
  /**
   * Gets the real part of a dual quat
   * @param  {quat} out real part
   * @param  {quat2} a Dual Quaternion
   * @return {quat} real part
   */

  var getReal = copy$6;
  /**
   * Gets the dual part of a dual quat
   * @param  {quat} out dual part
   * @param  {quat2} a Dual Quaternion
   * @return {quat} dual part
   */

  function getDual(out, a) {
    out[0] = a[4];
    out[1] = a[5];
    out[2] = a[6];
    out[3] = a[7];
    return out;
  }
  /**
   * Set the real component of a dual quat to the given quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @param {quat} q a quaternion representing the real part
   * @returns {quat2} out
   * @function
   */

  var setReal = copy$6;
  /**
   * Set the dual component of a dual quat to the given quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @param {quat} q a quaternion representing the dual part
   * @returns {quat2} out
   * @function
   */

  function setDual(out, q) {
    out[4] = q[0];
    out[5] = q[1];
    out[6] = q[2];
    out[7] = q[3];
    return out;
  }
  /**
   * Gets the translation of a normalized dual quat
   * @param  {vec3} out translation
   * @param  {quat2} a Dual Quaternion to be decomposed
   * @return {vec3} translation
   */

  function getTranslation$1(out, a) {
    var ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3];
    out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    return out;
  }
  /**
   * Translates a dual quat by the given vector
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to translate
   * @param {vec3} v vector to translate by
   * @returns {quat2} out
   */

  function translate$3(out, a, v) {
    var ax1 = a[0],
        ay1 = a[1],
        az1 = a[2],
        aw1 = a[3],
        bx1 = v[0] * 0.5,
        by1 = v[1] * 0.5,
        bz1 = v[2] * 0.5,
        ax2 = a[4],
        ay2 = a[5],
        az2 = a[6],
        aw2 = a[7];
    out[0] = ax1;
    out[1] = ay1;
    out[2] = az1;
    out[3] = aw1;
    out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
    out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
    out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
    out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
    return out;
  }
  /**
   * Rotates a dual quat around the X axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateX$3(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateX$2(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat around the Y axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateY$3(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateY$2(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat around the Z axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateZ$3(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateZ$2(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat by a given quaternion (a * q)
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {quat} q quaternion to rotate by
   * @returns {quat2} out
   */

  function rotateByQuatAppend(out, a, q) {
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3],
        ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax * qw + aw * qx + ay * qz - az * qy;
    out[1] = ay * qw + aw * qy + az * qx - ax * qz;
    out[2] = az * qw + aw * qz + ax * qy - ay * qx;
    out[3] = aw * qw - ax * qx - ay * qy - az * qz;
    ax = a[4];
    ay = a[5];
    az = a[6];
    aw = a[7];
    out[4] = ax * qw + aw * qx + ay * qz - az * qy;
    out[5] = ay * qw + aw * qy + az * qx - ax * qz;
    out[6] = az * qw + aw * qz + ax * qy - ay * qx;
    out[7] = aw * qw - ax * qx - ay * qy - az * qz;
    return out;
  }
  /**
   * Rotates a dual quat by a given quaternion (q * a)
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat} q quaternion to rotate by
   * @param {quat2} a the dual quaternion to rotate
   * @returns {quat2} out
   */

  function rotateByQuatPrepend(out, q, a) {
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3],
        bx = a[0],
        by = a[1],
        bz = a[2],
        bw = a[3];
    out[0] = qx * bw + qw * bx + qy * bz - qz * by;
    out[1] = qy * bw + qw * by + qz * bx - qx * bz;
    out[2] = qz * bw + qw * bz + qx * by - qy * bx;
    out[3] = qw * bw - qx * bx - qy * by - qz * bz;
    bx = a[4];
    by = a[5];
    bz = a[6];
    bw = a[7];
    out[4] = qx * bw + qw * bx + qy * bz - qz * by;
    out[5] = qy * bw + qw * by + qz * bx - qx * bz;
    out[6] = qz * bw + qw * bz + qx * by - qy * bx;
    out[7] = qw * bw - qx * bx - qy * by - qz * bz;
    return out;
  }
  /**
   * Rotates a dual quat around a given axis. Does the normalisation automatically
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {vec3} axis the axis to rotate around
   * @param {Number} rad how far the rotation should be
   * @returns {quat2} out
   */

  function rotateAroundAxis(out, a, axis, rad) {
    //Special case for rad = 0
    if (Math.abs(rad) < EPSILON) {
      return copy$7(out, a);
    }

    var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);
    rad = rad * 0.5;
    var s = Math.sin(rad);
    var bx = s * axis[0] / axisLength;
    var by = s * axis[1] / axisLength;
    var bz = s * axis[2] / axisLength;
    var bw = Math.cos(rad);
    var ax1 = a[0],
        ay1 = a[1],
        az1 = a[2],
        aw1 = a[3];
    out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    var ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7];
    out[4] = ax * bw + aw * bx + ay * bz - az * by;
    out[5] = ay * bw + aw * by + az * bx - ax * bz;
    out[6] = az * bw + aw * bz + ax * by - ay * bx;
    out[7] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Adds two dual quat's
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @returns {quat2} out
   * @function
   */

  function add$7(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    return out;
  }
  /**
   * Multiplies two dual quat's
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @returns {quat2} out
   */

  function multiply$7(out, a, b) {
    var ax0 = a[0],
        ay0 = a[1],
        az0 = a[2],
        aw0 = a[3],
        bx1 = b[4],
        by1 = b[5],
        bz1 = b[6],
        bw1 = b[7],
        ax1 = a[4],
        ay1 = a[5],
        az1 = a[6],
        aw1 = a[7],
        bx0 = b[0],
        by0 = b[1],
        bz0 = b[2],
        bw0 = b[3];
    out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
    out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
    out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
    out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
    out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
    out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
    out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
    out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
    return out;
  }
  /**
   * Alias for {@link quat2.multiply}
   * @function
   */

  var mul$7 = multiply$7;
  /**
   * Scales a dual quat by a scalar number
   *
   * @param {quat2} out the receiving dual quat
   * @param {quat2} a the dual quat to scale
   * @param {Number} b amount to scale the dual quat by
   * @returns {quat2} out
   * @function
   */

  function scale$7(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    return out;
  }
  /**
   * Calculates the dot product of two dual quat's (The dot product of the real parts)
   *
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @returns {Number} dot product of a and b
   * @function
   */

  var dot$3 = dot$2;
  /**
   * Performs a linear interpolation between two dual quats's
   * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
   *
   * @param {quat2} out the receiving dual quat
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat2} out
   */

  function lerp$3(out, a, b, t) {
    var mt = 1 - t;
    if (dot$3(a, b) < 0) t = -t;
    out[0] = a[0] * mt + b[0] * t;
    out[1] = a[1] * mt + b[1] * t;
    out[2] = a[2] * mt + b[2] * t;
    out[3] = a[3] * mt + b[3] * t;
    out[4] = a[4] * mt + b[4] * t;
    out[5] = a[5] * mt + b[5] * t;
    out[6] = a[6] * mt + b[6] * t;
    out[7] = a[7] * mt + b[7] * t;
    return out;
  }
  /**
   * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a dual quat to calculate inverse of
   * @returns {quat2} out
   */

  function invert$5(out, a) {
    var sqlen = squaredLength$3(a);
    out[0] = -a[0] / sqlen;
    out[1] = -a[1] / sqlen;
    out[2] = -a[2] / sqlen;
    out[3] = a[3] / sqlen;
    out[4] = -a[4] / sqlen;
    out[5] = -a[5] / sqlen;
    out[6] = -a[6] / sqlen;
    out[7] = a[7] / sqlen;
    return out;
  }
  /**
   * Calculates the conjugate of a dual quat
   * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
   *
   * @param {quat2} out the receiving quaternion
   * @param {quat2} a quat to calculate conjugate of
   * @returns {quat2} out
   */

  function conjugate$1(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    out[4] = -a[4];
    out[5] = -a[5];
    out[6] = -a[6];
    out[7] = a[7];
    return out;
  }
  /**
   * Calculates the length of a dual quat
   *
   * @param {quat2} a dual quat to calculate length of
   * @returns {Number} length of a
   * @function
   */

  var length$3 = length$2;
  /**
   * Alias for {@link quat2.length}
   * @function
   */

  var len$3 = length$3;
  /**
   * Calculates the squared length of a dual quat
   *
   * @param {quat2} a dual quat to calculate squared length of
   * @returns {Number} squared length of a
   * @function
   */

  var squaredLength$3 = squaredLength$2;
  /**
   * Alias for {@link quat2.squaredLength}
   * @function
   */

  var sqrLen$3 = squaredLength$3;
  /**
   * Normalize a dual quat
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a dual quaternion to normalize
   * @returns {quat2} out
   * @function
   */

  function normalize$3(out, a) {
    var magnitude = squaredLength$3(a);

    if (magnitude > 0) {
      magnitude = Math.sqrt(magnitude);
      var a0 = a[0] / magnitude;
      var a1 = a[1] / magnitude;
      var a2 = a[2] / magnitude;
      var a3 = a[3] / magnitude;
      var b0 = a[4];
      var b1 = a[5];
      var b2 = a[6];
      var b3 = a[7];
      var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
      out[0] = a0;
      out[1] = a1;
      out[2] = a2;
      out[3] = a3;
      out[4] = (b0 - a0 * a_dot_b) / magnitude;
      out[5] = (b1 - a1 * a_dot_b) / magnitude;
      out[6] = (b2 - a2 * a_dot_b) / magnitude;
      out[7] = (b3 - a3 * a_dot_b) / magnitude;
    }

    return out;
  }
  /**
   * Returns a string representation of a dual quatenion
   *
   * @param {quat2} a dual quaternion to represent as a string
   * @returns {String} string representation of the dual quat
   */

  function str$7(a) {
    return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
  }
  /**
   * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
   *
   * @param {quat2} a the first dual quaternion.
   * @param {quat2} b the second dual quaternion.
   * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
   */

  function exactEquals$7(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
  }
  /**
   * Returns whether or not the dual quaternions have approximately the same elements in the same position.
   *
   * @param {quat2} a the first dual quat.
   * @param {quat2} b the second dual quat.
   * @returns {Boolean} true if the dual quats are equal, false otherwise.
   */

  function equals$8(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
  }

  var quat2 = /*#__PURE__*/Object.freeze({
    create: create$7,
    clone: clone$7,
    fromValues: fromValues$7,
    fromRotationTranslationValues: fromRotationTranslationValues,
    fromRotationTranslation: fromRotationTranslation$1,
    fromTranslation: fromTranslation$3,
    fromRotation: fromRotation$4,
    fromMat4: fromMat4$1,
    copy: copy$7,
    identity: identity$5,
    set: set$7,
    getReal: getReal,
    getDual: getDual,
    setReal: setReal,
    setDual: setDual,
    getTranslation: getTranslation$1,
    translate: translate$3,
    rotateX: rotateX$3,
    rotateY: rotateY$3,
    rotateZ: rotateZ$3,
    rotateByQuatAppend: rotateByQuatAppend,
    rotateByQuatPrepend: rotateByQuatPrepend,
    rotateAroundAxis: rotateAroundAxis,
    add: add$7,
    multiply: multiply$7,
    mul: mul$7,
    scale: scale$7,
    dot: dot$3,
    lerp: lerp$3,
    invert: invert$5,
    conjugate: conjugate$1,
    length: length$3,
    len: len$3,
    squaredLength: squaredLength$3,
    sqrLen: sqrLen$3,
    normalize: normalize$3,
    str: str$7,
    exactEquals: exactEquals$7,
    equals: equals$8
  });

  /**
   * 2 Dimensional Vector
   * @module vec2
   */

  /**
   * Creates a new, empty vec2
   *
   * @returns {vec2} a new 2D vector
   */

  function create$8() {
    var out = new ARRAY_TYPE(2);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec2 initialized with values from an existing vector
   *
   * @param {vec2} a vector to clone
   * @returns {vec2} a new 2D vector
   */

  function clone$8(a) {
    var out = new ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  /**
   * Creates a new vec2 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @returns {vec2} a new 2D vector
   */

  function fromValues$8(x, y) {
    var out = new ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
  }
  /**
   * Copy the values from one vec2 to another
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the source vector
   * @returns {vec2} out
   */

  function copy$8(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  /**
   * Set the components of a vec2 to the given values
   *
   * @param {vec2} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @returns {vec2} out
   */

  function set$8(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
  }
  /**
   * Adds two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function add$8(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function subtract$6(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
  }
  /**
   * Multiplies two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function multiply$8(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
  }
  /**
   * Divides two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function divide$2(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
  }
  /**
   * Math.ceil the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to ceil
   * @returns {vec2} out
   */

  function ceil$2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
  }
  /**
   * Math.floor the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to floor
   * @returns {vec2} out
   */

  function floor$2(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
  }
  /**
   * Returns the minimum of two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function min$2(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
  }
  /**
   * Returns the maximum of two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function max$2(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
  }
  /**
   * Math.round the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to round
   * @returns {vec2} out
   */

  function round$2(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
  }
  /**
   * Scales a vec2 by a scalar number
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec2} out
   */

  function scale$8(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
  }
  /**
   * Adds two vec2's after scaling the second operand by a scalar value
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec2} out
   */

  function scaleAndAdd$2(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance$2(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x * x + y * y);
  }
  /**
   * Calculates the squared euclidian distance between two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance$2(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x * x + y * y;
  }
  /**
   * Calculates the length of a vec2
   *
   * @param {vec2} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length$4(a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x * x + y * y);
  }
  /**
   * Calculates the squared length of a vec2
   *
   * @param {vec2} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength$4(a) {
    var x = a[0],
        y = a[1];
    return x * x + y * y;
  }
  /**
   * Negates the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to negate
   * @returns {vec2} out
   */

  function negate$2(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to invert
   * @returns {vec2} out
   */

  function inverse$2(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    return out;
  }
  /**
   * Normalize a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to normalize
   * @returns {vec2} out
   */

  function normalize$4(out, a) {
    var x = a[0],
        y = a[1];
    var len = x * x + y * y;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$4(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  /**
   * Computes the cross product of two vec2's
   * Note that the cross product must by definition produce a 3D vector
   *
   * @param {vec3} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec3} out
   */

  function cross$2(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec2} out
   */

  function lerp$4(out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec2} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec2} out
   */

  function random$3(out, scale) {
    scale = scale || 1.0;
    var r = RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
  }
  /**
   * Transforms the vec2 with a mat2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat2} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat2(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
  }
  /**
   * Transforms the vec2 with a mat2d
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat2d} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat2d(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
  }
  /**
   * Transforms the vec2 with a mat3
   * 3rd vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat3} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat3$1(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  /**
   * Transforms the vec2 with a mat4
   * 3rd vector component is implicitly '0'
   * 4th vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat4$2(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  /**
   * Rotate a 2D vector
   * @param {vec2} out The receiving vec2
   * @param {vec2} a The vec2 point to rotate
   * @param {vec2} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec2} out
   */

  function rotate$4(out, a, b, c) {
    //Translate point to the origin
    var p0 = a[0] - b[0],
        p1 = a[1] - b[1],
        sinC = Math.sin(c),
        cosC = Math.cos(c); //perform rotation and translate to correct position

    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
  }
  /**
   * Get the angle between two 2D vectors
   * @param {vec2} a The first operand
   * @param {vec2} b The second operand
   * @returns {Number} The angle in radians
   */

  function angle$1(a, b) {
    var x1 = a[0],
        y1 = a[1],
        x2 = b[0],
        y2 = b[1];
    var len1 = x1 * x1 + y1 * y1;

    if (len1 > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len1 = 1 / Math.sqrt(len1);
    }

    var len2 = x2 * x2 + y2 * y2;

    if (len2 > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len2 = 1 / Math.sqrt(len2);
    }

    var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

    if (cosine > 1.0) {
      return 0;
    } else if (cosine < -1.0) {
      return Math.PI;
    } else {
      return Math.acos(cosine);
    }
  }
  /**
   * Set the components of a vec2 to zero
   *
   * @param {vec2} out the receiving vector
   * @returns {vec2} out
   */

  function zero$2(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {vec2} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$8(a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
  }
  /**
   * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
   *
   * @param {vec2} a The first vector.
   * @param {vec2} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals$8(a, b) {
    return a[0] === b[0] && a[1] === b[1];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {vec2} a The first vector.
   * @param {vec2} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$9(a, b) {
    var a0 = a[0],
        a1 = a[1];
    var b0 = b[0],
        b1 = b[1];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
  }
  /**
   * Alias for {@link vec2.length}
   * @function
   */

  var len$4 = length$4;
  /**
   * Alias for {@link vec2.subtract}
   * @function
   */

  var sub$6 = subtract$6;
  /**
   * Alias for {@link vec2.multiply}
   * @function
   */

  var mul$8 = multiply$8;
  /**
   * Alias for {@link vec2.divide}
   * @function
   */

  var div$2 = divide$2;
  /**
   * Alias for {@link vec2.distance}
   * @function
   */

  var dist$2 = distance$2;
  /**
   * Alias for {@link vec2.squaredDistance}
   * @function
   */

  var sqrDist$2 = squaredDistance$2;
  /**
   * Alias for {@link vec2.squaredLength}
   * @function
   */

  var sqrLen$4 = squaredLength$4;
  /**
   * Perform some operation over an array of vec2s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$2 = function () {
    var vec = create$8();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 2;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }

      return a;
    };
  }();

  var vec2 = /*#__PURE__*/Object.freeze({
    create: create$8,
    clone: clone$8,
    fromValues: fromValues$8,
    copy: copy$8,
    set: set$8,
    add: add$8,
    subtract: subtract$6,
    multiply: multiply$8,
    divide: divide$2,
    ceil: ceil$2,
    floor: floor$2,
    min: min$2,
    max: max$2,
    round: round$2,
    scale: scale$8,
    scaleAndAdd: scaleAndAdd$2,
    distance: distance$2,
    squaredDistance: squaredDistance$2,
    length: length$4,
    squaredLength: squaredLength$4,
    negate: negate$2,
    inverse: inverse$2,
    normalize: normalize$4,
    dot: dot$4,
    cross: cross$2,
    lerp: lerp$4,
    random: random$3,
    transformMat2: transformMat2,
    transformMat2d: transformMat2d,
    transformMat3: transformMat3$1,
    transformMat4: transformMat4$2,
    rotate: rotate$4,
    angle: angle$1,
    zero: zero$2,
    str: str$8,
    exactEquals: exactEquals$8,
    equals: equals$9,
    len: len$4,
    sub: sub$6,
    mul: mul$8,
    div: div$2,
    dist: dist$2,
    sqrDist: sqrDist$2,
    sqrLen: sqrLen$4,
    forEach: forEach$2
  });

  exports.glMatrix = common;
  exports.mat2 = mat2;
  exports.mat2d = mat2d;
  exports.mat3 = mat3;
  exports.mat4 = mat4;
  exports.quat = quat;
  exports.quat2 = quat2;
  exports.vec2 = vec2;
  exports.vec3 = vec3;
  exports.vec4 = vec4;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.i18next = factory());
}(this, function () { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var consoleLogger = {
    type: 'logger',
    log: function log(args) {
      this.output('log', args);
    },
    warn: function warn(args) {
      this.output('warn', args);
    },
    error: function error(args) {
      this.output('error', args);
    },
    output: function output(type, args) {
      var _console;

      /* eslint no-console: 0 */
      if (console && console[type]) (_console = console)[type].apply(_console, _toConsumableArray(args));
    }
  };

  var Logger =
  /*#__PURE__*/
  function () {
    function Logger(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Logger);

      this.init(concreteLogger, options);
    }

    _createClass(Logger, [{
      key: "init",
      value: function init(concreteLogger) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.prefix = options.prefix || 'i18next:';
        this.logger = concreteLogger || consoleLogger;
        this.options = options;
        this.debug = options.debug;
      }
    }, {
      key: "setDebug",
      value: function setDebug(bool) {
        this.debug = bool;
      }
    }, {
      key: "log",
      value: function log() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return this.forward(args, 'log', '', true);
      }
    }, {
      key: "warn",
      value: function warn() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return this.forward(args, 'warn', '', true);
      }
    }, {
      key: "error",
      value: function error() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return this.forward(args, 'error', '');
      }
    }, {
      key: "deprecate",
      value: function deprecate() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
      }
    }, {
      key: "forward",
      value: function forward(args, lvl, prefix, debugOnly) {
        if (debugOnly && !this.debug) return null;
        if (typeof args[0] === 'string') args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
        return this.logger[lvl](args);
      }
    }, {
      key: "create",
      value: function create(moduleName) {
        return new Logger(this.logger, _objectSpread({}, {
          prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
        }, this.options));
      }
    }]);

    return Logger;
  }();

  var baseLogger = new Logger();

  var EventEmitter =
  /*#__PURE__*/
  function () {
    function EventEmitter() {
      _classCallCheck(this, EventEmitter);

      this.observers = {};
    }

    _createClass(EventEmitter, [{
      key: "on",
      value: function on(events, listener) {
        var _this = this;

        events.split(' ').forEach(function (event) {
          _this.observers[event] = _this.observers[event] || [];

          _this.observers[event].push(listener);
        });
        return this;
      }
    }, {
      key: "off",
      value: function off(event, listener) {
        var _this2 = this;

        if (!this.observers[event]) {
          return;
        }

        this.observers[event].forEach(function () {
          if (!listener) {
            delete _this2.observers[event];
          } else {
            var index = _this2.observers[event].indexOf(listener);

            if (index > -1) {
              _this2.observers[event].splice(index, 1);
            }
          }
        });
      }
    }, {
      key: "emit",
      value: function emit(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        if (this.observers[event]) {
          var cloned = [].concat(this.observers[event]);
          cloned.forEach(function (observer) {
            observer.apply(void 0, args);
          });
        }

        if (this.observers['*']) {
          var _cloned = [].concat(this.observers['*']);

          _cloned.forEach(function (observer) {
            observer.apply(observer, [event].concat(args));
          });
        }
      }
    }]);

    return EventEmitter;
  }();

  // http://lea.verou.me/2016/12/resolve-promises-externally-with-this-one-weird-trick/
  function defer() {
    var res;
    var rej;
    var promise = new Promise(function (resolve, reject) {
      res = resolve;
      rej = reject;
    });
    promise.resolve = res;
    promise.reject = rej;
    return promise;
  }
  function makeString(object) {
    if (object == null) return '';
    /* eslint prefer-template: 0 */

    return '' + object;
  }
  function copy(a, s, t) {
    a.forEach(function (m) {
      if (s[m]) t[m] = s[m];
    });
  }

  function getLastOfPath(object, path, Empty) {
    function cleanKey(key) {
      return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
    }

    function canNotTraverseDeeper() {
      return !object || typeof object === 'string';
    }

    var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');

    while (stack.length > 1) {
      if (canNotTraverseDeeper()) return {};
      var key = cleanKey(stack.shift());
      if (!object[key] && Empty) object[key] = new Empty();
      object = object[key];
    }

    if (canNotTraverseDeeper()) return {};
    return {
      obj: object,
      k: cleanKey(stack.shift())
    };
  }

  function setPath(object, path, newValue) {
    var _getLastOfPath = getLastOfPath(object, path, Object),
        obj = _getLastOfPath.obj,
        k = _getLastOfPath.k;

    obj[k] = newValue;
  }
  function pushPath(object, path, newValue, concat) {
    var _getLastOfPath2 = getLastOfPath(object, path, Object),
        obj = _getLastOfPath2.obj,
        k = _getLastOfPath2.k;

    obj[k] = obj[k] || [];
    if (concat) obj[k] = obj[k].concat(newValue);
    if (!concat) obj[k].push(newValue);
  }
  function getPath(object, path) {
    var _getLastOfPath3 = getLastOfPath(object, path),
        obj = _getLastOfPath3.obj,
        k = _getLastOfPath3.k;

    if (!obj) return undefined;
    return obj[k];
  }
  function deepExtend(target, source, overwrite) {
    /* eslint no-restricted-syntax: 0 */
    for (var prop in source) {
      if (prop in target) {
        // If we reached a leaf string in target or source then replace with source or skip depending on the 'overwrite' switch
        if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }

    return target;
  }
  function regexEscape(str) {
    /* eslint no-useless-escape: 0 */
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
  }
  /* eslint-disable */

  var _entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;'
  };
  /* eslint-enable */

  function escape(data) {
    if (typeof data === 'string') {
      return data.replace(/[&<>"'\/]/g, function (s) {
        return _entityMap[s];
      });
    }

    return data;
  }

  var ResourceStore =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(ResourceStore, _EventEmitter);

    function ResourceStore(data) {
      var _this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        ns: ['translation'],
        defaultNS: 'translation'
      };

      _classCallCheck(this, ResourceStore);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ResourceStore).call(this));
      EventEmitter.call(_assertThisInitialized(_assertThisInitialized(_this))); // <=IE10 fix (unable to call parent constructor)

      _this.data = data || {};
      _this.options = options;

      if (_this.options.keySeparator === undefined) {
        _this.options.keySeparator = '.';
      }

      return _this;
    }

    _createClass(ResourceStore, [{
      key: "addNamespaces",
      value: function addNamespaces(ns) {
        if (this.options.ns.indexOf(ns) < 0) {
          this.options.ns.push(ns);
        }
      }
    }, {
      key: "removeNamespaces",
      value: function removeNamespaces(ns) {
        var index = this.options.ns.indexOf(ns);

        if (index > -1) {
          this.options.ns.splice(index, 1);
        }
      }
    }, {
      key: "getResource",
      value: function getResource(lng, ns, key) {
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
        var path = [lng, ns];
        if (key && typeof key !== 'string') path = path.concat(key);
        if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);

        if (lng.indexOf('.') > -1) {
          path = lng.split('.');
        }

        return getPath(this.data, path);
      }
    }, {
      key: "addResource",
      value: function addResource(lng, ns, key, value) {
        var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
          silent: false
        };
        var keySeparator = this.options.keySeparator;
        if (keySeparator === undefined) keySeparator = '.';
        var path = [lng, ns];
        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);

        if (lng.indexOf('.') > -1) {
          path = lng.split('.');
          value = ns;
          ns = path[1];
        }

        this.addNamespaces(ns);
        setPath(this.data, path, value);
        if (!options.silent) this.emit('added', lng, ns, key, value);
      }
    }, {
      key: "addResources",
      value: function addResources(lng, ns, resources) {
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
          silent: false
        };

        /* eslint no-restricted-syntax: 0 */
        for (var m in resources) {
          if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
            silent: true
          });
        }

        if (!options.silent) this.emit('added', lng, ns, resources);
      }
    }, {
      key: "addResourceBundle",
      value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
        var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
          silent: false
        };
        var path = [lng, ns];

        if (lng.indexOf('.') > -1) {
          path = lng.split('.');
          deep = resources;
          resources = ns;
          ns = path[1];
        }

        this.addNamespaces(ns);
        var pack = getPath(this.data, path) || {};

        if (deep) {
          deepExtend(pack, resources, overwrite);
        } else {
          pack = _objectSpread({}, pack, resources);
        }

        setPath(this.data, path, pack);
        if (!options.silent) this.emit('added', lng, ns, resources);
      }
    }, {
      key: "removeResourceBundle",
      value: function removeResourceBundle(lng, ns) {
        if (this.hasResourceBundle(lng, ns)) {
          delete this.data[lng][ns];
        }

        this.removeNamespaces(ns);
        this.emit('removed', lng, ns);
      }
    }, {
      key: "hasResourceBundle",
      value: function hasResourceBundle(lng, ns) {
        return this.getResource(lng, ns) !== undefined;
      }
    }, {
      key: "getResourceBundle",
      value: function getResourceBundle(lng, ns) {
        if (!ns) ns = this.options.defaultNS; // COMPATIBILITY: remove extend in v2.1.0

        if (this.options.compatibilityAPI === 'v1') return _objectSpread({}, {}, this.getResource(lng, ns));
        return this.getResource(lng, ns);
      }
    }, {
      key: "getDataByLanguage",
      value: function getDataByLanguage(lng) {
        return this.data[lng];
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.data;
      }
    }]);

    return ResourceStore;
  }(EventEmitter);

  var postProcessor = {
    processors: {},
    addPostProcessor: function addPostProcessor(module) {
      this.processors[module.name] = module;
    },
    handle: function handle(processors, value, key, options, translator) {
      var _this = this;

      processors.forEach(function (processor) {
        if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
      });
      return value;
    }
  };

  var Translator =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(Translator, _EventEmitter);

    function Translator(services) {
      var _this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Translator);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Translator).call(this));
      EventEmitter.call(_assertThisInitialized(_assertThisInitialized(_this))); // <=IE10 fix (unable to call parent constructor)

      copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat'], services, _assertThisInitialized(_assertThisInitialized(_this)));
      _this.options = options;

      if (_this.options.keySeparator === undefined) {
        _this.options.keySeparator = '.';
      }

      _this.logger = baseLogger.create('translator');
      return _this;
    }

    _createClass(Translator, [{
      key: "changeLanguage",
      value: function changeLanguage(lng) {
        if (lng) this.language = lng;
      }
    }, {
      key: "exists",
      value: function exists(key) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          interpolation: {}
        };
        var resolved = this.resolve(key, options);
        return resolved && resolved.res !== undefined;
      }
    }, {
      key: "extractFromKey",
      value: function extractFromKey(key, options) {
        var nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (nsSeparator === undefined) nsSeparator = ':';
        var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
        var namespaces = options.ns || this.options.defaultNS;

        if (nsSeparator && key.indexOf(nsSeparator) > -1) {
          var parts = key.split(nsSeparator);
          if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
          key = parts.join(keySeparator);
        }

        if (typeof namespaces === 'string') namespaces = [namespaces];
        return {
          key: key,
          namespaces: namespaces
        };
      }
    }, {
      key: "translate",
      value: function translate(keys, options) {
        var _this2 = this;

        if (_typeof(options) !== 'object' && this.options.overloadTranslationOptionHandler) {
          /* eslint prefer-rest-params: 0 */
          options = this.options.overloadTranslationOptionHandler(arguments);
        }

        if (!options) options = {}; // non valid keys handling

        if (keys === undefined || keys === null) return '';
        if (!Array.isArray(keys)) keys = [String(keys)]; // separators

        var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator; // get namespace(s)

        var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
            key = _this$extractFromKey.key,
            namespaces = _this$extractFromKey.namespaces;

        var namespace = namespaces[namespaces.length - 1]; // return key on CIMode

        var lng = options.lng || this.language;
        var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;

        if (lng && lng.toLowerCase() === 'cimode') {
          if (appendNamespaceToCIMode) {
            var nsSeparator = options.nsSeparator || this.options.nsSeparator;
            return namespace + nsSeparator + key;
          }

          return key;
        } // resolve from store


        var resolved = this.resolve(keys, options);
        var res = resolved && resolved.res;
        var resUsedKey = resolved && resolved.usedKey || key;
        var resExactUsedKey = resolved && resolved.exactUsedKey || key;
        var resType = Object.prototype.toString.apply(res);
        var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
        var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays; // object

        var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
        var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';

        if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
          if (!options.returnObjects && !this.options.returnObjects) {
            this.logger.warn('accessing an object - but returnObjects options is not enabled!');
            return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
          } // if we got a separator we loop over children - else we just return object as is
          // as having it set to false means no hierarchy so no lookup for nested values


          if (keySeparator) {
            var resTypeIsArray = resType === '[object Array]';
            var copy$$1 = resTypeIsArray ? [] : {}; // apply child translation on a copy

            /* eslint no-restricted-syntax: 0 */

            var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;

            for (var m in res) {
              if (Object.prototype.hasOwnProperty.call(res, m)) {
                var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
                copy$$1[m] = this.translate(deepKey, _objectSpread({}, options, {
                  joinArrays: false,
                  ns: namespaces
                }));
                if (copy$$1[m] === deepKey) copy$$1[m] = res[m]; // if nothing found use orginal value as fallback
              }
            }

            res = copy$$1;
          }
        } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
          // array special treatment
          res = res.join(joinArrays);
          if (res) res = this.extendTranslation(res, keys, options);
        } else {
          // string, empty or null
          var usedDefault = false;
          var usedKey = false; // fallback value

          if (!this.isValidLookup(res) && options.defaultValue !== undefined) {
            usedDefault = true;

            if (options.count !== undefined) {
              var suffix = this.pluralResolver.getSuffix(lng, options.count);
              res = options["defaultValue".concat(suffix)];
            }

            if (!res) res = options.defaultValue;
          }

          if (!this.isValidLookup(res)) {
            usedKey = true;
            res = key;
          } // save missing


          var updateMissing = options.defaultValue && options.defaultValue !== res && this.options.updateMissing;

          if (usedKey || usedDefault || updateMissing) {
            this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? options.defaultValue : res);
            var lngs = [];
            var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);

            if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
              for (var i = 0; i < fallbackLngs.length; i++) {
                lngs.push(fallbackLngs[i]);
              }
            } else if (this.options.saveMissingTo === 'all') {
              lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
            } else {
              lngs.push(options.lng || this.language);
            }

            var send = function send(l, k) {
              if (_this2.options.missingKeyHandler) {
                _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
              } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
                _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
              }

              _this2.emit('missingKey', l, namespace, k, res);
            };

            if (this.options.saveMissing) {
              var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';

              if (this.options.saveMissingPlurals && needsPluralHandling) {
                lngs.forEach(function (l) {
                  var plurals = _this2.pluralResolver.getPluralFormsOfKey(l, key);

                  plurals.forEach(function (p) {
                    return send([l], p);
                  });
                });
              } else {
                send(lngs, key);
              }
            }
          } // extend


          res = this.extendTranslation(res, keys, options, resolved); // append namespace if still key

          if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key); // parseMissingKeyHandler

          if (usedKey && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
        } // return


        return res;
      }
    }, {
      key: "extendTranslation",
      value: function extendTranslation(res, key, options, resolved) {
        var _this3 = this;

        if (this.i18nFormat && this.i18nFormat.parse) {
          res = this.i18nFormat.parse(res, options, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
            resolved: resolved
          });
        } else if (!options.skipInterpolation) {
          // i18next.parsing
          if (options.interpolation) this.interpolator.init(_objectSpread({}, options, {
            interpolation: _objectSpread({}, this.options.interpolation, options.interpolation)
          })); // interpolate

          var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
          if (this.options.interpolation.defaultVariables) data = _objectSpread({}, this.options.interpolation.defaultVariables, data);
          res = this.interpolator.interpolate(res, data, options.lng || this.language, options); // nesting

          if (options.nest !== false) res = this.interpolator.nest(res, function () {
            return _this3.translate.apply(_this3, arguments);
          }, options);
          if (options.interpolation) this.interpolator.reset();
        } // post process


        var postProcess = options.postProcess || this.options.postProcess;
        var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;

        if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
          res = postProcessor.handle(postProcessorNames, res, key, options, this);
        }

        return res;
      }
    }, {
      key: "resolve",
      value: function resolve(keys) {
        var _this4 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var found;
        var usedKey; // plain key

        var exactUsedKey; // key with context / plural

        var usedLng;
        var usedNS;
        if (typeof keys === 'string') keys = [keys]; // forEach possible key

        keys.forEach(function (k) {
          if (_this4.isValidLookup(found)) return;

          var extracted = _this4.extractFromKey(k, options);

          var key = extracted.key;
          usedKey = key;
          var namespaces = extracted.namespaces;
          if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
          var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
          var needsContextHandling = options.context !== undefined && typeof options.context === 'string' && options.context !== '';
          var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
          namespaces.forEach(function (ns) {
            if (_this4.isValidLookup(found)) return;
            usedNS = ns;
            codes.forEach(function (code) {
              if (_this4.isValidLookup(found)) return;
              usedLng = code;
              var finalKey = key;
              var finalKeys = [finalKey];

              if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
                _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
              } else {
                var pluralSuffix;
                if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count); // fallback for plural if context not found

                if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix); // get key for context if needed

                if (needsContextHandling) finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options.context)); // get key for plural if needed

                if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);
              } // iterate over finalKeys starting with most specific pluralkey (-> contextkey only) -> singularkey only


              var possibleKey;
              /* eslint no-cond-assign: 0 */

              while (possibleKey = finalKeys.pop()) {
                if (!_this4.isValidLookup(found)) {
                  exactUsedKey = possibleKey;
                  found = _this4.getResource(code, ns, possibleKey, options);
                }
              }
            });
          });
        });
        return {
          res: found,
          usedKey: usedKey,
          exactUsedKey: exactUsedKey,
          usedLng: usedLng,
          usedNS: usedNS
        };
      }
    }, {
      key: "isValidLookup",
      value: function isValidLookup(res) {
        return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
      }
    }, {
      key: "getResource",
      value: function getResource(code, ns, key) {
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
        return this.resourceStore.getResource(code, ns, key, options);
      }
    }]);

    return Translator;
  }(EventEmitter);

  function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  var LanguageUtil =
  /*#__PURE__*/
  function () {
    function LanguageUtil(options) {
      _classCallCheck(this, LanguageUtil);

      this.options = options;
      this.whitelist = this.options.whitelist || false;
      this.logger = baseLogger.create('languageUtils');
    }

    _createClass(LanguageUtil, [{
      key: "getScriptPartFromCode",
      value: function getScriptPartFromCode(code) {
        if (!code || code.indexOf('-') < 0) return null;
        var p = code.split('-');
        if (p.length === 2) return null;
        p.pop();
        return this.formatLanguageCode(p.join('-'));
      }
    }, {
      key: "getLanguagePartFromCode",
      value: function getLanguagePartFromCode(code) {
        if (!code || code.indexOf('-') < 0) return code;
        var p = code.split('-');
        return this.formatLanguageCode(p[0]);
      }
    }, {
      key: "formatLanguageCode",
      value: function formatLanguageCode(code) {
        // http://www.iana.org/assignments/language-tags/language-tags.xhtml
        if (typeof code === 'string' && code.indexOf('-') > -1) {
          var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
          var p = code.split('-');

          if (this.options.lowerCaseLng) {
            p = p.map(function (part) {
              return part.toLowerCase();
            });
          } else if (p.length === 2) {
            p[0] = p[0].toLowerCase();
            p[1] = p[1].toUpperCase();
            if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
          } else if (p.length === 3) {
            p[0] = p[0].toLowerCase(); // if lenght 2 guess it's a country

            if (p[1].length === 2) p[1] = p[1].toUpperCase();
            if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
            if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
            if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
          }

          return p.join('-');
        }

        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
      }
    }, {
      key: "isWhitelisted",
      value: function isWhitelisted(code) {
        if (this.options.load === 'languageOnly' || this.options.nonExplicitWhitelist) {
          code = this.getLanguagePartFromCode(code);
        }

        return !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(code) > -1;
      }
    }, {
      key: "getFallbackCodes",
      value: function getFallbackCodes(fallbacks, code) {
        if (!fallbacks) return [];
        if (typeof fallbacks === 'string') fallbacks = [fallbacks];
        if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
        if (!code) return fallbacks.default || []; // asume we have an object defining fallbacks

        var found = fallbacks[code];
        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
        if (!found) found = fallbacks[this.formatLanguageCode(code)];
        if (!found) found = fallbacks.default;
        return found || [];
      }
    }, {
      key: "toResolveHierarchy",
      value: function toResolveHierarchy(code, fallbackCode) {
        var _this = this;

        var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
        var codes = [];

        var addCode = function addCode(c) {
          if (!c) return;

          if (_this.isWhitelisted(c)) {
            codes.push(c);
          } else {
            _this.logger.warn("rejecting non-whitelisted language code: ".concat(c));
          }
        };

        if (typeof code === 'string' && code.indexOf('-') > -1) {
          if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
          if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
          if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
        } else if (typeof code === 'string') {
          addCode(this.formatLanguageCode(code));
        }

        fallbackCodes.forEach(function (fc) {
          if (codes.indexOf(fc) < 0) addCode(_this.formatLanguageCode(fc));
        });
        return codes;
      }
    }]);

    return LanguageUtil;
  }();

  /* eslint-disable */

  var sets = [{
    lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'ti', 'tr', 'uz', 'wa'],
    nr: [1, 2],
    fc: 1
  }, {
    lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],
    nr: [1, 2],
    fc: 2
  }, {
    lngs: ['ay', 'bo', 'cgg', 'fa', 'id', 'ja', 'jbo', 'ka', 'kk', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
    nr: [1],
    fc: 3
  }, {
    lngs: ['be', 'bs', 'dz', 'hr', 'ru', 'sr', 'uk'],
    nr: [1, 2, 5],
    fc: 4
  }, {
    lngs: ['ar'],
    nr: [0, 1, 2, 3, 11, 100],
    fc: 5
  }, {
    lngs: ['cs', 'sk'],
    nr: [1, 2, 5],
    fc: 6
  }, {
    lngs: ['csb', 'pl'],
    nr: [1, 2, 5],
    fc: 7
  }, {
    lngs: ['cy'],
    nr: [1, 2, 3, 8],
    fc: 8
  }, {
    lngs: ['fr'],
    nr: [1, 2],
    fc: 9
  }, {
    lngs: ['ga'],
    nr: [1, 2, 3, 7, 11],
    fc: 10
  }, {
    lngs: ['gd'],
    nr: [1, 2, 3, 20],
    fc: 11
  }, {
    lngs: ['is'],
    nr: [1, 2],
    fc: 12
  }, {
    lngs: ['jv'],
    nr: [0, 1],
    fc: 13
  }, {
    lngs: ['kw'],
    nr: [1, 2, 3, 4],
    fc: 14
  }, {
    lngs: ['lt'],
    nr: [1, 2, 10],
    fc: 15
  }, {
    lngs: ['lv'],
    nr: [1, 2, 0],
    fc: 16
  }, {
    lngs: ['mk'],
    nr: [1, 2],
    fc: 17
  }, {
    lngs: ['mnk'],
    nr: [0, 1, 2],
    fc: 18
  }, {
    lngs: ['mt'],
    nr: [1, 2, 11, 20],
    fc: 19
  }, {
    lngs: ['or'],
    nr: [2, 1],
    fc: 2
  }, {
    lngs: ['ro'],
    nr: [1, 2, 20],
    fc: 20
  }, {
    lngs: ['sl'],
    nr: [5, 1, 2, 3],
    fc: 21
  }, {
    lngs: ['he'],
    nr: [1, 2, 20, 21],
    fc: 22
  }];
  var _rulesPluralsTypes = {
    1: function _(n) {
      return Number(n > 1);
    },
    2: function _(n) {
      return Number(n != 1);
    },
    3: function _(n) {
      return 0;
    },
    4: function _(n) {
      return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
    },
    5: function _(n) {
      return Number(n === 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
    },
    6: function _(n) {
      return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
    },
    7: function _(n) {
      return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
    },
    8: function _(n) {
      return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
    },
    9: function _(n) {
      return Number(n >= 2);
    },
    10: function _(n) {
      return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
    },
    11: function _(n) {
      return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
    },
    12: function _(n) {
      return Number(n % 10 != 1 || n % 100 == 11);
    },
    13: function _(n) {
      return Number(n !== 0);
    },
    14: function _(n) {
      return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
    },
    15: function _(n) {
      return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
    },
    16: function _(n) {
      return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
    },
    17: function _(n) {
      return Number(n == 1 || n % 10 == 1 ? 0 : 1);
    },
    18: function _(n) {
      return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
    },
    19: function _(n) {
      return Number(n == 1 ? 0 : n === 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
    },
    20: function _(n) {
      return Number(n == 1 ? 0 : n === 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
    },
    21: function _(n) {
      return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
    },
    22: function _(n) {
      return Number(n === 1 ? 0 : n === 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
    }
  };
  /* eslint-enable */

  function createRules() {
    var rules = {};
    sets.forEach(function (set) {
      set.lngs.forEach(function (l) {
        rules[l] = {
          numbers: set.nr,
          plurals: _rulesPluralsTypes[set.fc]
        };
      });
    });
    return rules;
  }

  var PluralResolver =
  /*#__PURE__*/
  function () {
    function PluralResolver(languageUtils) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, PluralResolver);

      this.languageUtils = languageUtils;
      this.options = options;
      this.logger = baseLogger.create('pluralResolver');
      this.rules = createRules();
    }

    _createClass(PluralResolver, [{
      key: "addRule",
      value: function addRule(lng, obj) {
        this.rules[lng] = obj;
      }
    }, {
      key: "getRule",
      value: function getRule(code) {
        return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
      }
    }, {
      key: "needsPlural",
      value: function needsPlural(code) {
        var rule = this.getRule(code);
        return rule && rule.numbers.length > 1;
      }
    }, {
      key: "getPluralFormsOfKey",
      value: function getPluralFormsOfKey(code, key) {
        var _this = this;

        var ret = [];
        var rule = this.getRule(code);
        if (!rule) return ret;
        rule.numbers.forEach(function (n) {
          var suffix = _this.getSuffix(code, n);

          ret.push("".concat(key).concat(suffix));
        });
        return ret;
      }
    }, {
      key: "getSuffix",
      value: function getSuffix(code, count) {
        var _this2 = this;

        var rule = this.getRule(code);

        if (rule) {
          // if (rule.numbers.length === 1) return ''; // only singular
          var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
          var suffix = rule.numbers[idx]; // special treatment for lngs only having singular and plural

          if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
            if (suffix === 2) {
              suffix = 'plural';
            } else if (suffix === 1) {
              suffix = '';
            }
          }

          var returnSuffix = function returnSuffix() {
            return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
          }; // COMPATIBILITY JSON
          // v1


          if (this.options.compatibilityJSON === 'v1') {
            if (suffix === 1) return '';
            if (typeof suffix === 'number') return "_plural_".concat(suffix.toString());
            return returnSuffix();
          } else if (
          /* v2 */
          this.options.compatibilityJSON === 'v2') {
            return returnSuffix();
          } else if (
          /* v3 - gettext index */
          this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
            return returnSuffix();
          }

          return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
        }

        this.logger.warn("no plural rule found for: ".concat(code));
        return '';
      }
    }]);

    return PluralResolver;
  }();

  var Interpolator =
  /*#__PURE__*/
  function () {
    function Interpolator() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Interpolator);

      this.logger = baseLogger.create('interpolator');
      this.init(options, true);
    }
    /* eslint no-param-reassign: 0 */


    _createClass(Interpolator, [{
      key: "init",
      value: function init() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var reset = arguments.length > 1 ? arguments[1] : undefined;

        if (reset) {
          this.options = options;

          this.format = options.interpolation && options.interpolation.format || function (value) {
            return value;
          };
        }

        if (!options.interpolation) options.interpolation = {
          escapeValue: true
        };
        var iOpts = options.interpolation;
        this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;
        this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
        this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
        this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
        this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
        this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
        this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
        this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
        this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
        this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000; // the regexp

        this.resetRegExp();
      }
    }, {
      key: "reset",
      value: function reset() {
        if (this.options) this.init(this.options);
      }
    }, {
      key: "resetRegExp",
      value: function resetRegExp() {
        // the regexp
        var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
        this.regexp = new RegExp(regexpStr, 'g');
        var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
        this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
        var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
        this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
      }
    }, {
      key: "interpolate",
      value: function interpolate(str, data, lng, options) {
        var _this = this;

        var match;
        var value;
        var replaces;

        function regexSafe(val) {
          return val.replace(/\$/g, '$$$$');
        }

        var handleFormat = function handleFormat(key) {
          if (key.indexOf(_this.formatSeparator) < 0) return getPath(data, key);
          var p = key.split(_this.formatSeparator);
          var k = p.shift().trim();
          var f = p.join(_this.formatSeparator).trim();
          return _this.format(getPath(data, k), f, lng);
        };

        this.resetRegExp();
        var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
        replaces = 0; // unescape if has unescapePrefix/Suffix

        /* eslint no-cond-assign: 0 */

        while (match = this.regexpUnescape.exec(str)) {
          value = handleFormat(match[1].trim());
          str = str.replace(match[0], value);
          this.regexpUnescape.lastIndex = 0;
          replaces++;

          if (replaces >= this.maxReplaces) {
            break;
          }
        }

        replaces = 0; // regular escape on demand

        while (match = this.regexp.exec(str)) {
          value = handleFormat(match[1].trim());

          if (value === undefined) {
            if (typeof missingInterpolationHandler === 'function') {
              var temp = missingInterpolationHandler(str, match, options);
              value = typeof temp === 'string' ? temp : '';
            } else {
              this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
              value = '';
            }
          } else if (typeof value !== 'string' && !this.useRawValueToEscape) {
            value = makeString(value);
          }

          value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);
          str = str.replace(match[0], value);
          this.regexp.lastIndex = 0;
          replaces++;

          if (replaces >= this.maxReplaces) {
            break;
          }
        }

        return str;
      }
    }, {
      key: "nest",
      value: function nest(str, fc) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var match;
        var value;

        var clonedOptions = _objectSpread({}, options);

        clonedOptions.applyPostProcessor = false; // avoid post processing on nested lookup
        // if value is something like "myKey": "lorem $(anotherKey, { "count": {{aValueInOptions}} })"

        function handleHasOptions(key, inheritedOptions) {
          if (key.indexOf(',') < 0) return key;
          var p = key.split(',');
          key = p.shift();
          var optionsString = p.join(',');
          optionsString = this.interpolate(optionsString, clonedOptions);
          optionsString = optionsString.replace(/'/g, '"');

          try {
            clonedOptions = JSON.parse(optionsString);
            if (inheritedOptions) clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);
          } catch (e) {
            this.logger.error("failed parsing options string in nesting for key ".concat(key), e);
          }

          return key;
        } // regular escape on demand


        while (match = this.nestingRegexp.exec(str)) {
          value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions); // is only the nesting key (key1 = '$(key2)') return the value without stringify

          if (value && match[0] === str && typeof value !== 'string') return value; // no string to include or empty

          if (typeof value !== 'string') value = makeString(value);

          if (!value) {
            this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
            value = '';
          } // Nested keys should not be escaped by default #854
          // value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);


          str = str.replace(match[0], value);
          this.regexp.lastIndex = 0;
        }

        return str;
      }
    }]);

    return Interpolator;
  }();

  function remove(arr, what) {
    var found = arr.indexOf(what);

    while (found !== -1) {
      arr.splice(found, 1);
      found = arr.indexOf(what);
    }
  }

  var Connector =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(Connector, _EventEmitter);

    function Connector(backend, store, services) {
      var _this;

      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      _classCallCheck(this, Connector);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Connector).call(this));
      EventEmitter.call(_assertThisInitialized(_assertThisInitialized(_this))); // <=IE10 fix (unable to call parent constructor)

      _this.backend = backend;
      _this.store = store;
      _this.languageUtils = services.languageUtils;
      _this.options = options;
      _this.logger = baseLogger.create('backendConnector');
      _this.state = {};
      _this.queue = [];

      if (_this.backend && _this.backend.init) {
        _this.backend.init(services, options.backend, options);
      }

      return _this;
    }

    _createClass(Connector, [{
      key: "queueLoad",
      value: function queueLoad(languages, namespaces, options, callback) {
        var _this2 = this;

        // find what needs to be loaded
        var toLoad = [];
        var pending = [];
        var toLoadLanguages = [];
        var toLoadNamespaces = [];
        languages.forEach(function (lng) {
          var hasAllNamespaces = true;
          namespaces.forEach(function (ns) {
            var name = "".concat(lng, "|").concat(ns);

            if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
              _this2.state[name] = 2; // loaded
            } else if (_this2.state[name] < 0) ; else if (_this2.state[name] === 1) {
              if (pending.indexOf(name) < 0) pending.push(name);
            } else {
              _this2.state[name] = 1; // pending

              hasAllNamespaces = false;
              if (pending.indexOf(name) < 0) pending.push(name);
              if (toLoad.indexOf(name) < 0) toLoad.push(name);
              if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
            }
          });
          if (!hasAllNamespaces) toLoadLanguages.push(lng);
        });

        if (toLoad.length || pending.length) {
          this.queue.push({
            pending: pending,
            loaded: {},
            errors: [],
            callback: callback
          });
        }

        return {
          toLoad: toLoad,
          pending: pending,
          toLoadLanguages: toLoadLanguages,
          toLoadNamespaces: toLoadNamespaces
        };
      }
    }, {
      key: "loaded",
      value: function loaded(name, err, data) {
        var _name$split = name.split('|'),
            _name$split2 = _slicedToArray(_name$split, 2),
            lng = _name$split2[0],
            ns = _name$split2[1];

        if (err) this.emit('failedLoading', lng, ns, err);

        if (data) {
          this.store.addResourceBundle(lng, ns, data);
        } // set loaded


        this.state[name] = err ? -1 : 2; // consolidated loading done in this run - only emit once for a loaded namespace

        var loaded = {}; // callback if ready

        this.queue.forEach(function (q) {
          pushPath(q.loaded, [lng], ns);
          remove(q.pending, name);
          if (err) q.errors.push(err);

          if (q.pending.length === 0 && !q.done) {
            // only do once per loaded -> this.emit('loaded', q.loaded);
            Object.keys(q.loaded).forEach(function (l) {
              if (!loaded[l]) loaded[l] = [];

              if (q.loaded[l].length) {
                q.loaded[l].forEach(function (ns) {
                  if (loaded[l].indexOf(ns) < 0) loaded[l].push(ns);
                });
              }
            });
            /* eslint no-param-reassign: 0 */

            q.done = true;

            if (q.errors.length) {
              q.callback(q.errors);
            } else {
              q.callback();
            }
          }
        }); // emit consolidated loaded event

        this.emit('loaded', loaded); // remove done load requests

        this.queue = this.queue.filter(function (q) {
          return !q.done;
        });
      }
    }, {
      key: "read",
      value: function read(lng, ns, fcName) {
        var _this3 = this;

        var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;
        var callback = arguments.length > 5 ? arguments[5] : undefined;
        if (!lng.length) return callback(null, {}); // noting to load

        return this.backend[fcName](lng, ns, function (err, data) {
          if (err && data
          /* = retryFlag */
          && tried < 5) {
            setTimeout(function () {
              _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
            }, wait);
            return;
          }

          callback(err, data);
        });
      }
      /* eslint consistent-return: 0 */

    }, {
      key: "prepareLoading",
      value: function prepareLoading(languages, namespaces) {
        var _this4 = this;

        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var callback = arguments.length > 3 ? arguments[3] : undefined;

        if (!this.backend) {
          this.logger.warn('No backend was added via i18next.use. Will not load resources.');
          return callback && callback();
        }

        if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
        if (typeof namespaces === 'string') namespaces = [namespaces];
        var toLoad = this.queueLoad(languages, namespaces, options, callback);

        if (!toLoad.toLoad.length) {
          if (!toLoad.pending.length) callback(); // nothing to load and no pendings...callback now

          return null; // pendings will trigger callback
        }

        toLoad.toLoad.forEach(function (name) {
          _this4.loadOne(name);
        });
      }
    }, {
      key: "load",
      value: function load(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {}, callback);
      }
    }, {
      key: "reload",
      value: function reload(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {
          reload: true
        }, callback);
      }
    }, {
      key: "loadOne",
      value: function loadOne(name) {
        var _this5 = this;

        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

        var _name$split3 = name.split('|'),
            _name$split4 = _slicedToArray(_name$split3, 2),
            lng = _name$split4[0],
            ns = _name$split4[1];

        this.read(lng, ns, 'read', null, null, function (err, data) {
          if (err) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
          if (!err && data) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);

          _this5.loaded(name, err, data);
        });
      }
    }, {
      key: "saveMissing",
      value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
        var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

        if (this.backend && this.backend.create) {
          this.backend.create(languages, namespace, key, fallbackValue, null
          /* unused callback */
          , _objectSpread({}, options, {
            isUpdate: isUpdate
          }));
        } // write to store to avoid resending


        if (!languages || !languages[0]) return;
        this.store.addResource(languages[0], namespace, key, fallbackValue);
      }
    }]);

    return Connector;
  }(EventEmitter);

  function get() {
    return {
      debug: false,
      initImmediate: true,
      ns: ['translation'],
      defaultNS: ['translation'],
      fallbackLng: ['dev'],
      fallbackNS: false,
      // string or array of namespaces
      whitelist: false,
      // array with whitelisted languages
      nonExplicitWhitelist: false,
      load: 'all',
      // | currentOnly | languageOnly
      preload: false,
      // array with preload languages
      simplifyPluralSuffix: true,
      keySeparator: '.',
      nsSeparator: ':',
      pluralSeparator: '_',
      contextSeparator: '_',
      partialBundledLanguages: false,
      // allow bundling certain languages that are not remotely fetched
      saveMissing: false,
      // enable to send missing values
      updateMissing: false,
      // enable to update default values if different from translated value (only useful on initial development, or when keeping code as source of truth)
      saveMissingTo: 'fallback',
      // 'current' || 'all'
      saveMissingPlurals: true,
      // will save all forms not only singular key
      missingKeyHandler: false,
      // function(lng, ns, key, fallbackValue) -> override if prefer on handling
      missingInterpolationHandler: false,
      // function(str, match)
      postProcess: false,
      // string or array of postProcessor names
      returnNull: true,
      // allows null value as valid translation
      returnEmptyString: true,
      // allows empty string value as valid translation
      returnObjects: false,
      joinArrays: false,
      // or string to join array
      returnedObjectHandler: function returnedObjectHandler() {},
      // function(key, value, options) triggered if key returns object but returnObjects is set to false
      parseMissingKeyHandler: false,
      // function(key) parsed a key that was not found in t() before returning
      appendNamespaceToMissingKey: false,
      appendNamespaceToCIMode: false,
      overloadTranslationOptionHandler: function handle(args) {
        var ret = {};
        if (_typeof(args[1]) === 'object') ret = args[1];
        if (typeof args[1] === 'string') ret.defaultValue = args[1];
        if (typeof args[2] === 'string') ret.tDescription = args[2];

        if (_typeof(args[2]) === 'object' || _typeof(args[3]) === 'object') {
          var options = args[3] || args[2];
          Object.keys(options).forEach(function (key) {
            ret[key] = options[key];
          });
        }

        return ret;
      },
      interpolation: {
        escapeValue: true,
        format: function format(value, _format, lng) {
          return value;
        },
        prefix: '{{',
        suffix: '}}',
        formatSeparator: ',',
        // prefixEscaped: '{{',
        // suffixEscaped: '}}',
        // unescapeSuffix: '',
        unescapePrefix: '-',
        nestingPrefix: '$t(',
        nestingSuffix: ')',
        // nestingPrefixEscaped: '$t(',
        // nestingSuffixEscaped: ')',
        // defaultVariables: undefined // object that can have values to interpolate on - extends passed in interpolation data
        maxReplaces: 1000 // max replaces to prevent endless loop

      }
    };
  }
  /* eslint no-param-reassign: 0 */

  function transformOptions(options) {
    // create namespace object if namespace is passed in as string
    if (typeof options.ns === 'string') options.ns = [options.ns];
    if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
    if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS]; // extend whitelist with cimode

    if (options.whitelist && options.whitelist.indexOf('cimode') < 0) {
      options.whitelist = options.whitelist.concat(['cimode']);
    }

    return options;
  }

  function noop() {}

  var I18n =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(I18n, _EventEmitter);

    function I18n() {
      var _this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, I18n);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(I18n).call(this));
      EventEmitter.call(_assertThisInitialized(_assertThisInitialized(_this))); // <=IE10 fix (unable to call parent constructor)

      _this.options = transformOptions(options);
      _this.services = {};
      _this.logger = baseLogger;
      _this.modules = {
        external: []
      };

      if (callback && !_this.isInitialized && !options.isClone) {
        // https://github.com/i18next/i18next/issues/879
        if (!_this.options.initImmediate) {
          _this.init(options, callback);

          return _possibleConstructorReturn(_this, _assertThisInitialized(_assertThisInitialized(_this)));
        }

        setTimeout(function () {
          _this.init(options, callback);
        }, 0);
      }

      return _this;
    }

    _createClass(I18n, [{
      key: "init",
      value: function init() {
        var _this2 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var callback = arguments.length > 1 ? arguments[1] : undefined;

        if (typeof options === 'function') {
          callback = options;
          options = {};
        }

        this.options = _objectSpread({}, get(), this.options, transformOptions(options));
        this.format = this.options.interpolation.format;
        if (!callback) callback = noop;

        function createClassOnDemand(ClassOrObject) {
          if (!ClassOrObject) return null;
          if (typeof ClassOrObject === 'function') return new ClassOrObject();
          return ClassOrObject;
        } // init services


        if (!this.options.isClone) {
          if (this.modules.logger) {
            baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
          } else {
            baseLogger.init(null, this.options);
          }

          var lu = new LanguageUtil(this.options);
          this.store = new ResourceStore(this.options.resources, this.options);
          var s = this.services;
          s.logger = baseLogger;
          s.resourceStore = this.store;
          s.languageUtils = lu;
          s.pluralResolver = new PluralResolver(lu, {
            prepend: this.options.pluralSeparator,
            compatibilityJSON: this.options.compatibilityJSON,
            simplifyPluralSuffix: this.options.simplifyPluralSuffix
          });
          s.interpolator = new Interpolator(this.options);
          s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options); // pipe events from backendConnector

          s.backendConnector.on('*', function (event) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }

            _this2.emit.apply(_this2, [event].concat(args));
          });

          if (this.modules.languageDetector) {
            s.languageDetector = createClassOnDemand(this.modules.languageDetector);
            s.languageDetector.init(s, this.options.detection, this.options);
          }

          if (this.modules.i18nFormat) {
            s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
            if (s.i18nFormat.init) s.i18nFormat.init(this);
          }

          this.translator = new Translator(this.services, this.options); // pipe events from translator

          this.translator.on('*', function (event) {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }

            _this2.emit.apply(_this2, [event].concat(args));
          });
          this.modules.external.forEach(function (m) {
            if (m.init) m.init(_this2);
          });
        } // append api


        var storeApi = ['getResource', 'addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
        storeApi.forEach(function (fcName) {
          _this2[fcName] = function () {
            var _this2$store;

            return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
          };
        });
        var deferred = defer();

        var load = function load() {
          _this2.changeLanguage(_this2.options.lng, function (err, t) {
            _this2.isInitialized = true;

            _this2.logger.log('initialized', _this2.options);

            _this2.emit('initialized', _this2.options);

            deferred.resolve(t); // not rejecting on err (as err is only a loading translation failed warning)

            callback(err, t);
          });
        };

        if (this.options.resources || !this.options.initImmediate) {
          load();
        } else {
          setTimeout(load, 0);
        }

        return deferred;
      }
      /* eslint consistent-return: 0 */

    }, {
      key: "loadResources",
      value: function loadResources() {
        var _this3 = this;

        var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;

        if (!this.options.resources || this.options.partialBundledLanguages) {
          if (this.language && this.language.toLowerCase() === 'cimode') return callback(); // avoid loading resources for cimode

          var toLoad = [];

          var append = function append(lng) {
            if (!lng) return;

            var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);

            lngs.forEach(function (l) {
              if (toLoad.indexOf(l) < 0) toLoad.push(l);
            });
          };

          if (!this.language) {
            // at least load fallbacks in this case
            var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            fallbacks.forEach(function (l) {
              return append(l);
            });
          } else {
            append(this.language);
          }

          if (this.options.preload) {
            this.options.preload.forEach(function (l) {
              return append(l);
            });
          }

          this.services.backendConnector.load(toLoad, this.options.ns, callback);
        } else {
          callback(null);
        }
      }
    }, {
      key: "reloadResources",
      value: function reloadResources(lngs, ns, callback) {
        var deferred = defer();
        if (!lngs) lngs = this.languages;
        if (!ns) ns = this.options.ns;
        if (!callback) callback = noop;
        this.services.backendConnector.reload(lngs, ns, function (err) {
          deferred.resolve(); // not rejecting on err (as err is only a loading translation failed warning)

          callback(err);
        });
        return deferred;
      }
    }, {
      key: "use",
      value: function use(module) {
        if (module.type === 'backend') {
          this.modules.backend = module;
        }

        if (module.type === 'logger' || module.log && module.warn && module.error) {
          this.modules.logger = module;
        }

        if (module.type === 'languageDetector') {
          this.modules.languageDetector = module;
        }

        if (module.type === 'i18nFormat') {
          this.modules.i18nFormat = module;
        }

        if (module.type === 'postProcessor') {
          postProcessor.addPostProcessor(module);
        }

        if (module.type === '3rdParty') {
          this.modules.external.push(module);
        }

        return this;
      }
    }, {
      key: "changeLanguage",
      value: function changeLanguage(lng, callback) {
        var _this4 = this;

        var deferred = defer();
        this.emit('languageChanging', lng);

        var done = function done(err, l) {
          _this4.translator.changeLanguage(l);

          if (l) {
            _this4.emit('languageChanged', l);

            _this4.logger.log('languageChanged', l);
          }

          deferred.resolve(function () {
            return _this4.t.apply(_this4, arguments);
          });
          if (callback) callback(err, function () {
            return _this4.t.apply(_this4, arguments);
          });
        };

        var setLng = function setLng(l) {
          if (l) {
            _this4.language = l;
            _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
            if (!_this4.translator.language) _this4.translator.changeLanguage(l);
            if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
          }

          _this4.loadResources(function (err) {
            done(err, l);
          });
        };

        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
          setLng(this.services.languageDetector.detect());
        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
          this.services.languageDetector.detect(setLng);
        } else {
          setLng(lng);
        }

        return deferred;
      }
    }, {
      key: "getFixedT",
      value: function getFixedT(lng, ns) {
        var _this5 = this;

        var fixedT = function fixedT(key, opts) {
          var options = _objectSpread({}, opts);

          if (_typeof(opts) !== 'object') {
            for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
              rest[_key3 - 2] = arguments[_key3];
            }

            options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
          }

          options.lng = options.lng || fixedT.lng;
          options.lngs = options.lngs || fixedT.lngs;
          options.ns = options.ns || fixedT.ns;
          return _this5.t(key, options);
        };

        if (typeof lng === 'string') {
          fixedT.lng = lng;
        } else {
          fixedT.lngs = lng;
        }

        fixedT.ns = ns;
        return fixedT;
      }
    }, {
      key: "t",
      value: function t() {
        var _this$translator;

        return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
      }
    }, {
      key: "exists",
      value: function exists() {
        var _this$translator2;

        return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
      }
    }, {
      key: "setDefaultNamespace",
      value: function setDefaultNamespace(ns) {
        this.options.defaultNS = ns;
      }
    }, {
      key: "loadNamespaces",
      value: function loadNamespaces(ns, callback) {
        var _this6 = this;

        var deferred = defer();

        if (!this.options.ns) {
          callback && callback();
          return Promise.resolve();
        }

        if (typeof ns === 'string') ns = [ns];
        ns.forEach(function (n) {
          if (_this6.options.ns.indexOf(n) < 0) _this6.options.ns.push(n);
        });
        this.loadResources(function (err) {
          deferred.resolve();
          if (callback) callback(err);
        });
        return deferred;
      }
    }, {
      key: "loadLanguages",
      value: function loadLanguages(lngs, callback) {
        var deferred = defer();
        if (typeof lngs === 'string') lngs = [lngs];
        var preloaded = this.options.preload || [];
        var newLngs = lngs.filter(function (lng) {
          return preloaded.indexOf(lng) < 0;
        }); // Exit early if all given languages are already preloaded

        if (!newLngs.length) {
          if (callback) callback();
          return Promise.resolve();
        }

        this.options.preload = preloaded.concat(newLngs);
        this.loadResources(function (err) {
          deferred.resolve();
          if (callback) callback(err);
        });
        return deferred;
      }
    }, {
      key: "dir",
      value: function dir(lng) {
        if (!lng) lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
        if (!lng) return 'rtl';
        var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam'];
        return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? 'rtl' : 'ltr';
      }
      /* eslint class-methods-use-this: 0 */

    }, {
      key: "createInstance",
      value: function createInstance() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var callback = arguments.length > 1 ? arguments[1] : undefined;
        return new I18n(options, callback);
      }
    }, {
      key: "cloneInstance",
      value: function cloneInstance() {
        var _this7 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

        var mergedOptions = _objectSpread({}, this.options, options, {
          isClone: true
        });

        var clone = new I18n(mergedOptions);
        var membersToCopy = ['store', 'services', 'language'];
        membersToCopy.forEach(function (m) {
          clone[m] = _this7[m];
        });
        clone.translator = new Translator(clone.services, clone.options);
        clone.translator.on('*', function (event) {
          for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          clone.emit.apply(clone, [event].concat(args));
        });
        clone.init(mergedOptions, callback);
        clone.translator.options = clone.options; // sync options

        return clone;
      }
    }]);

    return I18n;
  }(EventEmitter);

  var i18next = new I18n();

  return i18next;

}));

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.i18nextBrowserLanguageDetector = factory());
}(this, function () { 'use strict';

  var arr = [];
  var each = arr.forEach;
  var slice = arr.slice;

  function defaults(obj) {
    each.call(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === undefined) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  }

  var cookie = {
    create: function create(name, value, minutes, domain) {
      var expires = void 0;
      if (minutes) {
        var date = new Date();
        date.setTime(date.getTime() + minutes * 60 * 1000);
        expires = '; expires=' + date.toGMTString();
      } else expires = '';
      domain = domain ? 'domain=' + domain + ';' : '';
      document.cookie = name + '=' + value + expires + ';' + domain + 'path=/';
    },

    read: function read(name) {
      var nameEQ = name + '=';
      var ca = document.cookie.split(';');
      for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) === ' ') {
          c = c.substring(1, c.length);
        }if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
      }
      return null;
    },

    remove: function remove(name) {
      this.create(name, '', -1);
    }
  };

  var cookie$1 = {
    name: 'cookie',

    lookup: function lookup(options) {
      var found = void 0;

      if (options.lookupCookie && typeof document !== 'undefined') {
        var c = cookie.read(options.lookupCookie);
        if (c) found = c;
      }

      return found;
    },
    cacheUserLanguage: function cacheUserLanguage(lng, options) {
      if (options.lookupCookie && typeof document !== 'undefined') {
        cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain);
      }
    }
  };

  var querystring = {
    name: 'querystring',

    lookup: function lookup(options) {
      var found = void 0;

      if (typeof window !== 'undefined') {
        var query = window.location.search.substring(1);
        var params = query.split('&');
        for (var i = 0; i < params.length; i++) {
          var pos = params[i].indexOf('=');
          if (pos > 0) {
            var key = params[i].substring(0, pos);
            if (key === options.lookupQuerystring) {
              found = params[i].substring(pos + 1);
            }
          }
        }
      }

      return found;
    }
  };

  var hasLocalStorageSupport = void 0;
  try {
    hasLocalStorageSupport = window !== 'undefined' && window.localStorage !== null;
    var testKey = 'i18next.translate.boo';
    window.localStorage.setItem(testKey, 'foo');
    window.localStorage.removeItem(testKey);
  } catch (e) {
    hasLocalStorageSupport = false;
  }

  var localStorage = {
    name: 'localStorage',

    lookup: function lookup(options) {
      var found = void 0;

      if (options.lookupLocalStorage && hasLocalStorageSupport) {
        var lng = window.localStorage.getItem(options.lookupLocalStorage);
        if (lng) found = lng;
      }

      return found;
    },
    cacheUserLanguage: function cacheUserLanguage(lng, options) {
      if (options.lookupLocalStorage && hasLocalStorageSupport) {
        window.localStorage.setItem(options.lookupLocalStorage, lng);
      }
    }
  };

  var navigator$1 = {
    name: 'navigator',

    lookup: function lookup(options) {
      var found = [];

      if (typeof navigator !== 'undefined') {
        if (navigator.languages) {
          // chrome only; not an array, so can't use .push.apply instead of iterating
          for (var i = 0; i < navigator.languages.length; i++) {
            found.push(navigator.languages[i]);
          }
        }
        if (navigator.userLanguage) {
          found.push(navigator.userLanguage);
        }
        if (navigator.language) {
          found.push(navigator.language);
        }
      }

      return found.length > 0 ? found : undefined;
    }
  };

  var htmlTag = {
    name: 'htmlTag',

    lookup: function lookup(options) {
      var found = void 0;
      var htmlTag = options.htmlTag || (typeof document !== 'undefined' ? document.documentElement : null);

      if (htmlTag && typeof htmlTag.getAttribute === 'function') {
        found = htmlTag.getAttribute('lang');
      }

      return found;
    }
  };

  var path = {
    name: 'path',

    lookup: function lookup(options) {
      var found = void 0;
      if (typeof window !== 'undefined') {
        var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
        if (language instanceof Array) {
          if (typeof options.lookupFromPathIndex === 'number') {
            if (typeof language[options.lookupFromPathIndex] !== 'string') {
              return undefined;
            }
            found = language[options.lookupFromPathIndex].replace('/', '');
          } else {
            found = language[0].replace('/', '');
          }
        }
      }
      return found;
    }
  };

  var subdomain = {
    name: 'subdomain',

    lookup: function lookup(options) {
      var found = void 0;
      if (typeof window !== 'undefined') {
        var language = window.location.href.match(/(?:http[s]*\:\/\/)*(.*?)\.(?=[^\/]*\..{2,5})/gi);
        if (language instanceof Array) {
          if (typeof options.lookupFromSubdomainIndex === 'number') {
            found = language[options.lookupFromSubdomainIndex].replace('http://', '').replace('https://', '').replace('.', '');
          } else {
            found = language[0].replace('http://', '').replace('https://', '').replace('.', '');
          }
        }
      }
      return found;
    }
  };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function getDefaults() {
    return {
      order: ['querystring', 'cookie', 'localStorage', 'navigator', 'htmlTag'],
      lookupQuerystring: 'lng',
      lookupCookie: 'i18next',
      lookupLocalStorage: 'i18nextLng',

      // cache user language
      caches: ['localStorage'],
      excludeCacheFor: ['cimode']
      //cookieMinutes: 10,
      //cookieDomain: 'myDomain'
    };
  }

  var Browser = function () {
    function Browser(services) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Browser);

      this.type = 'languageDetector';
      this.detectors = {};

      this.init(services, options);
    }

    _createClass(Browser, [{
      key: 'init',
      value: function init(services) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        this.services = services;
        this.options = defaults(options, this.options || {}, getDefaults());

        // backwards compatibility
        if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;

        this.i18nOptions = i18nOptions;

        this.addDetector(cookie$1);
        this.addDetector(querystring);
        this.addDetector(localStorage);
        this.addDetector(navigator$1);
        this.addDetector(htmlTag);
        this.addDetector(path);
        this.addDetector(subdomain);
      }
    }, {
      key: 'addDetector',
      value: function addDetector(detector) {
        this.detectors[detector.name] = detector;
      }
    }, {
      key: 'detect',
      value: function detect(detectionOrder) {
        var _this = this;

        if (!detectionOrder) detectionOrder = this.options.order;

        var detected = [];
        detectionOrder.forEach(function (detectorName) {
          if (_this.detectors[detectorName]) {
            var lookup = _this.detectors[detectorName].lookup(_this.options);
            if (lookup && typeof lookup === 'string') lookup = [lookup];
            if (lookup) detected = detected.concat(lookup);
          }
        });

        var found = void 0;
        detected.forEach(function (lng) {
          if (found) return;
          var cleanedLng = _this.services.languageUtils.formatLanguageCode(lng);
          if (_this.services.languageUtils.isWhitelisted(cleanedLng)) found = cleanedLng;
        });

        if (!found) {
          var fallbacks = this.i18nOptions.fallbackLng;
          if (typeof fallbacks === 'string') fallbacks = [fallbacks];
          if (!fallbacks) fallbacks = [];

          if (Object.prototype.toString.apply(fallbacks) === '[object Array]') {
            found = fallbacks[0];
          } else {
            found = fallbacks[0] || fallbacks.default && fallbacks.default[0];
          }
        };

        return found;
      }
    }, {
      key: 'cacheUserLanguage',
      value: function cacheUserLanguage(lng, caches) {
        var _this2 = this;

        if (!caches) caches = this.options.caches;
        if (!caches) return;
        if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
        caches.forEach(function (cacheName) {
          if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
        });
      }
    }]);

    return Browser;
  }();

  Browser.type = 'languageDetector';

  return Browser;

}));
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.i18nextXHRBackend = factory());
}(this, (function () { 'use strict';

var arr = [];
var each = arr.forEach;
var slice = arr.slice;

function defaults(obj) {
  each.call(slice.call(arguments, 1), function (source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === undefined) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function addQueryString(url, params) {
  if (params && (typeof params === 'undefined' ? 'undefined' : _typeof(params)) === 'object') {
    var queryString = '',
        e = encodeURIComponent;

    // Must encode data
    for (var paramName in params) {
      queryString += '&' + e(paramName) + '=' + e(params[paramName]);
    }

    if (!queryString) {
      return url;
    }

    url = url + (url.indexOf('?') !== -1 ? '&' : '?') + queryString.slice(1);
  }

  return url;
}

// https://gist.github.com/Xeoncross/7663273
function ajax(url, options, callback, data, cache) {

  if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
    if (!cache) {
      data['_t'] = new Date();
    }
    // URL encoded form data must be in querystring format
    data = addQueryString('', data).slice(1);
  }

  if (options.queryStringParams) {
    url = addQueryString(url, options.queryStringParams);
  }

  try {
    var x;
    if (XMLHttpRequest) {
      x = new XMLHttpRequest();
    } else {
      x = new ActiveXObject('MSXML2.XMLHTTP.3.0');
    }
    x.open(data ? 'POST' : 'GET', url, 1);
    if (!options.crossDomain) {
      x.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
    }
    x.withCredentials = !!options.withCredentials;
    if (data) {
      x.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    }
    if (x.overrideMimeType) {
      x.overrideMimeType("application/json");
    }
    var h = options.customHeaders;
    if (h) {
      for (var i in h) {
        x.setRequestHeader(i, h[i]);
      }
    }
    x.onreadystatechange = function () {
      x.readyState > 3 && callback && callback(x.responseText, x);
    };
    x.send(data);
  } catch (e) {
    console && console.log(e);
  }
}

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getDefaults() {
  return {
    loadPath: '/locales/{{lng}}/{{ns}}.json',
    addPath: '/locales/add/{{lng}}/{{ns}}',
    allowMultiLoading: false,
    parse: JSON.parse,
    crossDomain: false,
    ajax: ajax
  };
}

var Backend = function () {
  function Backend(services) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Backend);

    this.init(services, options);

    this.type = 'backend';
  }

  _createClass(Backend, [{
    key: 'init',
    value: function init(services) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this.services = services;
      this.options = defaults(options, this.options || {}, getDefaults());
    }
  }, {
    key: 'readMulti',
    value: function readMulti(languages, namespaces, callback) {
      var loadPath = this.options.loadPath;
      if (typeof this.options.loadPath === 'function') {
        loadPath = this.options.loadPath(languages, namespaces);
      }

      var url = this.services.interpolator.interpolate(loadPath, { lng: languages.join('+'), ns: namespaces.join('+') });

      this.loadUrl(url, callback);
    }
  }, {
    key: 'read',
    value: function read(language, namespace, callback) {
      var loadPath = this.options.loadPath;
      if (typeof this.options.loadPath === 'function') {
        loadPath = this.options.loadPath([language], [namespace]);
      }

      var url = this.services.interpolator.interpolate(loadPath, { lng: language, ns: namespace });

      this.loadUrl(url, callback);
    }
  }, {
    key: 'loadUrl',
    value: function loadUrl(url, callback) {
      var _this = this;

      this.options.ajax(url, this.options, function (data, xhr) {
        if (xhr.status >= 500 && xhr.status < 600) return callback('failed loading ' + url, true /* retry */);
        if (xhr.status >= 400 && xhr.status < 500) return callback('failed loading ' + url, false /* no retry */);

        var ret = void 0,
            err = void 0;
        try {
          ret = _this.options.parse(data, url);
        } catch (e) {
          err = 'failed parsing ' + url + ' to json';
        }
        if (err) return callback(err, false);
        callback(null, ret);
      });
    }
  }, {
    key: 'create',
    value: function create(languages, namespace, key, fallbackValue) {
      var _this2 = this;

      if (typeof languages === 'string') languages = [languages];

      var payload = {};
      payload[key] = fallbackValue || '';

      languages.forEach(function (lng) {
        var url = _this2.services.interpolator.interpolate(_this2.options.addPath, { lng: lng, ns: namespace });

        _this2.options.ajax(url, _this2.options, function (data, xhr) {
          //const statusCode = xhr.status.toString();
          // TODO: if statusCode === 4xx do log
        }, payload);
      });
    }
  }]);

  return Backend;
}();

Backend.type = 'backend';

return Backend;

})));

/**
 * @file tgajs - Javascript decoder & (experimental) encoder for TGA files
 * @desc tgajs is a fork from https://github.com/vthibault/jsTGALoader
 * @author Vincent Thibault (Original author)
 * @author Lukas Schmitt
 * @version 1.0.0
 */

/* Copyright (c) 2013, Vincent Thibault. All rights reserved.

 Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
 list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
 this list of conditions and the following disclaimer in the documentation
 and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

(function (_global) {
  'use strict';

  /**
   * @var {object} TGA type constants
   */
  Targa.Type = {
    NO_DATA: 0,
    INDEXED: 1,
    RGB: 2,
    GREY: 3,
    RLE_INDEXED: 9,
    RLE_RGB: 10,
    RLE_GREY: 11
  };

  /**
   * @var {object} TGA origin constants
   */
  Targa.Origin = {
    BOTTOM_LEFT: 0x00,
    BOTTOM_RIGHT: 0x01,
    TOP_LEFT: 0x02,
    TOP_RIGHT: 0x03,
    SHIFT: 0x04,
    MASK: 0x30,
    ALPHA: 0x08
  };

  Targa.HEADER_SIZE = 18;
  Targa.FOOTER_SIZE = 26;
  Targa.LITTLE_ENDIAN = true;
  Targa.RLE_BIT = 0x80;
  Targa.RLE_MASK = 0x7f;
  Targa.RLE_PACKET = 1;
  Targa.RAW_PACKET = 2;
  Targa.SIGNATURE = "TRUEVISION-XFILE.\0";

  /**
   * TGA Namespace
   * @constructor
   */
  function Targa() {
    if (arguments.length == 1) {
      var h = arguments[0];

      this.header = createHeader(h);
      setHeaderBooleans(this.header);
      checkHeader(this.header);
    }
  }

  /**
   * Sets header or default values
   * @param header header
   * @returns {Object}
   */
  function createHeader(header) {
    return {
      /* 0x00  BYTE */  idLength: defaultFor(header.idLength, 0),
      /* 0x01  BYTE */  colorMapType: defaultFor(header.colorMapType, 0),
      /* 0x02  BYTE */  imageType: defaultFor(header.imageType, Targa.Type.RGB),
      /* 0x03  WORD */  colorMapIndex: defaultFor(header.colorMapIndex, 0),
      /* 0x05  WORD */  colorMapLength: defaultFor(header.colorMapLength, 0),
      /* 0x07  BYTE */  colorMapDepth: defaultFor(header.colorMapDepth, 0),
      /* 0x08  WORD */  offsetX: defaultFor(header.offsetX, 0),
      /* 0x0a  WORD */  offsetY: defaultFor(header.offsetY, 0),
      /* 0x0c  WORD */  width: defaultFor(header.width, 0),
      /* 0x0e  WORD */  height: defaultFor(header.height, 0),
      /* 0x10  BYTE */  pixelDepth: defaultFor(header.pixelDepth,32),
      /* 0x11  BYTE */  flags: defaultFor(header.flags, 8)
    };
  }

  function defaultFor(arg, val) { return typeof arg !== 'undefined' ? arg : val; }

  /**
   * Write footer of TGA file to view
   * Byte 0-3 - Extension Area Offset, 0 if no Extension Area exists
   * Byte 4-7 - Developer Directory Offset, 0 if no Developer Area exists
   * Byte 8-25 - Signature
   * @param {Uint8Array} footer
   */
  function writeFooter(footer) {
    var signature = Targa.SIGNATURE;
    var offset = footer.byteLength - signature.length;
    for (var i = 0; i < signature.length; i++) {
      footer[offset + i] = signature.charCodeAt(i);
    }
  }

  /**
   * Write header of TGA file to view
   * @param header
   * @param view DataView
   */
  function writeHeader(header, view) {
    var littleEndian = Targa.LITTLE_ENDIAN;

    view.setUint8(0x00, header.idLength);
    view.setUint8(0x01, header.colorMapType);
    view.setUint8(0x02, header.imageType);
    view.setUint16(0x03, header.colorMapIndex, littleEndian);
    view.setUint16(0x05, header.colorMapLength, littleEndian);
    view.setUint8(0x07, header.colorMapDepth);
    view.setUint16(0x08, header.offsetX, littleEndian);
    view.setUint16(0x0a, header.offsetY, littleEndian);
    view.setUint16(0x0c, header.width, littleEndian);
    view.setUint16(0x0e, header.height, littleEndian);
    view.setUint8(0x10, header.pixelDepth);
    view.setUint8(0x11, header.flags);
  }

  function readHeader(view) {
    var littleEndian = Targa.LITTLE_ENDIAN;

    // Not enough data to contain header ?
    if (view.byteLength  < 0x12) {
      throw new Error('Targa::load() - Not enough data to contain header');
    }

    var header = {};
    header.idLength = view.getUint8(0x00);
    header.colorMapType = view.getUint8(0x01);
    header.imageType =  view.getUint8(0x02);
    header.colorMapIndex = view.getUint16(0x03, littleEndian);
    header.colorMapLength = view.getUint16(0x05, littleEndian);
    header.colorMapDepth = view.getUint8(0x07);
    header.offsetX = view.getUint16(0x08, littleEndian);
    header.offsetY = view.getUint16(0x0a, littleEndian);
    header.width = view.getUint16(0x0c, littleEndian);
    header.height = view.getUint16(0x0e, littleEndian);
    header.pixelDepth = view.getUint8(0x10);
    header.flags = view.getUint8(0x11);

    return header;
  }

  /**
   * Set additional header booleans
   * @param header
   */
  function setHeaderBooleans(header) {
    header.hasEncoding = (header.imageType === Targa.Type.RLE_INDEXED || header.imageType === Targa.Type.RLE_RGB || header.imageType === Targa.Type.RLE_GREY);
    header.hasColorMap = (header.imageType === Targa.Type.RLE_INDEXED || header.imageType === Targa.Type.INDEXED);
    header.isGreyColor = (header.imageType === Targa.Type.RLE_GREY || header.imageType === Targa.Type.GREY);
    header.bytePerPixel = header.pixelDepth >> 3;
    header.origin = (header.flags & Targa.Origin.MASK) >> Targa.Origin.SHIFT;
    header.alphaBits = header.flags & Targa.Origin.ALPHA;
  }

  /**
   * Check the header of TGA file to detect errors
   *
   * @param {object} header tga header structure
   * @throws Error
   */
  function checkHeader(header) {
    // What the need of a file without data ?
    if (header.imageType === Targa.Type.NO_DATA) {
      throw new Error('Targa::checkHeader() - No data');
    }

    // Indexed type
    if (header.hasColorMap) {
      if (header.colorMapLength > 256 || header.colorMapType !== 1) {
        throw new Error('Targa::checkHeader() - Unsupported colormap for indexed type');
      }
      if (header.colorMapDepth !== 16 && header.colorMapDepth !== 24  && header.colorMapDepth !== 32) {
        throw new Error('Targa::checkHeader() - Unsupported colormap depth');
      }
    }
    else {
      if (header.colorMapType) {
        throw new Error('Targa::checkHeader() - Why does the image contain a palette ?');
      }
    }

    // Check image size
    if (header.width <= 0 || header.height <= 0) {
      throw new Error('Targa::checkHeader() - Invalid image size');
    }

    // Check pixel size
    if (header.pixelDepth !== 8 &&
      header.pixelDepth !== 16 &&
      header.pixelDepth !== 24 &&
      header.pixelDepth !== 32) {
      throw new Error('Targa::checkHeader() - Invalid pixel size "' + header.pixelDepth + '"');
    }

    // Check alpha size
    if (header.alphaBits !== 0 &&
        header.alphaBits !== 1 &&
        header.alphaBits !== 8) {
      throw new Error('Targa::checkHeader() - Unsuppported alpha size');
    }
  }


  /**
   * Decode RLE compression
   *
   * @param {Uint8Array} data
   * @param {number} bytesPerPixel bytes per Pixel
   * @param {number} outputSize in byte: width * height * pixelSize
   */
  function decodeRLE(data, bytesPerPixel, outputSize) {
    var pos, c, count, i, offset;
    var pixels, output;

    output = new Uint8Array(outputSize);
    pixels = new Uint8Array(bytesPerPixel);
    offset = 0; // offset in data
    pos = 0; // offset for output

    while (pos < outputSize) {
      c = data[offset++]; // current byte to check
      count = (c & Targa.RLE_MASK) + 1; // repetition count of pixels, the lower 7 bits + 1

      // RLE packet, if highest bit is set to 1.
      if (c & Targa.RLE_BIT) {
        // Copy pixel values to be repeated to tmp array
        for (i = 0; i < bytesPerPixel; ++i) {
          pixels[i] = data[offset++];
        }

        // Copy pixel values * count to output
        for (i = 0; i < count; ++i) {
          output.set(pixels, pos);
          pos += bytesPerPixel;
        }
      }

      // Raw packet (Non-Run-Length Encoded)
      else {
        count *= bytesPerPixel;
        for (i = 0; i < count; ++i) {
          output[pos++] = data[offset++];
        }
      }
    }

    if (pos > outputSize) {
      throw new Error("Targa::decodeRLE() - Read bytes: " + pos + " Expected bytes: " + outputSize);
    }

    return output;
  }

  /**
   * Encode ImageData object with RLE compression
   *
   * @param header
   * @param imageData from canvas to compress
   */
  function encodeRLE(header, imageData) {
    var maxRepetitionCount = 128;
    var i;
    var data = imageData;
    var output = []; // output size is unknown
    var pos = 0; // pos in imageData array
    var bytesPerPixel = header.pixelDepth >> 3;
    var offset = 0;
    var packetType, packetLength, packetHeader;
    var tgaLength = header.width * header.height * bytesPerPixel;
    var isSamePixel = function isSamePixel(pos, offset) {
      for (var i = 0; i < bytesPerPixel; i++) {
        if (data[pos * bytesPerPixel + i] !== data[offset * bytesPerPixel + i]) {
          return false;
        }
      }
      return true;
    };
    var getPacketType = function(pos) {
      if (isSamePixel(pos, pos + 1)) {
        return Targa.RLE_PACKET;
      }
      return Targa.RAW_PACKET;
    };

    while (pos * bytesPerPixel < data.length && pos * bytesPerPixel < tgaLength) {
      // determine packet type
      packetType = getPacketType(pos);

      // determine packet length
      packetLength = 0;
      if (packetType === Targa.RLE_PACKET) {
        while (pos + packetLength < data.length
        && packetLength < maxRepetitionCount
        && isSamePixel(pos, pos + packetLength)) {
          packetLength++;
        }
      } else { // packetType === Targa.RAW_PACKET
        while (pos + packetLength < data.length
        && packetLength < maxRepetitionCount
        && getPacketType(pos + packetLength) === Targa.RAW_PACKET) {
          packetLength++;
        }
      }

      // write packet header
      packetHeader = packetLength - 1;
      if (packetType === Targa.RLE_PACKET) {
        packetHeader |= Targa.RLE_BIT;
      }
      output[offset++] = packetHeader;

      // write rle packet pixel OR raw pixels
      if (packetType === Targa.RLE_PACKET) {
        for (i = 0; i < bytesPerPixel; i++) {
          output[i + offset] = data[i + pos * bytesPerPixel];
        }
        offset += bytesPerPixel;
      } else {
        for (i = 0; i < bytesPerPixel * packetLength; i++) {
          output[i + offset] = data[i + pos * bytesPerPixel];
        }
        offset += bytesPerPixel * packetLength;
      }
      pos += packetLength;
    }

    return new Uint8Array(output);
  }


  /**
   * Return a ImageData object from a TGA file (8bits)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} indexes - index to colorMap
   * @param {Array} colorMap
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData8bits(imageData, indexes, colorMap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var color, index, offset, i, x, y;
    var bytePerPixel = this.header.colorMapDepth >> 3;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i++) {
        offset = (x + width * y) * 4;
        index = indexes[i] * bytePerPixel;
        if (bytePerPixel === 4) {
          imageData[offset    ] = colorMap[index + 2]; // red
          imageData[offset + 1] = colorMap[index + 1]; // green
          imageData[offset + 2] = colorMap[index    ]; // blue
          imageData[offset + 3] = colorMap[index + 3]; // alpha
        } else if (bytePerPixel === 3) {
          imageData[offset    ] = colorMap[index + 2]; // red
          imageData[offset + 1] = colorMap[index + 1]; // green
          imageData[offset + 2] = colorMap[index    ]; // blue
          imageData[offset + 3] = 255; // alpha
        } else if (bytePerPixel === 2) {
          color = colorMap[index] | (colorMap[index + 1] << 8);
          imageData[offset    ] = (color & 0x7C00) >> 7; // red
          imageData[offset + 1] = (color & 0x03E0) >> 2; // green
          imageData[offset + 2] = (color & 0x001F) << 3; // blue
          imageData[offset + 3] = (color & 0x8000) ? 0 : 255; // overlay 0 = opaque and 1 = transparent Discussion at: https://bugzilla.gnome.org/show_bug.cgi?id=683381
        }
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (16bits)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData16bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var color, offset, i, x, y;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 2) {
        color = pixels[i] | (pixels[i + 1] << 8);
        offset = (x + width * y) * 4;
        imageData[offset    ] = (color & 0x7C00) >> 7; // red
        imageData[offset + 1] = (color & 0x03E0) >> 2; // green
        imageData[offset + 2] = (color & 0x001F) << 3; // blue
        imageData[offset + 3] = (color & 0x8000) ? 0 : 255; // overlay 0 = opaque and 1 = transparent Discussion at: https://bugzilla.gnome.org/show_bug.cgi?id=683381
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (24bits)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData24bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var offset, i, x, y;
    var bpp = this.header.pixelDepth >> 3;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += bpp) {
        offset = (x + width * y) * 4;
        imageData[offset + 3] = 255;  // alpha
        imageData[offset + 2] = pixels[i    ]; // blue
        imageData[offset + 1] = pixels[i + 1]; // green
        imageData[offset    ] = pixels[i + 2]; // red
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (32bits)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data from TGA file
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData32bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var i, x, y, offset;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 4) {
        offset = (x + width * y) * 4;
        imageData[offset + 2] = pixels[i    ]; // blue
        imageData[offset + 1] = pixels[i + 1]; // green
        imageData[offset    ] = pixels[i + 2]; // red
        imageData[offset + 3] = pixels[i + 3]; // alpha
      }
    }

    return imageData;
  }

  /**
   * Return a ImageData object from a TGA file (32bits). Uses pre multiplied alpha values
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data from TGA file
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData32bitsPre(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var i, x, y, offset, alpha;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 4) {
        offset = (x + width * y) * 4;
        alpha = pixels[i + 3] * 255; // TODO needs testing
        imageData[offset + 2] = pixels[i    ] / alpha; // blue
        imageData[offset + 1] = pixels[i + 1] / alpha; // green
        imageData[offset    ] = pixels[i + 2] / alpha; // red
        imageData[offset + 3] = pixels[i + 3]; // alpha
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (8bits grey)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageDataGrey8bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var color, offset, i, x, y;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i++) {
        color = pixels[i];
        offset = (x + width * y) * 4;
        imageData[offset    ] = color; // red
        imageData[offset + 1] = color; // green
        imageData[offset + 2] = color; // blue
        imageData[offset + 3] = 255;   // alpha
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (16bits grey) 8 Bit RGB and 8 Bit Alpha
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageDataGrey16bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var color, offset, i, x, y;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 2) {
        color = pixels[i];
        offset = (x + width * y) * 4;
        imageData[offset] = color;
        imageData[offset + 1] = color;
        imageData[offset + 2] = color;
        imageData[offset + 3] = pixels[i + 1];
      }
    }

    return imageData;
  }


  /**
   * Open a targa file using XHR, be aware with Cross Domain files...
   *
   * @param {string} path - Path of the filename to load
   * @param {function} callback - callback to trigger when the file is loaded
   */
  Targa.prototype.open = function targaOpen(path, callback) {
    var req, tga = this;
    req = new XMLHttpRequest();
    req.open('GET', path, true);
    req.responseType = 'arraybuffer';
    req.onload = function () {
      if (this.status === 200) {
        tga.arrayBuffer = req.response;
        tga.load(tga.arrayBuffer);
        if (callback) {
          callback.call(tga);
        }
      }
    };
    req.send(null);
  };


  function readFooter(view) {
    var offset = view.byteLength - Targa.FOOTER_SIZE;
    var signature = Targa.SIGNATURE;

    var footer = {};

    var signatureArray = new Uint8Array(view.buffer, offset + 0x08, signature.length);
    var str = String.fromCharCode.apply(null, signatureArray);

    if (!isSignatureValid(str)) {
      footer.hasFooter = false;
      return footer;
    }

    footer.hasFooter = true;
    footer.extensionOffset = view.getUint32(offset, Targa.LITTLE_ENDIAN);
    footer.developerOffset = view.getUint32(offset + 0x04, Targa.LITTLE_ENDIAN);
    footer.hasExtensionArea = footer.extensionOffset !== 0;
    footer.hasDeveloperArea = footer.developerOffset !== 0;

    if (footer.extensionOffset) {
      footer.attributeType = view.getUint8(footer.extensionOffset + 494);
    }

    return footer;
  }

  function isSignatureValid(str) {
    var signature = Targa.SIGNATURE;

    for (var i = 0; i < signature.length; i++) {
      if (str.charCodeAt(i) !== signature.charCodeAt(i)) {
        return false;
      }
    }

    return true;
  }

  /**
   * Load and parse a TGA file
   *
   * @param {ArrayBuffer} data - TGA file buffer array
   */
  Targa.prototype.load = function targaLoad(data) {
    var dataView = new DataView(data);

    this.headerData = new Uint8Array(data, 0, Targa.HEADER_SIZE);

    this.header = readHeader(dataView); // Parse Header
    setHeaderBooleans(this.header);
    checkHeader(this.header); // Check if a valid TGA file (or if we can load it)

    var offset = Targa.HEADER_SIZE;
    // Move to data
    offset += this.header.idLength;
    if (offset >= data.byteLength) {
      throw new Error('Targa::load() - No data');
    }

    // Read palette
    if (this.header.hasColorMap) {
      var colorMapSize = this.header.colorMapLength * (this.header.colorMapDepth >> 3);
      this.palette = new Uint8Array(data, offset, colorMapSize);
      offset += colorMapSize;
    }

    var bytesPerPixel = this.header.pixelDepth >> 3;
    var imageSize = this.header.width * this.header.height;
    var pixelTotal = imageSize * bytesPerPixel;

    if (this.header.hasEncoding) { // RLE encoded
      var RLELength = data.byteLength - offset - Targa.FOOTER_SIZE;
      var RLEData = new Uint8Array(data, offset, RLELength);
      this.imageData = decodeRLE(RLEData, bytesPerPixel, pixelTotal);
    } else { // RAW pixels
      this.imageData = new Uint8Array(data, offset, this.header.hasColorMap ? imageSize : pixelTotal);
    }
    
    this.footer = readFooter(dataView);

    if (this.header.alphaBits !== 0  || this.footer.hasExtensionArea && (this.footer.attributeType === 3 || this.footer.attributeType === 4)) {
      this.footer.usesAlpha = true;
    }
  };


  /**
   * Return a ImageData object from a TGA file
   *
   * @param {object} imageData - Optional ImageData to work with
   * @returns {object} imageData
   */
  Targa.prototype.getImageData = function targaGetImageData(imageData) {
    var width = this.header.width;
    var height = this.header.height;
    var origin = (this.header.flags & Targa.Origin.MASK) >> Targa.Origin.SHIFT;
    var x_start, x_step, x_end, y_start, y_step, y_end;
    var getImageData;

    // Create an imageData
    if (!imageData) {
      if (document) {
        imageData = document.createElement('canvas').getContext('2d').createImageData(width, height);
      }
      // In Thread context ?
      else {
        imageData = {
          width: width,
          height: height,
          data: new Uint8ClampedArray(width * height * 4)
        };
      }
    }

    if (origin === Targa.Origin.TOP_LEFT || origin === Targa.Origin.TOP_RIGHT) {
      y_start = 0;
      y_step = 1;
      y_end = height;
    }
    else {
      y_start = height - 1;
      y_step = -1;
      y_end = -1;
    }

    if (origin === Targa.Origin.TOP_LEFT || origin === Targa.Origin.BOTTOM_LEFT) {
      x_start = 0;
      x_step = 1;
      x_end = width;
    }
    else {
      x_start = width - 1;
      x_step = -1;
      x_end = -1;
    }

    // TODO: use this.header.offsetX and this.header.offsetY ?

    switch (this.header.pixelDepth) {
      case 8:
        getImageData = this.header.isGreyColor ? getImageDataGrey8bits : getImageData8bits;
        break;

      case 16:
        getImageData = this.header.isGreyColor ? getImageDataGrey16bits : getImageData16bits;
        break;

      case 24:
        getImageData = getImageData24bits;
        break;

      case 32:
        if (this.footer.hasExtensionArea) {
          if (this.footer.attributeType === 3) { // straight alpha
            getImageData = getImageData32bits;
          } else if (this.footer.attributeType === 4) { // pre multiplied alpha
            getImageData = getImageData32bitsPre;
          } else { // ignore alpha values if attributeType set to 0, 1, 2
            getImageData = getImageData24bits;
          }
        } else {
          if (this.header.alphaBits !== 0) {
            getImageData = getImageData32bits;
          } else { // 32 bits Depth, but alpha Bits set to 0
            getImageData = getImageData24bits;
          }
        }

        break;
    }

    getImageData.call(this, imageData.data, this.imageData, this.palette, width, y_start, y_step, y_end, x_start, x_step, x_end);
    return imageData;
  };

  /** (Experimental)
   *  Encodes imageData into TGA format
   *  Only TGA True Color 32 bit with optional RLE encoding is supported for now
   * @param imageData
   */
  Targa.prototype.setImageData = function targaSetImageData(imageData) {

    if (!imageData) {
      throw new Error('Targa::setImageData() - imageData argument missing');
    }

    var width = this.header.width;
    var height = this.header.height;
    var expectedLength = width * height * (this.header.pixelDepth  >> 3);
    var origin = (this.header.flags & Targa.Origin.MASK) >> Targa.Origin.SHIFT;
    var x_start, x_step, x_end, y_start, y_step, y_end;

    if (origin === Targa.Origin.TOP_LEFT || origin === Targa.Origin.TOP_RIGHT) {
      y_start = 0; // start bottom, step upward
      y_step = 1;
      y_end = height;
    } else {
      y_start = height - 1; // start at top, step downward
      y_step = -1;
      y_end = -1;
    }

    if (origin === Targa.Origin.TOP_LEFT || origin === Targa.Origin.BOTTOM_LEFT) {
      x_start = 0; // start left, step right
      x_step = 1;
      x_end = width;
    } else {
      x_start = width - 1; // start right, step left
      x_step = -1;
      x_end = -1;
    }

    if (!this.imageData) {
      this.imageData = new Uint8Array(expectedLength);
    }

    // start top left if origin is bottom left
    // swapping order of first two arguments does the trick for writing
    // this converts canvas data to internal tga representation
    // this.imageData contains tga data
    getImageData32bits(this.imageData, imageData.data, this.palette, width, y_start, y_step, y_end, x_start, x_step, x_end);

    var data = this.imageData;

    if (this.header.hasEncoding) {
      data = encodeRLE(this.header, data);
    }

    var bufferSize = Targa.HEADER_SIZE + data.length + Targa.FOOTER_SIZE;
    var buffer = new ArrayBuffer(bufferSize);

    this.arrayBuffer = buffer;
    // create array, useful for inspecting data while debugging
    this.headerData = new Uint8Array(buffer, 0, Targa.HEADER_SIZE);
    this.RLEData = new Uint8Array(buffer, Targa.HEADER_SIZE, data.length);
    this.footerData = new Uint8Array(buffer, Targa.HEADER_SIZE + data.length, Targa.FOOTER_SIZE);

    var headerView = new DataView(this.headerData.buffer);
    writeHeader(this.header, headerView);
    this.RLEData.set(data);
    writeFooter(this.footerData);
  };

  /**
   * Return a canvas with the TGA render on it
   *
   * @returns {object} CanvasElement
   */
  Targa.prototype.getCanvas = function targaGetCanvas() {
    var canvas, ctx, imageData;

    canvas = document.createElement('canvas');
    ctx = canvas.getContext('2d');
    imageData = ctx.createImageData(this.header.width, this.header.height);

    canvas.width = this.header.width;
    canvas.height = this.header.height;

    ctx.putImageData(this.getImageData(imageData), 0, 0);

    return canvas;
  };


  /**
   * Return a dataURI of the TGA file
   *
   * @param {string} type - Optional image content-type to output (default: image/png)
   * @returns {string} url
   */
  Targa.prototype.getDataURL = function targaGetDatURL(type) {
    return this.getCanvas().toDataURL(type || 'image/png');
  };

  /**
   * Return a objectURL of the TGA file
   * The url can be used in the download attribute of a link
   * @returns {string} url
   */
  Targa.prototype.getBlobURL = function targetGetBlobURL() {
    if (!this.arrayBuffer) {
      throw new Error('Targa::getBlobURL() - No data available for blob');
    }
    var blob = new Blob([this.arrayBuffer], { type: "image/x-tga" });
    return URL.createObjectURL(blob);
  };


  // Find Context
  var shim = {};
  if (typeof(exports) === 'undefined') {
    if (typeof(define) === 'function' && typeof(define.amd) === 'object' && define.amd) {
      define(function () {
        return Targa;
      });
    } else {
      // Browser
      shim.exports = typeof(window) !== 'undefined' ? window : _global;
    }
  }
  else {
    // Commonjs
    shim.exports = exports;
  }


  // Export
  if (shim.exports) {
    shim.exports.TGA = Targa;
  }

})(this);

'use strict';
var Mago3D = (function() 
{
'use strict';

/**
 * color 처리 관련 도메인
 * @class ColorAPI
 */
var ColorAPI = {};

ColorAPI.changeColor = function(api, magoManager) 
{
	var projectId = api.getProjectId();
	var dataKey = api.getDataKey();
	var objectIds = api.getObjectIds();
	var property = api.getProperty();
	var propertyKey = null;
	var propertyValue = null;
	if (property !== null && property !== "") 
	{
		var properties = property.split("=");
		propertyKey = properties[0];
		propertyValue = properties[1];
	}
	var colorString = api.getColor();
	if (colorString === undefined || colorString === 0)
	{ return; }
	
	var color = api.getColor().split(",");
	var rgbColor = [ color[0]/255, color[1]/255, color[2]/255 ] ;
	
	var isExistObjectIds = false;
	if (objectIds !== null && objectIds.length !== 0) 
	{
		isExistObjectIds = true;
	}
	
	var changeHistorys = [];
	if (isExistObjectIds) 
	{
		for (var i=0, objectCount = objectIds.length; i<objectCount; i++) 
		{
			var changeHistory = new ChangeHistory();
			changeHistory.setProjectId(projectId);
			changeHistory.setDataKey(dataKey);
			changeHistory.setObjectId(objectIds[i]);
			changeHistory.setProperty(property);
			changeHistory.setPropertyKey(propertyKey);
			changeHistory.setPropertyValue(propertyValue);
			changeHistory.setRgbColor(rgbColor);
			
			changeHistorys.push(changeHistory);
		}
	}
	else 
	{
		var changeHistory = new ChangeHistory();
		changeHistory.setProjectId(projectId);
		changeHistory.setDataKey(dataKey);
		changeHistory.setObjectId(null);
		changeHistory.setProperty(property);
		changeHistory.setPropertyKey(propertyKey);
		changeHistory.setPropertyValue(propertyValue);
		changeHistory.setRgbColor(rgbColor);
		
		changeHistorys.push(changeHistory);
	}

	var changeHistory;
	var historiesCount = changeHistorys.length;
	for (var i=0; i<historiesCount; i++)
	{
		changeHistory = changeHistorys[i];
		MagoConfig.saveColorHistory(projectId, dataKey, changeHistory.getObjectId(), changeHistory);
	}
};
'use strict';

/**
 * Draw 관련 API를 담당하는 클래스
 * 원래는 이렇게 만들려고 한게 아니지만, legacy 파일이랑 이름, function 등이 중복되서 이렇게 만들었음
 * @class DrawAPI
 */
var DrawAPI = {};

DrawAPI.drawAppendData = function(api, magoManager) 
{
	magoManager.getObjectIndexFile(api.getProjectId(), api.getProjectDataFolder());
};

DrawAPI.drawInsertIssueImage = function(api, magoManager) 
{
	// pin 을 표시
	if (magoManager.objMarkerSC === undefined || api.getDrawType() === 0) 
	{
		magoManager.objMarkerSC = new ObjectMarker();
		magoManager.objMarkerSC.geoLocationData.geographicCoord = new GeographicCoord();
		ManagerUtils.calculateGeoLocationData(parseFloat(api.getLongitude()), parseFloat(api.getLatitude()), parseFloat(api.getElevation()), 
			undefined, undefined, undefined, magoManager.objMarkerSC.geoLocationData, magoManager);
	}
	
	var objMarker = magoManager.objMarkerManager.newObjectMarker();
	
	magoManager.objMarkerSC.issue_id = api.getIssueId();
	magoManager.objMarkerSC.issue_type = api.getIssueType();
	magoManager.objMarkerSC.geoLocationData.geographicCoord.setLonLatAlt(parseFloat(api.getLongitude()), parseFloat(api.getLatitude()), parseFloat(api.getElevation()));
	
	objMarker.copyFrom(magoManager.objMarkerSC);
	magoManager.objMarkerSC = undefined;
};
'use strict';

/**
 * 변환 행렬 API
 * @class LocationAndRotationAPI
 */
var LocationAndRotationAPI = {};

LocationAndRotationAPI.changeLocationAndRotation = function(api, magoManager) 
{
//	var buildingId = api.getDataKey();
//	var buildingType = "structure";
//	var building = this.getNeoBuildingByTypeId(buildingType, buildingId);

	var changeHistory = new ChangeHistory();
	changeHistory.setProjectId(api.getProjectId());
	changeHistory.setDataKey(api.getDataKey());
	changeHistory.setLatitude(parseFloat(api.getLatitude()));
	changeHistory.setLongitude(parseFloat(api.getLongitude()));
	changeHistory.setElevation(parseFloat(api.getElevation()));
	changeHistory.setHeading(parseFloat(api.getHeading()));
	changeHistory.setPitch(parseFloat(api.getPitch()));
	changeHistory.setRoll(parseFloat(api.getRoll()));
	
	magoManager.changeLocationAndRotation(	api.getProjectId(),
		api.getDataKey(),
		parseFloat(api.getLatitude()),
		parseFloat(api.getLongitude()),
		parseFloat(api.getElevation()),
		parseFloat(api.getHeading()),
		parseFloat(api.getPitch()),
		parseFloat(api.getRoll()),
		api.getAnimationOption()
	);
	
	// MagoConfig에 저장......?
};
'use strict';

/**
 * lod 처리 관련 도메인
 * @class LodAPI
 */
var LodAPI = {};

LodAPI.changeLod = function(api, magoManager) 
{
	if (api.getLod0DistInMeters() !== null && api.getLod0DistInMeters() !== "") { magoManager.magoPolicy.setLod0DistInMeters(api.getLod0DistInMeters()); }
	if (api.getLod1DistInMeters() !== null && api.getLod1DistInMeters() !== "") { magoManager.magoPolicy.setLod1DistInMeters(api.getLod1DistInMeters()); }
	if (api.getLod2DistInMeters() !== null && api.getLod2DistInMeters() !== "") { magoManager.magoPolicy.setLod2DistInMeters(api.getLod2DistInMeters()); }
	if (api.getLod3DistInMeters() !== null && api.getLod3DistInMeters() !== "") { magoManager.magoPolicy.setLod3DistInMeters(api.getLod3DistInMeters()); }
	if (api.getLod4DistInMeters() !== null && api.getLod4DistInMeters() !== "") { magoManager.magoPolicy.setLod4DistInMeters(api.getLod4DistInMeters()); }
	if (api.getLod5DistInMeters() !== null && api.getLod5DistInMeters() !== "") { magoManager.magoPolicy.setLod5DistInMeters(api.getLod5DistInMeters()); }
};
'use strict';

/**
 * save the data related with making feature move
 * @class AnimationData
 */
var AnimationData = function() 
{
	if (!(this instanceof AnimationData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.birthTime; //the first update time
	this.lastTime; // the last update time.
	this.durationInSeconds;
	
	// start location.
	this.startLongitude;
	this.startLatitude;
	this.startAltitude;
	
	// target location.
	this.targetLongitude;
	this.targetLatitude;
	this.targetAltitude;
	
	// target rotation.
	this.targetHeading;
	this.targetPitch;
	this.targetRoll;
	
	// linear velocity in m/s.
	this.linearVelocityInMetersSecond;
	
	// angular velocity deg/s.
	this.headingAngDegSecondVelocity;
	this.pitchAngDegSecondVelocity;
	this.rollAngDegSecondVelocity;
};

'use strict';

/**
 * manage AnimationData
 * @class AnimationData
 */
var AnimationData = function() 
{
	if (!(this instanceof AnimationData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.birthTime;
	this.lastTime; // the last update time.
	this.durationInSeconds;
	
	// start location.
	this.startLongitude;
	this.startLatitude;
	this.startAltitude;
	
	// target location.
	this.targetLongitude;
	this.targetLatitude;
	this.targetAltitude;
	
	// target rotation.
	this.targetHeading;
	this.targetPitch;
	this.targetRoll;
	
	// linear velocity in m/s.
	this.linearVelocityInMetersSecond;
	
	// angular velocity deg/s.
	this.headingAngDegSecondVelocity;
	this.pitchAngDegSecondVelocity;
	this.rollAngDegSecondVelocity;
};

/**
 * AnimationManager
 * @class AnimationManager
 */
var AnimationManager = function() 
{
	if (!(this instanceof AnimationManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.nodesMap;
	
};

/**
 * put the node which will move
 */
AnimationManager.prototype.putNode = function(node) 
{
	if (this.nodesMap === undefined)
	{ this.nodesMap = {}; }
	
	var nodeId = node.data.nodeId;
	this.nodesMap[nodeId] = node;
};

/**
 * Check whether this node already moved or not
 * @param {MagoManager} magoManager
 */
AnimationManager.prototype.checkAnimation = function(magoManager) 
{
	if (this.nodesMap === undefined)
	{ return; }
	
	var node;
	for (var key in this.nodesMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.nodesMap, key))
		{
			node = this.nodesMap[key];
			if (node.finishedAnimation(magoManager))
			{
				delete this.nodesMap[key];
			}
		}
	}
};

'use strict';

/**
 * 하늘에 구름을 관리하는 매니저
 *
 * @class Atmosphere
 */
var Atmosphere = function() 
{
	if (!(this instanceof Atmosphere)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.cloudsManager = new CloudsManager();
	this.shadowBlendingCube = new ShadowBlendingCube();
};

/**
 * 구름이 땅에 그림자를 그릴때 사용함
 *
 * @class ShadowBlendingCube
 */
var ShadowBlendingCube = function() 
{
	if (!(this instanceof ShadowBlendingCube)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vertexMatrix = new VertexMatrix();
	this.tTrianglesMatrix = new TTrianglesMatrix();
	this.init(this.vertexMatrix, this.tTrianglesMatrix);

	this.vboVertexCacheKey;
	this.vboIndexCacheKey;
	this.indicesCount = 0;
};

/**
 * 구름이 땅에 그림자를 그릴때 초기화
 *
 * @param vtxMat 변수
 * @param tTriMat 변수
 */
ShadowBlendingCube.prototype.init = function(vtxMat, tTriMat) 
{
	// create a blending cube, with faces inverted.
	var cubeSideSemiLength = 150.5;

	var r = 0.1;
	var g = 0.1;
	var b = 0.1;
	var alpha = 0.6;

	// Center Bottom of the cube.
	var vertexList = vtxMat.newVertexList();
	var vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, -cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, -cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, -cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, -cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	// Bottom of the cube.
	vertexList = vtxMat.newVertexList();
	vertex = vertexList.newVertex();
	vertex.setPosition(-cubeSideSemiLength, -cubeSideSemiLength,
		-cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(cubeSideSemiLength, -cubeSideSemiLength,
		-cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(cubeSideSemiLength, cubeSideSemiLength,
		-cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(-cubeSideSemiLength, cubeSideSemiLength,
		-cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	// Top of the cube.
	vertexList = vtxMat.newVertexList();
	vertex = vertexList.newVertex();
	vertex.setPosition(-cubeSideSemiLength, -cubeSideSemiLength,
		cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(cubeSideSemiLength, -cubeSideSemiLength,
		cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(cubeSideSemiLength, cubeSideSemiLength,
		cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(-cubeSideSemiLength, cubeSideSemiLength,
		cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	// Center Top of the cube.
	vertexList = vtxMat.newVertexList();
	vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	// Now, make the tTrianglesMatrix.
	vtxMat.makeTTrianglesLateralSidesLOOP(tTriMat);
	// tTriMat.invert_trianglesSense();
};

/**
 * 그래픽 카드에 데이터를 올릴때 요청
 *
 * @returns floatArray
 */
ShadowBlendingCube.prototype.getVBOVertexColorRGBAFloatArray = function() 
{
	var floatArray = this.vertexMatrix.getVBOVertexColorRGBAFloatArray();
	return floatArray;
};

/**
 * 그래픽 카드에 데이터를 올릴때 사용(삼각형을 이루어 주는 순서)
 *
 * @returns shortArray
 */
ShadowBlendingCube.prototype.getVBOIndicesShortArray = function() 
{
	this.vertexMatrix.setVertexIdxInList();
	var shortArray = this.tTrianglesMatrix.getVBOIndicesShortArray();
	this.indicesCount = shortArray.length;

	return shortArray;
};

/**
 * 구름 매니저
 *
 * @class CloudsManager
 */
var CloudsManager = function() 
{
	if (!(this instanceof CloudsManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.circularCloudsArray = [];
};

/**
 * 원형 구름 생성
 *
 * @returns circularCloud
 */
CloudsManager.prototype.newCircularCloud = function() 
{
	var circularCloud = new CircularCloud();
	this.circularCloudsArray.push(circularCloud);
	return circularCloud;
};

/**
 * 원형 구름
 *
 * @class CircularCloud
 */
var CircularCloud = function() 
{
	if (!(this instanceof CircularCloud)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.radius = 200.0;
	this.depth = 150.0;
	this.numPointsForCicle = 8;

	this.vertexMatrix = new VertexMatrix();
	this.tTrianglesMatrix = new TTrianglesMatrix();
	this.shadowVertexMatrix = new VertexMatrix();
	this.shadowTTrianglesMatrix = new TTrianglesMatrix();

	this.sunLightDirection = new Point3D();
	this.sunLightDirection.set(1, 1, -5);
	this.sunLightDirection.unitary();

	this.longitude;
	this.latitude;
	this.altitude;
	this.position;
	this.positionHIGH;
	this.positionLOW;

	this.bbox = new BoundingBox();
	this.cullingPosition;
	this.cullingRadius;

	this.vboVertexCacheKey;
	this.vboIndexCacheKey;
	this.vboShadowVertexCacheKey;
	this.vboShadowIndexCacheKey;
	this.indicesCount = 0;

	this.rendered = false; // Test.

	// SCRATCH. SCRATCH. SCRATCH. SCRATCH. SCRATCH. SCRATCH.
	// SCRATCH. SCRATCH.
	this.point3dSC = new Point3D();
	this.vertexSC = new Vertex();
};

/**
 * 그래픽 카드에 올릴 데이터를 요청
 *
 * @returns floatArray
 */
CircularCloud.prototype.getVBOVertexColorFloatArray = function() 
{
	var floatArray;
	floatArray = this.vertexMatrix.getVBOVertexColorFloatArray(floatArray);
	return floatArray;
};

/**
 * 그래픽 카드에 올릴 데이터를 요청(삼각형)
 *
 * @returns floatArray
 */
CircularCloud.prototype.getVBOIndicesShortArray = function() 
{
	this.vertexMatrix.setVertexIdxInList();
	var shortArray = this.tTrianglesMatrix.getVBOIndicesShortArray();
	this.indicesCount = shortArray.length;

	return shortArray;
};

/**
 * 그래픽 카드에 올릴 데이터를 요청(Vertex)
 *
 * @returns floatArray
 */
CircularCloud.prototype.getVBOShadowVertexFloatArray = function() 
{
	var floatArray;
	floatArray = this.shadowVertexMatrix.getVBOVertexFloatArray(floatArray);
	return floatArray;
};

/**
 * 그래픽 카드에 올릴 데이터를 요청(삼삭형 순서)
 *
 * @returns shortArray
 */
CircularCloud.prototype.getVBOShadowIndicesShortArray = function() 
{
	this.shadowVertexMatrix.setVertexIdxInList();
	var shortArray = this.shadowTTrianglesMatrix.getVBOIndicesShortArray();
	this.indicesCount = shortArray.length;

	return shortArray;
};

/**
 * 로케이션을 따라서 회전
 *
 * @param vtxMat
 *            변수
 */
CircularCloud.prototype.rotateMeshByLocation = function(vtxMat) 
{
	// we rotate the cloud mesh by longitude, latitude.
	var matrix = new Matrix4();

	// 1) Rotation Z. Longitude.
	matrix.rotationAxisAngDeg(-this.longitude, 0.0, 0.0, 1.0);
	vtxMat.transformPointsByMatrix4(matrix);

	// 2) Rotation X'. Latitude.
	var longitudeRad = this.longitude * Math.PI / 180.0;

	var cloudEquatorialPos = new Point3D();
	var zAxis = new Point3D();
	var pitchAxis;
	cloudEquatorialPos.set(Math.cos(longitudeRad), Math.sin(longitudeRad), 0.0);
	zAxis.set(0.0, 0.0, 1.0);
	pitchAxis = cloudEquatorialPos.crossProduct(zAxis, pitchAxis);
	pitchAxis.unitary();

	// matrix.rotationAxisAngDeg(90.0-this.latitude, Math.cos(longitudeRad-90),
	// -Math.sin(longitudeRad-90), 0.0);
	matrix.rotationAxisAngDeg(90.0 - this.latitude, pitchAxis.x, pitchAxis.y,
		0.0);
	vtxMat.transformPointsByMatrix4(matrix);
};

/**
 * 햇빛 방향으로 시작
 */
CircularCloud.prototype.doShadowMeshWithSunDirection = function() 
{
	var distance = 3000.0;
	var vertexList = this.shadowVertexMatrix.getVertexList(5); // Bottom radius
	// zero ring.
	vertexList.translateVertices(this.sunLightDirection.x,
		this.sunLightDirection.y, this.sunLightDirection.z, distance);

	vertexList = this.shadowVertexMatrix.getVertexList(4); // Bottom minor
	// ring.
	vertexList.translateVertices(this.sunLightDirection.x,
		this.sunLightDirection.y, this.sunLightDirection.z, distance);

	vertexList = this.shadowVertexMatrix.getVertexList(3); // Bottom major
	// ring.
	vertexList.translateVertices(this.sunLightDirection.x,
		this.sunLightDirection.y, this.sunLightDirection.z, distance);
};

/**
 * 구름 생성
 *
 * @param logitude
 *            경도
 * @param latitude
 *            위도
 * @param radius
 *            반지름
 * @param depth
 *            깊이
 * @param numPointsForCircle
 *            동그라미 하나당 점의 갯수
 */
CircularCloud.prototype.createCloud = function(longitude, latitude, altitude,
	radius, depth, numPointsForCircle) 
{
	this.longitude = longitude;
	this.latitude = latitude;
	this.altitude = altitude;
	this.radius = radius;
	this.depth = depth;
	this.numPointsForCicle = numPointsForCircle;

	this.makeMesh(this.vertexMatrix, this.tTrianglesMatrix,
		this.shadowVertexMatrix, this.shadowTTrianglesMatrix);
	// this.makeMesh(this.shadowVertexMatrix, this.shadowTTrianglesMatrix,
	// true);
	// this.shadowTTrianglesMatrix.invertTrianglesSense();// TEST!!!!!!
	this.doShadowMeshWithSunDirection();

	this.rotateMeshByLocation(this.vertexMatrix);
	this.rotateMeshByLocation(this.shadowVertexMatrix);

	var position = Cesium.Cartesian3.fromDegrees(this.longitude, this.latitude,
		this.altitude);
	this.position = position;

	// var splitValue = Cesium.EncodedCartesian3.encode(position);
	var splitVelueX = Cesium.EncodedCartesian3.encode(position.x);
	var splitVelueY = Cesium.EncodedCartesian3.encode(position.y);
	var splitVelueZ = Cesium.EncodedCartesian3.encode(position.z);

	this.positionHIGH = new Float32Array([ splitVelueX.high, splitVelueY.high,
		splitVelueZ.high ]);
	this.positionLOW = new Float32Array([ splitVelueX.low, splitVelueY.low,
		splitVelueZ.low ]);

	this.bbox = this.shadowVertexMatrix.getBoundingBox(this.bbox);
	var cloudPoint3d;
	cloudPoint3d = this.bbox.getCenterPoint(cloudPoint3d);
	this.cullingPosition = new Cesium.Cartesian3(cloudPoint3d.x
			+ this.position.x, cloudPoint3d.y + this.position.y, cloudPoint3d.z
			+ this.position.z);
	this.cullingRadius = this.bbox.getMaxLength() / 2;
};

/**
 * mesh 생성
 *
 * @param vtxMat
 *            변수
 * @param tTriMat
 *            변수
 * @param shadowVtxMat
 *            변수
 * @param shadowTTriMat
 *            변수
 */
CircularCloud.prototype.makeMesh = function(vtxMat, tTriMat, shadowVtxMat,
	shadowTTriMat) 
{
	// use vertex_matrix.
	// our cloud has 6 rings. Top ring and the bottom ring has radius zero.
	var numPointsForRing = 16;
	var increAngRad = (2.0 * Math.PI) / numPointsForRing;
	var angRad = 0.0;
	var vertex;
	var shadowVertex;
	var semiDepth = this.depth / 2.0;
	var x = 0.0;
	var y = 0.0;
	var randomValue = 0;
	// var cloudWhite = 0.98;

	// 1) Top ring. radius zero.
	var vertexList = vtxMat.newVertexList();
	var shadowVertexList = shadowVtxMat.newVertexList();
	randomValue = 0.9 + 0.3 * Math.random();
	for (var i = 0; i < numPointsForRing; i++) 
	{
		vertex = vertexList.newVertex();
		vertex.setPosition(x, y, semiDepth);
		shadowVertex = shadowVertexList.newVertex();
		shadowVertex.setPosition(x, y, -semiDepth * 1.2);
		vertex.setColorRGB(randomValue, randomValue, randomValue);
	}

	// 2) Top menor_ring.
	angRad = 0.0;
	var menorRingRadius = this.radius * 0.7;
	vertexList = vtxMat.newVertexList();
	shadowVertexList = shadowVtxMat.newVertexList();
	for (var i = 0; i < numPointsForRing; i++) 
	{
		// Math.random(); // returns from 0.0 to 1.0.
		randomValue = (2 + Math.random()) / 2;
		vertex = vertexList.newVertex();
		shadowVertex = shadowVertexList.newVertex();
		x = menorRingRadius * Math.cos(angRad) * randomValue;
		y = menorRingRadius * Math.sin(angRad) * randomValue;
		shadowVertex.setPosition(x, y, -semiDepth * 2);
		vertex.setPosition(x, y, semiDepth * 0.8);
		randomValue = 0.9 + 0.3 * Math.random();
		vertex.setColorRGB(randomValue, randomValue, randomValue);
		angRad += increAngRad;
	}

	// 3) Top major_ring.
	angRad = 0.0;
	vertexList = vtxMat.newVertexList();
	shadowVertexList = shadowVtxMat.newVertexList();
	for (var i = 0; i < numPointsForRing; i++) 
	{
		randomValue = (2 + Math.random()) / 2;
		vertex = vertexList.newVertex();
		shadowVertex = shadowVertexList.newVertex();
		x = this.radius * Math.cos(angRad) * randomValue;
		y = this.radius * Math.sin(angRad) * randomValue;
		shadowVertex.setPosition(x, y, -semiDepth * 2);
		vertex.setPosition(x, y, semiDepth * 0.4);

		randomValue = 0.9 + 0.3 * Math.random();
		vertex.setColorRGB(randomValue, randomValue, randomValue);
		angRad += increAngRad;
	}

	// 4) Bottom major_ring.
	angRad = 0.0;
	vertexList = vtxMat.newVertexList();
	shadowVertexList = shadowVtxMat.newVertexList();
	for ( var i = 0; i < numPointsForRing; i++ ) 
	{
		randomValue = (2 + Math.random()) / 2;
		vertex = vertexList.newVertex();
		shadowVertex = shadowVertexList.newVertex();
		x = this.radius * Math.cos(angRad) * randomValue;
		y = this.radius * Math.sin(angRad) * randomValue;
		shadowVertex.setPosition(x, y, -semiDepth * 2);
		vertex.setPosition(x, y, -semiDepth * 0.4);
		randomValue = 0.8 + 0.3 * Math.random();
		vertex.setColorRGB(randomValue, randomValue, randomValue);
		angRad += increAngRad;
	}

	// 5) Bottom menor_ring.
	angRad = 0.0;
	menorRingRadius = this.radius * 0.7;
	vertexList = vtxMat.newVertexList();
	shadowVertexList = shadowVtxMat.newVertexList();
	for (var i = 0; i < numPointsForRing; i++ ) 
	{
		randomValue = (2 + Math.random()) / 2;
		vertex = vertexList.newVertex();
		shadowVertex = shadowVertexList.newVertex();
		x = menorRingRadius * Math.cos(angRad) * randomValue;
		y = menorRingRadius * Math.sin(angRad) * randomValue;
		vertex.setPosition(x, y, -semiDepth * 0.8);
		shadowVertex.setPosition(x, y, -semiDepth * 1.2);

		randomValue = 0.6 + 0.3 * Math.random();
		vertex.setColorRGB(randomValue, randomValue, randomValue);
		// vertex.setColorRGB(0.58, 0.58, 0.58);
		angRad += increAngRad;
	}

	// 6) Bottom ring. radius zero.
	vertexList = vtxMat.newVertexList();
	shadowVertexList = shadowVtxMat.newVertexList();
	randomValue = 0.6 + 0.3 * Math.random();
	for ( var i = 0; i < numPointsForRing; i++ ) 
	{
		// randomValue = (2+Math.random())/2;
		vertex = vertexList.newVertex();
		shadowVertex = shadowVertexList.newVertex();
		vertex.setPosition(0.0, 0.0, -semiDepth);
		shadowVertex.setPosition(0.0, 0.0, -semiDepth);

		vertex.setColorRGB(randomValue, randomValue, randomValue);
		// vertex.setColorRGB(0.58, 0.58, 0.58);
	}

	// Now, make the tTrianglesMatrix.
	vtxMat.makeTTrianglesLateralSidesLOOP(tTriMat);
	shadowVtxMat.makeTTrianglesLateralSidesLOOP(shadowTTriMat);
	// tTriMat.invertTrianglesSense(); // No.

	// Now, calculate the culling bbox.
};

'use strict';

/**
 * Bounding box
 * 영역박스
 * 
 * @alias BoundingBox
 * @class BoundingBox
 */
var BoundingBox = function() 
{
	if (!(this instanceof BoundingBox)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.minX = 1000000.0;
	this.minY = 1000000.0;
	this.minZ = 1000000.0;

	this.maxX = -1000000.0;
	this.maxY = -1000000.0;
	this.maxZ = -1000000.0;
};

/**
 * Initiate the value of the bounding box
 * @param {Point3D} point 3차원 점
 */
BoundingBox.prototype.init = function(point) 
{
	point = point || new Point3D();

	this.minX = point.x;
	this.minY = point.y;
	this.minZ = point.z;

	this.maxX = point.x;
	this.maxY = point.y;
	this.maxZ = point.z;
};

/**
 * Delete bounding box
 * 영역박스 삭제
 * 
 */
BoundingBox.prototype.deleteObjects = function() 
{
	this.minX = undefined;
	this.minY = undefined;
	this.minZ = undefined;

	this.maxX = undefined;
	this.maxY = undefined;
	this.maxZ = undefined;
};

/**
 *
 * Copy other box
 * @param bbox box
 */
BoundingBox.prototype.copyFrom = function(bbox) 
{
	this.minX = bbox.minX;
	this.minY = bbox.minY;
	this.minZ = bbox.minZ;

	this.maxX = bbox.maxX;
	this.maxY = bbox.maxY;
	this.maxZ = bbox.maxZ;
};

/**
 * Move the center of the box to the origin
 */
BoundingBox.prototype.translateToOrigin = function() 
{
	var semiXLength = this.getXLength() /2;
	var semiYLength = this.getYLength() /2;
	var semiZLength = this.getZLength() /2;
	
	this.minX = -semiXLength;
	this.minY = -semiYLength;
	this.minZ = -semiZLength;

	this.maxX = semiXLength;
	this.maxY = semiYLength;
	this.maxZ = semiZLength;
};

/**
 * Expane the size of the box as double of the given distance
 * 영역박스 확대
 * 
 * @param {Number} distance
 */
BoundingBox.prototype.expand = function(distance) 
{
	distance = distance || 0.0;
	distance = Math.abs(distance);

	this.minX -= distance;
	this.minY -= distance;
	this.minZ -= distance;

	this.maxX += distance;
	this.maxY += distance;
	this.maxZ += distance;
};

/**
 * 주어진 3차원 점을 포함하는 영역으로 영역박스 크기를 변경
 * 
 * @param {Point3D} point 3차원 점
 */
BoundingBox.prototype.addPoint = function(point) 
{
	if (point === undefined)	{ return; }

	if (point.x < this.minX) { this.minX = point.x; }
	else if (point.x > this.maxX) { this.maxX = point.x; }

	if (point.y < this.minY) { this.minY = point.y; }
	else if (point.y > this.maxY) { this.maxY = point.y; }

	if (point.z < this.minZ) { this.minZ = point.z; }
	else if (point.z > this.maxZ) { this.maxZ = point.z; }
};

/**
 * Set the range of the box which contain given box
 * 주어진 영역박스를 포함하는 영역으로 영역박스 크기를 변경
 * 
 * @param {BoundingBox} box 영역박스
 */
BoundingBox.prototype.addBox = function(box) 
{
	if (box === undefined)	{ return; }

	if (box.minX < this.minX) { this.minX = box.minX; }
	if (box.maxX > this.maxX) { this.maxX = box.maxX; }

	if (box.minY < this.minY) { this.minY = box.minY; }
	if (box.maxY > this.maxY) { this.maxY = box.maxY; }

	if (box.minZ < this.minZ) { this.minZ = box.minZ; }
	if (box.maxZ > this.maxZ) { this.maxZ = box.maxZ; }
};

/**
 * Get the minimum length among x, y, z edges' lengths
 * 영역박스의 가로, 세로, 높이 중에서 최소값
 * 
 * @returns {Number} 최소값
 */
BoundingBox.prototype.getMinLength = function() 
{
	return Math.min(this.maxX - this.minX, this.maxY - this.minY, this.maxZ - this.minZ);
};

/**
 * Get the maximum length among x, y, z edges' lengths
 * @returns {Number} 최대값
 */
BoundingBox.prototype.getMaxLength = function() 
{
	return Math.max(this.maxX - this.minX, this.maxY - this.minY, this.maxZ - this.minZ);
};

/**
 * Get the length of the edge which is parallel to x axis
 * 영역박스의 X축 방향의 길이
 * 
 * @returns {Number} 길이값
 */
BoundingBox.prototype.getXLength = function() 
{
	return this.maxX - this.minX;
};

/**
 * Get the length of the edge which is parallel to y axis
 * 영역박스의 Y축 방향의 길이
 * 
 * @returns {Number} 길이값
 */
BoundingBox.prototype.getYLength = function() 
{
	return this.maxY - this.minY;
};

/**
 * Get the length of the edge which is parallel to z axis
 * 영역박스의 Z축 방향의 길이
 * 
 * @returns {Number} 길이값
 */
BoundingBox.prototype.getZLength = function() 
{
	return this.maxZ - this.minZ;
};

/**
 * Get the center point of this box
 * 영역박스의 중심점을 구한다.
 * 
 * @param {Point3D} result 영역박스의 중심점
 * 
 * @returns {Point3D} 영역박스의 중심점
 */
BoundingBox.prototype.getCenterPoint = function(result) 
{
	if ( result === undefined ) { result = new Point3D(); }

	result.set((this.maxX + this.minX)/2, (this.maxY + this.minY)/2, (this.maxZ + this.minZ)/2);

	return result;
};

/**
 * 
 * 영역박스의 중심점을 구한다.
 * 
 * @returns {Number} apriximately radius.
 */
BoundingBox.prototype.getRadiusAprox = function() 
{
	var maxLength = this.getMaxLength();
	return maxLength/1.5;
};


/**
 * 영역박스와 점과의 교차 여부를 판단
 * 
 * @param {Point3D} point 3차원 점
 * @returns {Boolean} 교차 여부
 */
BoundingBox.prototype.intersectWithPoint = function(point) 
{
	if (point === undefined)	{ return false; }

	if (point.x < this.minX || point.x > this.maxX || 
		point.y < this.minY || point.y > this.maxY ||
		point.z < this.minZ || point.z > this.maxZ) 
	{
		return false;
	}

	//return this.isPoint3dInside(point.x, point.y, point.z);
	return true;
};

/**
 * Check whether the given point is contained or intersected with this box
 * 영역박스와 점과의 교차 여부를 판단
 * 
 * @param {Number} x x성분
 * @param {Number} y y성분
 * @param {Number} z z성분
 * @returns {Boolean} 교차 여부
 */
BoundingBox.prototype.isPoint3dInside = function(x, y, z) 
{
	if (x < this.minX || x > this.maxX) 
	{
		return false;
	}
	else if (y < this.minY || y > this.maxY) 
	{
		return false;
	}
	else if (z < this.minZ || z > this.maxZ) 
	{
		return false;
	}

	return true;
};

/**
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {BoundingBox} box 영역박스
 * @returns {Boolean} 교차 여부
 */
BoundingBox.prototype.intersectWithBox = function(box)
{
	if (box === undefined)	{ return false; }

	if (box.minX > this.maxX || box.maxX < this.minX ||
		box.minY > this.maxY || box.maxY < this.minY ||
		box.minZ > this.maxZ || box.maxZ < this.minZ)
	{
		return false;
	}

	return true;
};

/**
 * Check whether this box and the given box are intersected by each others.
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {BoundingBox} box Bounding box 영역박스
 * @returns {Boolean} the flag whether they are intersected or not 교차 여부 
 */
BoundingBox.prototype.intersectsWithBBox = function(box) 
{
	var intersection = true;

	if (this.maxX < box.minX)
	{
		intersection = false;
	}
	else if (this.minX > box.maxX)
	{
		intersection = false;
	}
	else if (this.maxY < box.minY)
	{
		intersection = false;
	}
	else if (this.minY > box.maxY)
	{
		intersection = false;
	}
	else if (this.maxZ < box.minZ)
	{
		intersection = false;
	}
	else if (this.minZ > box.maxZ)
	{
		intersection = false;
	}

	return intersection;
};

'use strict';

/**
 * This class is needed to be implemented at the future. not yet implemented fully.
 * @class BoundingSphere
 */
var BoundingSphere = function() 
{
	if (!(this instanceof BoundingSphere)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.center = new Point3D();
	this.radius = 0.0;
};
'use strict';

/**
 * This class is needed to be implemented more, but it will be used at the future.
 * @class Box
 */
var Box = function(width, length, height) 
{
	if (!(this instanceof Box)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.mesh;
	this.vbo_vicks_container;
	this.vbo_vicks_containerEdges;
	this.centerPoint;
	this.width;
	this.length;
	this.height;
	
	if (width !== undefined)
	{ this.width = width; }
	
	if (length !== undefined)
	{ this.length = length; }
	
	if (height !== undefined)
	{ this.height = height; }

};

/**
 * Get the VBO key container
 */
Box.prototype.getVboKeysContainer = function()
{
	return this.vbo_vicks_container;
};

/**
 * Render this box feature
 * @param {MagoManager} magoManager
 * @param {Shader} shader
 * @param {Number} renderType
 */
Box.prototype.render = function(magoManager, shader, renderType)
{
	if (this.mesh === undefined)
	{
		this.mesh = this.makeMesh(this.width, this.length, this.height);
		return;
	}

	this.mesh.render(magoManager, shader, renderType);
};

/**
 * Set the width,length, height of this feature
 * @param {Number} width
 * @param {Number} length
 * @param {Number} height 
 */
Box.prototype.makeMesh = function(width, length, height)
{
	// check dimensions of the box.
	if (width !== undefined)
	{ this.width = width; }
	
	if (length !== undefined)
	{ this.length = length; }
	
	if (height !== undefined)
	{ this.height = height; }
	
	if (this.width === undefined)
	{ this.width = 1; }
	
	if (this.length === undefined)
	{ this.length = 1; }
	
	if (this.height === undefined)
	{ this.height = 1; }
	
	if (this.centerPoint === undefined)
	{ this.centerPoint = new Point3D(0, 0, 0); }
	
	if (this.vbo_vicks_container === undefined)
	{ this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer(); }
	
	if (this.vbo_vicks_containerEdges === undefined)
	{ this.vbo_vicks_containerEdges = new VBOVertexIdxCacheKeysContainer(); }
	
	// Create a parametric mesh.
	var pMesh = new ParametricMesh();
		
	// Create a Profile2d.
	pMesh.profile = new Profile2D(); 
	var profileAux = pMesh.profile; 
	
	// Create a outer ring in the Profile2d.
	var outerRing = profileAux.newOuterRing();
	var rect = outerRing.newElement("RECTANGLE");
	rect.setCenterPosition(this.centerPoint.x, this.centerPoint.y);
	rect.setDimensions(this.width, this.length);
	
	// Extrude the Profile.
	var extrudeSegmentsCount = 1;
	var extrusionVector = undefined;
	pMesh.extrude(profileAux, this.height, extrudeSegmentsCount, extrusionVector);
	
	var bIncludeBottomCap = true;
	var bIncludeTopCap = true;
	var mesh = pMesh.getSurfaceIndependentMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	
	// translate the box bcos center the origen to the center of the box.
	mesh.translate(0, 0, -this.height/2);

	return mesh;
};





































'use strict';

/**
 * buildings seed.
 * Represent single building feature.
 * @class BuildingSeed
 */
var BuildingSeed = function() 
{
	if (!(this instanceof BuildingSeed)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.fisrtName;
	this.name = "";
	this.buildingId;
	this.buildingFileName;
	this.geographicCoord; // class : GeographicCoord.
	this.rotationsDegree; // class : Point3D. (heading, pitch, roll).
	this.bBox;            // class : BoundingBox.
	this.geographicCoordOfBBox; // class : GeographicCoord.
	this.smartTileOwner;
};

/**
 * clear this instance
 */
BuildingSeed.prototype.deleteObjects = function() 
{
	this.fisrtName = undefined;
	this.name = undefined;
	this.buildingId = undefined;
	this.buildingFileName = undefined;
	
	this.geographicCoord.deleteObjects(); 
	this.rotationsDegree.deleteObjects();
	this.bBox.deleteObjects();           
	this.geographicCoordOfBBox.deleteObjects(); 
	
	this.geographicCoord = undefined; 
	this.rotationsDegree = undefined;
	this.bBox = undefined;           
	this.geographicCoordOfBBox = undefined; 
};

/**
 * buildings seed list
 * @class BuildingSeedList
 */
var BuildingSeedList = function() 
{
	if (!(this instanceof BuildingSeedList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.buildingSeedArray = [];
	this.minGeographicCoord; // longitude, latitude, altitude.
	this.maxGeographicCoord; // longitude, latitude, altitude.
	
	this.dataArrayBuffer; // binary data.
};

/**
 * 어떤 일을 하고 있습니까?
 */
BuildingSeedList.prototype.deleteObjects = function() 
{
	this.minGeographicCoord.deleteObjects(); 
	this.maxGeographicCoord.deleteObjects(); 
	
	this.minGeographicCoord = undefined; 
	this.maxGeographicCoord = undefined;
	
	if (this.buildingSeedArray)
	{
		var buildingSeedsCount = this.buildingSeedArray.length;
		for (var i=0; i<buildingSeedsCount; i++)
		{
			this.buildingSeedArray[i].deleteObjects();
			this.buildingSeedArray[i] = undefined;
		}
		this.buildingSeedArray = undefined;
	}
	
	this.dataArrayBuffer = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 */
BuildingSeedList.prototype.newBuildingSeed = function() 
{
	var buildingSeed = new BuildingSeed();
	this.buildingSeedArray.push(buildingSeed);
	return buildingSeed;
};

/**
 * 어떤 일을 하고 있습니까?
 */
BuildingSeedList.prototype.parseBuildingSeedArrayBuffer = function() 
{
	if (this.dataArrayBuffer === undefined)
	{ return false; }
	
	var arrayBuffer = this.dataArrayBuffer;
	var bytesReaded = 0;
	var buildingNameLength;
	var longitude;
	var latitude;
	var altitude;

	var buildingsCount = new Int32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0];
	bytesReaded += 4;
	for (var i =0; i<buildingsCount; i++) 
	{
		var buildingSeed = this.newBuildingSeed();

		if (buildingSeed.geographicCoord === undefined)
		{ buildingSeed.geographicCoord = new GeographicCoord(); }

		if (buildingSeed.bBox === undefined) 
		{ buildingSeed.bBox = new BoundingBox(); }

		buildingNameLength = new Int32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0];
		bytesReaded += 4;
		var decoder = new TextDecoder('utf-8');
		var buildingName = decoder.decode(new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ buildingNameLength)));
		//var buildingName = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ buildingNameLength)));
		bytesReaded += buildingNameLength;

		// now the geographic coords, but this is provisional coords.
		longitude = new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8))[0]; bytesReaded += 8;
		latitude = new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8))[0]; bytesReaded += 8;
		altitude = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;

		buildingSeed.bBox.minX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.minY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.minZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.maxX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.maxY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.maxZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;

		// create a building and set the location.
		buildingSeed.buildingId = buildingName.substr(4, buildingNameLength-4);
		buildingSeed.buildingFileName = buildingName;
		buildingSeed.geographicCoord.setLonLatAlt(longitude, latitude, altitude);
	}
	
	return true;
};




























'use strict';

/**
 * buildings seed list
 * @class BuildingSeedList
 */
var BuildingSeedList = function() 
{
	if (!(this instanceof BuildingSeedList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.buildingSeedArray = [];
	this.minGeographicCoord; // longitude, latitude, altitude.
	this.maxGeographicCoord; // longitude, latitude, altitude.
	
	this.dataArrayBuffer; // binary data.
};

/**
 * Clear the list of BuildingSeed in this instance
 */
BuildingSeedList.prototype.deleteObjects = function() 
{
	this.minGeographicCoord.deleteObjects(); 
	this.maxGeographicCoord.deleteObjects(); 
	
	this.minGeographicCoord = undefined; 
	this.maxGeographicCoord = undefined;
	
	if (this.buildingSeedArray)
	{
		var buildingSeedsCount = this.buildingSeedArray.length;
		for (var i=0; i<buildingSeedsCount; i++)
		{
			this.buildingSeedArray[i].deleteObjects();
			this.buildingSeedArray[i] = undefined;
		}
		this.buildingSeedArray = undefined;
	}
	
	this.dataArrayBuffer = undefined;
};

/**
 * Create new buildingSeed feature
 * @returns {BuildingSeed}
 */
BuildingSeedList.prototype.newBuildingSeed = function() 
{
	var buildingSeed = new BuildingSeed();
	this.buildingSeedArray.push(buildingSeed);
	return buildingSeed;
};

/**
 * Parse the binary data sent from server to save the data as building seed 
 */
BuildingSeedList.prototype.parseBuildingSeedArrayBuffer = function() 
{
	if (this.dataArrayBuffer === undefined)
	{ return false; }
	
	var arrayBuffer = this.dataArrayBuffer;
	var bytesReaded = 0;
	var buildingNameLength;
	var longitude;
	var latitude;
	var altitude;

	var buildingsCount = new Int32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0];
	bytesReaded += 4;
	for (var i =0; i<buildingsCount; i++) 
	{
		var buildingSeed = this.newBuildingSeed();

		if (buildingSeed.geographicCoord === undefined)
		{ buildingSeed.geographicCoord = new GeographicCoord(); }

		if (buildingSeed.bBox === undefined) 
		{ buildingSeed.bBox = new BoundingBox(); }

		buildingNameLength = new Int32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0];
		bytesReaded += 4;
		var decoder = new TextDecoder('utf-8');
		var buildingName = decoder.decode(new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ buildingNameLength)));
		//var buildingName = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ buildingNameLength)));
		bytesReaded += buildingNameLength;

		// now the geographic coords, but this is provisional coords.
		longitude = new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8))[0]; bytesReaded += 8;
		latitude = new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8))[0]; bytesReaded += 8;
		altitude = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;

		buildingSeed.bBox.minX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.minY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.minZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.maxX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.maxY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.maxZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;

		// create a building and set the location.
		buildingSeed.buildingId = buildingName.substr(4, buildingNameLength-4);
		buildingSeed.buildingFileName = buildingName;
		buildingSeed.geographicCoord.setLonLatAlt(longitude, latitude, altitude);
	}
	
	return true;
};





'use strict';

/**
 * 카메라
 * @class Camera
 */
var Camera = function() 
{
	if (!(this instanceof Camera)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.position = new Point3D(); 
	this.direction = new Point3D(); 
	this.up = new Point3D();
	this.right = new Point3D();
	this.frustum = new Frustum(); // current frustum.
	this.bigFrustum = new Frustum(); // sum of all frustums.
	this.dirty = true;
	this.frustumsArray = [];
	this.frustumsArray.push(this.frustum);
	
	// frustum points.
	this.nearCenterPoint = new Point3D();
	this.farCenterPoint = new Point3D();
	
	this.farLeftBottomPoint = new Point3D();
	this.farRightTopPoint = new Point3D();
	
	// directions.
	this.leftBottomDir = new Point3D();
	this.rightTopDir = new Point3D();
	
	// normals.
	this.leftNormal = new Point3D();
	this.rightNormal = new Point3D();
	this.bottomNormal = new Point3D();
	this.topNormal = new Point3D();
	this.tracked;
};

/**
 * Copy the position and the direction and up point of the other camera
 * @param {Camera} camera
 */
Camera.prototype.copyPosDirUpFrom = function(camera)
{
	this.position.copyFrom(camera.position);
	this.direction.copyFrom(camera.direction);
	this.up.copyFrom(camera.up);
};

/**
 * 
 * Translate this camera with translation vector
 * @param translationVec
 */
Camera.prototype.translate = function(translationVec)
{
	this.position.add(translationVec.x, translationVec.y, translationVec.z);
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.transformByMatrix4 = function(mat)
{
	// transform position, direction and up.
	/*
	this.position = this.transformPoint3DByMatrix4(this.position, mat);
	
	if (this.rotMat === undefined)
	{ this.rotMat = mat3.create(); }
	
	this.rotMat = mat3.fromMat4(this.rotMat, mat);

	this.direction = this.rotatePoint3DByMatrix3(this.direction, this.rotMat);
	this.up = this.rotatePoint3DByMatrix3(this.up, this.rotMat);
	*/
	// Calculate with our matrix4.
	this.position = mat.transformPoint3D(this.position, this.position);
	this.direction = mat.rotatePoint3D(this.direction, this.direction);
	this.up = mat.rotatePoint3D(this.up, this.up);
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.getCameraDirectionLine = function(resultLine)
{
	if (resultLine === undefined)
	{ resultLine = new Line(); }
	
	resultLine.point.set(this.position.x, this.position.y, this.position.z);
	resultLine.direction.set(this.direction.x, this.direction.y, this.direction.z);
	
	return resultLine;
};

/**
 * determine camHeight
 * @class Camera
 */
Camera.prototype.getCameraElevation = function()
{
	var geographicCoords;
	geographicCoords = Globe.CartesianToGeographicWgs84(this.position.x, this.position.y, this.position.z, geographicCoords);
	var latDeg = geographicCoords.latitude;
	var camModul = this.position.getModul();
	var radius = Globe.radiusAtLatitudeDeg(latDeg);
	return  camModul - radius;
};

/**
 * Get the right(up)
 * @class Camera
 */
Camera.prototype.getCameraRight = function()
{
	if (this.right === undefined)
	{ this.right = new Point3D(); }
	
	this.right = this.direction.crossProduct(this.up, this.right);
	return this.right;
};

/**
 * Transforms the vector "point" by given matrix4
 * @param point
 * @param {Mat4} mat
 * @returns {Vec3} 
 */
Camera.prototype.transformPoint3DByMatrix4 = function(point, mat)
{
	var pos = glMatrix.vec3.clone([point.x, point.y, point.z]);
	var tPos = glMatrix.vec3.create();
	tPos = glMatrix.vec3.transformMat4(tPos, pos, mat);
	point.set(tPos[0], tPos[1], tPos[2]);
	
	return point;
};

/**
 * Transforms the vector "point" by given matrix4
 * @param point
 * @param {Mat3} mat
 * @returns {Vec3} 
 */
Camera.prototype.rotatePoint3DByMatrix3 = function(point, mat)
{
	var pos = glMatrix.vec3.clone([point.x, point.y, point.z]);
	var tPos = glMatrix.vec3.create();
	tPos = glMatrix.vec3.transformMat3(tPos, pos, mat);
	point.set(tPos[0], tPos[1], tPos[2]);
	
	return point;
};

/**
 * set dirty flag of the object
 * -dirty flag : Avoid unnecessary work by deferring it until the result is needed.
 * @class Camera
 */
Camera.prototype.setDirty = function(cameraIsDirty)
{
	this.dirty = cameraIsDirty;
};

/**
 * get dirty flag of the object
 * @class Camera
 */
Camera.prototype.getDirty = function()
{
	return this.dirty;
};

/**
 * Check whether this camera is moved or not
 * @param {Number} newPosX
 * @param {Number} newPosY
 * @param {Number} newPosZ
 * @param {Number} newDirX
 * @param {Number} newDirY
 * @param {Number} newDirZ
 * @param {Number} newUpX
 * @param {Number} newUpY
 * @param {Number} newUpZ
 * @returns {Boolean} 
 * 
 */
Camera.prototype.isCameraMoved = function(newPosX, newPosY, newPosZ, newDirX, newDirY, newDirZ, newUpX, newUpY, newUpZ )
{
	if (this.position.x === newPosX && this.position.y === newPosY && this.position.z === newPosZ && 
		this.direction.x === newDirX && this.direction.y === newDirY && this.direction.z === newDirZ && 
		this.up.x === newUpX && this.up.y === newUpY && this.up.z === newUpZ)
	{ return false; }
	else
	{ return true; }
};

/**
 * get the small Frustum in big frustum
 * @class Camera
 */
Camera.prototype.getFrustum = function(idx)
{
	if (this.frustumsArray[idx] === undefined)
	{
		this.frustumsArray[idx] = new Frustum();
		this.frustumsArray[idx].fovRad[0] = this.frustumsArray[0].fovRad[0];
		this.frustumsArray[idx].fovyRad[0]= this.frustumsArray[0].fovyRad[0];
		this.frustumsArray[idx].aspectRatio[0] = this.frustumsArray[0].aspectRatio[0];
		this.frustumsArray[idx].tangentOfHalfFovy[0] = this.frustumsArray[0].tangentOfHalfFovy[0];
	}
	
	return this.frustumsArray[idx];
};

/**
 * Get the lastest frustum of this camera
 */
Camera.prototype.getLastFrustum = function()
{
	return this.getFrustum(this.frustumsArray.length - 1);
};

/**
 * The list of the distance between the divided frustum of visualization volume using each small frustum's near and far
 */
Camera.prototype.setFrustumsDistances = function(numFrustums, distancesArray)
{
	var nearFarDistances;
	var frustum;
	for (var i=0; i<numFrustums; i++)
	{
		nearFarDistances = distancesArray[i];
		frustum = this.getFrustum(i);
		frustum.near[0] = distancesArray[i*2];
		frustum.far[0] = distancesArray[i*2+1];
		if (i === 0)
		{
			this.bigFrustum.near[0] = distancesArray[i*2];
		}
		if (i === numFrustums - 1)
		{
			this.bigFrustum.far[0] = distancesArray[i*2+1];
		}
	}
};

/**
 * 
 * Calculate the value of fovyRad and aspectRatio of each small frustum
 * @param aspectRatio aspect ratio
 * @param fovyRad the radian of FOV(Field Of View) y
 * @class Camera
 */
Camera.prototype.setAspectRatioAndFovyRad = function(aspectRatio, fovyRad)
{
	var frustum, frustum0;
	
	frustum0 = this.getFrustum(0);
	frustum0.aspectRatio[0] = aspectRatio;
	frustum0.fovyRad[0] = fovyRad; 
	frustum0.fovRad[0] = fovyRad*aspectRatio;
	frustum0.tangentOfHalfFovy[0] = Math.tan(fovyRad/2);
		
	var frustumsCount = this.frustumsArray.length;
	for (var i=1; i<frustumsCount; i++)
	{
		frustum = this.getFrustum(i);
		frustum.aspectRatio[0] = frustum0.aspectRatio[0];
		frustum.fovyRad[0] = frustum0.fovyRad[0]; 
		frustum.fovRad[0] = frustum0.fovRad[0];
		frustum.tangentOfHalfFovy[0] = frustum0.tangentOfHalfFovy[0];
	}
	
	this.bigFrustum.aspectRatio[0] = frustum0.aspectRatio[0];
	this.bigFrustum.fovyRad[0] = frustum0.fovyRad[0]; 
	this.bigFrustum.fovRad[0] = frustum0.fovRad[0];
	this.bigFrustum.tangentOfHalfFovy[0] = frustum0.tangentOfHalfFovy[0];
};

/**
 * Set the current frustum in bigFrustum
 * @class Camera
 */
Camera.prototype.setCurrentFrustum = function(frustumIdx)
{
	this.frustum = this.getFrustum(frustumIdx);
};

/**
 */
Camera.prototype.bindCameraUniforms = function(gl, shader) 
{
	// Bind frustum near & far.
	var frustum = this.frustum;
	gl.uniform1f(shader.frustumNear_loc, frustum.near[0]);
	gl.uniform1f(shader.frustumFar_loc, frustum.far[0]);
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.calculateFrustumsPlanes = function()
{
	var plane;
	var frustum0; // the 1rst frustum.
	
	// Use the frustum0 to calculate nearWidth, nearHeight, farWidth & farHeight.
	frustum0 = this.getFrustum(0);
	var nearHeight = frustum0.tangentOfHalfFovy * frustum0.near * 2;
	var farHeight = frustum0.tangentOfHalfFovy * frustum0.far * 2;
	var nearWidth = nearHeight * frustum0.aspectRatio;
	var farWidht = farHeight * frustum0.aspectRatio;
	
	var px = this.position.x;
	var py = this.position.y;
	var pz = this.position.z;

	var dx = this.direction.x;
	var dy = this.direction.y;
	var dz = this.direction.z;
	
	// calculate right direction. "up" and "direction" must be unitaries.
	this.right = this.direction.crossProduct(this.up, this.right);
	
	// calculate the near and far points.
	this.nearCenterPoint.set(px + dx * frustum0.near, py + dy * frustum0.near, pz + dz * frustum0.near);
	this.farCenterPoint.set(px + dx * frustum0.far, py + dy * frustum0.far, pz + dz * frustum0.far);
	
	// far plane points.
	this.farLeftBottomPoint.set(this.farCenterPoint.x - this.right.x*farWidht*0.5 - this.up.x*farHeight*0.5, 
		this.farCenterPoint.y - this.right.y*farWidht*0.5 - this.up.y*farHeight*0.5, 
		this.farCenterPoint.z - this.right.z*farWidht*0.5 - this.up.z*farHeight*0.5);
								
	this.farRightTopPoint.set(this.farLeftBottomPoint.x + this.right.x*farWidht + this.up.x*farHeight, 
		this.farLeftBottomPoint.y + this.right.y*farWidht + this.up.y*farHeight, 
		this.farLeftBottomPoint.z + this.right.z*farWidht + this.up.z*farHeight);				
	
	// calculate directions.
	this.leftBottomDir.set(this.farLeftBottomPoint.x - px, this.farLeftBottomPoint.y - py, this.farLeftBottomPoint.z - pz);
	this.leftBottomDir.unitary(); // no necessary.
	
	this.rightTopDir.set(this.farRightTopPoint.x - px, this.farRightTopPoint.y - py, this.farRightTopPoint.z - pz);
	this.rightTopDir.unitary(); // no necessary.
	
	// near plane.
	plane = frustum0.planesArray[0];
	plane.setPointAndNormal(this.nearCenterPoint.x, this.nearCenterPoint.y, this.nearCenterPoint.z, dx, dy, dz);
							
	// far plane.
	plane = frustum0.planesArray[1];
	plane.setPointAndNormal(this.farCenterPoint.x, this.farCenterPoint.y, this.farCenterPoint.z, -dx, -dy, -dz);

	// The 4 lateral planes are the same for all frustum0s.
	// left plane.
	this.leftNormal = this.leftBottomDir.crossProduct(this.up, this.leftNormal);
	this.leftNormal.unitary();
	plane = frustum0.planesArray[2];
	plane.setPointAndNormal(px, py, pz, this.leftNormal.x, this.leftNormal.y, this.leftNormal.z);
							
	// bottom plane.
	this.bottomNormal = this.right.crossProduct(this.leftBottomDir, this.bottomNormal);
	this.bottomNormal.unitary();
	plane = frustum0.planesArray[3];
	plane.setPointAndNormal(px, py, pz, this.bottomNormal.x, this.bottomNormal.y, this.bottomNormal.z);
							
	// right plane.
	this.rightNormal = this.up.crossProduct(this.rightTopDir, this.rightNormal);
	this.rightNormal.unitary();
	plane = frustum0.planesArray[4];
	plane.setPointAndNormal(px, py, pz, this.rightNormal.x, this.rightNormal.y, this.rightNormal.z);
	
	// top plane.
	this.topNormal = this.rightTopDir.crossProduct(this.right, this.topNormal);
	this.topNormal.unitary();
	plane = frustum0.planesArray[5];
	plane.setPointAndNormal(px, py, pz, this.topNormal.x, this.topNormal.y, this.topNormal.z);
	
	// once finished, calculate the rest of frustums.
	var frustum;
	var frustumsCount = this.frustumsArray.length;
	for (var i=1; i<frustumsCount; i++)
	{
		frustum = this.getFrustum(i);
		
		// calculate the near and far points.
		this.nearCenterPoint.set(px + dx * frustum.near, py + dy * frustum.near, pz + dz * frustum.near);
		this.farCenterPoint.set(px + dx * frustum.far, py + dy * frustum.far, pz + dz * frustum.far);
		
		// near plane.
		plane = frustum.planesArray[0];
		plane.setPointAndNormal(this.nearCenterPoint.x, this.nearCenterPoint.y, this.nearCenterPoint.z, dx, dy, dz);
								
		// far plane.
		plane = frustum.planesArray[1];
		plane.setPointAndNormal(this.farCenterPoint.x, this.farCenterPoint.y, this.farCenterPoint.z, -dx, -dy, -dz);
		
		// the lateral planes.
		for (var j=2; j<6; j++)
		{
			frustum.planesArray[j] = frustum0.planesArray[j];
		}
	}
	
	// finally calculate the totalFrustum(BigFrustum).
	// calculate the near and far points.
	this.nearCenterPoint.set(px + dx * this.bigFrustum.near, py + dy * this.bigFrustum.near, pz + dz * this.bigFrustum.near);
	this.farCenterPoint.set(px + dx * this.bigFrustum.far, py + dy * this.bigFrustum.far, pz + dz * this.bigFrustum.far);
	
	// near plane.
	plane = this.bigFrustum.planesArray[0];
	plane.setPointAndNormal(this.nearCenterPoint.x, this.nearCenterPoint.y, this.nearCenterPoint.z, dx, dy, dz);
							
	// far plane.
	plane = this.bigFrustum.planesArray[1];
	plane.setPointAndNormal(this.farCenterPoint.x, this.farCenterPoint.y, this.farCenterPoint.z, -dx, -dy, -dz);
		
	var lastFrustum = this.getLastFrustum();
	for (var j=2; j<6; j++) // starting in i==2.
	{
		// the bigFrustum is esqual to frustum0 except in the "far".
		this.bigFrustum.planesArray[j] = frustum0.planesArray[j];
	}
};

/**
 * if track node exist, do track.
 * @param {Object} magoManager
 */
Camera.prototype.doTrack = function(magoManager)
{
	if (this.tracked)
	{
		// Set camera position.*
		var trackNode = this.tracked;
		if (MagoConfig.getPolicy().geo_view_library === Constant.CESIUM)
		{
			var camera = magoManager.scene.camera;
			var position = camera.positionWC;
			var movedCamPos;

			var geoLocDatamanager = trackNode.getNodeGeoLocDataManager();
			//var geoLocationData = geoLocDatamanager.getTrackGeoLocationData();
			if (geoLocDatamanager === undefined)
			{ return; }
			
			var geoLocationData = geoLocDatamanager.getCurrentGeoLocationData();
			if (geoLocationData === undefined)
			{ return; }

			var prevGeoLocationData = geoLocDatamanager.getGeoLocationData(1);
			if (defined(prevGeoLocationData))
			{
				var currentPos = geoLocationData.position;
				var prevPos =  prevGeoLocationData.position;

				var dx = currentPos.x - prevPos.x;
				var dy = currentPos.y - prevPos.y;
				var dz  = currentPos.z - prevPos.z;
				movedCamPos = new Cesium.Cartesian3();
				movedCamPos.x = position.x + dx;
				movedCamPos.y = position.y + dy;
				movedCamPos.z = position.z + dz;
			}
			var targetGeographicCoords = geoLocationData.getGeographicCoords();
			if (targetGeographicCoords === undefined)
			{ return; }
			var target = Cesium.Cartesian3.fromDegrees(targetGeographicCoords.longitude, targetGeographicCoords.latitude, targetGeographicCoords.altitude);
			var range = Cesium.Cartesian3.distance(movedCamPos ? movedCamPos : position, target);
			var hpr = new Cesium.HeadingPitchRange(camera.heading, camera.pitch, range);

			camera.lookAt(target, hpr); //How To lookAt off : use camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
			
			/*var sphere = new Sphere();
			var radiusAprox_aux = trackNode.data.bbox.getRadiusAprox();
			sphere.radius = radiusAprox_aux;
			sphere.center = target;

			camera.viewBoundingSphere(sphere, hpr);*/
		}
		else
		{
			//this.lookAt() -> we must develope lookAt function in magoworld.
		}
	}
};

/**
 * stop track 
 * @param {Object} magoManager
 */
Camera.prototype.stopTrack = function(magoManager)
{
	this.tracked = undefined;
	if (MagoConfig.getPolicy().geo_view_library === Constant.CESIUM)
	{
		magoManager.scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY); //set camera transform
	}
	else
	{
		//this.lookAtStop() -> we must develope lookAtStop function in magoworld.
	}
};

/**
 * set track node.
 * Node is a single feature at F4D specification
 * Implement this function for tracking moving objects such as automatically moving vehicle
 * @param {Object} node
 */
Camera.prototype.setTrack = function(node)
{
	this.tracked = node;
};
'use strict';

/**
 * 카메라
 * @class CCTV
 */
var CCTV = function(name) 
{
	if (!(this instanceof CCTV)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.name = "noName";
	if (name !== undefined)
	{ this.name = name; }

	this.geoLocationData = new GeoLocationData();
	this.minHeading = 0.0;
	this.maxHeading = 90.0;
	
	this.heading = 0.0;
	this.pitch = 0.0;
	this.roll = 0.0;
	this.targetHeading;
	this.targetPitch;
	this.targetRoll;
	
	this.rotMat = new Matrix4();
	this.camera = new Camera();
	this.vboKeyContainer; // class: VBOVertexIdxCacheKeyContainer.
	this.vboKeyContainerEdges; // class: VBOVertexIdxCacheKeyContainer.
	this.color = new Color();
	this.color.setRGBA(0.0, 0.5, 0.9, 0.3);
	this.greenFactorSpeed = 1.0;
	this.blueFactorSpeed = 2.0;
	this.alphaFactorSpeed = 2.0;
	
	this.headingAngularSpeed = 25.0; // deg per second.
	this.pitchAngularSpeed;
	this.rollAngularSpeed; 
	this.lastTime;
	
	this.greenFactor = 1.0;
	this.blueFactor = 1.0;
	this.alphaFactor = 1.0;
};

/**
 * Update time as current time
 * @param currTime current time
 */
CCTV.prototype.updateTime = function(currTime)
{
	this.lastTime = currTime;
};

/**
 * Calculate the angularSpped to rotate the CCTV with the three direction : heading, pitch, roll
 * @param headingDeg
 * @param pitchDeg
 * @param rollDeg
 * @param transitionTimeSec
 * 
 */
CCTV.prototype.setOrientation = function(headingDeg, pitchDeg, rollDeg, transitionTimeSec)
{
	this.targetHeading = headingDeg;
	this.targetPitch = pitchDeg;
	this.targetRoll = rollDeg;
	
	// Now, calculate angularSpeeds.
	// Heading.
	if (this.targetHeading !== undefined)
	{
		var increHeading = this.targetHeading - this.heading;
		this.headingAngularSpeed = increHeading/transitionTimeSec;
		
		if (this.headingAngularSpeed === 0)
		{
			this.targetHeading = undefined;
			this.headingAngularSpeed = undefined;
		}
	}
	
	// Pitch.
	if (this.targetPitch !== undefined)
	{
		var increPitch = this.targetPitch - this.pitch;
		this.pitchAngularSpeed = increPitch/transitionTimeSec;
		
		if (this.pitchAngularSpeed === 0)
		{
			this.targetPitch = undefined;
			this.pitchAngularSpeed = undefined;
		}
	}
	
	// Roll.
	if (this.targetRoll !== undefined)
	{
		var increRoll = this.targetRoll - this.roll;
		this.rollAngularSpeed = increRoll/transitionTimeSec;
		
		if (this.rollAngularSpeed === 0)
		{
			this.targetRoll = undefined;
			this.rollAngularSpeed = undefined;
		}
	}
};

/**
 * Rotate the CCTV with current time and pre-calculated angular speed
 * @param currTime current time 
 */
CCTV.prototype.updateOrientation = function(currTime)
{
	// Check if camera is rotating.
	if (this.targetHeading === undefined && this.targetPitch === undefined && this.targetRoll === undefined)
	{ return; }
	
	if (this.lastTime === undefined)
	{ this.lastTime = currTime; }

	var timeAmount = (currTime - this.lastTime)/1000;
	
	// Heading.
	if (this.headingAngularSpeed !== undefined)
	{
		this.heading += timeAmount * this.headingAngularSpeed;
		// Check if heading arrived to targetHeading.
		if (this.headingAngularSpeed > 0)
		{
			// Camera is rotating ccw.
			if (this.heading >= this.targetHeading)
			{
				this.heading = this.targetHeading;
				this.targetHeading = undefined;
			}
		}
		else 
		{
			// Camera is rotating cw.
			if (this.heading <= this.targetHeading)
			{
				this.heading = this.targetHeading;
				this.targetHeading = undefined;
			}
		}
		
		if (this.headingAngularSpeed === 0)
		{
			this.targetHeading = undefined;
			this.headingAngularSpeed = undefined;
		}
	}
	
	// Pitch.
	if (this.pitchAngularSpeed !== undefined)
	{
		this.pitch += timeAmount * this.pitchAngularSpeed;
		
		// Check if pitch arrived to targetPitch.
		if (this.pitchAngularSpeed > 0)
		{
			// Camera is rotating ccw.
			if (this.pitch >= this.targetPitch)
			{
				this.pitch = this.targetPitch;
				this.targetPitch = undefined;
			}
		}
		else
		{
			// Camera is rotating cw.
			if (this.pitch <= this.targetPitch)
			{
				this.pitch = this.targetPitch;
				this.targetPitch = undefined;
			}
		}
		
		if (this.pitchAngularSpeed === 0)
		{
			this.targetPitch = undefined;
			this.pitchAngularSpeed = 0;
		}
	}
	
	// Roll.
	if (this.rollAngularSpeed !== undefined)
	{
		this.roll += timeAmount * this.rollAngularSpeed;
		// Check if pitch arrived to targetPitch.
		if (this.rollAngularSpeed > 0)
		{
			// Camera is rotating ccw.
			if (this.roll >= this.targetRoll)
			{
				this.roll = this.targetRoll;
				this.targetRoll = undefined;
			}
		}
		else 
		{
			// Camera is rotating cw.
			if (this.roll <= this.targetRoll)
			{
				this.roll = this.targetRoll;
				this.targetRoll = undefined;
			}
		}
		
		if (this.rollAngularSpeed === 0)
		{
			this.targetRoll = undefined;
			this.rollAngularSpeed = undefined;
		}
	}
	
	this.calculateRotationMatrix();
};

/**
 * only rotating with the heading direction
 * @param currTime current time
 */
CCTV.prototype.updateHeading = function(currTime)
{
	// Old function.
	if (this.lastTime === undefined)
	{ this.lastTime = currTime; }

	var timeAmount = (currTime - this.lastTime)/1000;
	this.heading += timeAmount * this.headingAngularSpeed;
	
	if (this.heading > this.maxHeading)
	{
		this.heading = this.maxHeading;
		this.headingAngularSpeed *= -1.0;
	}
	else if (this.heading < this.minHeading)
	{
		this.heading = this.minHeading;
		this.headingAngularSpeed *= -1.0;
	}
	
	this.calculateRotationMatrix();
};

/**
 * Update the color of the screen shown at the CCTV
 * @param currTime
 */
CCTV.prototype.updateColor = function(currTime)
{
	if (this.lastTime === undefined)
	{ this.lastTime = currTime; }

	var timeAmount = (currTime - this.lastTime)/1000;
	
	// change color.
	if (this.greenFactor === undefined)
	{ this.greenFactor = 1.0; }
	
	if (this.blueFactor === undefined)
	{ this.blueFactor = 1.0; }
	
	if (this.alphaFactor === undefined)
	{ this.alphaFactor = 1.0; }
	
	this.greenFactor += this.greenFactorSpeed * timeAmount;
	this.blueFactor += this.blueFactorSpeed * timeAmount;
	
	if (this.greenFactor > 0.5 )
	{
		this.greenFactor = 0.5;
		this.greenFactorSpeed *= -1;
	}
	
	if (this.greenFactor < 0.0 )
	{
		this.greenFactor = 0.0;
		this.greenFactorSpeed *= -1;
	}
	
	if (this.blueFactor > 0.9 )
	{
		this.blueFactor = 0.9;
		this.blueFactorSpeed *= -1;
	}
	
	if (this.blueFactor < 0.0 )
	{
		this.blueFactor = 0.0;
		this.blueFactorSpeed *= -1;
	}
	
	
	if (this.alphaFactor > 0.6 )
	{
		this.alphaFactor = 0.6;
		this.alphaFactorSpeed *= -1;
	}
	
	if (this.alphaFactor < 0.0 )
	{
		this.alphaFactor = 0.0;
		this.alphaFactorSpeed *= -1;
	}
	
	this.color.setRGBA(0.0, this.greenFactor, this.blueFactor, this.alphaFactor);
};

/**
 * Calculate the matrix when update the orientation of the matrix
 */
CCTV.prototype.calculateRotationMatrix = function()
{
	var rotMatAux;
	rotMatAux = Matrix4.getRotationDegZXYMatrix(this.heading, this.pitch, this.roll, rotMatAux);
	this.rotMat = rotMatAux.getMultipliedByMatrix(this.geoLocationData.rotMatrix, this.rotMat);
};

/**
 * get the Vbo of the mesh which consist of the frustum of this CCTV
 * @param resultVboContainer
 * @param resultVboContainerEdges
 * @param vboMemManager
 */
CCTV.prototype.getVbo = function(resultVboContainer, resultVboContainerEdges, vboMemManager)
{
	if (resultVboContainer === undefined)
	{ resultVboContainer = new VBOVertexIdxCacheKeysContainer(); }

	if (this.vboKeyContainerEdges === undefined)
	{ this.vboKeyContainerEdges = new VBOVertexIdxCacheKeysContainer(); }

	var frustumMesh;
	
	// make vbo.
	frustumMesh = this.makeFrustumGeometry_2(frustumMesh);
	var bIncludeBottomCap = true;
	var bIncludeTopCap = true;
	
	// now rotate in X axis.
	var rotMatAux = new Matrix4();
	var frustum = this.camera.bigFrustum;
	var halfFovyRad = frustum.fovyRad / 2.0;
	rotMatAux.rotationAxisAngDeg((-halfFovyRad) * 180.0 / Math.PI, 1.0, 0.0, 0.0);
	
	var surfIndepMesh = frustumMesh.getSurfaceIndependentMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	surfIndepMesh.transformByMatrix4(rotMatAux);
	surfIndepMesh.setColor(0.0, 0.5, 0.9, 0.3);
	
	surfIndepMesh.getVbo(resultVboContainer, vboMemManager);
	surfIndepMesh.getVboEdges(this.vboKeyContainerEdges, vboMemManager);
	
	return resultVboContainer;
};

/**
 * 
 */
CCTV.prototype.render = function(gl, magoManager, shader)
{
	if (this.vboKeyContainer === undefined)
	{ return; }
	
	var cacheKeys_count = this.vboKeyContainer.vboCacheKeysArray.length;
	
	//gl.uniform1i(shader.bApplySpecularLighting_loc, false);
	
	// Must applicate the transformMatrix.
	gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, this.geoLocationData.rotMatrix._floatArrays);
	gl.uniform3fv(shader.buildingPosHIGH_loc, this.geoLocationData.positionHIGH);
	gl.uniform3fv(shader.buildingPosLOW_loc, this.geoLocationData.positionLOW);
	
	gl.uniform1i(shader.hasTexture_loc, false); //.
	
	gl.enable(gl.POLYGON_OFFSET_FILL);
	gl.polygonOffset(1, 3);
	
	var renderWireframe;
	
	var refMatrixType = 2;
	gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
	gl.uniformMatrix4fv(shader.refMatrix_loc, false, this.rotMat._floatArrays);
	
	var renderer = magoManager.renderer;
	
	// render wireframe.
	renderWireframe = true;
	renderer.renderNormals = false;
	gl.uniform4fv(shader.oneColor4_loc, [0.0, 0.0, 0.0, 1.0]);
	renderer.renderVboContainer(gl, this.vboKeyContainerEdges, magoManager, shader, renderWireframe);
	
	// now render fill.
	gl.enable(gl.BLEND);
	renderWireframe = false;
	renderer.renderNormals = true;
	//gl.uniform4fv(shader.oneColor4_loc, [this.blueFactor, this.greenFactor, 0.0, this.alphaFactor]);
	gl.uniform4fv(shader.oneColor4_loc, [this.blueFactor, 0.0, 0.0, this.alphaFactor]);
	renderer.renderVboContainer(gl, this.vboKeyContainer, magoManager, shader, renderWireframe);
	gl.disable(gl.BLEND);
	
	gl.disable(gl.POLYGON_OFFSET_FILL);
};

/**
 * Make Frustum Geometry for this CCTV
 * @param resultMesh the frustum
 */
CCTV.prototype.makeFrustumGeometry_2 = function(resultMesh)
{
	// 1rst, make the profile: icecream shape.
	if (resultMesh === undefined)
	{ resultMesh = new ParametricMesh(); }

	resultMesh.profile = new Profile2D(); 
	var profileAux = resultMesh.profile; 
	
	// camera geometry values.
	var frustum = this.camera.bigFrustum;
	var far = frustum.far;
	var halfFovyRad = frustum.fovyRad / 2.0;
	var halfFovxRad = frustum.fovRad / 2.0;
	
	var left = -far * Math.tan(halfFovxRad);
	var right = -left;
	var top = far * Math.tan(halfFovyRad);
	var bottom = -top;
	
	// Outer ring.**
	var outerRing = profileAux.newOuterRing();
	var polyLine, point3d, arc;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-far * Math.sin(halfFovxRad), far * Math.cos(halfFovxRad)); // 0
	point3d = polyLine.newPoint2d(0.0, 0.0); // 1
	point3d = polyLine.newPoint2d(far * Math.sin(halfFovxRad), far * Math.cos(halfFovxRad)); // 2
	
	var startAngDeg = 90.0 - halfFovxRad * 180.0 / Math.PI;
	var endAngDeg = 90.0 + halfFovxRad * 180.0 / Math.PI;
	arc = outerRing.newElement("ARC");
	this.sweepSense = 1;
	arc.setCenterPosition(0.0, 0.0);
	arc.setRadius(far);
	////arc.setStartPoint(far * Math.sin(halfFovxRad), far * Math.cos(halfFovxRad));
	////arc.setEndPoint(-far * Math.sin(halfFovxRad), far * Math.cos(halfFovxRad));
	arc.setStartAngleDegree(startAngDeg);
	arc.setSweepAngleDegree(endAngDeg - startAngDeg);
	arc.numPointsFor360Deg = 36;
	
	// now revolve.
	var revolveAngDeg, revolveSegmentsCount, revolveSegment2d;
	revolveAngDeg = (halfFovyRad * 2) * 180.0 / Math.PI;
	revolveSegment2d = new Segment2D();
	var strPoint2d = new Point2D(-1, 0);
	var endPoint2d = new Point2D(1, 0);
	revolveSegment2d.setPoints(strPoint2d, endPoint2d);
	revolveSegmentsCount = 6;
	resultMesh.revolve(profileAux, revolveAngDeg, revolveSegmentsCount, revolveSegment2d);
	
	return resultMesh;
};

/**
 * Make Frustum Geometry for this CCTV
 * @param resultMesh the frustum
 */
CCTV.prototype.makeFrustumGeometry = function(resultMesh)
{
	// make a frustum mesh.
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }

	if (resultMesh.hedgesList === undefined)
	{ resultMesh.hedgesList = new HalfEdgesList(); }
	
	// 1rst, calculate the positions of 5 vertices.
	var focusPosition = new Point3D(0.0, 0.0, 0.0);
	
	var frustum = this.camera.bigFrustum;
	var far = frustum.far;
	var halfFovyRad = frustum.fovyRad / 2.0;
	var halfFovxRad = frustum.fovRad / 2.0;
	
	var left = -far * Math.tan(halfFovxRad);
	var right = -left;
	var top = far * Math.tan(halfFovyRad);
	var bottom = -top;
	
	var farLeftDown = new Point3D(left, bottom, -far);
	var farRightDown = new Point3D(right, bottom, -far);
	var farRightTop = new Point3D(right, top, -far);
	var farLeftTop = new Point3D(left, top, -far);
	
	// now make vertices. 5 vertices in total.
	var focusVertex = new Vertex(focusPosition);
	var farLeftDownVertex = new Vertex(farLeftDown);
	var farRightDownVertex = new Vertex(farRightDown);
	var farRightTopVertex = new Vertex(farRightTop);
	var farLeftTopVertex = new Vertex(farLeftTop);
	
	// provisionally make wireframe here.
	if (this.vboKeyContainerEdges === undefined)
	{ this.vboKeyContainerEdges = new VBOVertexIdxCacheKeysContainer(); }

	var face;
	
	// there are no near polygon.
	// 1- far polygon.
	var farSurface = resultMesh.newSurface();
	face = farSurface.newFace();
	// ad vertices in ccw order.
	face.addVertex(farLeftDownVertex);
	face.addVertex(farLeftTopVertex);
	face.addVertex(farRightTopVertex);
	face.addVertex(farRightDownVertex);
	
	// make wireframe vbo.
	var vertex_1, vertex_2, pos_1, pos_2;
	var next_idx;
	var curr_edge_idx = 0;
	var posDataArray = [];
	var indicesDataArray = [];
	
	var vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	
	// 2- top polygon.
	var topSurface = resultMesh.newSurface();
	face = topSurface.newFace();
	// ad vertices in ccw order.
	face.addVertex(focusVertex);
	face.addVertex(farRightTopVertex);
	face.addVertex(farLeftTopVertex);
	
	// make wireframe vbo.
	vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	
	// 3- left polygon.
	var leftSurface = resultMesh.newSurface();
	face = leftSurface.newFace();
	// ad vertices in ccw order.
	face.addVertex(focusVertex);
	face.addVertex(farLeftTopVertex);
	face.addVertex(farLeftDownVertex);
	
	// make wireframe vbo.
	vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	
	// 4- bottom polygon.
	var bottomSurface = resultMesh.newSurface();
	face = bottomSurface.newFace();
	// ad vertices in ccw order.
	face.addVertex(focusVertex);
	face.addVertex(farLeftDownVertex);
	face.addVertex(farRightDownVertex);
	
	// make wireframe vbo.
	vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	
	// 5- right polygon.
	var rightSurface = resultMesh.newSurface();
	face = rightSurface.newFace();
	// ad vertices in ccw order.
	face.addVertex(focusVertex);
	face.addVertex(farRightDownVertex);
	face.addVertex(farRightTopVertex);
	
	// make wireframe vbo.
	vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	var vboEdges = this.vboKeyContainerEdges.newVBOVertexIdxCacheKey();
	vboEdges.posVboDataArray = Float32Array.from(posDataArray);
	vboEdges.idxVboDataArray = Int16Array.from(indicesDataArray);
	vboEdges.indicesCount = vboEdges.idxVboDataArray.length;

	resultMesh.calculateVerticesNormals();
	
	return resultMesh;
};

// CCTVList.
/**
 * 카메라
 * @class CCTVList
 */
var CCTVList = function() 
{
	if (!(this instanceof CCTVList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.camerasList = [];
	this.bDrawCCTVNames = true;
	
};

/**
 * Create CCTV with name
 * @param {String} name
 */
CCTVList.prototype.new_CCTV = function(name)
{
	var cctv = new CCTV();
	if (name !== undefined)
	{ cctv.name = name; }
	
	this.camerasList.push(cctv);
	return cctv;
};

/**
 * Get single CCTV instance as the index of the instance in this CCTV list
 * @param {Number} idx
 * @returns {CCTV}
 */
CCTVList.prototype.getCCTV = function(idx)
{
	return this.camerasList[idx];
};

/**
 * Get single CCTV instance as the name of the instance
 * @param {String} cameraName the name of that CCTV
 */
CCTVList.prototype.getCCTVByName = function(cameraName)
{
	var find = false;
	var camerasCount = this.getCCTVCount();
	var i=0;
	var cam, resultCam;
	while (!find && i<camerasCount)
	{
		cam = this.getCCTV(i);
		if (cam.name === cameraName)
		{
			resultCam = cam;
			find = true;
		}
		i++;
	}
	
	return resultCam;
};

/**
 * Get the number of the CCTV in this list 
 * @returns {Number} count
 */
CCTVList.prototype.getCCTVCount = function()
{
	return this.camerasList.length;
};

/**
 * Update the properties of the list of CCTV with current time and render the view that each CCTV show
 * @param {MagoManager} magoManager
 * @param shader
 */
CCTVList.prototype.render = function(magoManager, shader)
{
	var cctvsCount = this.getCCTVCount();
	
	if (cctvsCount === 0)
	{ return; }
	
	var gl = magoManager.sceneState.gl;
	shader.resetLastBuffersBinded();
	var shaderProgram = shader.program;
		
	gl.useProgram(shaderProgram);
	gl.uniform1i(shader.bApplySpecularLighting_loc, false);
	gl.disableVertexAttribArray(shader.texCoord2_loc);
	gl.enableVertexAttribArray(shader.position3_loc);
	gl.enableVertexAttribArray(shader.normal3_loc);
		
	shader.bindUniformGenerals();
	gl.uniform1i(shader.textureFlipYAxis_loc, magoManager.sceneState.textureFlipYAxis);
	
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.

	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.noiseTexture);
	gl.activeTexture(gl.TEXTURE2);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.textureAux_1x1);
	shader.last_tex_id = magoManager.textureAux_1x1;
		
	magoManager.renderer.renderTexture = false;
	var currTime = new Date().getTime();
		
	for (var i=0; i<cctvsCount; i++)
	{
		var cctv = this.getCCTV(i);
		cctv.updateColor(currTime);
		cctv.updateOrientation(currTime);
		cctv.render(gl, magoManager, shader);
		cctv.updateTime(currTime);
	}
	
	if (this.bDrawCCTVNames !== undefined && this.bDrawCCTVNames === true)
	{
		magoManager.drawCCTVNames(this.camerasList);
	}
	
	shader.disableVertexAttribArrayAll();
};

































'use strict';

// CCTVList.
/**
 * 카메라
 * @class CCTVList
 */
var CCTVList = function() 
{
	if (!(this instanceof CCTVList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.camerasList = [];
	this.bDrawCCTVNames = true;
	
};

/**
 * Create CCTV with name
 * @param {String} name
 */
CCTVList.prototype.new_CCTV = function(name)
{
	var cctv = new CCTV();
	if (name !== undefined)
	{ cctv.name = name; }
	
	this.camerasList.push(cctv);
	return cctv;
};

/**
 * Get single CCTV instance as the index of the instance in this CCTV list
 * @param {Number} idx
 * @returns {CCTV}
 */
CCTVList.prototype.getCCTV = function(idx)
{
	return this.camerasList[idx];
};

/**
 * Get single CCTV instance as the name of the instance
 * @param {String} cameraName the name of that CCTV
 */
CCTVList.prototype.getCCTVByName = function(cameraName)
{
	var find = false;
	var camerasCount = this.getCCTVCount();
	var i=0;
	var cam, resultCam;
	while (!find && i<camerasCount)
	{
		cam = this.getCCTV(i);
		if (cam.name === cameraName)
		{
			resultCam = cam;
			find = true;
		}
		i++;
	}
	
	return resultCam;
};

/**
 * Get the number of the CCTV in this list 
 * @returns {Number} count
 */
CCTVList.prototype.getCCTVCount = function()
{
	return this.camerasList.length;
};

/**
 * Update the properties of the list of CCTV with current time and render the view that each CCTV show
 * @param {MagoManager} magoManager
 * @param shader
 */
CCTVList.prototype.render = function(magoManager, shader)
{
	var cctvsCount = this.getCCTVCount();
	
	if (cctvsCount === 0)
	{ return; }
	
	var gl = magoManager.sceneState.gl;
	shader.resetLastBuffersBinded();
	var shaderProgram = shader.program;
		
	gl.useProgram(shaderProgram);
	gl.uniform1i(shader.bApplySpecularLighting_loc, false);
	gl.disableVertexAttribArray(shader.texCoord2_loc);
	gl.enableVertexAttribArray(shader.position3_loc);
	gl.enableVertexAttribArray(shader.normal3_loc);
		
	shader.bindUniformGenerals();
	gl.uniform1i(shader.textureFlipYAxis_loc, magoManager.sceneState.textureFlipYAxis);
	
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.

	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.noiseTexture);
	gl.activeTexture(gl.TEXTURE2);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.textureAux_1x1);
	shader.last_tex_id = magoManager.textureAux_1x1;
		
	magoManager.renderer.renderTexture = false;
	var currTime = new Date().getTime();
		
	for (var i=0; i<cctvsCount; i++)
	{
		var cctv = this.getCCTV(i);
		cctv.updateColor(currTime);
		cctv.updateOrientation(currTime);
		cctv.render(gl, magoManager, shader);
		cctv.updateTime(currTime);
	}
	
	if (this.bDrawCCTVNames !== undefined && this.bDrawCCTVNames === true)
	{
		magoManager.drawCCTVNames(this.camerasList);
	}
	
	shader.disableVertexAttribArrayAll();
};

'use strict';



/**
 * Save and calculate the color value as RGB
 * @class Color
 */
var Color = function() 
{
	if (!(this instanceof Color)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.r = 0;
	this.g = 0;
	this.b = 0;
	this.a = 1;
};


/**
 * Match gray scale to RGB scale
 * @param gray the percentage of the gray color. normalize the value from 0.0 to 1.0
 * @param {Color} resultColor
 * @returns {Color} 
 */
Color.grayToRGB_MagoStyle = function(gray, resultColor) 
{
	if (resultColor === undefined)
	{ resultColor = new Color(); }
	
	if (gray > 1.0){ gray = 1.0; }
	else if (gray<0.0){ gray = 0.0; }
	
	var r, g, b;
	
	r = -gray + 1.0;
	
	if (gray > 0.5)
	{
		g = -gray*2.0 + 2.0; 
	}
	else 
	{
		g = gray*2.0;
	}
	
	b = gray;
	
	resultColor.setRGB(r, g, b);
	
	return resultColor;
};

/**
 * copy of the value of RGB instance
 * @param {Color} color
 */
Color.prototype.copyFrom = function(color) 
{
	this.r = color.r;
	this.g = color.g;
	this.b = color.b;
	this.a = color.a;
};

/**
 * Clear the RGBA value of this instance
 */
Color.prototype.deleteObjects = function() 
{
	this.r = undefined;
	this.g = undefined;
	this.b = undefined;
	this.a = undefined;
};
  
/**
 * Set the value of RGBA (A means transparancy) as default. 
 * @param red the value of red
 * @param green the value of green
 * @param blue the value of blue
 * @param alpha the value of transparancy
 */
Color.prototype.set = function(red, green, blue, alpha) 
{

	this.r = red; 
	this.g = green; 
	this.b = blue; 
	this.a = alpha;
};
  
/**
 * Set the value of RGB
 * @param red the value of red
 * @param green the value of green
 * @param blue the value of blue
 */
Color.prototype.setRGB = function(red, green, blue) 
{

	this.r = red; 
	this.g = green; 
	this.b = blue;
};
  
/**
 * Set the value of RGBA (A means transparancy)
 * @param red the value of red
 * @param green the value of green
 * @param blue the value of blue
 * @param alpha the value of transparancy
 */
Color.prototype.setRGBA = function(red, green, blue, alpha) 
{
	//this[0] = red;
	//this[1] = green;
	//this[2] = blue;
	//this[3] = alpha;
	this.r = red; this.g = green; this.b = blue; this.a = alpha;
};

/**
 * This class is used for color code of GL
 * @class SelectionColor
 */
var SelectionColor = function() 
{
	if (!(this instanceof SelectionColor)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.color = new Color();
};

/**
 * Initiate the color value of this feature
 */
SelectionColor.prototype.init = function() 
{
	this.color.r = 0;
	this.color.g = 0;
	this.color.b = 0;
	this.cycle = 0;
};

/**
 * get the color code of given RGB color
 * @param {Color} resultColor target color instance
 */
SelectionColor.prototype.getAvailableColor = function(resultColor) 
{
	if (resultColor === undefined)
	{ resultColor = new Color(); }
	
	resultColor.setRGB(this.color.r, this.color.g, this.color.b);
	
	this.color.b += 1;
	if (this.color.b >= 254)
	{
		this.color.b = 0;
		this.color.g += 1;
		if (this.color.g >= 254)
		{
			this.color.g = 0;
			this.color.r += 1;
			if (this.color.r >= 254)
			{
				this.color.r = 0;
				this.cycle += 1;
			}
		}
	}
	
	return resultColor;
};

/**
 * Change the RGB code to color code.
 * (255,255,255) is used to white color so 254 number is used
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @returns Color code
 */
SelectionColor.prototype.decodeColor3 = function(r, g, b) 
{
	return 64516*r + 254*g + b;
};







'use strict';

/**
 * Frame Buffer Object
 * @class FBO
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {Number} width Framebuffer width.
 * @param {Number} height Framebuffer height.
 */
var FBO = function(gl, width, height) 
{
	if (!(this instanceof FBO)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * WebGL rendering context.
	 * @type {WebGLRenderingContext}
	 * @default WebGLRenderingContext
	 */
	this.gl = gl;
	
	/**
	 * Framebuffer width.
	 * @type {Number}
	 * @default 0
	 */
	this.width = new Int32Array(1);
	
	/**
	 * Framebuffer height.
	 * @type {Number}
	 * @default 0
	 */
	this.height = new Int32Array(1);
	
	/**
	 * WebGL Framebuffer.
	 * @type {WebGLFramebuffer}
	 * @default WebGLFramebuffer
	 */
	this.fbo = gl.createFramebuffer();
	
	
	/**
	 * WebGL Renderbuffer.
	 * @type {WebGLRenderbuffer}
	 * @default WebGLRenderbuffer
	 */
	this.depthBuffer = gl.createRenderbuffer();
	
	/**
	 * WebGL texture.
	 * @type {WebGLTexture}
	 * @default WebGLTexture
	 */
	this.colorBuffer = gl.createTexture();
	
	/**
	 * Boolean var that indicates that the parameters must be updated.
	 * @type {Boolean}
	 * @default true
	 */
	this.dirty = true;
	
	// Init process.
	this.width[0] = width;
	this.height[0] = height;
  
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, this.colorBuffer);  
	
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); //LINEAR_MIPMAP_LINEAR
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	//gl.generateMipmap(gl.TEXTURE_2D)

	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width[0], height[0], 0, gl.RGBA, gl.UNSIGNED_BYTE, null); 
  
	gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
	gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthBuffer);
	gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width[0], height[0]);
	gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthBuffer);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.colorBuffer, 0);
	if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) 
	{
		throw "Incomplete frame buffer object.";
	}

	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};    

/**
 * Binds the framebuffer.
 */
FBO.prototype.bind = function() 
{
	this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
};

/**
 * Unbinds the framebuffer.
 */
FBO.prototype.unbind = function() 
{
	this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
};

/**
 * Deletes all objects.
 * @param gl
 */
FBO.prototype.deleteObjects = function(gl) 
{
	if (this.depthBuffer)
	{ gl.deleteRenderbuffer(this.depthBuffer); }
	this.depthBuffer = undefined;
	
	if (this.colorBuffer)
	{ gl.deleteTexture(this.colorBuffer); }
	this.colorBuffer = undefined;
	
	if (this.fbo)
	{ gl.deleteFramebuffer(this.fbo); }
	this.fbo = undefined;
	
	
};

/**
 * Returns a new WebGL buffer.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {TypedArray} data Data array to bind.
 * @returns {WebGLBuffer} WebGL Buffer.
 */
FBO.createBuffer = function(gl, data) 
{
	const buffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
	return buffer;
};

/**
 * Binds a framebuffer and texture to this instance
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {WebGLFramebuffer} framebuffer WebGL Framebuffer.
 * @param {WebGLTexture} texture WebGL Texture.
 */
FBO.bindFramebuffer = function(gl, framebuffer, texture) 
{
	gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
	if (texture) 
	{
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
	}
};
/**
 * Binds the attribute of each 
 */
FBO.bindAttribute = function(gl, buffer, attribute, numComponents) 
{
	gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	gl.enableVertexAttribArray(attribute);
	gl.vertexAttribPointer(attribute, numComponents, gl.FLOAT, false, 0, 0);
};

FBO.bindTexture = function(gl, texture, unit) 
{
	gl.activeTexture(gl.TEXTURE0 + unit);
	gl.bindTexture(gl.TEXTURE_2D, texture);
};

















































'use strict';

/**
 * xmlhttprequest 요청 개수를 저장하기 위한 객체
 * @class FileRequestControler
 */
var FileRequestControler = function() 
{
	if (!(this instanceof FileRequestControler)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.maxFilesRequestedCount = 1;
	this.filesRequestedCount = 0;
	this.headerFilesRequestedCount = 0;
	this.modelRefFilesRequestedCount = 0;
	this.lowLodDataRequestedCount = 0;
	this.lowLodImagesRequestedCount = 0;
};

FileRequestControler.prototype.isFull = function ()
{
	return this.filesRequestedCount >= this.maxFilesRequestedCount; 
};

FileRequestControler.prototype.isFullHeaders = function ()
{
	return this.headerFilesRequestedCount >= 1; 
};

FileRequestControler.prototype.isFullPlus = function (extraCount)
{
	if (extraCount === undefined)
	{ extraCount = 0; }
	
	return this.filesRequestedCount >= (this.maxFilesRequestedCount + extraCount); 
};

FileRequestControler.prototype.isFullPlusModelReferences = function (extraCount)
{
	if (extraCount === undefined)
	{ extraCount = 0; }
	
	return this.modelRefFilesRequestedCount >= (this.maxFilesRequestedCount + extraCount); 
};

FileRequestControler.prototype.isFullPlusLowLodData = function (extraCount)
{
	if (extraCount === undefined)
	{ extraCount = 0; }
	
	return this.lowLodDataRequestedCount >= (this.maxFilesRequestedCount + extraCount); 
};

FileRequestControler.prototype.isFullPlusLowLodImages = function (extraCount)
{
	if (extraCount === undefined)
	{ extraCount = 0; }
	
	return this.lowLodImagesRequestedCount >= (this.maxFilesRequestedCount + extraCount); 
};

'use strict';

var keyFlags = {
	moveForward  : false,
	moveBackward : false,
	moveLeft     : false,
	moveRight    : false
};

function getFlagFromKeyCode(code)
{
	switch (code)
	{
	case 37 :	// Arrow-Left
	{
		//console.log("KeyDown Left");
		return 'moveLeft';
	}
	case 38 :	// Arrow-Up
	{
		//console.log("KeyDown Up");
		return 'moveForward';
	}
	case 39 :	// Arrow-Right
	{
		//console.log("KeyDown Right");
		return 'moveRight';
	}
	case 40 :	// Arrow-Down
	{
		//console.log("KeyDown Down");
		return 'moveBackward';
	}
	default :
	{
		return undefined;
	}
	}
};

function onKeyDown(event)
{
	var flag = getFlagFromKeyCode(event.keyCode);
	if ( typeof flag !== 'undefined')
	{
		keyFlags[flag] = true;
	}
};

function onKeyUp(event)
{
	var flag = getFlagFromKeyCode(event.keyCode);
	if ( typeof flag !== 'undefined')
	{
		keyFlags[flag] = false;
	}
};

/**
 * 카메라 1인칭 시점 모드
 * 
 */
function FirstPersonView ()
{
	this._camera = undefined;
	this._cameraBAK = undefined;
	this._position = new Point3D();
	this._rotation = new Point3D();
	this._positionSpeed = 1.0;
	this._ratationSpeed = 1.0;
}

Object.defineProperties(FirstPersonView.prototype, {
	"camera": {
		get : function () { return this._camera; },
		set : function (value) { this._camera = value; }
	},
	"position": {
		get : function () { return this._position; },
		set : function (value) { this._position = value; }		
	},
	"rotation": {
		get : function () { return this._rotation; },
		set : function (value) { this._rotation = value; }
	},
	"positionSpeed": {
		get : function () { return this._positionSpeed; },
		set : function (value) { this._positionSpeed = value; }
	},
	"rotationSpeed": {
		get : function () { return this._ratationSpeed; },
		set : function (value) { this._ratationSpeed = value; }
	}
});

FirstPersonView.prototype.init = function ()
{
	this._position.set(0.0, 0.0, 0.0);
	this._rotation.set(0.0, 0.0, 0.0);

	document.addEventListener('keydown', onKeyDown, false);
	document.addEventListener('keyup', onKeyUp, false);
};

FirstPersonView.prototype.release = function ()
{
	this._camera = undefined;
	this._cameraBAK = undefined;
	document.removeEventListener('keydown', onKeyDown, false);
	document.removeEventListener('keyup', onKeyUp, false);
};

FirstPersonView.prototype.move = function (vector)
{
	var position = glMatrix.vec3.fromValues(this._position.x, this._position.y, this.position.z);
	var matrix = glMatrix.mat4.create();
	glMatrix.mat4.rotateY(matrix, matrix, this._rotation.y);
	glMatrix.vec3.transformMat4(vector, vector, matrix);
	glMatrix.vec3.add(position, position, vector);
	this._position.set(position[0], position[1], position[2]);
};
FirstPersonView.prototype.update = function(manager)
{
	if (this._camera === undefined)	{ return; }
	if (keyFlags.moveForward)
	{
		//var isBlocked = manager.checkCollision(this._camera.position, this._camera.direction);
		//if (isBlocked)	{ return; }
		this._camera.moveForward(0.5);
		this.move(vec3.fromValues(0.0, 1.0, 0.0));
	}
	if (keyFlags.moveBackward)
	{
		this._camera.moveBackward(0.5);
		this.move(vec3.fromValues(0.0, -1.0, 0.0));
	}
	if (keyFlags.moveLeft)
	{
		this._camera.lookLeft(0.1);
		this.move(vec3.fromValues(-1.0, 0.0, 0.0));	
	}		
	if (keyFlags.moveRight)
	{
		this._camera.lookRight(0.1);
		this.move(vec3.fromValues(1.0, 0.0, 0.0));	
	}
};

'use strict';

/**
 * Furstum used by camera
 * @class Frustum
 */
var Frustum = function() 
{
	if (!(this instanceof Frustum)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.near = new Float32Array([0.1]);
	this.far = new Float32Array([1000.0]);
	this.fovyRad = new Float32Array([0.8037]); //vertical viewing angle
	this.tangentOfHalfFovy = new Float32Array([0.0]); // to get the length of the horizontal angle of fov
	this.fovRad = new Float32Array([1.047]);//horizontal viewing angle
	this.aspectRatio = new Float32Array([1.3584]);
	this.planesArray = [];
	this.dirty = true;
	
	// plane[0] = near, plane[1] = far.
	for (var i=0; i<6; i++)
	{
		var plane = new Plane();
		this.planesArray.push(plane);
	}
};

/**
 * copy the other frustum
 * @param {Frustum} frustum
 */
Frustum.prototype.copyParametersFrom = function(frustum) 
{
	this.near[0] = frustum.near[0];
	this.far[0] = frustum.far[0];
	this.fovyRad[0] = frustum.fovyRad[0];
	this.tangentOfHalfFovy[0] = frustum.tangentOfHalfFovy[0];
	this.fovRad[0] = frustum.fovRad[0];
	this.aspectRatio[0] = frustum.aspectRatio[0];
};

/**
 * Set the near of frustum by distance
 * @param {Float32} near
 */
Frustum.prototype.setNear = function(near) 
{
	this.near[0] = near;
};

/**
 * Set the fart of frustum by distance
 * @param {Float32} far
 */
Frustum.prototype.setFar = function(far) 
{
	this.far[0] = far;
};

/**
 * Check whether the bounding sphere of the feature is intersected with the near and far of the frustum for frustum culling
 * @param {Sphere} sphere
 * @returns {Boolean}
 */
Frustum.prototype.intersectionNearFarSphere = function(sphere) 
{
	var intersects = false;
	for (var i=0; i<2; i++)
	{
		var intersectionType = this.planesArray[i].intersectionSphere(sphere);
		if (intersectionType === Constant.INTERSECTION_OUTSIDE)
		{ return Constant.INTERSECTION_OUTSIDE; }
		else if (intersectionType === Constant.INTERSECTION_INTERSECT)
		{ intersects = true; }
	}
	
	if (intersects)
	{ return Constant.INTERSECTION_INTERSECT; }
	else
	{ return Constant.INTERSECTION_INSIDE; }
};

/**
 * Check whether the bounding sphere of the feature is intersected with this frustum for frustum culling
 * @param {Sphere} sphere
 * @returns {Boolean}
 */
Frustum.prototype.intersectionSphere = function(sphere) 
{
	var intersects = false;
	for (var i=0; i<6; i++)
	{
		var intersectionType = this.planesArray[i].intersectionSphere(sphere);
		if (intersectionType === Constant.INTERSECTION_OUTSIDE)
		{ return Constant.INTERSECTION_OUTSIDE; }
		else if (intersectionType === Constant.INTERSECTION_INTERSECT)
		{ intersects = true; }
	}
	
	if (intersects)
	{ return Constant.INTERSECTION_INTERSECT; }
	else
	{ return Constant.INTERSECTION_INSIDE; }
};






























'use strict';

/**
 * Manage the objects which is shown at each volume of this frustum
 * @class FrustumVolumeControl
 */
var FrustumVolumeControl = function() 
{
	if (!(this instanceof FrustumVolumeControl)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.frustumVolumensMap = {};
};

/**
 * Find the specific volumn by the key of this.frustumVolumensMap
 * @param {Number} key
 * @returns {Frustum} 
 */
FrustumVolumeControl.prototype.getFrustumVolumeCulling = function(key)
{
	// 1rst, check if exist. If no exist create it.
	if (!this.frustumVolumensMap.hasOwnProperty(key))
	{
		this.frustumVolumensMap[key] = {};
		this.frustumVolumensMap[key].fullyIntersectedLowestTilesArray = [];
		this.frustumVolumensMap[key].partiallyIntersectedLowestTilesArray = [];
		this.frustumVolumensMap[key].visibleNodes = new VisibleObjectsController();
	}
	
	return this.frustumVolumensMap[key];
};

/**
 * Initiate and clear all the objects in the array
 */
FrustumVolumeControl.prototype.initArrays = function()
{
	var frustumVolumeObject;
	for (var key in this.frustumVolumensMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.frustumVolumensMap, key)) 
		{
			frustumVolumeObject = this.frustumVolumensMap[key];
			frustumVolumeObject.fullyIntersectedLowestTilesArray.length = 0;
			frustumVolumeObject.partiallyIntersectedLowestTilesArray.length = 0;
			frustumVolumeObject.visibleNodes.initArrays();
		}
	}
};
'use strict';

/**
 * This class represents the coordinate as geographic coordinate system
 * @class GeographicCoord
 */
var GeographicCoord = function(lon, lat, alt) 
{
	if (!(this instanceof GeographicCoord)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.longitude;
	this.latitude;
	this.altitude;
	
	if (lon !== undefined)
	{ this.longitude = lon; }
	
	if (lat !== undefined)
	{ this.latitude = lat; }
	
	if (alt !== undefined)
	{ this.altitude = alt; }

	this.absolutePoint; // x, y, z of the coordinate in wgs84.
	this.vboKeysContainer;
	this.geoLocDataManager;
	this.owner;
};

/**
 * Clear the value of this instance from the vbo key container and geoLocDataManager 
 * @param {VBOMemoryManager}vboMemManager
 */
GeographicCoord.prototype.deleteObjects = function(vboMemManager) 
{
	this.longitude = undefined;
	this.latitude = undefined;
	this.altitude = undefined;
	
	if (this.absolutePoint !== undefined)
	{
		this.absolutePoint.deleteObjects();
		this.absolutePoint = undefined;
	}
	
	if (this.vboKeysContainer !== undefined)
	{
		this.vboKeysContainer.deleteGlObjects(vboMemManager.gl, vboMemManager);
	}
	
	if (this.geoLocDataManager !== undefined)
	{
		this.geoLocDataManager.deleteObjects();
	}
	
	this.owner = undefined;
};

/**
 * Change this GeographicCoord point to Point3D point
 * @param {Point3D} resultPoint3D
 */
GeographicCoord.prototype.getWgs84Point3D = function(resultPoint3d) 
{
	var cartesianAux = Globe.geographicToCartesianWgs84(this.longitude, this.latitude, this.altitude, undefined);
	
	if (resultPoint3d === undefined)
	{ resultPoint3d = new Point3D(); }
	
	resultPoint3d.set(cartesianAux[0], cartesianAux[1], cartesianAux[2]);
	return resultPoint3d;
};

/**
 * Change this GeographicCoord point to Point2D point using Mercator projection
 * @param {Point2D} resultPoint2d
 */
GeographicCoord.prototype.getMercatorProjection = function(resultPoint2d) 
{
	return Globe.geographicToMercatorProjection(this.longitude, this.latitude, resultPoint2d);
};

/**
 * get the GeoLocationDataManager of this feature
 */
GeographicCoord.prototype.getGeoLocationDataManager = function() 
{
	if (this.geoLocDataManager === undefined)
	{ this.geoLocDataManager = new GeoLocationDataManager(); }
	
	return this.geoLocDataManager ;
};

/**
 * Copy the value of the other GeographicCoord feature
 * @param {GeographicCoord} geographicCoord
 */
GeographicCoord.prototype.copyFrom = function(geographicCoord) 
{
	this.longitude = geographicCoord.longitude;
	this.latitude = geographicCoord.latitude;
	this.altitude = geographicCoord.altitude;
};

/**
 * Set lon,lat,alt at this feature
 * @param longitude 경도
 * @param latitude 위도
 * @param altitude 고도
 */
GeographicCoord.prototype.setLonLatAlt = function(longitude, latitude, altitude) 
{
	if (longitude !== undefined)
	{ this.longitude = longitude; }
	if (latitude !== undefined)
	{ this.latitude = latitude; }
	if (altitude !== undefined)
	{ this.altitude = altitude; }
};

/**
 * get the middle point between two GeopraphicCoord features
 * @param {GeographicCoord} geographicCoordA
 * @param {GeographicCoord} geographicCoordB
 * @param {GeographicCoord} resultGeographicCoord
 * @returns {GeographicCoord}
 */
GeographicCoord.getMidPoint = function(geographicCoordA, geographicCoordB, resultGeographicCoord) 
{
	var midLat = ( geographicCoordA.latitude + geographicCoordB.latitude) / 2.0;
	var midLon = ( geographicCoordA.longitude + geographicCoordB.longitude) / 2.0;
	var midAlt = ( geographicCoordA.altitude + geographicCoordB.altitude) / 2.0;
	
	if (resultGeographicCoord === undefined)
	{ resultGeographicCoord = new GeographicCoord(midLon, midLat, midAlt); }
	else 
	{
		resultGeographicCoord.setLonLatAlt(midLon, midLat, midAlt);
	}
	
	return resultGeographicCoord;
};

/**
 * make the vbo data of this feature
 * @param {VBOMemoryManager} vboMemManager
 */
 
GeographicCoord.prototype.prepareData = function(vboMemManager) 
{
	if (this.vboKeysContainer === undefined)
	{ this.vboKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
	
	if (this.vboKeysContainer.getVbosCount() === 0)
	{
		var vboKey = this.vboKeysContainer.newVBOVertexIdxCacheKey();
		
		// Position.
		var pos = new Float32Array([0.0, 0.0, 0.0]);
		vboKey.setDataArrayPos(pos, vboMemManager);
	}
	
	return true;
};

/**
 * Render this feature
 */
GeographicCoord.prototype.renderPoint = function(magoManager, shader, gl, renderType) 
{
	if (!this.prepareData(magoManager.vboMemoryManager))
	{ return false; }
	
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader);
	
	if (renderType === 2)
	{
		var selectionManager = magoManager.selectionManager;
		var selectionColor = magoManager.selectionColor;

		var selColor = selectionColor.getAvailableColor(undefined); 
		var idxKey = selectionColor.decodeColor3(selColor.r, selColor.g, selColor.b);

		selectionManager.setCandidateGeneral(idxKey, this);
		gl.uniform4fv(shader.oneColor4_loc, [selColor.r/255.0, selColor.g/255.0, selColor.b/255.0, 1.0]);
	}
	
	var vbo_vicky = this.vboKeysContainer.vboCacheKeysArray[0]; // there are only one.
	if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
	{ return false; }

	gl.drawArrays(gl.POINTS, 0, vbo_vicky.vertexCount);
	
	
};


//*
//*
//*
/**
 * 어떤 일을 하고 있습니까?
 * @class GeographicCoordsList
 */
var GeographicCoordsList = function() 
{
	if (!(this instanceof GeographicCoordsList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.geographicCoordsArray = [];
	this.vboKeysContainer;
	this.owner;
	
	// Aux vars.
	this.points3dList; // used to render.
};

/**
 * push single point
 * @param {GeographicCoord}
 */
GeographicCoordsList.prototype.addGeoCoord = function(geographicPoint) 
{
	this.geographicCoordsArray.push(geographicPoint);
	geographicPoint.owner = this;
};

/**
 * get single point
 * @param {Number} idx the index of target
 */
GeographicCoordsList.prototype.getGeoCoord = function(idx) 
{
	if (this.geographicCoordsArray === undefined)
	{ return undefined; }
	
	return this.geographicCoordsArray[idx];
};

/**
 * Get the number of the point in this list
 * @returns {Number} the number of the points
 */
GeographicCoordsList.prototype.getGeoCoordsCount = function() 
{
	if (this.geographicCoordsArray === undefined)
	{ return 0; }
	
	return this.geographicCoordsArray.length;
};

/**
 * This function returns points3dArray relative to the geoLocIn.
 * @param {GeoLocationData} geoLocIn the information about the axis of this GeographicCoord
 * @param resultPoint3dArray
 * 
 */
GeographicCoordsList.prototype.getPointsRelativeToGeoLocation = function(geoLocIn, resultPoints3dArray) 
{

	if (resultPoints3dArray === undefined)
	{ resultPoints3dArray = []; }
	
	var geoPointsCount = this.getGeoCoordsCount();
	
	for (var i=0; i<geoPointsCount; i++)
	{
		var geoCoord = this.getGeoCoord(i);
		var geoLoc = geoCoord.geoLocDataManager.getCurrentGeoLocationData();
		var posAbs = geoLoc.position;
		
		resultPoints3dArray[i] = geoLocIn.getTransformedRelativePosition(posAbs, resultPoints3dArray[i]);
	}
	
	return resultPoints3dArray;
};

/**
 * Clear the data in this instance and delete the vbo info of this instance
 */
GeographicCoordsList.prototype.deleteObjects = function(vboMemManager) 
{
	if (this.geographicCoordsArray !== undefined)
	{
		var geoPointsCount = this.getGeoCoordsCount();
		
		for (var i=0; i<geoPointsCount; i++)
		{
			this.geographicCoordsArray[i].deleteGlObjects(vboMemManager);
			this.geographicCoordsArray[i] = undefined;
		}
		this.geographicCoordsArray = undefined;
	}
	
	if (this.vboKeysContainer !== undefined)
	{
		this.vboKeysContainer.deleteGlObjects(vboMemManager);
		this.vboKeysContainer = undefined;
	}
	
	this.owner = undefined;
};

/**
 * Make Lines making the first point as the origin for the other points. Change the points to the GeographicCoords.
 */
GeographicCoordsList.prototype.makeLines = function(magoManager) 
{
	if (this.geographicCoordsArray === undefined || this.geographicCoordsArray.length === 0)
	{ return false; }
	
	// To render lines, use Point3DList class object.
	if (this.points3dList === undefined)
	{ this.points3dList = new Point3DList(); }
	
	var geoLoc = this.points3dList.getGeographicLocation();
	
	// Take the 1rst geographicCoord's geoLocation.
	var geoCoord = this.getGeoCoord(0);
	var geoLocDataManagerFirst = geoCoord.getGeoLocationDataManager();
	var geoLocFirst = geoLocDataManagerFirst.getCurrentGeoLocationData();
	geoLoc.copyFrom(geoLocFirst);
	
	var points3dArray = this.getPointsRelativeToGeoLocation(geoLoc, undefined);
	this.points3dList.deleteVboKeysContainer(magoManager);
	this.points3dList.deletePoints3d();
	this.points3dList.addPoint3dArray(points3dArray);
	
};

/**
 * Render lines
 */
GeographicCoordsList.prototype.renderLines = function(magoManager, shader, renderType, bLoop, bEnableDepth) 
{
	if (this.geographicCoordsArray === undefined)
	{ return false; }
	
	if (this.points3dList === undefined)
	{ return false; }
	
	var shader = magoManager.postFxShadersManager.getShader("pointsCloud");
	shader.useProgram();
	shader.disableVertexAttribArrayAll();
	shader.resetLastBuffersBinded();
	shader.enableVertexAttribArray(shader.position3_loc);
	shader.bindUniformGenerals();
	
	this.points3dList.renderLines(magoManager, shader, renderType, bLoop, bEnableDepth);
	
	shader.disableVertexAttribArrayAll();
};

/**
 * Rendering this feature
 * @param magoManager
 * @param shader
 * @param renderType
 * @param bEnableDepth
 * 
 */
GeographicCoordsList.prototype.renderPoints = function(magoManager, shader, renderType, bEnableDepth) 
{
	if (this.geographicCoordsArray === undefined)
	{ return false; }
	
	var gl = magoManager.sceneState.gl;
	
	//var vertexAttribsCount = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	//for(var i = 0; i<vertexAttribsCount; i++)
	//	gl.disableVertexAttribArray(i);

	var shader = magoManager.postFxShadersManager.getShader("pointsCloud");
	shader.useProgram();
	
	shader.disableVertexAttribArrayAll();
	shader.resetLastBuffersBinded();

	shader.enableVertexAttribArray(shader.position3_loc);
	
	shader.bindUniformGenerals();
	
	gl.uniform1i(shader.bPositionCompressed_loc, false);
	gl.uniform1i(shader.bUse1Color_loc, true);
	gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 0.1, 1.0]); //.
	gl.uniform1f(shader.fixPointSize_loc, 15.0);
	gl.uniform1i(shader.bUseFixPointSize_loc, true);
	
	if (bEnableDepth === undefined)
	{ bEnableDepth = true; }
	
	if (bEnableDepth)
	{ gl.enable(gl.DEPTH_TEST); }
	else
	{ gl.disable(gl.DEPTH_TEST); }

	// Render pClouds.
	var geoCoord;
	var geoCoordsCount = this.geographicCoordsArray.length;
	for (var i=0; i<geoCoordsCount; i++)
	{
		geoCoord = this.geographicCoordsArray[i];
		geoCoord.renderPoint(magoManager, shader, gl, renderType);
	}
	
	// Check if exist selectedGeoCoord.
	var currSelected = magoManager.selectionManager.getSelectedGeneral();
	if (currSelected !== undefined && currSelected.constructor.name === "GeographicCoord")
	{
		gl.uniform4fv(shader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.
		gl.uniform1f(shader.fixPointSize_loc, 10.0);
		currSelected.renderPoint(magoManager, shader, gl, renderType);
	}
	
	shader.disableVertexAttribArrayAll();
	gl.enable(gl.DEPTH_TEST);
	
	// Write coords.
	var canvas = magoManager.getObjectLabel();
	var ctx = canvas.getContext("2d");
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	ctx.font = "13px Arial";

	var gl = magoManager.sceneState.gl;
	var worldPosition;
	var screenCoord;
	for (var i=0; i<geoCoordsCount; i++)
	{
		geoCoord = this.geographicCoordsArray[i];
		var geoLocDataManager = geoCoord.getGeoLocationDataManager();
		var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
		worldPosition = geoLoc.position;
		screenCoord = ManagerUtils.calculateWorldPositionToScreenCoord(gl, worldPosition.x, worldPosition.y, worldPosition.z, screenCoord, magoManager);
		screenCoord.x += 15;
		screenCoord.y -= 15;
		//var geoCoords = geoLoc.geographicCoord;
		if (screenCoord.x >= 0 && screenCoord.y >= 0)
		{
			var word = "lon: " + geoCoord.longitude.toFixed(5) + ", lat: " + geoCoord.latitude.toFixed(5);
			ctx.strokeText(word, screenCoord.x, screenCoord.y);
			ctx.fillText(word, screenCoord.x, screenCoord.y);
		}
	}
	ctx.restore();
	
};

/**
 * Change Point3D features from WGS84 Points
 * @param resultPoint3DArray the target
 */
GeographicCoordsList.prototype.getWgs84Points3D = function(resultPoint3DArray) 
{
	if (resultPoint3DArray === undefined)
	{ resultPoint3DArray = []; }
	
	var geoCoord;
	var geoCoordsCount = this.geographicCoordsArray.length;
	for (var i=0; i<geoCoordsCount; i++)
	{
		geoCoord = this.geographicCoordsArray[i];
		var wgs84Point3d = geoCoord.getWgs84Point3D(undefined);
		resultPoint3DArray.push(wgs84Point3d);
	}
	
	return resultPoint3DArray;
};














































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class GeographicCoordsList
 */
var GeographicCoordsList = function() 
{
	if (!(this instanceof GeographicCoordsList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.geographicCoordsArray = [];
	this.vboKeysContainer;
	this.owner;
	
	// Aux vars.
	this.points3dList; // used to render.
};

/**
 * push single point
 * @param {GeographicCoord}
 */
GeographicCoordsList.prototype.addGeoCoord = function(geographicPoint) 
{
	this.geographicCoordsArray.push(geographicPoint);
	geographicPoint.owner = this;
};

/**
 * get single point
 * @param {Number} idx the index of target
 */
GeographicCoordsList.prototype.getGeoCoord = function(idx) 
{
	if (this.geographicCoordsArray === undefined)
	{ return undefined; }
	
	return this.geographicCoordsArray[idx];
};

/**
 * Get the number of the point in this list
 * @returns {Number} the number of the points
 */
GeographicCoordsList.prototype.getGeoCoordsCount = function() 
{
	if (this.geographicCoordsArray === undefined)
	{ return 0; }
	
	return this.geographicCoordsArray.length;
};

/**
 * This function returns points3dArray relative to the geoLocIn.
 * @param {GeoLocationData} geoLocIn the information about the axis of this GeographicCoord
 * @param resultPoint3dArray
 * 
 */
GeographicCoordsList.prototype.getPointsRelativeToGeoLocation = function(geoLocIn, resultPoints3dArray) 
{

	if (resultPoints3dArray === undefined)
	{ resultPoints3dArray = []; }
	
	var geoPointsCount = this.getGeoCoordsCount();
	
	for (var i=0; i<geoPointsCount; i++)
	{
		var geoCoord = this.getGeoCoord(i);
		var geoLoc = geoCoord.geoLocDataManager.getCurrentGeoLocationData();
		var posAbs = geoLoc.position;
		
		resultPoints3dArray[i] = geoLocIn.getTransformedRelativePosition(posAbs, resultPoints3dArray[i]);
	}
	
	return resultPoints3dArray;
};

/**
 * Clear the data in this instance and delete the vbo info of this instance
 */
GeographicCoordsList.prototype.deleteObjects = function(vboMemManager) 
{
	if (this.geographicCoordsArray !== undefined)
	{
		var geoPointsCount = this.getGeoCoordsCount();
		
		for (var i=0; i<geoPointsCount; i++)
		{
			this.geographicCoordsArray[i].deleteGlObjects(vboMemManager);
			this.geographicCoordsArray[i] = undefined;
		}
		this.geographicCoordsArray = undefined;
	}
	
	if (this.vboKeysContainer !== undefined)
	{
		this.vboKeysContainer.deleteGlObjects(vboMemManager);
		this.vboKeysContainer = undefined;
	}
	
	this.owner = undefined;
};

/**
 * Make Lines making the first point as the origin for the other points. Change the points to the GeographicCoords.
 */
GeographicCoordsList.prototype.makeLines = function(magoManager) 
{
	if (this.geographicCoordsArray === undefined || this.geographicCoordsArray.length === 0)
	{ return false; }
	
	// To render lines, use Point3DList class object.
	if (this.points3dList === undefined)
	{ this.points3dList = new Point3DList(); }
	
	var geoLoc = this.points3dList.getGeographicLocation();
	
	// Take the 1rst geographicCoord's geoLocation.
	var geoCoord = this.getGeoCoord(0);
	var geoLocDataManagerFirst = geoCoord.getGeoLocationDataManager();
	var geoLocFirst = geoLocDataManagerFirst.getCurrentGeoLocationData();
	geoLoc.copyFrom(geoLocFirst);
	
	var points3dArray = this.getPointsRelativeToGeoLocation(geoLoc, undefined);
	this.points3dList.deleteVboKeysContainer(magoManager);
	this.points3dList.deletePoints3d();
	this.points3dList.addPoint3dArray(points3dArray);
	
};

/**
 * Render lines
 */
GeographicCoordsList.prototype.renderLines = function(magoManager, shader, renderType, bLoop, bEnableDepth) 
{
	if (this.geographicCoordsArray === undefined)
	{ return false; }
	
	if (this.points3dList === undefined)
	{ return false; }
	
	var shader = magoManager.postFxShadersManager.getShader("pointsCloud");
	shader.useProgram();
	shader.disableVertexAttribArrayAll();
	shader.resetLastBuffersBinded();
	shader.enableVertexAttribArray(shader.position3_loc);
	shader.bindUniformGenerals();
	
	this.points3dList.renderLines(magoManager, shader, renderType, bLoop, bEnableDepth);
	
	shader.disableVertexAttribArrayAll();
};

/**
 * Rendering this feature
 * @param magoManager
 * @param shader
 * @param renderType
 * @param bEnableDepth
 * 
 */
GeographicCoordsList.prototype.renderPoints = function(magoManager, shader, renderType, bEnableDepth) 
{
	if (this.geographicCoordsArray === undefined)
	{ return false; }
	
	var gl = magoManager.sceneState.gl;
	
	//var vertexAttribsCount = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	//for(var i = 0; i<vertexAttribsCount; i++)
	//	gl.disableVertexAttribArray(i);

	var shader = magoManager.postFxShadersManager.getShader("pointsCloud");
	shader.useProgram();
	
	shader.disableVertexAttribArrayAll();
	shader.resetLastBuffersBinded();

	shader.enableVertexAttribArray(shader.position3_loc);
	
	shader.bindUniformGenerals();
	
	gl.uniform1i(shader.bPositionCompressed_loc, false);
	gl.uniform1i(shader.bUse1Color_loc, true);
	gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 0.1, 1.0]); //.
	gl.uniform1f(shader.fixPointSize_loc, 15.0);
	gl.uniform1i(shader.bUseFixPointSize_loc, true);
	
	if (bEnableDepth === undefined)
	{ bEnableDepth = true; }
	
	if (bEnableDepth)
	{ gl.enable(gl.DEPTH_TEST); }
	else
	{ gl.disable(gl.DEPTH_TEST); }

	// Render pClouds.
	var geoCoord;
	var geoCoordsCount = this.geographicCoordsArray.length;
	for (var i=0; i<geoCoordsCount; i++)
	{
		geoCoord = this.geographicCoordsArray[i];
		geoCoord.renderPoint(magoManager, shader, gl, renderType);
	}
	
	// Check if exist selectedGeoCoord.
	var currSelected = magoManager.selectionManager.getSelectedGeneral();
	if (currSelected !== undefined && currSelected.constructor.name === "GeographicCoord")
	{
		gl.uniform4fv(shader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.
		gl.uniform1f(shader.fixPointSize_loc, 10.0);
		currSelected.renderPoint(magoManager, shader, gl, renderType);
	}
	
	shader.disableVertexAttribArrayAll();
	gl.enable(gl.DEPTH_TEST);
	
	// Write coords.
	var canvas = magoManager.getObjectLabel();
	var ctx = canvas.getContext("2d");
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	ctx.font = "13px Arial";

	var gl = magoManager.sceneState.gl;
	var worldPosition;
	var screenCoord;
	for (var i=0; i<geoCoordsCount; i++)
	{
		geoCoord = this.geographicCoordsArray[i];
		var geoLocDataManager = geoCoord.getGeoLocationDataManager();
		var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
		worldPosition = geoLoc.position;
		screenCoord = ManagerUtils.calculateWorldPositionToScreenCoord(gl, worldPosition.x, worldPosition.y, worldPosition.z, screenCoord, magoManager);
		screenCoord.x += 15;
		screenCoord.y -= 15;
		//var geoCoords = geoLoc.geographicCoord;
		if (screenCoord.x >= 0 && screenCoord.y >= 0)
		{
			var word = "lon: " + geoCoord.longitude.toFixed(5) + ", lat: " + geoCoord.latitude.toFixed(5);
			ctx.strokeText(word, screenCoord.x, screenCoord.y);
			ctx.fillText(word, screenCoord.x, screenCoord.y);
		}
	}
	ctx.restore();
	
};

/**
 * Change Point3D features from WGS84 Points
 * @param resultPoint3DArray the target
 */
GeographicCoordsList.prototype.getWgs84Points3D = function(resultPoint3DArray) 
{
	if (resultPoint3DArray === undefined)
	{ resultPoint3DArray = []; }
	
	var geoCoord;
	var geoCoordsCount = this.geographicCoordsArray.length;
	for (var i=0; i<geoCoordsCount; i++)
	{
		geoCoord = this.geographicCoordsArray[i];
		var wgs84Point3d = geoCoord.getWgs84Point3D(undefined);
		resultPoint3DArray.push(wgs84Point3d);
	}
	
	return resultPoint3DArray;
};










































'use strict';

/**
 * Bouonding box which has vertexs represented as lon,lat,alt.
 * @class GeographicExtent
 */
var GeographicExtent = function() 
{
	if (!(this instanceof GeographicExtent)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.minGeographicCoord;
	this.maxGeographicCoord;
};

/**
 * Clear the value of this instance
 */
GeographicExtent.prototype.deleteObjects = function() 
{
	if (this.minGeographicCoord !== undefined)
	{
		this.minGeographicCoord.deleteObjects();
		this.minGeographicCoord = undefined;
	}
	
	if (this.maxGeographicCoord !== undefined)
	{
		this.maxGeographicCoord.deleteObjects();
		this.maxGeographicCoord = undefined;
	}
};

/**
 * set the value of this instance
 * @param minLon the value of lon of the lower bound
 * @param minLat the value of lat of the lower bound
 * @param minAlt the value of alt of the lower bound
 * @param maxLon the value of lon of the lower bound
 * @param maxLat the value of lat of the lower bound
 * @param maxAlt the value of alt of the lower bound
 */
GeographicExtent.prototype.setExtent = function(minLon, minLat, minAlt, maxLon, maxLat, maxAlt) 
{
	if (this.minGeographicCoord === undefined)
	{ this.minGeographicCoord = new GeographicCoord(); }
	
	this.minGeographicCoord.setLonLatAlt(minLon, minLat, minAlt);
	
	if (this.maxGeographicCoord === undefined)
	{ this.maxGeographicCoord = new GeographicCoord(); }
	
	this.maxGeographicCoord.setLonLatAlt(maxLon, maxLat, maxAlt);
};

/**
 * Get the middle point of the lower bound point and uppper bound point
 * @param resultGeographicCoord the point which will save the result
 * @returns {GeographicCoord}
 */
GeographicExtent.prototype.getMidPoint = function(resultGeographicCoord) 
{
	return GeographicCoord.getMidPoint(this.minGeographicCoord, this.maxGeographicCoord, resultGeographicCoord);
};


















































'use strict';

/**
 * GeoLocationData is a class object that contains axis information about the location on "geographicCoord".
 * 
 * @class GeoLocationData
 * @constructor 
 * @param {string} geoLocationDataName The name of the geoLocationData.
 */
var GeoLocationData = function(geoLocationDataName) 
{
	if (!(this instanceof GeoLocationData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * The name of this geographicLocationData.
	 * @type {String}
	 * @default "noName"
	 */
	this.name;
	
	if (geoLocationDataName === undefined) { this.name = "noName"; }
	else { this.name = geoLocationDataName; }
	
	/**
	 * The geographic location (Longitude, Latitude, Altitude). This is the main data of this class.
	 * @type {GeographicCoord}
	 * @default undefined
	 */
	this.geographicCoord; 
	
	/**
	 * The z-axis rotation.
	 * @type {Number}
	 * @default 0
	 */
	this.heading;
	
	/**
	 * The x-axis rotation.
	 * @type {Number}
	 * @default 0
	 */
	this.pitch;
	
	/**
	 * The y-axis rotation.
	 * @type {Number}
	 * @default 0
	 */
	this.roll;
	
	/**
	 * The date relationed with this geoLocationData.
	 * @type {Date}
	 * @default undefined
	 */
	this.date; // year - month - day - hour - min - seg - miliseg.
	
	/**
	 * The position in world coordinates (x, y, z) of this geoLocationData.
	 * @type {Point3D}
	 * @default (0,0,0).
	 */
	this.position;   
	
	/**
	 * The high part of the splitted position.
	 * @type {Float32Array(3)}
	 * @default [0,0,0]
	 */
	this.positionHIGH; 
	
	/**
	 * The low part of the splitted position.
	 * @type {Float32Array(3)}
	 * @default [0,0,0]
	 */
	this.positionLOW; 
	
	/**
	 * The effective absoluteCoord (x, y, z) of this geoLocationData.
	 * @type {Point3D}
	 * @default (0,0,0).
	 */
	this.pivotPoint; // Actual position = pivotPoint.
	
	/**
	 * The transformation matrix of the geographicCoord. This matrix no includes Heading, Pitch or Roll rotations.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.geoLocMatrix; 
	
	/**
	 * The inverse of the transformation matrix of the geographicCoord. This matrix no includes Heading, Pitch or Roll rotations.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.geoLocMatrixInv; 
	
	/**
	 * The transformation matrix of the geographicCoord. This matrix includes Heading, Pitch or Roll rotations.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.tMatrix;      
	
	/**
	 * The inverse of the transformation matrix of the geographicCoord. This matrix includes Heading, Pitch or Roll rotations.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.tMatrixInv;   
	
	/**
	 * The rotation matrix of the geographicCoord. This matrix includes Heading, Pitch or Roll rotations.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.rotMatrix;    
	
	/**
	 * The inverse of the rotation matrix of the geographicCoord. This matrix includes Heading, Pitch or Roll rotations.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.rotMatrixInv; 
	
	/**
	 * The translation in local coordinates(x, y, z) of this geoLocationData.
	 * @type {Point3D}
	 * @default undefined
	 */
	this.pivotPointTraslationLC; 
};

/**
 * Sets the parameters Heading, pitch and Roll.
 * @param {Number} heading The heading value in degrees.
 * @param {Number} pitch The pitch value in degrees.
 * @param {Number} roll The roll value in degrees.
 */
GeoLocationData.prototype.setRotationHeadingPitchRoll = function(heading, pitch, roll) 
{
	// Note: Sets the parameters if exist argument.
	if (heading !== undefined)
	{ this.heading = heading; }
	
	if (pitch !== undefined)
	{ this.pitch = pitch; }

	if (roll !== undefined)
	{ this.roll = roll; }
};

/**
 * Returns the geographic coordinates.
 * @Returns {GeographicCoord} this.geographicCoord
 */
GeoLocationData.prototype.getGeographicCoords = function() 
{
	return this.geographicCoord;
};

/**
 * Sets the parameters Longitude, Latitude and Altitude of the geographic coordinates.
 * @param {Number} longitude The longitude in degrees.
 * @param {Number} latitude The latitude in degrees.
 * @param {Number} altitude The altitude in meters.
 */
GeoLocationData.prototype.setGeographicCoordsLonLatAlt = function(longitude, latitude, altitude) 
{
	if (this.geographicCoord === undefined)
	{ this.geographicCoord = new GeographicCoord(); }
	
	this.geographicCoord.setLonLatAlt(longitude, latitude, altitude);
};

/**
 * Deletes all objects of this class.
 @param {VboMemoryManager} vboMemManager The manager and controller of the gpu memory.
 */
GeoLocationData.prototype.deleteObjects = function(vboMemManager) 
{
	this.name = undefined;
	if (this.geographicCoord)
	{ this.geographicCoord.deleteObjects(vboMemManager); }
	this.geographicCoord = undefined;
	
	this.heading = undefined;
	this.pitch = undefined;
	this.roll = undefined;
	
	this.date = undefined; 
	
	if (this.position)
	{ this.position.deleteObjects(); }  
	this.position = undefined;
	this.positionHIGH = undefined;
	this.positionLOW = undefined; 
	if (this.pivotPoint)
	{ this.pivotPoint.deleteObjects(); }  
	this.pivotPoint = undefined;
	
	// F4D Matrix4.*
	if (this.geoLocMatrix)
	{ this.geoLocMatrix.deleteObjects(); }
	if (this.geoLocMatrixInv)
	{ this.geoLocMatrixInv.deleteObjects(); }
	if (this.tMatrix)
	{ this.tMatrix.deleteObjects(); } 
	if (this.tMatrixInv)
	{ this.tMatrixInv.deleteObjects(); } 
	if (this.rotMatrix)
	{ this.rotMatrix.deleteObjects(); }  
	if (this.rotMatrixInv)
	{ this.rotMatrixInv.deleteObjects(); } 
	
	this.geoLocMatrix = undefined;
	this.geoLocMatrixInv = undefined; 
	this.tMatrix = undefined;     
	this.tMatrixInv = undefined;  
	this.rotMatrix = undefined;   
	this.rotMatrixInv = undefined; 
	
	// Aditional.
	if (this.pivotPointTraslationLC)
	{ this.pivotPointTraslationLC.deleteObjects(); }
	this.pivotPointTraslationLC = undefined;
};

/**
 * Adds the translation vector into position.
 */
GeoLocationData.prototype.doEffectivePivotPointTranslation = function() 
{
	// this function adds the "pivotPointTraslation" to the positions.
	// this function is not for move the building on the globe. This function is only for translate the pivot point of the building.
	// Note: the translation vector only must be added into "this.pivotPoint". TODO:
	if (this.pivotPointTraslationLC === undefined)
	{ return; }
	
	var traslationVector;
	traslationVector = this.tMatrix.rotatePoint3D(this.pivotPointTraslationLC, traslationVector );
	
	this.position.x += traslationVector.x;
	this.position.y += traslationVector.y;
	this.position.z += traslationVector.z;

	this.positionLOW[0] += traslationVector.x;
	this.positionLOW[1] += traslationVector.y;
	this.positionLOW[2] += traslationVector.z;

	if (this.pivotPoint === undefined)
	{ this.pivotPoint = new Point3D(); }

	this.pivotPoint.set(this.position.x, this.position.y, this.position.z);
};


/**
 * Copies all data of this class into the return geoLoctationData.
 *@param {GeoLocationData} 
 */
GeoLocationData.prototype.copyFrom = function(geoLocData) 
{
	if (geoLocData === undefined)
	{ return; }
	
	this.name = geoLocData.name;
	if (geoLocData.geographicCoord)
	{
		if (this.geographicCoord === undefined)
		{ this.geographicCoord = new GeographicCoord(); }
		
		this.geographicCoord.copyFrom(geoLocData.geographicCoord); // longitude, latitude, altitude.
	}
	
	this.heading = geoLocData.heading;
	this.pitch = geoLocData.pitch;
	this.roll = geoLocData.roll;
	
	this.date = geoLocData.date; // year - month - day - hour - min - seg - miliseg.
	
	if (geoLocData.position)
	{
		if (this.position === undefined)
		{ this.position = new Point3D(); }
		this.position.copyFrom(geoLocData.position);
	}
	if (geoLocData.positionHIGH)
	{
		if (this.positionHIGH === undefined)
		{ this.positionHIGH = new Float32Array(3); }
		
		this.positionHIGH[0]= geoLocData.positionHIGH[0];
		this.positionHIGH[1]= geoLocData.positionHIGH[1];
		this.positionHIGH[2]= geoLocData.positionHIGH[2];
	}
	if (geoLocData.positionLOW)
	{
		if (this.positionLOW === undefined)
		{ this.positionLOW = new Float32Array(3); }
		
		this.positionLOW[0]= geoLocData.positionLOW[0];
		this.positionLOW[1]= geoLocData.positionLOW[1];
		this.positionLOW[2]= geoLocData.positionLOW[2];
	}
	if (geoLocData.pivotPoint)
	{
		if (this.pivotPoint === undefined)
		{ this.pivotPoint = new Point3D(); }
		
		this.pivotPoint.copyFrom(geoLocData.pivotPoint);
	}
	
	// F4D Matrix4.*
	if (geoLocData.geoLocMatrix)
	{
		if (this.geoLocMatrix === undefined)
		{ this.geoLocMatrix = new Matrix4(); }
		
		this.geoLocMatrix.copyFromMatrix4(geoLocData.geoLocMatrix);
	}
	if (geoLocData.geoLocMatrixInv)
	{
		if (this.geoLocMatrixInv === undefined)
		{ this.geoLocMatrixInv = new Matrix4(); }
		
		this.geoLocMatrixInv.copyFromMatrix4(geoLocData.geoLocMatrixInv);
	}
	if (geoLocData.tMatrix)
	{
		if (this.tMatrix === undefined)
		{ this.tMatrix = new Matrix4(); }
		
		this.tMatrix.copyFromMatrix4(geoLocData.tMatrix);
	}
	if (geoLocData.tMatrixInv)
	{
		if (this.tMatrixInv === undefined)
		{ this.tMatrixInv = new Matrix4(); }
		
		this.tMatrixInv.copyFromMatrix4(geoLocData.tMatrixInv);
	}
	if (geoLocData.rotMatrix)
	{
		if (this.rotMatrix === undefined)
		{ this.rotMatrix = new Matrix4(); }
		
		this.rotMatrix.copyFromMatrix4(geoLocData.rotMatrix);
	}
	if (geoLocData.rotMatrixInv)
	{
		if (this.rotMatrixInv === undefined)
		{ this.rotMatrixInv = new Matrix4(); }
		
		this.rotMatrixInv.copyFromMatrix4(geoLocData.rotMatrixInv);
	}
	
	if (geoLocData.aditionalTraslation)
	{
		if (this.aditionalTraslation === undefined)
		{ this.aditionalTraslation = new Point3D(); }
		
		this.aditionalTraslation.copyFrom(geoLocData.aditionalTraslation);
	}
	
};

/**
 * This function transforms a local position of this geoLocation to world position.
 * @param localCoord  instance of Point3D.
 * @param resultWorldCoord. instance of Point3D.
 * @returns resultWorldCoord. instance of Point3D.
 */
GeoLocationData.prototype.localCoordToWorldCoord = function(localCoord, resultWorldCoord) 
{
	if (localCoord === undefined || this.tMatrix === undefined)
	{ return undefined; }
	
	if (resultWorldCoord === undefined)
	{ resultWorldCoord = new Point3D(); }
	
	resultWorldCoord = this.tMatrix.transformPoint3D(localCoord, resultWorldCoord); 
	return resultWorldCoord;
};

/**
 * This function transforms an absolute position to local position for this geoLocation.
 * @param worldCoord  instance of Point3D.
 * @param resultLocalCoord. instance of Point3D.
 * @returns resultLocalCoord. instance of Point3D.
 */
GeoLocationData.prototype.worldCoordToLocalCoord = function(worldCoord, resultLocalCoord) 
{
	var tMatrixInv = this.getTMatrixInv();
	if (worldCoord === undefined || tMatrixInv === undefined)
	{ return undefined; }
	
	if (resultLocalCoord === undefined)
	{ resultLocalCoord = new Point3D(); }
	
	resultLocalCoord = tMatrixInv.transformPoint3D(worldCoord, resultLocalCoord); 
	return resultLocalCoord;
};

/**
 * 
 * @returns this.locMatrixInv.
 */
GeoLocationData.prototype.getLocMatrixInv = function() 
{
	if (this.geoLocMatrixInv === undefined)
	{
		var locMatrixInv = glMatrix.mat4.create();
		locMatrixInv = glMatrix.mat4.invert(locMatrixInv, this.geoLocMatrix._floatArrays );
		
		this.geoLocMatrixInv = new Matrix4();
		this.geoLocMatrixInv.setByFloat32Array(locMatrixInv);
	}
	
	return this.geoLocMatrixInv;
};

/**
 * 
 * @returns this.rotMatrixInv.
 */
GeoLocationData.prototype.getRotMatrixInv = function() 
{
	if (this.rotMatrixInv === undefined)
	{
		var rotMatrixInv = glMatrix.mat4.create();
		rotMatrixInv = glMatrix.mat4.invert(rotMatrixInv, this.rotMatrix._floatArrays );
		
		this.rotMatrixInv = new Matrix4();
		this.rotMatrixInv.setByFloat32Array(rotMatrixInv);
	}
	
	return this.rotMatrixInv;
};

/**
 * 
 * @returns this.tMatrixInv.
 */
GeoLocationData.prototype.getTMatrixInv = function() 
{
	if (this.tMatrixInv === undefined)
	{
		var tMatrixInv = glMatrix.mat4.create();
		tMatrixInv = glMatrix.mat4.invert(tMatrixInv, this.tMatrix._floatArrays);
		
		this.tMatrixInv = new Matrix4();
		this.tMatrixInv.setByFloat32Array(tMatrixInv);
	}
	
	return this.tMatrixInv;
};

/**
 * 
 * @returns this.geoLocMatrixInv.
 */
GeoLocationData.prototype.getGeoLocationMatrixInv = function() 
{
	if (this.geoLocMatrixInv === undefined)
	{
		var geoLocMatrixInv = glMatrix.mat4.create();
		geoLocMatrixInv = glMatrix.mat4.invert(geoLocMatrixInv, this.geoLocMatrix._floatArrays  );
		
		this.geoLocMatrixInv = new Matrix4();
		this.geoLocMatrixInv.setByFloat32Array(geoLocMatrixInv);
	}
	
	return this.geoLocMatrixInv;
};

/**
 * This function transforms an absolute camera (world coord) into a relative camera (local coord) for this geoLocation.
 * @param absoluteCamera instance of Camera. 
 * @param resultCamera instance of Camera. This is the transformed camera.
 * @returns resultCamera
 */
GeoLocationData.prototype.getTransformedRelativeCamera = function(absoluteCamera, resultCamera) 
{
	if (resultCamera === undefined)
	{ resultCamera = new Camera(); }
	
	var pointAux = new Point3D();
	
	pointAux.set(absoluteCamera.position.x - this.position.x, 
		absoluteCamera.position.y - this.position.y, 
		absoluteCamera.position.z - this.position.z);
		
	var rotMatInv = this.getRotMatrixInv();
	
	resultCamera.position = rotMatInv.transformPoint3D(pointAux, resultCamera.position);
	
	pointAux.set(absoluteCamera.direction.x, absoluteCamera.direction.y, absoluteCamera.direction.z);
	resultCamera.direction = rotMatInv.transformPoint3D(pointAux, resultCamera.direction);
	
	pointAux.set(absoluteCamera.up.x, absoluteCamera.up.y, absoluteCamera.up.z);
	resultCamera.up = rotMatInv.transformPoint3D(pointAux, resultCamera.up);
  
	pointAux.x = undefined;
	pointAux.y = undefined;
	pointAux.z = undefined;
	pointAux = undefined;
	
	return resultCamera;
};

/**
 * 
 */
GeoLocationData.prototype.getTransformedRelativePositionNoApplyHeadingPitchRoll = function(absolutePosition, resultRelativePosition) 
{
	if (resultRelativePosition === undefined)
	{ resultRelativePosition = new Point3D(); }
	
	var pointAux = new Point3D();
	
	pointAux.set(absolutePosition.x, 
		absolutePosition.y, 
		absolutePosition.z);
	var locMatInv = this.getLocMatrixInv();
	resultRelativePosition = locMatInv.transformPoint3D(pointAux, resultRelativePosition);
	
	return resultRelativePosition;
};

/**
 * Change the absolute coordinate feature to relative coordinate feature
 * @param absolutePosition
 * @param {Point3D} resultRelativePosition
 */
GeoLocationData.prototype.getTransformedRelativePosition = function(absolutePosition, resultRelativePosition) 
{
	if (resultRelativePosition === undefined)
	{ resultRelativePosition = new Point3D(); }
	
	var pointAux = new Point3D();
	
	pointAux.set(absolutePosition.x - this.position.x, 
		absolutePosition.y - this.position.y, 
		absolutePosition.z - this.position.z);
	var rotMatInv = this.getRotMatrixInv();
	resultRelativePosition = rotMatInv.transformPoint3D(pointAux, resultRelativePosition);
	
	return resultRelativePosition;
};

/**
 * This function transforms an absolute camera (world coord) into a relative camera (local coord) for this geoLocation.
 */
GeoLocationData.prototype.getTransformedRelativePositionsArray = function(absolutePositionsArray, resultRelativePositionsArray) 
{
	if (absolutePositionsArray === undefined)
	{ return resultRelativePositionsArray; }
	
	if (resultRelativePositionsArray === undefined)
	{ resultRelativePositionsArray = []; }
	
	var absolutePoints3dCount = absolutePositionsArray.length;
	for (var i=0; i<absolutePoints3dCount; i++)
	{
		var relPoint3d = this.getTransformedRelativePosition(absolutePositionsArray[i], undefined);
		resultRelativePositionsArray.push(relPoint3d);
	}
	
	return resultRelativePositionsArray;
};

/**
 */
GeoLocationData.prototype.bindGeoLocationUniforms = function(gl, shader) 
{
	gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, this.rotMatrix._floatArrays);
	gl.uniform3fv(shader.buildingPosHIGH_loc, [this.positionHIGH[0], this.positionHIGH[1], this.positionHIGH[2]]);
	gl.uniform3fv(shader.buildingPosLOW_loc, [this.positionLOW[0], this.positionLOW[1], this.positionLOW[2]]);
};

//*
//*
//*

/**
 * GeoLocationDataManager is a class object that contains GeoLocationData objects in an array.
 * 
 * @class GeoLocationDataManager
 * @constructor 
 */
var GeoLocationDataManager = function() 
{
	if (!(this instanceof GeoLocationDataManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.geoLocationDataArray = [];
	this.geoLocationDataArrayMaxLengthAllowed = 15;
};

/**
 * Clear all object of GeoLocationDataManager
 */
GeoLocationDataManager.prototype.deleteObjects = function() 
{
	if (this.geoLocationDataArray)
	{
		for (var i=0; i<this.geoLocationDataArray.length; i++)
		{
			this.geoLocationDataArray[i].deleteObjects();
			this.geoLocationDataArray[i] = undefined;
		}
		this.geoLocationDataArray = [];
	}
};

/**
 * Remove the latest GeoLocationData instance
 */
GeoLocationDataManager.prototype.popGeoLocationData = function() 
{
	this.geoLocationDataArray.pop();
};

/**
 * put the geoLocationData from this.geoLocationDataArray
 * @param geoLocationName 변수
 */
GeoLocationDataManager.prototype.newGeoLocationData = function(geoLocationName) 
{
	if (geoLocationName === undefined)
	{ geoLocationName = "noName" + this.geoLocationDataArray.length.toString(); }
	var geoLocationData = new GeoLocationData(geoLocationName);
	this.geoLocationDataArray.unshift(geoLocationData);
	
	if (this.geoLocationDataArray.length > this.geoLocationDataArrayMaxLengthAllowed)
	{
		this.geoLocationDataArray.pop();
		// delete extracted geoLocdata. TODO:
	}

	return geoLocationData;
};

/**
 * return the length of this geoLocationDataArray
 * @returns {Number} the length of this geoLocationDataArray
 */
GeoLocationDataManager.prototype.getGeoLocationDatasCount = function() 
{
	return this.geoLocationDataArray.length;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param {Number} idx
 * @returns this.geoLoactionDataArray[idx]
 */
GeoLocationDataManager.prototype.getGeoLocationData = function(idx) 
{
	if (idx > this.geoLocationDataArray.length - 1)
	{ return undefined; }
	return this.geoLocationDataArray[idx];
};

/**
 * provisionally return the first data of GeoLocationDataArray
 * @class GeoLocationData
 * @param {Number}idx
 * @returns {GeoLocationData}this.geoLoactionDataArray[idx]
 */
GeoLocationDataManager.prototype.getCurrentGeoLocationData = function() 
{
	if (this.geoLocationDataArray.length === 0)
	{
		return undefined;
	}
	return this.geoLocationDataArray[0]; // provisionally return the 1rst.
};

'use strict';


/**
 * GeoLocationDataManager is a class object that contains GeoLocationData objects in an array.
 * 
 * @class GeoLocationDataManager
 * @constructor 
 */
var GeoLocationDataManager = function() 
{
	if (!(this instanceof GeoLocationDataManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.geoLocationDataArray = [];
	this.geoLocationDataArrayMaxLengthAllowed = 15;
};

/**
 * Clear all object of GeoLocationDataManager
 */
GeoLocationDataManager.prototype.deleteObjects = function() 
{
	if (this.geoLocationDataArray)
	{
		for (var i=0; i<this.geoLocationDataArray.length; i++)
		{
			this.geoLocationDataArray[i].deleteObjects();
			this.geoLocationDataArray[i] = undefined;
		}
		this.geoLocationDataArray = [];
	}
};

/**
 * Remove the latest GeoLocationData instance
 */
GeoLocationDataManager.prototype.popGeoLocationData = function() 
{
	this.geoLocationDataArray.pop();
};

/**
 * put the geoLocationData from this.geoLocationDataArray
 * @param geoLocationName 변수
 */
GeoLocationDataManager.prototype.newGeoLocationData = function(geoLocationName) 
{
	if (geoLocationName === undefined)
	{ geoLocationName = "noName" + this.geoLocationDataArray.length.toString(); }
	var geoLocationData = new GeoLocationData(geoLocationName);
	this.geoLocationDataArray.unshift(geoLocationData);
	
	if (this.geoLocationDataArray.length > this.geoLocationDataArrayMaxLengthAllowed)
	{
		this.geoLocationDataArray.pop();
		// delete extracted geoLocdata. TODO:
	}

	return geoLocationData;
};

/**
 * return the length of this geoLocationDataArray
 * @returns {Number} the length of this geoLocationDataArray
 */
GeoLocationDataManager.prototype.getGeoLocationDatasCount = function() 
{
	return this.geoLocationDataArray.length;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param {Number} idx
 * @returns this.geoLoactionDataArray[idx]
 */
GeoLocationDataManager.prototype.getGeoLocationData = function(idx) 
{
	if (idx > this.geoLocationDataArray.length - 1)
	{ return undefined; }
	return this.geoLocationDataArray[idx];
};

/**
 * provisionally return the first data of GeoLocationDataArray
 * @class GeoLocationData
 * @param {Number}idx
 * @returns {GeoLocationData}this.geoLoactionDataArray[idx]
 */
GeoLocationDataManager.prototype.getCurrentGeoLocationData = function() 
{
	if (this.geoLocationDataArray.length === 0)
	{
		return undefined;
	}
	return this.geoLocationDataArray[0]; // provisionally return the 1rst.
};
'use strict';

/**
 * This class is used to assume the real globe of earth as ellipsoid
 * @class Globe
 */
var Globe = function() 
{
	if (!(this instanceof Globe)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	//WGS 84.
	// Extracted from WikiPedia "Geodetic datum".
	// WGS 84 Defining Parameters
	// semi-major axis	a	6378137.0 m
	// Reciprocal of flattening	1/f	298.257223563
	
	// WGS 84 derived geometric constants
	// Semi-minor axis	b = a(1 − f)	6356752.3142 m
	// First eccentricity squared	e2 = (1 − b2/a2 = 2f − f2) =	6.69437999014 x 10−3
	// Second eccentricity squared	e′2	= (a2/b2 − 1 = f(2 − f)/(1 − f)2) = 6.73949674228 x 10−3
	//----------------------------------------------------------
	
	this.equatorialRadius = 6378137.0; // meters.
	this.polarRadius = 6356752.3142; // meters.
	this.firstEccentricitySquared = 6.69437999014E-3;
	this.secondEccentricitySquared = 6.73949674228E-3;
	this.degToRadFactor = Math.PI/180.0;
};

/**
 * @returns {Number} equatorial Radius
 */
Globe.equatorialRadius = function()
{
	return 6378137.0;
};

/**
 * @returns {Number}
 */
Globe.equatorialRadiusSquared = function()
{
	return 40680631590769.0;
};

/**
 * @returns {Number}
 */
Globe.polarRadius = function()
{
	return 6356752.3142;
};

/**
 * @returns {Number}
 */
Globe.polarRadiusSquared = function()
{
	return 40408299984087.05552164;
};
/**
 * This function returns the radius of earth at the latitude "latDeg".
 * @param latDeg the latitude
 * @returns {Number}
 */
Globe.radiusAtLatitudeDeg = function(latDeg)
{

	// a = equatorialRadius, b = polarRadius.
	// r = a*b / sqrt(a2*sin2(lat) + b2*cos2(lat)).
	//------------------------------------------------------
	
	var latRad = latDeg * Math.PI/180.0;
	var a = Globe.equatorialRadius();
	var b = Globe.polarRadius();
	var a2 = Globe.equatorialRadiusSquared();
	var b2 = Globe.polarRadiusSquared();
	
	var sin = Math.sin(latRad);
	var cos = Math.cos(latRad);
	var sin2 = sin*sin;
	var cos2 = cos*cos;
	
	var radius = (a*b)/(Math.sqrt(a2*sin2 + b2*cos2));
	return radius;
};
/**
 * Normalize the elements of the 3D feature
 * @param {Float32Array} cartesian this can be any feature such as a point or a axis to make unitary
 * 
 */
Globe.prototype.normalizeCartesian = function(cartesian)
{
	if (cartesian === undefined)
	{ return; }

	var modul = Math.sqrt(cartesian[0]*cartesian[0] + cartesian[1]*cartesian[1] + cartesian[2]*cartesian[2] );
	cartesian[0] /= modul;
	cartesian[1] /= modul;
	cartesian[2] /= modul;
	
	return cartesian;
};

/**
 * Return the transformation matrix which transform the cartesian point to wgs84
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z 
 * @param {Float32Array} float32Array
 * @returns {Float32Array} float32Array
 * 
 */
Globe.prototype.transformMatrixAtCartesianPointWgs84 = function(x, y, z, float32Array)
{
	var xAxis, yAxis, zAxis;
	
	zAxis = this.normalAtCartesianPointWgs84(x, y, z, zAxis);
	
	// Check if zAxis is vertical vector. PENDENT.
	
	// now, calculate the east direction. 
	// project zAxis to plane XY and calculate the left perpendicular.
	xAxis = new Float32Array(3);
	xAxis[0] = -y;
	xAxis[1] = x;
	xAxis[2] = 0.0;
	xAxis = this.normalizeCartesian(xAxis);
	
	// finally calculate the north direction.
	var xAxisVector = new Point3D(xAxis[0], xAxis[1], xAxis[2]);
	var yAxisVector = new Point3D();
	var zAxisVector = new Point3D(zAxis[0], zAxis[1], zAxis[2]);
	
	yAxisVector = zAxisVector.crossProduct(xAxisVector, yAxisVector);
	
	if (float32Array === undefined)
	{ float32Array = new Float32Array(16); }
	
	float32Array[0] = xAxisVector.x;
	float32Array[1] = xAxisVector.y;
	float32Array[2] = xAxisVector.z;
	float32Array[3] = 0.0;
	
	float32Array[4] = yAxisVector.x;
	float32Array[5] = yAxisVector.y;
	float32Array[6] = yAxisVector.z;
	float32Array[7] = 0.0;
	
	float32Array[8] = zAxisVector.x;
	float32Array[9] = zAxisVector.y;
	float32Array[10] = zAxisVector.z;
	float32Array[11] = 0.0;
	
	float32Array[12] = x;
	float32Array[13] = y;
	float32Array[14] = z;
	float32Array[15] = 1.0;
	
	return float32Array;
};
/**
 * function used by "MagoWorld" to paning & rotate the globe by dragging mouse.
 * @param {Line} line
 * @param {Float32Array} resultCartesian
 * @param {Number} radius
 * @returns {Float32Array} resultCartesian
 */
Globe.prototype.intersectionLineWgs84 = function(line, resultCartesian, radius)
{
	// 
	// line: (x, y, z) = x1 + t(x2 - x1), y1 + t(y2 - y1), z1 + t(z2 - z1)
	// sphere: (x - x3)^2 + (y - y3)^2 + (z - z3)^2 = r^2, where x3, y3, z3 is the center of the sphere.
	
	// line:
	var p1 = line.point;
	var lineDir = line.direction;
	var dist = 1000.0;// any value is ok.
	var p2 = new Point3D(p1.x + lineDir.x * dist, p1.y + lineDir.y * dist, p1.z + lineDir.z * dist);
	var x1 = p1.x;
	var y1 = p1.y;
	var z1 = p1.z;
	var x2 = p2.x;
	var y2 = p2.y;
	var z2 = p2.z;

	// sphere:
	var x3 = 0;
	var y3 = 0;
	var z3 = 0;
	var r = this.equatorialRadius; // provisionally.
	if (radius !== undefined)
	{ r = radius; }
	
	// resolve:
	var x21 = (x2-x1);
	var y21 = (y2-y1);
	var z21 = (z2-z1);
	
	var a = x21*x21 + y21*y21 + z21*z21;
	
	var x13 = (x1-x3);
	var y13 = (y1-y3);
	var z13 = (z1-z3);
	
	var b = 2*(x21 * x13 + y21 * y13 + z21 * z13);
	
	var c = x3*x3 + y3*y3 + z3*z3 + x1*x1 + y1*y1 + z1*z1 - 2*(x3*x1 + y3*y1+ z3*z1) - r*r;
	
	var discriminant = b*b - 4*a*c;
	
	if (discriminant < 0)
	{
		// no intersection.
		return undefined;
	}
	else if (discriminant === 0)
	{
		// this is tangent.
		if (resultCartesian === undefined)
		{ resultCartesian = []; } // Float32Array has no enough precision.
		
		var t1 = (-b)/(2*a);
		var intersectPoint1 = new Point3D(x1 + (x2 - x1)*t1, y1 + (y2 - y1)*t1, z1 + (z2 - z1)*t1);
		resultCartesian[0] = intersectPoint1.x;
		resultCartesian[1] = intersectPoint1.y;
		resultCartesian[2] = intersectPoint1.z;
		
	}
	else
	{
		// find the nearest to p1.
		var sqrtDiscriminant = Math.sqrt(discriminant);
		var t1 = (-b + sqrtDiscriminant)/(2*a);
		var t2 = (-b - sqrtDiscriminant)/(2*a);
		
		// solution 1.
		var intersectPoint1 = new Point3D(x1 + (x2 - x1)*t1, y1 + (y2 - y1)*t1, z1 + (z2 - z1)*t1);
		var intersectPoint2 = new Point3D(x1 + (x2 - x1)*t2, y1 + (y2 - y1)*t2, z1 + (z2 - z1)*t2);
		
		var dist1 = p1.squareDistToPoint(intersectPoint1);
		var dist2 = p1.squareDistToPoint(intersectPoint2);
		
		if (resultCartesian === undefined)
		{ resultCartesian = []; } // Float32Array has no enough precision.
		
		if (dist1 < dist2)
		{
			resultCartesian[0] = intersectPoint1.x;
			resultCartesian[1] = intersectPoint1.y;
			resultCartesian[2] = intersectPoint1.z;
		}
		else
		{
			resultCartesian[0] = intersectPoint2.x;
			resultCartesian[1] = intersectPoint2.y;
			resultCartesian[2] = intersectPoint2.z;
		}
	}
	
	return resultCartesian;
	
};


/**
 * Change cartesian point to WGS84 and nromalize that.
 * @param {Number} x the x coordi value of input cartesian point
 * @param {Number} y the y coordi value of input cartesian point
 * @param {Number} z the z coordi value of input cartesian point
 * @param {Float32Array} resultNormal the cartesian point which will hold the calculated result
 * @returns {Float32Array} resultNormal
 */
Globe.prototype.normalAtCartesianPointWgs84 = function(x, y, z, resultNormal)
{
	if (resultNormal === undefined)
	{ resultNormal = new Float32Array(3); }

	var equatorialRadiusSquared = this.equatorialRadius * this.equatorialRadius;
	var polarRadiusSquared = this.polarRadius * this.polarRadius;

	resultNormal[0] = x / equatorialRadiusSquared;
	resultNormal[1] = y / equatorialRadiusSquared;
	resultNormal[2] = z / polarRadiusSquared;
	
	// Normalize cartesian.
	resultNormal = this.normalizeCartesian(resultNormal);
	
	return resultNormal;
};

/**
 * Calculate atan
 * @param {Number} y
 * @param {Number} x
 * @returns {Number} 
 */
Globe.atan2Test = function(y, x) 
{
	var M_PI = Math.PI;
	if (x > 0.0)
	{
		return Math.atan(y/x);
	}
	else if (x < 0.0)
	{
		if (y >= 0.0)
		{
			return Math.atan(y/x) + M_PI;
		}
		else 
		{
			return Math.atan(y/x) - M_PI;
		}
	}
	else if (x === 0.0)
	{
		if (y>0.0)
		{
			return M_PI/2.0;
		}
		else if (y<0.0)
		{
			return -M_PI/2.0;
		}
		else 
		{
			return 0.0; // return undefined.
		}
	}
};

/**
 * Change absolute coordinate to WGS84 coordinate 
 * @param {Number} x the x coordi of the point of absolute coordinate
 * @param {Number} y the y coordi of the point of absolute coordinate
 * @param {Number} z the z coordi of the point of absolute coordinate
 * @param {Float32Array} result the cartesian point which will contain the calculated point
 * @param {Boolean} bStoreAbsolutePosition This decide whether store absolute value at the 'result' point or not as the property
 * @param {Float32Array} result
 * 
 */
Globe.CartesianToGeographicWgs84 = function (x, y, z, result, bStoreAbsolutePosition) 
{
	// From WebWorldWind.
	// According to H. Vermeille, "An analytical method to transform geocentric into geodetic coordinates"
	// http://www.springerlink.com/content/3t6837t27t351227/fulltext.pdf
	// Journal of Geodesy, accepted 10/2010, not yet published
	
	/*
	this.equatorialRadius = 6378137.0; // meters.
	this.polarRadius = 6356752.3142; // meters.
	this.firstEccentricitySquared = 6.69437999014E-3;
	this.secondEccentricitySquared = 6.73949674228E-3;
	this.degToRadFactor = Math.PI/180.0;
	*/
	var firstEccentricitySquared = 6.69437999014E-3;
	var equatorialRadius = 6378137.0;
	/*
	var X = z,
		Y = x,
		Z = y,
		*/
	var X = x,
		Y = y,
		Z = z,
		XXpYY = X * X + Y * Y,
		sqrtXXpYY = Math.sqrt(XXpYY),
		a = equatorialRadius,
		ra2 = 1 / (a * a),
		e2 = firstEccentricitySquared,
		e4 = e2 * e2,
		p = XXpYY * ra2,
		q = Z * Z * (1 - e2) * ra2,
		r = (p + q - e4) / 6,
		h,
		phi,
		u,
		evoluteBorderTest = 8 * r * r * r + e4 * p * q,
		rad1,
		rad2,
		rad3,
		atan,
		v,
		w,
		k,
		D,
		sqrtDDpZZ,
		e,
		lambda,
		s2;

	if (evoluteBorderTest > 0 || q !== 0) 
	{
		if (evoluteBorderTest > 0) 
		{
			// Step 2: general case
			rad1 = Math.sqrt(evoluteBorderTest);
			rad2 = Math.sqrt(e4 * p * q);

			// 10*e2 is my arbitrary decision of what Vermeille means by "near... the cusps of the evolute".
			if (evoluteBorderTest > 10 * e2) 
			{
				rad3 = Math.cbrt((rad1 + rad2) * (rad1 + rad2));
				u = r + 0.5 * rad3 + 2 * r * r / rad3;
			}
			else 
			{
				u = r + 0.5 * Math.cbrt((rad1 + rad2) * (rad1 + rad2))
					+ 0.5 * Math.cbrt((rad1 - rad2) * (rad1 - rad2));
			}
		}
		else 
		{
			// Step 3: near evolute
			rad1 = Math.sqrt(-evoluteBorderTest);
			rad2 = Math.sqrt(-8 * r * r * r);
			rad3 = Math.sqrt(e4 * p * q);
			//atan = 2 * Math.atan2(rad3, rad1 + rad2) / 3;
			atan = 2 * Globe.atan2Test(rad3, rad1 + rad2) / 3;

			u = -4 * r * Math.sin(atan) * Math.cos(Math.PI / 6 + atan);
		}

		v = Math.sqrt(u * u + e4 * q);
		w = e2 * (u + v - q) / (2 * v);
		k = (u + v) / (Math.sqrt(w * w + u + v) + w);
		D = k * sqrtXXpYY / (k + e2);
		sqrtDDpZZ = Math.sqrt(D * D + Z * Z);

		h = (k + e2 - 1) * sqrtDDpZZ / k;
		//phi = 2 * Math.atan2(Z, sqrtDDpZZ + D);
		phi = 2 * Globe.atan2Test(Z, sqrtDDpZZ + D);
	}
	else 
	{
		// Step 4: singular disk
		rad1 = Math.sqrt(1 - e2);
		rad2 = Math.sqrt(e2 - p);
		e = Math.sqrt(e2);

		h = -a * rad1 * rad2 / e;
		phi = rad2 / (e * rad2 + rad1 * Math.sqrt(p));
	}

	// Compute lambda
	s2 = Math.sqrt(2);
	if ((s2 - 1) * Y < sqrtXXpYY + X) 
	{
		// case 1 - -135deg < lambda < 135deg
		//lambda = 2 * Math.atan2(Y, sqrtXXpYY + X);
		lambda = 2 * Globe.atan2Test(Y, sqrtXXpYY + X);
	}
	else if (sqrtXXpYY + Y < (s2 + 1) * X) 
	{
		// case 2 - -225deg < lambda < 45deg
		//lambda = -Math.PI * 0.5 + 2 * Math.atan2(X, sqrtXXpYY - Y);
		lambda = -Math.PI * 0.5 + 2 * Globe.atan2Test(X, sqrtXXpYY - Y);
	}
	else 
	{
		// if (sqrtXXpYY-Y<(s2=1)*X) {  // is the test, if needed, but it's not
		// case 3: - -45deg < lambda < 225deg
		//lambda = Math.PI * 0.5 - 2 * Math.atan2(X, sqrtXXpYY + Y);
		lambda = Math.PI * 0.5 - 2 * Globe.atan2Test(X, sqrtXXpYY + Y);
	}

	if (result === undefined)
	{ result = new GeographicCoord(); }

	var factor = 180.0 / Math.PI;
	result.latitude = factor * phi;
	result.longitude = factor * lambda;
	result.altitude = h;
	
	if (bStoreAbsolutePosition !== undefined && bStoreAbsolutePosition === true)
	{
		// In this case, store into result_geographicCoord the x, y, z values.
		if (result.absolutePoint === undefined)
		{ result.absolutePoint = new Point3D(x, y, z); }
		else
		{ result.absolutePoint.set(x, y, z); }
	}

	return result;
};

/**
 * This change the GeographicCoord feature to Point2D feature
 * @param {Number} longitude
 * @param {Number} latitude
 * @param {Point2D} resultPoint2d
 * @returns {Point2D} 
 */
Globe.geographicToMercatorProjection = function(longitude, latitude, resultPoint2d) 
{
	// longitude = [-180, 180].
	// latitude = [-90, 90].
	var degToRadFactor = Math.PI/180.0;
	var lonRad = longitude * degToRadFactor;
	var latRad = latitude * degToRadFactor;
	
	return Globe.geographicRadianToMercatorProjection(lonRad, latRad, resultPoint2d);
};

/**
 * This change the GeographicCoord feature to Point2D feature using Mercator projection
 * @param {Number} lonRad
 * @param {Number} latRad
 * @param {Point2D} resultPoint2d
 * @returns {Point2D}
 */
Globe.geographicRadianToMercatorProjection = function(lonRad, latRad, resultPoint2d) 
{
	// longitude = [-pi, pi].
	// latitude = [-pi/2, pi/2].
	var equatorialRadius = Globe.equatorialRadius();
	if (resultPoint2d === undefined)
	{ resultPoint2d = new Point2D(); }

	resultPoint2d.set(equatorialRadius * lonRad, equatorialRadius * latRad);
	
	return resultPoint2d;
};

/**
 * This change the GeographicCoord feature to the cartesian WGS84 point using the blow method.
 * defined in the LINZ standard LINZS25000 (Standard for New Zealand Geodetic Datum 2000)
 * https://www.linz.govt.nz/data/geodetic-system/coordinate-conversion/geodetic-datum-conversions/equations-used-datum
 * @param {Number} longitude
 * @param {Number} latitude
 * @param {Number} altitude
 * @param {Float32Array} resultCartesian
 * @returns {Float32Array} resultCartesian
 */
Globe.geographicToCartesianWgs84 = function(longitude, latitude, altitude, resultCartesian)
{
	// a = semi-major axis.
	// e2 = firstEccentricitySquared.
	// v = a / sqrt(1 - e2 * sin2(lat)).
	// x = (v+h)*cos(lat)*cos(lon).
	// y = (v+h)*cos(lat)*sin(lon).
	// z = [v*(1-e2)+h]*sin(lat).
	var degToRadFactor = Math.PI/180.0;
	var equatorialRadius = Globe.equatorialRadius();
	var firstEccentricitySquared = 6.69437999014E-3;
	var lonRad = longitude * degToRadFactor;
	var latRad = latitude * degToRadFactor;
	var cosLon = Math.cos(lonRad);
	var cosLat = Math.cos(latRad);
	var sinLon = Math.sin(lonRad);
	var sinLat = Math.sin(latRad);
	var a = equatorialRadius;
	var e2 = firstEccentricitySquared;
	var v = a/Math.sqrt(1.0 - e2 * sinLat * sinLat);
	var h = altitude;
	
	if (resultCartesian === undefined)
	{ resultCartesian = []; }
	
	resultCartesian[0]=(v+h)*cosLat*cosLon;
	resultCartesian[1]=(v+h)*cosLat*sinLon;
	resultCartesian[2]=(v*(1.0-e2)+h)*sinLat;
	
	return resultCartesian;
};
/**
 * This change the array of the absolute coordinates represented as the angle to the array of WGS84
 * @param {Number} longitude
 * @param {Number} latitude
 * @param {Number} altitude
 * @param {Float32Array} resultCartesian
 * @returns {Float32Array} resultCartesian
 */

Globe.geographicRadianArrayToFloat32ArrayWgs84 = function(lonArray, latArray, altArray, resultCartesianArray)
{
	// defined in the LINZ standard LINZS25000 (Standard for New Zealand Geodetic Datum 2000)
	// https://www.linz.govt.nz/data/geodetic-system/coordinate-conversion/geodetic-datum-conversions/equations-used-datum
	// a = semi-major axis.
	// e2 = firstEccentricitySquared.
	// v = a / sqrt(1 - e2 * sin2(lat)).
	// x = (v+h)*cos(lat)*cos(lon).
	// y = (v+h)*cos(lat)*sin(lon).
	// z = [v*(1-e2)+h]*sin(lat).
	var equatorialRadius = 6378137.0; // meters.
	var firstEccentricitySquared = 6.69437999014E-3;
	
	var lonRad;
	var latRad;
	var cosLon;
	var cosLat;
	var sinLon;
	var sinLat;
	var a = equatorialRadius;
	var e2 = firstEccentricitySquared;
	var e2a = 1.0 - e2;
	var v;
	var h;
	
	var coordsCount = lonArray.length;
	if (resultCartesianArray === undefined)
	{
		resultCartesianArray = new Float32Array(coordsCount*3);
	}
	for (var i=0; i<coordsCount; i++)
	{
		lonRad = lonArray[i];
		latRad = latArray[i];
		cosLon = Math.cos(lonRad);
		cosLat = Math.cos(latRad);
		sinLon = Math.sin(lonRad);
		sinLat = Math.sin(latRad);
		v = a/Math.sqrt(1.0 - e2 * sinLat * sinLat);
		h = altArray[i];
		
		resultCartesianArray[i*3] = (v+h)*cosLat*cosLon;
		resultCartesianArray[i*3+1] = (v+h)*cosLat*sinLon;
		resultCartesianArray[i*3+2] = (v*e2a+h)*sinLat;
	}
	
	return resultCartesianArray;
};

		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
'use strict';

/**
 * Main Mago class.
 * @class MagoManager
 */
var MagoManager = function() 
{
	if (!(this instanceof MagoManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * Auxiliary renderer.
	 * @type {Renderer}
	 * @default Renderer.
	 */
	this.renderer = new Renderer(this);
	
	/**
	 * Manages the selected objects.
	 * @type {SelectionManager}
	 * @default SelectionManager.
	 */
	this.selectionManager = new SelectionManager();
	
	/**
	 * Manages the shaders.
	 * @type {PostFxShadersManager}
	 * @default PostFxShadersManager.
	 */
	this.postFxShadersManager = new PostFxShadersManager();
	
	/**
	 * Manages the request & loading files.
	 * @type {ReaderWriter}
	 * @default ReaderWriter.
	 */
	this.readerWriter = new ReaderWriter();
	
	/**
	 * Contains the Mago3D policy data.
	 * @type {Policy}
	 * @default Policy.
	 */
	this.magoPolicy = new Policy();
	
	/**
	 * Manages & controls the movement of the objects in the scene.
	 * @type {AnimationManager}
	 * @default undefined.
	 */
	this.animationManager; 
	
	/**
	 * Manages & controls all the textures.
	 * @type {TexturesManager}
	 * @default TexturesManager.
	 */
	this.texturesManager = new TexturesManager(this);
	
	/**
	 * Manages & controls the tiles.
	 * @type {SmartTileManager}
	 * @default SmartTileManager.
	 */
	this.smartTileManager = new SmartTileManager();
	
	/**
	 * Manages & controls the deleting objects queue.
	 * @type {ProcessQueue}
	 * @default ProcessQueue.
	 */
	this.processQueue = new ProcessQueue();
	
	/**
	 * Manages & controls the parsing of loaded files.
	 * @type {ParseQueue}
	 * @default ParseQueue.
	 */
	this.parseQueue = new ParseQueue();
	
	/**
	 * Manages & controls the creation of the nodes (node = main object in Mago3D).
	 * @type {HierarchyManager}
	 * @default HierarchyManager.
	 */
	this.hierarchyManager = new HierarchyManager();

	/**
	 * Depth framebuffer object.
	 * @type {FBO}
	 * @default undefined.
	 */
	this.depthFboNeo;
	
	/**
	 * Depth framebuffer object for auxiliary and test use.
	 * @type {FBO}
	 * @default undefined.
	 */
	this.depthFboAux;
	
	/**
	 * Framebuffer object used for color coding selection.
	 * @type {FBO}
	 * @default undefined.
	 */
	this.selectionFbo; 
	
	/**
	 * Current x position of the mouse in screen coordinates.
	 * @type {Number}
	 * @default 0.
	 */
	this.mouse_x = 0;
	
	/**
	 * Current y position of the mouse in screen coordinates.
	 * @type {Number}
	 * @default 0.
	 */
	this.mouse_y = 0;
	
	
	this.mouseLeftDown = false;
	this.mouseMiddleDown = false;
	this.mouseDragging = false;
	this.selObjMovePlane;

	this.objectSelected;
	this.buildingSelected;
	this.octreeSelected;
	this.nodeSelected;

	this.mustCheckIfDragging = true;
	this.thereAreStartMovePoint = false;
	this.startMovPoint = new Point3D();
	
	this.configInformation;
	this.cameraFPV = new FirstPersonView();
	this.myCameraSCX;
	
	var serverPolicy = MagoConfig.getPolicy();
	if (serverPolicy !== undefined)
	{
		this.magoPolicy.setLod0DistInMeters(serverPolicy.geo_lod0);
		this.magoPolicy.setLod1DistInMeters(serverPolicy.geo_lod1);
		this.magoPolicy.setLod2DistInMeters(serverPolicy.geo_lod2);
		this.magoPolicy.setLod3DistInMeters(serverPolicy.geo_lod3);
		this.magoPolicy.setLod4DistInMeters(serverPolicy.geo_lod4);
		this.magoPolicy.setLod5DistInMeters(serverPolicy.geo_lod5);
	}

	this.kernel = [ 0.33, 0.0, 0.85,
		0.25, 0.3, 0.5,
		0.1, 0.3, 0.85,
		-0.15, 0.2, 0.85,
		-0.33, 0.05, 0.6,
		-0.1, -0.15, 0.85,
		-0.05, -0.32, 0.25,
		0.2, -0.15, 0.85,
		0.6, 0.0, 0.55,
		0.5, 0.6, 0.45,
		-0.01, 0.7, 0.35,
		-0.33, 0.5, 0.45,
		-0.45, 0.0, 0.55,
		-0.65, -0.5, 0.7,
		0.0, -0.5, 0.55,
		0.33, 0.3, 0.35];

	// Test for sphere.***
	this.sphereKernel = [];
	var kernelSize = 16;
	for (var i=0; i<kernelSize; i++) 
	{
		this.sphereKernel.push(2.0 * (Math.random() - 0.5));
		this.sphereKernel.push(2.0 * (Math.random() - 0.5));
		this.sphereKernel.push(2.0 * (Math.random() - 0.5));
	}
	// End ssao.------------------------------------------------
	
	// var to delete.*********************************************
	this.loadQueue = new LoadQueue(this); // Old. delete.***

	// Vars.****************************************************************
	this.sceneState = new SceneState(); // this contains all scene mtrices and camera position.***
	this.selectionColor = new SelectionColor();
	this.vboMemoryManager = new VBOMemoryManager();
	

	this.fileRequestControler = new FileRequestControler();
	this.visibleObjControlerOctrees = new VisibleObjectsController(); 
	this.visibleObjControlerNodes = new VisibleObjectsController(); 
	this.visibleObjControlerTerrain = new VisibleObjectsController(); 
	
	this.boundingSphere_Aux; 
	this.radiusAprox_aux;

	this.lastCamPos = new Point3D();
	this.squareDistUmbral = 22.0;

	this.lowestOctreeArray = [];

	this.backGround_fileReadings_count = 0; // this can be as max = 9.***
	this.backGround_imageReadings_count = 0;
	this.isCameraMoving = false; 
	this.isCameraInsideNeoBuilding = false;
	this.renderingFase = 0;

	this.bPicking = false;
	this.scene;

	this.numFrustums;
	this.isLastFrustum = false;
	this.currentFrustumIdx = 0;
	this.highLightColor4 = new Float32Array([0.2, 1.0, 0.2, 1.0]);
	this.thereAreUrgentOctrees = false;
	
	this.hierarchyManager = new HierarchyManager();
	
	// small object size.
	this.smallObjectSize = 0.153;
	
	// sqrtTable.
	
	this.sqrtTable = new Float32Array(11);
	// make 100 values.
	var increValue = 0.1;
	for (var i=0; i<11; i++)
	{
		this.sqrtTable[i] = Math.sqrt(1+(increValue*i)*(increValue*i));
	}
	
	this.managerUtil = new ManagerUtils();

	// CURRENTS.********************************************************************
	this.currentSelectedObj_idx = -1;
	this.currentByteColorPicked = new Uint8Array(4);
	this.currentShader;

	// SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.***
	this.pointSC= new Point3D();
	this.pointSC_2= new Point3D();
	this.arrayAuxSC = [];

	this.currentTimeSC;
	this.dateSC = new Date();
	this.startTimeSC;
	this.maxMilisecondsForRender = 10;

	this.terranTileSC;

	this.resultRaySC = new Float32Array(3);
	this.matrix4SC = new Matrix4();
	this.axisXYZ = new AxisXYZ();

	this.demoBlocksLoaded = false;

	this.objMarkerManager = new ObjectMarkerManager();
	this.pin = new Pin();
	
	//this.weatherStation = new WeatherStation();
	
	// renderWithTopology === 0 -> render only CityGML.***
	// renderWithTopology === 1 -> render only IndoorGML.***
	// renderWithTopology === 2 -> render both.***
	this.tempSettings = {};
	this.tempSettings.renderWithTopology = 1;
	this.tempSettings.renderSpaces = true;
	this.tempSettings.spacesAlpha = 0.6;
	
	//this.tinTerrainManager = new TinTerrainManager();
};

/**
 * object 를 그리는 두가지 종류의 function을 호출
 */
MagoManager.prototype.init = function(gl) 
{
	this.bInit = true;
	
	if (this.sceneState.gl === undefined)
	{ this.sceneState.gl = gl; }
	if (this.vboMemoryManager.gl === undefined)
	{ this.vboMemoryManager.gl = gl; }
};

/**
 * object 를 그리는 두가지 종류의 function을 호출
 * @param scene 변수 Cesium Scene.
 * @param pass 변수
 * @param frustumIdx 변수
 * @param numFrustums 변수
 */
MagoManager.prototype.start = function(scene, pass, frustumIdx, numFrustums) 
{
	// Calculate FPS.
	//var start = new Date().getTime();
	
	// this is cesium version.***
	// mago3d 활성화가 아니면 화면을 그리지 않음
	if (!this.magoPolicy.getMagoEnable()) { return; }

	var isLastFrustum = false;
	this.numFrustums = numFrustums;
	this.currentFrustumIdx = this.numFrustums-frustumIdx-1;
	if (this.currentFrustumIdx === numFrustums-1) 
	{
		isLastFrustum = true;
		this.isLastFrustum = true;
	}

	// cesium 새 버전에서 지원하지 않음
	var picking = pass.pick;
	if (picking) 
	{
		//
	}
	else 
	{
		if (this.configInformation === undefined)
		{
			this.configInformation = MagoConfig.getPolicy();
		}
		if (scene)
		{
			var gl = scene.context._gl;
			gl.getExtension("EXT_frag_depth");
			
			if (!this.bInit)
			{ this.init(gl); }
		
			if (gl.isContextLost())
			{ return; }

			
		}

		this.startRender(isLastFrustum, this.currentFrustumIdx, numFrustums);
			
	}
};

/**
 * Swaps the current rendering Phase.
 */
MagoManager.prototype.swapRenderingFase = function() 
{
	this.renderingFase = !this.renderingFase;
};

/**
 * 빌딩을 준비(새버전)
 * @param {gl} gl
 */
MagoManager.prototype.prepareNeoBuildingsAsimetricVersion = function(gl, visibleObjControlerNodes) 
{
	// for all renderables, prepare data.***
	var neoBuilding;
	var node, rootNode;
	var projectFolderName;
	var neoBuildingFolderName;
	//var geometryDataPath = this.readerWriter.getCurrentDataPath();
	var geometryDataPath = this.readerWriter.geometryDataPath; // default geometryDataPath = "/f4d".***
	if (this.headersRequestedCounter === undefined)
	{ this.headersRequestedCounter = 0; }

	var currentVisibleNodes = [].concat(visibleObjControlerNodes.currentVisibles0, visibleObjControlerNodes.currentVisibles2, visibleObjControlerNodes.currentVisibles3, visibleObjControlerNodes.currentVisiblesAux);
	for (var i=0, length = currentVisibleNodes.length; i<length; i++) 
	{
		node = currentVisibleNodes[i];
		
		// Check if the node is a referenceNode.***
		var attributes = node.data.attributes;
		if (attributes.projectId !== undefined && attributes.isReference !== undefined && attributes.isReference === true)
		{
			// check if has neoBuilding.***
			neoBuilding = currentVisibleNodes[i].data.neoBuilding;
			if (neoBuilding === undefined)
			{
				var neoBuildingFolderName = attributes.buildingFolderName;
				projectFolderName = attributes.projectFolderName;
				
				// demand to staticModelsManager the neoBuilding.***
				var projectId = attributes.projectId;
				var staticModelsManager = this.hierarchyManager.getStaticModelsManager();
				var staticModel = staticModelsManager.getStaticModel(projectId);
				neoBuilding = staticModel.neoBuilding;
				neoBuildingFolderName = staticModel.buildingFolderName;
				projectFolderName = staticModel.projectFolderName;
				
				//neoBuilding = staticModelsManager.getStaticModel(staticModelDataPath);
				
				// make a buildingSeed.***
				var buildingSeed = new BuildingSeed();
				buildingSeed.fisrtName = neoBuildingFolderName;
				buildingSeed.name = neoBuildingFolderName;
				buildingSeed.buildingId = neoBuildingFolderName;
				buildingSeed.buildingFileName = neoBuildingFolderName;
				buildingSeed.geographicCoord = new GeographicCoord(attributes.longitude, attributes.latitude, attributes.height); // class : GeographicCoord.
				buildingSeed.rotationsDegree = new Point3D(attributes.pitch, attributes.roll, attributes.heading); // class : Point3D. (heading, pitch, roll).
				buildingSeed.bBox = new BoundingBox();           // class : BoundingBox.
				buildingSeed.bBox.init();
				buildingSeed.bBox.expand(10.0); // we dont know the bbox size, provisionally set as 10,10,10.***
				buildingSeed.geographicCoordOfBBox = new GeographicCoord(attributes.longitude, attributes.latitude, attributes.height);  // class : GeographicCoord.
				buildingSeed.smartTileOwner;
				
				// Now, set neoBuildings parameters.***
				neoBuilding.buildingFileName = neoBuildingFolderName;
				neoBuilding.nodeOwner = node;
				node.data.neoBuilding = neoBuilding;
				node.data.buildingSeed = buildingSeed;
				node.data.projectFolderName = projectFolderName;

				if (neoBuilding.metaData === undefined) 
				{ 
					neoBuilding.metaData = new MetaData(); 
					
					if (neoBuilding.metaData.geographicCoord === undefined)
					{ neoBuilding.metaData.geographicCoord = new GeographicCoord(); }

					if (neoBuilding.metaData.bbox === undefined) 
					{ neoBuilding.metaData.bbox = new BoundingBox(); }
				
					neoBuilding.metaData.geographicCoord.setLonLatAlt(buildingSeed.geographicCoord.longitude, buildingSeed.geographicCoord.latitude, buildingSeed.geographicCoord.altitude);
					neoBuilding.metaData.bbox.copyFrom(buildingSeed.bBox);
					neoBuilding.metaData.heading = buildingSeed.rotationsDegree.z;
					neoBuilding.metaData.pitch = buildingSeed.rotationsDegree.x;
					neoBuilding.metaData.roll = buildingSeed.rotationsDegree.y;
				}

				neoBuilding.name = "test_" + neoBuildingFolderName;
				neoBuilding.buildingId = neoBuildingFolderName;
			
				neoBuilding.buildingType = "basicBuilding";
				//nodeBbox.copyFrom(buildingSeed.bBox); // initially copy from building.
				if (neoBuilding.bbox === undefined)
				{ neoBuilding.bbox = new BoundingBox(); }
				neoBuilding.bbox.copyFrom(buildingSeed.bBox);
				neoBuilding.projectFolderName = node.data.projectFolderName;
			}
		}
		else 
		{
			projectFolderName = node.data.projectFolderName;
			neoBuilding = currentVisibleNodes[i].data.neoBuilding;
		}
		
		// Check if this node has topologyData.***
		/*
		if(node.data && node.data.attributes && node.data.attributes.hasTopology)
		{
			if(neoBuilding.network === undefined)
			{
				// load topologyData for this node.***
				neoBuilding.network = new Network(node);
				var network = neoBuilding.network;
				var magoManager = this;
				
				var geometryDataPath = this.readerWriter.geometryDataPath;
				var indoorGml_filePath = geometryDataPath + "/"  + projectFolderName + "/"  + neoBuilding.buildingFileName + "/topology.json";
				
				loadWithXhr(indoorGml_filePath).done(function(response) 
				{
					var enc = new TextDecoder("utf-8");
					var stringText = enc.decode(response);
					var SampleIndoorJson = JSON.parse(stringText);
					var gmlDataContainer = new GMLDataContainer(SampleIndoorJson, "1.0.3");
					network.parseTopologyData(magoManager, gmlDataContainer);
					
				}).fail(function(status) 
				{
					
				}).always(function() 
				{
					
				});
			}
	
		}
		*/

		// check if this building is ready to render.***
		// 1) MetaData
		var metaData = neoBuilding.metaData;
		if (metaData.fileLoadState === CODE.fileLoadState.READY) 
		{
			projectFolderName = neoBuilding.projectFolderName;
			if (this.fileRequestControler.isFullHeaders())	{ return; }
			var neoBuildingHeaderPath = geometryDataPath + "/"  + projectFolderName + "/"  + neoBuilding.buildingFileName + "/HeaderAsimetric.hed";
			
			this.readerWriter.getNeoHeaderAsimetricVersion(gl, neoBuildingHeaderPath, neoBuilding, this.readerWriter, this); // Here makes the tree of octree.***
		}
		
	}
	currentVisibleNodes.length = 0;
};

/**
 * Here updates the modelView matrices.
 * @param {SceneState} sceneState
 */
MagoManager.prototype.upDateSceneStateMatrices = function(sceneState) 
{
	if (this.myCameraSCX === undefined) 
	{ this.myCameraSCX = new Camera(); }

	if (this.configInformation === undefined) 
	{
		// We are on MagoWorld. No need update matrices.***
		return;
	}

	if (this.configInformation.geo_view_library === Constant.CESIUM)
	{
		// * if this is in Cesium:
		var scene = this.scene;
		var uniformState = scene._context.uniformState;
		
		// check if the matrices changed.***
		// compare with the lastModelViewProjectionMatrix.***

		//var uniformState = scene._context._us;
		Cesium.Matrix4.toArray(uniformState._modelViewProjectionRelativeToEye, sceneState.modelViewProjRelToEyeMatrix._floatArrays);
		Cesium.Matrix4.toArray(uniformState._modelViewProjection, sceneState.modelViewProjMatrix._floatArrays); // always dirty.
		Cesium.Matrix4.toArray(uniformState._modelViewRelativeToEye, sceneState.modelViewRelToEyeMatrix._floatArrays);
		
		sceneState.modelViewRelToEyeMatrixInv._floatArrays = Cesium.Matrix4.inverseTransformation(sceneState.modelViewRelToEyeMatrix._floatArrays, sceneState.modelViewRelToEyeMatrixInv._floatArrays);// original.***
		sceneState.modelViewMatrix._floatArrays = Cesium.Matrix4.clone(uniformState.view, sceneState.modelViewMatrix._floatArrays);
		Cesium.Matrix4.toArray(uniformState._projection, sceneState.projectionMatrix._floatArrays);

		var cameraPosition = scene.context._us._cameraPosition;
		ManagerUtils.calculateSplited3fv([cameraPosition.x, cameraPosition.y, cameraPosition.z], sceneState.encodedCamPosHigh, sceneState.encodedCamPosLow);

		sceneState.modelViewMatrixInv._floatArrays = Cesium.Matrix4.inverseTransformation(sceneState.modelViewMatrix._floatArrays, sceneState.modelViewMatrixInv._floatArrays);// original.***
		sceneState.normalMatrix4._floatArrays = Cesium.Matrix4.transpose(sceneState.modelViewMatrixInv._floatArrays, sceneState.normalMatrix4._floatArrays);// original.***
		
		var frustumCommandsList = this.scene._frustumCommandsList;
		if (frustumCommandsList === undefined)
		{ frustumCommandsList = this.scene.frustumCommandsList; }
		
		// Update sceneState camera.***
		this.upDateCamera(sceneState.camera);
		
		var camPosX = this.scene.camera.positionWC.x;
		var camPosY = this.scene.camera.positionWC.y;
		var camPosZ = this.scene.camera.positionWC.z;
		var camDirX = this.scene.camera.direction.x;
		var camDirY = this.scene.camera.direction.y;
		var camDirZ = this.scene.camera.direction.z;
		var camUpX = this.scene.camera.up.x;
		var camUpY = this.scene.camera.up.y;
		var camUpZ = this.scene.camera.up.z;
		if (sceneState.camera.isCameraMoved(camPosX, camPosY, camPosZ, camDirX, camDirY, camDirZ, camUpX, camUpY, camUpZ ))
		{
			this.isCameraMoved = true;
		}
					
		sceneState.drawingBufferWidth[0] = scene.drawingBufferWidth;
		sceneState.drawingBufferHeight[0] = scene.drawingBufferHeight;
	}
	else if (this.configInformation.geo_view_library === Constant.MAGOWORLD)
	{
		var camera = sceneState.camera;
		var camPos = camera.position;
		var frustum0 = camera.getFrustum(0);
		sceneState.camera.frustum.aspectRatio = sceneState.drawingBufferWidth / sceneState.drawingBufferHeight;
		// determine frustum near & far.***
		var camHeight = camera.getCameraElevation();
		var eqRadius = Globe.equatorialRadius();
		frustum0.far[0] = (eqRadius + camHeight);
		//frustum0.far[0] = 30000000.0;
		frustum0.near[0] = 0.1 + camHeight / 10000000;
		
		
		ManagerUtils.calculateSplited3fv([camPos.x, camPos.y, camPos.z], sceneState.encodedCamPosHigh, sceneState.encodedCamPosLow);
		
		// projection.***
		// considere near as zero provisionally.***
		sceneState.projectionMatrix._floatArrays = glMatrix.mat4.perspective(sceneState.projectionMatrix._floatArrays, frustum0.fovyRad[0], frustum0.aspectRatio, 0.0, frustum0.far[0]);
		
		// modelView.***
		//sceneState.modelViewMatrix._floatArrays; 
		sceneState.modelViewMatrixInv._floatArrays = glMatrix.mat4.invert(sceneState.modelViewMatrixInv._floatArrays, sceneState.modelViewMatrix._floatArrays);
	
		// normalMat.***
		sceneState.normalMatrix4._floatArrays = glMatrix.mat4.transpose(sceneState.normalMatrix4._floatArrays, sceneState.modelViewMatrixInv._floatArrays);
		
		// modelViewRelToEye.***
		sceneState.modelViewRelToEyeMatrix._floatArrays = glMatrix.mat4.copy(sceneState.modelViewRelToEyeMatrix._floatArrays, sceneState.modelViewMatrix._floatArrays);
		sceneState.modelViewRelToEyeMatrix._floatArrays[12] = 0;
		sceneState.modelViewRelToEyeMatrix._floatArrays[13] = 0;
		sceneState.modelViewRelToEyeMatrix._floatArrays[14] = 0;
		sceneState.modelViewRelToEyeMatrix._floatArrays[15] = 1;
		sceneState.modelViewRelToEyeMatrixInv._floatArrays = glMatrix.mat4.invert(sceneState.modelViewRelToEyeMatrixInv._floatArrays, sceneState.modelViewRelToEyeMatrix._floatArrays);
		
		// modelViewProjection.***
		sceneState.modelViewProjMatrix._floatArrays = glMatrix.mat4.multiply(sceneState.modelViewProjMatrix._floatArrays, sceneState.projectionMatrix._floatArrays, sceneState.modelViewMatrix._floatArrays);

		// modelViewProjectionRelToEye.***
		sceneState.modelViewProjRelToEyeMatrix.copyFromMatrix4(sceneState.modelViewProjMatrix);
		sceneState.modelViewProjRelToEyeMatrix._floatArrays[12] = 0;
		sceneState.modelViewProjRelToEyeMatrix._floatArrays[13] = 0;
		sceneState.modelViewProjRelToEyeMatrix._floatArrays[14] = 0;
		sceneState.modelViewProjRelToEyeMatrix._floatArrays[15] = 1;
		

		frustum0.tangentOfHalfFovy[0] = Math.tan(frustum0.fovyRad[0]/2);
		
	}
	
	if (this.depthFboNeo !== undefined)
	{
		var noiseTexture = this.texturesManager.getNoiseTexture4x4();
		sceneState.ssaoNoiseScale2[0] = this.depthFboNeo.width[0]/noiseTexture.width;
		sceneState.ssaoNoiseScale2[1] = this.depthFboNeo.height[0]/noiseTexture.height;
	}
	
	// set the auxiliar camera.
	this.myCameraSCX.direction.set(sceneState.camera.direction.x, sceneState.camera.direction.y, sceneState.camera.direction.z);
	this.myCameraSCX.up.set(sceneState.camera.up.x, sceneState.camera.up.y, sceneState.camera.up.z);
	var frustum0 = this.myCameraSCX.getFrustum(0);
	var sceneCamFurustum0 = sceneState.camera.getFrustum(0);
	frustum0.near[0] = sceneCamFurustum0.near[0];
	frustum0.far[0] = sceneCamFurustum0.far[0];
	frustum0.fovyRad[0] = sceneCamFurustum0.fovyRad[0];
	frustum0.tangentOfHalfFovy[0] = sceneCamFurustum0.tangentOfHalfFovy[0];
	frustum0.fovRad[0] = sceneCamFurustum0.fovRad[0];
	frustum0.aspectRatio[0] = sceneCamFurustum0.aspectRatio[0];
	
	
};

/**
 * Here updates the camera's parameters and frustum planes.
 * @param {Camera} camera
 */
MagoManager.prototype.upDateCamera = function(resultCamera) 
{
	if (this.configInformation.geo_view_library === Constant.CESIUM)
	{
		var scene = this.scene;
		var frustumCommandsList = scene.frustumCommandsList;
		var frustumIdx = this.currentFrustumIdx;
		var camera = this.sceneState.camera;
		var currentFrustumFar = frustumCommandsList[frustumIdx].far;
		var currentFrustumNear = frustumCommandsList[frustumIdx].near;
		
		// take all frustums near-far distances.***
		// In Cesium: If useLogDepth opaqueFrustumNearOffset = 0.9. Else opaqueFrustumNearOffset = 0.9999;
		var nearOffset = scene.opaqueFrustumNearOffset;
		var numFrustums = frustumCommandsList.length;
		var distancesArray = [];
		var tanHalfFovy = undefined;
		for (var i=0; i<numFrustums; i++)
		{
			distancesArray[i*2] = frustumCommandsList[i].near;
			distancesArray[i*2+1] = frustumCommandsList[i].far;
			
			if ( i !== 0 )
			{ distancesArray[i*2] *= nearOffset; }
			
			// Set frustum parameters.***
			var frustum = camera.getFrustum(i);
			frustum.far[0] = frustumCommandsList[i].far; 
			frustum.near[0] = frustumCommandsList[i].near;
			frustum.fovRad[0] = scene.camera.frustum._fov;
			frustum.fovyRad[0]= scene.camera.frustum._fovy;
			frustum.aspectRatio[0] = scene.camera.frustum._aspectRatio;
			if (tanHalfFovy === undefined)
			{ tanHalfFovy = Math.tan(frustum.fovyRad/2); }
			frustum.tangentOfHalfFovy[0] = tanHalfFovy;
		}
		
		// Set cam dir & up by modelViewMatrix.***
		var sceneState = this.sceneState;
		var modelViewMatInv = sceneState.modelViewMatrixInv;
		//var camPosX = modelViewMatInv._floatArrays[12]; // No enough precision. 
		//var camPosY = modelViewMatInv._floatArrays[13]; // No enough precision. 
		//var camPosZ = modelViewMatInv._floatArrays[14]; // No enough precision. 
		
		var camPosX = scene.camera.positionWC.x;
		var camPosY = scene.camera.positionWC.y;
		var camPosZ = scene.camera.positionWC.z;
		
		var camDirX = -modelViewMatInv._floatArrays[8];
		var camDirY = -modelViewMatInv._floatArrays[9];
		var camDirZ = -modelViewMatInv._floatArrays[10];
		
		var camUpX = modelViewMatInv._floatArrays[4];
		var camUpY = modelViewMatInv._floatArrays[5];
		var camUpZ = modelViewMatInv._floatArrays[6];
		
		resultCamera.position.set(camPosX, camPosY, camPosZ);
		resultCamera.direction.set(camDirX, camDirY, camDirZ);
		resultCamera.up.set(camUpX, camUpY, camUpZ);
		
		var aspectRatio = frustum.aspectRatio;
		var fovy = frustum.fovyRad;	
		
		frustum = resultCamera.getFrustum(frustumIdx);
		resultCamera.frustum.near[0] = currentFrustumNear;
		resultCamera.frustum.far[0] = currentFrustumFar;
		resultCamera.setFrustumsDistances(numFrustums, distancesArray);
		resultCamera.setAspectRatioAndFovyRad(aspectRatio, fovy);
		resultCamera.calculateFrustumsPlanes();
		
		//resultCamera.currentFrustumFar
	}
	else if (this.configInformation.geo_view_library === Constant.MAGOWORLD)
	{
		var camera = this.sceneState.camera;
		
		var frustumIdx = 0;
		var camera = this.sceneState.camera;
		var frustum = camera.getFrustum(frustumIdx);
		var aspectRatio = frustum.aspectRatio;
		var fovy = frustum.fovyRad;
		//frustum.far[0] = this.scene._frustumCommandsList[frustumIdx].far; 
		//frustum.near[0] = this.scene._frustumCommandsList[frustumIdx].near;
		var currentFrustumFar = frustum.far;
		var currentFrustumNear = frustum.near;
		
		this.sceneState.camera.frustum.near[0] = currentFrustumNear;
		this.sceneState.camera.frustum.far[0] = currentFrustumFar;
		this.sceneState.camera.frustum.aspectRatio = aspectRatio;
		
		// take all frustums near-far distances.***
		var numFrustums = 1;
		var distancesArray = [];
		for (var i=0; i<numFrustums; i++)
		{
			distancesArray[i*2] = frustum.near;
			distancesArray[i*2+1] = frustum.far;
		}
		
		resultCamera.position.set(camera.position.x, camera.position.y, camera.position.z);
		resultCamera.direction.set(camera.direction.x, camera.direction.y, camera.direction.z);
		resultCamera.up.set(camera.up.x, camera.up.y, camera.up.z);
		frustum = resultCamera.getFrustum(frustumIdx);
		frustum.near[0] = currentFrustumNear;
		frustum.far[0] = currentFrustumFar;
		resultCamera.setFrustumsDistances(numFrustums, distancesArray);
		resultCamera.setAspectRatioAndFovyRad(aspectRatio, fovy);
		resultCamera.calculateFrustumsPlanes();
	}
};




/**
 * start rendering.
 * @param scene 변수
 * @param isLastFrustum 변수
 */
 
MagoManager.prototype.load_testTextures = function() 
{
	if (this.pin.texture === undefined)
	{
		var gl = this.sceneState.gl;
		
		this.pin.texture = new Texture();
		var filePath_inServer = this.magoPolicy.imagePath + "/bugger.png";
		this.pin.texture.texId = gl.createTexture();
		this.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, this.pin.texture, undefined, this);
		this.pin.texturesArray.push(this.pin.texture);
		
		var cabreadoTex = new Texture();
		filePath_inServer = this.magoPolicy.imagePath + "/improve.png";
		cabreadoTex.texId = gl.createTexture();
		this.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, cabreadoTex, undefined, this);
		this.pin.texturesArray.push(cabreadoTex);
		
		cabreadoTex = new Texture();
		filePath_inServer = this.magoPolicy.imagePath + "/etc.png";
		cabreadoTex.texId = gl.createTexture();
		this.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, cabreadoTex, undefined, this);
		this.pin.texturesArray.push(cabreadoTex);
		
		cabreadoTex = new Texture();
		filePath_inServer = this.magoPolicy.imagePath + "/new.png";
		cabreadoTex.texId = gl.createTexture();
		this.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, cabreadoTex, undefined, this);
		this.pin.texturesArray.push(cabreadoTex);
		
		cabreadoTex = new Texture();
		filePath_inServer = this.magoPolicy.imagePath + "/funny.jpg";
		cabreadoTex.texId = gl.createTexture();
		this.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, cabreadoTex, undefined, this);
		this.pin.texturesArray.push(cabreadoTex);
	}
};

/**
 * start rendering.
 * @param scene 변수
 * @param isLastFrustum 변수
 */
MagoManager.prototype.getCurrentTime = function() 
{
	if (this.currTime === undefined) 
	{
		this.dateSC = new Date();
		this.currTime = this.dateSC.getTime();
	}
	return this.currTime;
};

/**
 * Returns WebGL Rendering Context.
 */
MagoManager.prototype.getGl = function() 
{
	if (this.sceneState === undefined)
	{ return undefined; }
	
	return this.sceneState.gl;
};

/**
 * Loads necessary data.
 */
MagoManager.prototype.loadAndPrepareData = function() 
{
	var gl = this.getGl();
	
	// 1) LOD 0.***********************************************************************************
	this.visibleObjControlerOctrees.initArrays(); // init.******

	var neoBuilding;
	var node;
	var octree;
	// lod 0 & lod 1.
	this.checkPropertyFilters(this.visibleObjControlerNodes.currentVisibles0);
	this.checkPropertyFilters(this.visibleObjControlerNodes.currentVisibles2);
	var nodesCount = this.visibleObjControlerNodes.currentVisibles0.length;
	for (var i=0; i<nodesCount; i++) 
	{
		node = this.visibleObjControlerNodes.currentVisibles0[i];
		if (!this.getRenderablesDetailedNeoBuildingAsimetricVersion(gl, node, this.visibleObjControlerOctrees, 0))
		{
			// any octree is visible.
			this.visibleObjControlerNodes.currentVisibles0.splice(i, 1);
			i--;
			nodesCount = this.visibleObjControlerNodes.currentVisibles0.length;
		}
	}
	
	this.prepareVisibleOctreesSortedByDistance(gl, this.visibleObjControlerOctrees); 
	this.prepareVisibleOctreesSortedByDistanceLOD2(gl, this.visibleObjControlerOctrees.currentVisibles0); 
	this.prepareVisibleOctreesSortedByDistanceLOD2(gl, this.visibleObjControlerOctrees.currentVisibles1); 
	this.prepareVisibleOctreesSortedByDistanceLOD2(gl, this.visibleObjControlerOctrees.currentVisibles2); 
	
	// lod 2.
	if (this.readerWriter.referencesList_requested < 5)
	{
		nodesCount = this.visibleObjControlerNodes.currentVisibles2.length;
		for (var i=0; i<nodesCount; i++) 
		{
			node = this.visibleObjControlerNodes.currentVisibles2[i];
			if (!this.getRenderablesDetailedNeoBuildingAsimetricVersion(gl, node, this.visibleObjControlerOctrees, 2))
			{
				// any octree is visible.
				this.visibleObjControlerNodes.currentVisibles2.splice(i, 1);
				i--;
				nodesCount = this.visibleObjControlerNodes.currentVisibles2.length;
			}
		}

		this.prepareVisibleOctreesSortedByDistanceLOD2(gl, this.visibleObjControlerOctrees.currentVisibles2); 
	}
	
	// lod3, lod4, lod5.***
	this.prepareVisibleLowLodNodes(this.visibleObjControlerNodes.currentVisibles3);
	this.prepareVisibleLowLodNodes(this.visibleObjControlerNodes.currentVisibles2);
	this.prepareVisibleLowLodNodes(this.visibleObjControlerNodes.currentVisibles0);
	
	// Init the pCloudPartitionsMother_requested.***
	this.readerWriter.pCloudPartitionsMother_requested = 0;
	
	// TinTerrain.*******************************************************************************************************************************
	if (this.isFarestFrustum())
	{
		if (this.tinTerrainManager !== undefined)
		{ this.tinTerrainManager.prepareVisibleTinTerrains(this); }
	}
	//if(this.isFarestFrustum())
	this.manageQueue();
	
};

/**
 * Manages the selection process.
 */
MagoManager.prototype.managePickingProcess = function() 
{
	var gl = this.getGl();
	
	if (this.selectionFbo === undefined) 
	{ this.selectionFbo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight); }
	
	if (this.isCameraMoved || this.bPicking) // 
	{
		this.selectionFbo.bind(); // framebuffer for color selection.***
		gl.enable(gl.DEPTH_TEST);
		gl.depthFunc(gl.LEQUAL);
		gl.depthRange(0, 1);
		gl.disable(gl.CULL_FACE);
		if (this.isLastFrustum)
		{
			// this is the farest frustum, so init selection process.***
			gl.clearColor(1, 1, 1, 1); // white background.***
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // clear buffer.***
			this.selectionManager.clearCandidates();
		}
		
		this.renderer.renderGeometryColorCoding(this.visibleObjControlerNodes);
		this.swapRenderingFase();
		
		if (this.currentFrustumIdx === 0)
		{
			this.isCameraMoved = false;
		}
		
		
	}
	
	if (this.currentFrustumIdx === 0)
	{
		if ( this.bPicking === true)
		{
			// this is the closest frustum.***
			this.bPicking = false;
			this.arrayAuxSC.length = 0;
			this.selectionManager.clearCurrents();
			this.objectSelected = this.getSelectedObjects(gl, this.mouse_x, this.mouse_y, this.arrayAuxSC);
			this.buildingSelected = this.arrayAuxSC[0];
			this.octreeSelected = this.arrayAuxSC[1];
			this.nodeSelected = this.arrayAuxSC[3];
			if (this.nodeSelected)
			{ this.rootNodeSelected = this.nodeSelected.getRoot(); }
			else
			{ this.rootNodeSelected = undefined; }
				
				
			this.arrayAuxSC.length = 0;
			if (this.buildingSelected !== undefined) 
			{
				this.displayLocationAndRotation(this.buildingSelected);
				this.selectedObjectNotice(this.buildingSelected);
			}
			if (this.objectSelected !== undefined) 
			{
				//this.displayLocationAndRotation(currentSelectedBuilding);
				//this.selectedObjectNotice(currentSelectedBuilding);
				//console.log("objectId = " + selectedObject.objectId);
			}
			

			// Test flyTo by topology.******************************************************************************
			var selCandidatesEdges = this.selectionManager.getSelectionCandidatesFamily("networkEdges");
			var selCandidatesNodes = this.selectionManager.getSelectionCandidatesFamily("networkNodes");
			var flyed = false;
			if (selCandidatesEdges)
			{
				var edgeSelected = selCandidatesEdges.currentSelected;
				if (edgeSelected && edgeSelected.vtxSegment)
				{
					// calculate the 2 positions of the edge.***
					var camPos = this.sceneState.camera.position;
					var vtxSeg = edgeSelected.vtxSegment;
					var pos1 = new Point3D();
					var pos2 = new Point3D();
					pos1.copyFrom(vtxSeg.startVertex.point3d);
					pos2.copyFrom(vtxSeg.endVertex.point3d);
					pos1.add(0.0, 0.0, 1.7); // add person height.***
					pos2.add(0.0, 0.0, 1.7); // add person height.***
						
						
					// calculate pos1 & pos2 to worldCoordinate.***
					// Need the building tMatrix.***
					var network = edgeSelected.networkOwner;
					var node = network.nodeOwner;
					var geoLocDataManager = node.data.geoLocDataManager;
					var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
					var tMat = geoLoc.tMatrix;
						
					// To positions must add "pivotPointTraslation" if exist.***
					// If building moved to bboxCenter, for example, then exist "pivotPointTraslation".***
					var pivotTranslation = geoLoc.pivotPointTraslationLC;
					if (pivotTranslation)
					{
						pos1.add(pivotTranslation.x, pivotTranslation.y, pivotTranslation.z);
						pos2.add(pivotTranslation.x, pivotTranslation.y, pivotTranslation.z);
					}

					var worldPos1 = tMat.transformPoint3D(pos1, undefined);
					var worldPos2 = tMat.transformPoint3D(pos2, undefined);

					// select the farestPoint to camera.***
					var dist1 = camPos.squareDistToPoint(worldPos1);
					var dist2 = camPos.squareDistToPoint(worldPos2);
					var pointSelected;
					if (dist1<dist2)
					{
						pointSelected = worldPos2;
					}
					else
					{ pointSelected = worldPos1; }
						
					// now flyTo pointSelected.***
					this.flyToTopology(pointSelected, 2);
					flyed = true;
				}
			}
			if (!flyed && selCandidatesNodes)
			{
				var nodeSelected = selCandidatesNodes.currentSelected;
				if (nodeSelected)
				{
					// calculate the 2 positions of the edge.***
					var camPos = this.sceneState.camera.position;
					var pos1 = new Point3D(nodeSelected.position.x, nodeSelected.position.y, nodeSelected.position.z);
					pos1.add(0.0, 0.0, 1.7); // add person height.***
						
						
					// calculate pos1 & pos2 to worldCoordinate.***
					// Need the building tMatrix.***
					var network = nodeSelected.networkOwner;
					var node = network.nodeOwner;
					var geoLocDataManager = node.data.geoLocDataManager;
					var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
					var tMat = geoLoc.tMatrix;
						
					// To positions must add "pivotPointTraslation" if exist.***
					// If building moved to bboxCenter, for example, then exist "pivotPointTraslation".***
					var pivotTranslation = geoLoc.pivotPointTraslationLC;
					if (pivotTranslation)
					{
						pos1.add(pivotTranslation.x, pivotTranslation.y, pivotTranslation.z);
					}
						
					var worldPos1 = tMat.transformPoint3D(pos1, undefined);
						
					// now flyTo pointSelected.***
					this.flyToTopology(worldPos1, 2);
					flyed = true;
				}
			}
			// End Test flyTo by topology.******************************************************************************
			
		}
		
		this.selectionColor.init(); // selection colors manager.***
	}
	this.selectionFbo.unbind();
	gl.enable(gl.CULL_FACE);
};

/**
 * Main rendering function.
 */
MagoManager.prototype.doRender = function(frustumVolumenObject) 
{
	var gl = this.getGl();
	var cameraPosition = this.sceneState.camera.position;
	var currentShader = undefined;
	
	// 1) The depth render.**********************************************************************************************************************
	var ssao_idx = 0; // 0= depth. 1= color.***
	this.renderType = 0;
	var renderTexture = false;
	
	// Take the depFrameBufferObject of the current frustumVolume.***
	if (frustumVolumenObject.depthFbo === undefined) { frustumVolumenObject.depthFbo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight); }
	if (this.sceneState.drawingBufferWidth[0] !== frustumVolumenObject.depthFbo.width[0] || this.sceneState.drawingBufferHeight[0] !== frustumVolumenObject.depthFbo.height[0])
	{
		// move this to onResize.***
		frustumVolumenObject.depthFbo.deleteObjects(gl);
		frustumVolumenObject.depthFbo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight);
		this.sceneState.camera.frustum.dirty = true;
	}
	this.depthFboNeo = frustumVolumenObject.depthFbo;
	this.depthFboNeo.bind(); 

	gl.clearColor(1, 1, 1, 1);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	gl.viewport(0, 0, this.sceneState.drawingBufferWidth[0], this.sceneState.drawingBufferHeight[0]);
	this.renderer.renderGeometry(gl, ssao_idx, this.visibleObjControlerNodes);
	// test mago geometries.***********************************************************************************************************
	this.renderer.renderMagoGeometries(ssao_idx); //TEST
	this.depthFboNeo.unbind();
	this.swapRenderingFase();

	// 2) color render.************************************************************************************************************
	if (this.configInformation.geo_view_library === Constant.CESIUM)
	{
		var scene = this.scene;
		scene._context._currentFramebuffer._bind();
	}
	
	ssao_idx = 1;
	this.renderType = 1;
	this.renderer.renderGeometry(gl, ssao_idx, this.visibleObjControlerNodes);
	
	if (this.weatherStation)
	{
		//this.weatherStation.test_renderWindLayer(this);
		//this.weatherStation.test_renderTemperatureLayer(this);
		//this.weatherStation.test_renderCuttingPlanes(this, ssao_idx);
		/*
		var renderType = 1;
		var currentShader;
			currentShader = this.postFxShadersManager.getShader("modelRefSsao"); 
			currentShader.useProgram();
			gl.uniform1i(currentShader.bApplySsao_loc, true); // apply ssao default.***
			gl.enable(gl.BLEND);
			
			var noiseTexture = this.texturesManager.getNoiseTexture4x4();
			var textureAux_1x1 = this.texturesManager.getTextureAux1x1();
			
			gl.uniform1i(currentShader.bApplySpecularLighting_loc, true);
			gl.enableVertexAttribArray(currentShader.texCoord2_loc);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.enableVertexAttribArray(currentShader.normal3_loc);
			
			gl.uniform1i(currentShader.colorType_loc, 1); // 0= oneColor, 1= attribColor, 2= texture.***
			gl.uniform1i(currentShader.bApplySsao_loc, false); // apply ssao default.***

			if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
			
			currentShader.bindUniformGenerals();
			gl.uniform1i(currentShader.textureFlipYAxis_loc, this.sceneState.textureFlipYAxis);
			
			//buildingGeoLocation.bindGeoLocationUniforms(gl, currentShader);
			gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]));
			gl.uniform3fv(currentShader.buildingPosHIGH_loc, new Float32Array([0,0,0]));
			gl.uniform3fv(currentShader.buildingPosLOW_loc, new Float32Array([0,0,0]));

			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, this.depthFboNeo.colorBuffer);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
			gl.activeTexture(gl.TEXTURE2); 
			gl.bindTexture(gl.TEXTURE_2D, textureAux_1x1);
			currentShader.last_tex_id = textureAux_1x1;
		//this.weatherStation.test_renderTemperatureMesh(this, currentShader, renderType);
		this.weatherStation.test_renderPrecipitationMesh(this, currentShader, renderType);
		gl.disable(gl.BLEND);
		
		currentShader.disableVertexAttribArrayAll();
		*/
	}
	
	gl.viewport(0, 0, this.sceneState.drawingBufferWidth[0], this.sceneState.drawingBufferHeight[0]);
		
	this.swapRenderingFase();
	
	// 3) test mago geometries.***********************************************************************************************************
	this.renderer.renderMagoGeometries(ssao_idx); //TEST
	
	// 4) Render filter.******************************************************************************************************************
	//this.renderFilter();
};

/**
 * Main loop function. This function contains all Mago3D Pipe-Line.
 * @param {Boolean} isLastFrustum Indicates if this is the last frustum in the render pipe-line.
 * @param {Number} frustumIdx Current frustum indice.
 * @param {Number} numFrustums Total frustums count in current rendering pipe-line.
 */
MagoManager.prototype.startRender = function(isLastFrustum, frustumIdx, numFrustums) 
{
	// Update the current frame's frustums count.
	this.numFrustums = numFrustums;
	this.isLastFrustum = isLastFrustum;

	var gl = this.getGl();
	this.upDateSceneStateMatrices(this.sceneState);
	
	if (this.isFarestFrustum())
	{
		this.dateSC = new Date();
		this.currTime = this.dateSC.getTime();
		
		this.load_testTextures();
		
		// Before of multiFrustumCullingSmartTile, do animation check, bcos during animation some object can change smartTile-owner.***
		if (this.animationManager !== undefined)
		{ this.animationManager.checkAnimation(this); }

		if (this.myCameraSCX === undefined) 
		{ this.myCameraSCX = new Camera(); }
		
		if (!this.isCameraMoving && !this.mouseLeftDown && !this.mouseMiddleDown)
		{
			this.upDateCamera(this.myCameraSCX);
			this.doMultiFrustumCullingSmartTiles(this.myCameraSCX);
		}
		
		gl.clearStencil(0); // provisionally here.***
		gl.clear(gl.STENCIL_BUFFER_BIT);

		// If mago camera has track node, camera look track node.
		this.sceneState.camera.doTrack(this);
	}
	
	
	var cameraPosition = this.sceneState.camera.position;
	
	// Take the current frustumVolumenObject.***
	var frustumVolumenObject = this.frustumVolumeControl.getFrustumVolumeCulling(frustumIdx); 
	this.myCameraSCX.setCurrentFrustum(frustumIdx);
	this.sceneState.camera.setCurrentFrustum(frustumIdx);
	var visibleNodes = frustumVolumenObject.visibleNodes;
	
	if (!this.isCameraMoving && !this.mouseLeftDown && !this.mouseMiddleDown)
	{
		if (this.frustumVolumeControl === undefined)
		{ return; }

		var frustumVolume = this.myCameraSCX.bigFrustum;
		var doFrustumCullingToBuildings = false;
		this.tilesMultiFrustumCullingFinished(frustumVolumenObject.fullyIntersectedLowestTilesArray, visibleNodes, cameraPosition, frustumVolume, doFrustumCullingToBuildings);

		doFrustumCullingToBuildings = true;
		this.tilesMultiFrustumCullingFinished(frustumVolumenObject.partiallyIntersectedLowestTilesArray, visibleNodes, cameraPosition, frustumVolume, doFrustumCullingToBuildings);
		
		this.prepareNeoBuildingsAsimetricVersion(gl, visibleNodes); 

	}

	var currentShader = undefined;
	this.visibleObjControlerNodes = visibleNodes; // set the current visible nodes.***

	// prepare data if camera is no moving.***
	if (!this.isCameraMoving && !this.mouseLeftDown && !this.mouseMiddleDown)
	{
		this.loadAndPrepareData();
		this.managePickingProcess();
	}
	
	if (this.bPicking === true && isLastFrustum)
	{
		var pixelPos;
		
		if (this.magoPolicy.issueInsertEnable === true)
		{
			if (this.objMarkerSC === undefined)
			{ this.objMarkerSC = new ObjectMarker(); }
			
			pixelPos = new Point3D();
			pixelPos = ManagerUtils.calculatePixelPositionWorldCoord(gl, this.mouse_x, this.mouse_y, pixelPos, undefined, undefined, this);
			var objMarker = this.objMarkerManager.newObjectMarker();
			ManagerUtils.calculateGeoLocationDataByAbsolutePoint(pixelPos.x, pixelPos.y, pixelPos.z, objMarker.geoLocationData, this);
		}
		
		if (this.magoPolicy.objectInfoViewEnable === true)
		{
			if (this.objMarkerSC === undefined)
			{ this.objMarkerSC = new ObjectMarker(); }
			
			if (pixelPos === undefined)
			{
				pixelPos = new Point3D();
				pixelPos = ManagerUtils.calculatePixelPositionWorldCoord(gl, this.mouse_x, this.mouse_y, pixelPos, undefined, undefined, this);
			}
			
			ManagerUtils.calculateGeoLocationDataByAbsolutePoint(pixelPos.x, pixelPos.y, pixelPos.z, this.objMarkerSC.geoLocationData, this);
		}
	}
	// lightDepthRender: TODO.***

	// Render process.***
	this.doRender(frustumVolumenObject);
	
	// test. Draw the buildingNames.***
	if (this.magoPolicy.getShowLabelInfo())
	{
		this.drawBuildingNames(this.visibleObjControlerNodes) ;
	}
};


/**
 * Prepare current visibles low LOD nodes.***
 */
MagoManager.prototype.prepareVisibleLowLodNodes = function(lowLodNodesArray) 
{
	if (this.readerWriter.skinLegos_requested > 5)
	{ return; }
	
	// Prepare lod3, lod4 and lod5 meshes.***
	// check "this.visibleObjControlerNodes.currentVisibles3".***
	var node;
	var neoBuilding;
	var extraCount = 5;
	
	var lowLodNodesCount = lowLodNodesArray.length;
	for (var i=0; i<lowLodNodesCount; i++) 
	{
		node = lowLodNodesArray[i];
		
		neoBuilding = node.data.neoBuilding;
		
		neoBuilding.prepareSkin(this);
		
		if (this.readerWriter.skinLegos_requested > 5)
		{ return; }
	}
};

/**
 * Draw building names on scene.
 */
MagoManager.prototype.drawBuildingNames = function(visibleObjControlerNodes) 
{
	var canvas = this.getObjectLabel();
	var ctx = canvas.getContext("2d");
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

	// lod2.
	var gl = this.getGl();
	var node;
	var nodeRoot;
	var geoLocDataManager;
	var geoLoc;
	var neoBuilding;
	var worldPosition;
	var screenCoord;
	
	// 1rst, collect rootNodes.
	var rootNodesMap = {};
	var currentVisiblesArray = visibleObjControlerNodes.currentVisibles2.concat(visibleObjControlerNodes.currentVisibles3);
	var nodesCount = currentVisiblesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		node = currentVisiblesArray[i];
		nodeRoot = node.getRoot();
		if (node.data === undefined || node.data.neoBuilding === undefined)
		{ continue; }
		
		var key = node.data.neoBuilding.buildingId;
		///rootNodesMap.set(nodeRoot, nodeRoot);
		rootNodesMap[key] = nodeRoot;
	}
	

	for (var key in rootNodesMap)
	{
		if (Object.prototype.hasOwnProperty.call(rootNodesMap, key))
		{
			//nodeRoot = rootNodesArray[i];
			nodeRoot = rootNodesMap[key];
			geoLocDataManager = nodeRoot.data.geoLocDataManager;
			geoLoc = geoLocDataManager.getCurrentGeoLocationData();
			//neoBuilding = node.data.neoBuilding;
			worldPosition = nodeRoot.getBBoxCenterPositionWorldCoord(geoLoc);
			screenCoord = ManagerUtils.calculateWorldPositionToScreenCoord(gl, worldPosition.x, worldPosition.y, worldPosition.z, screenCoord, this);
			
			if (screenCoord.x >= 0 && screenCoord.y >= 0)
			{
				ctx.font = "13px Arial";
				//ctx.strokeText(nodeRoot.data.nodeId, screenCoord.x, screenCoord.y);
				//ctx.fillText(nodeRoot.data.nodeId, screenCoord.x, screenCoord.y);
				ctx.strokeText(nodeRoot.data.data_name, screenCoord.x, screenCoord.y);
				ctx.fillText(nodeRoot.data.data_name, screenCoord.x, screenCoord.y);
			}
		}
	}
	
	rootNodesMap = {};

	ctx.restore();
};

/**
 * The camera was moved.
 */
MagoManager.prototype.cameraMoved = function() 
{
	this.sceneState.camera.setDirty(true);
	
	if (this.selectionFbo === undefined) 
	{ this.selectionFbo = new FBO(this.sceneState.gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight); }

	this.selectionFbo.dirty = true;
};

/**
 * Selects an object of the current visible objects that's under mouse.
 * @param {GL} gl.
 * @param {int} mouseX Screen x position of the mouse.
 * @param {int} mouseY Screen y position of the mouse.
 * @param {VisibleObjectsControler} visibleObjControlerBuildings Contains the current visible objects clasified by LOD.
 * @returns {Array} resultSelectedArray 
 */
MagoManager.prototype.getSelectedObjects = function(gl, mouseX, mouseY, resultSelectedArray) 
{
	// Read the picked pixel and find the object.*********************************************************
	var mosaicWidth = 9;
	var mosaicHeight = 9;
	var totalPixelsCount = mosaicWidth*mosaicHeight;
	var pixels = new Uint8Array(4 * mosaicWidth * mosaicHeight); // 4 x 3x3 pixel, total 9 pixels select.***
	var pixelX = mouseX - Math.floor(mosaicWidth/2);
	var pixelY = this.sceneState.drawingBufferHeight - mouseY - Math.floor(mosaicHeight/2); // origin is bottom.***
	
	if (pixelX < 0){ pixelX = 0; }
	if (pixelY < 0){ pixelY = 0; }
	
	gl.readPixels(pixelX, pixelY, mosaicWidth, mosaicHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null); // unbind framebuffer.***
	
	//this.selectionManager.clearCurrents();

	// now, select the object.***
	// The center pixel of the selection is 12, 13, 14.***
	var centerPixel = Math.floor(totalPixelsCount/2);
	var idx = this.selectionColor.decodeColor3(pixels[centerPixel*3], pixels[centerPixel*3+1], pixels[centerPixel*3+2]);
	this.selectionManager.selectObjects(idx);
	
	var selectedObject = this.selectionManager.currentReferenceSelected;

	resultSelectedArray[0] = this.selectionManager.currentBuildingSelected;
	resultSelectedArray[1] = this.selectionManager.currentOctreeSelected;
	resultSelectedArray[2] = this.selectionManager.currentReferenceSelected;
	resultSelectedArray[3] = this.selectionManager.currentNodeSelected;
	
	// Aditionally check if selected an edge of topology.***
	var selNetworkEdges = this.selectionManager.getSelectionCandidatesFamily("networkEdges");
	if (selNetworkEdges)
	{
		var currEdgeSelected = selNetworkEdges.currentSelected;
		var i = 0;
		while (currEdgeSelected === undefined && i< totalPixelsCount)
		{
			var idx = this.selectionColor.decodeColor3(pixels[i*3], pixels[i*3+1], pixels[i*3+2]);
			currEdgeSelected = selNetworkEdges.selectObject(idx);
			i++;
		}
	}
	
	// TEST: Check if selected a cuttingPlane.***
	var selGeneralObjects = this.selectionManager.getSelectionCandidatesFamily("general");
	if (selGeneralObjects)
	{
		var currObjectSelected = selGeneralObjects.currentSelected;
		var i = 0;
		while (currObjectSelected === undefined && i< totalPixelsCount)
		{
			var idx = this.selectionColor.decodeColor3(pixels[i*3], pixels[i*3+1], pixels[i*3+2]);
			currObjectSelected = selGeneralObjects.selectObject(idx);
			i++;
		}
	}
	
	return selectedObject;
};

/**
 * Calculates the plane on move an object.
 * @param {GL} gl 변수
 * @param {int} pixelX Screen x position of the pixel.
 * @param {int} pixelY Screen y position of the pixel.
 * @returns {Plane} resultSelObjMovePlane Calculated plane.
 */
MagoManager.prototype.calculateSelObjMovePlaneAsimetricMode = function(gl, pixelX, pixelY, resultSelObjMovePlane) 
{
	if (this.pointSC === undefined)
	{ this.pointSC = new Point3D(); }
	
	if (this.pointSC2 === undefined)
	{ this.pointSC2 = new Point3D(); }
	
	var geoLocDataManager = this.nodeSelected.getNodeGeoLocDataManager();
	
	ManagerUtils.calculatePixelPositionWorldCoord(gl, pixelX, pixelY, this.pointSC2, undefined, undefined, this);
	var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
	var tMatrixInv = buildingGeoLocation.getTMatrixInv();
	this.pointSC = tMatrixInv.transformPoint3D(this.pointSC2, this.pointSC); // buildingSpacePoint.***

	if (resultSelObjMovePlane === undefined)
	{ resultSelObjMovePlane = new Plane(); }
	// the plane is in world coord.***
	resultSelObjMovePlane.setPointAndNormal(this.pointSC.x, this.pointSC.y, this.pointSC.z, 0.0, 0.0, 1.0);
	return resultSelObjMovePlane;
};

/**
 * Returns true if is dragging.
 * 
 * @returns {Boolean} 드래그 여부
 */
MagoManager.prototype.isDragging = function() 
{
	// test function.***
	var bIsDragging = false;
	var gl = this.sceneState.gl;

	if (this.magoPolicy.objectMoveMode === CODE.moveMode.ALL)	// Moving all
	{
		this.arrayAuxSC.length = 0;
		this.selectionFbo.bind();
		var current_objectSelected = this.getSelectedObjects(gl, this.mouse_x, this.mouse_y, this.arrayAuxSC);
		var currentBuildingSelected = this.arrayAuxSC[0];
		var currentNodeSelected = this.arrayAuxSC[3];
		var currentRootNodeSelected;
		if (currentNodeSelected)
		{
			currentRootNodeSelected = currentNodeSelected.getRoot();
		}
		this.arrayAuxSC.length = 0;

		if (currentRootNodeSelected === this.rootNodeSelected) 
		{
			bIsDragging = true;
		}
		else 
		{
			bIsDragging = false;
		}
	}
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.OBJECT) // Moving object
	{
		this.arrayAuxSC.length = 0;
		this.selectionFbo.bind();
		var current_objectSelected = this.getSelectedObjects(gl, this.mouse_x, this.mouse_y, this.arrayAuxSC);
		this.arrayAuxSC.length = 0;

		if (current_objectSelected === this.objectSelected) 
		{
			bIsDragging = true;
		}
		else 
		{
			bIsDragging = false;
		}
	}
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.GEOGRAPHICPOINTS) 
	{
		// Compare currentSelectedObject with the nowSelectedObject.***
		var currSelected = this.selectionManager.getSelectedGeneral();
		this.arrayAuxSC.length = 0;
		this.selectionFbo.bind();
		this.getSelectedObjects(gl, this.mouse_x, this.mouse_y, this.arrayAuxSC);
		var nowSelected = this.selectionManager.getSelectedGeneral();
		if (nowSelected !== undefined && nowSelected === currSelected)
		{
			var className = nowSelected.constructor.name;
			if (className === "GeographicCoord")
			{
				bIsDragging = true;
			}
			else 
			{
				bIsDragging = false;
			}
		}
	}
	else
	{
		if (this.weatherStation)
		{
			// check if there are cuttingPlanes to move.***
			this.selectionFbo.bind();
			var current_objectSelected = this.getSelectedObjects(gl, this.mouse_x, this.mouse_y, this.arrayAuxSC);
			var selGeneralObjects = this.selectionManager.getSelectionCandidatesFamily("general");
			if (selGeneralObjects)
			{
				var currObjectSelected = selGeneralObjects.currentSelected;
				if (currObjectSelected)
				{
					// check if is a cuttingPlane.***
					if (currObjectSelected instanceof CuttingPlane)
					{
						bIsDragging = true;
					}
				}
				else 
				{
					
					bIsDragging = false;
				}
			}
			else
			{ bIsDragging = false; }
		}
	}
	
	if (!bIsDragging)
	{
		this.selectionManager.clearCandidates();
	}

	return bIsDragging;
};

/**
 * 카메라 motion 활성 또는 비활성
 * 
 * @param {Boolean} state 카메라 모션 활성화 여부
 */
MagoManager.prototype.setCameraMotion = function(state)
{
	if (this.configInformation.geo_view_library === Constant.CESIUM)
	{
		this.scene.screenSpaceCameraController.enableRotate = state;
		this.scene.screenSpaceCameraController.enableZoom = state;
		this.scene.screenSpaceCameraController.enableLook = state;
		this.scene.screenSpaceCameraController.enableTilt = state;
		this.scene.screenSpaceCameraController.enableTranslate = state;
	}
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionLeftUp = function(mouseX, mouseY) 
{
	if (this.objectMoved)
	{
		this.objectMoved = false;
		var nodeSelected = this.selectionManager.currentNodeSelected;
		if (nodeSelected === undefined)
		{ return; }
		
		this.saveHistoryObjectMovement(this.objectSelected, nodeSelected);
	}
	
	this.isCameraMoving = false;
	this.mouseLeftDown = false;
	this.mouseDragging = false;
	this.selObjMovePlane = undefined;
	this.mustCheckIfDragging = true;
	this.thereAreStartMovePoint = false;

	this.dateSC = new Date();
	this.currentTimeSC = this.dateSC.getTime();
	var miliSecondsUsed = this.currentTimeSC - this.startTimeSC;
	if (miliSecondsUsed < 1500) 
	{
		if (this.mouse_x === mouseX && this.mouse_y === mouseY) 
		{
			this.bPicking = true;
		}
	}
	
	this.setCameraMotion(true);
	
	// Clear startPositions of mouseAction.***
	var mouseAction = this.sceneState.mouseAction;
	mouseAction.clearStartPositionsAux(); // provisionally only clear the aux.***
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.keyDown = function(key) 
{
	if (key === 32) // 32 = 'space'.***
	{
		if (this.pointsCloudSsao === undefined)
		{ this.pointsCloudSsao = true; }
		
		if (this.pointsCloudSsao)
		{ this.pointsCloudSsao = false; }
		else
		{ this.pointsCloudSsao = true; }
	
	
	}
	/*
	else if (key === 37) // 37 = 'left'.***
	{
		
	}
	else if (key === 38) // 38 = 'up'.***
	{
		
	}
	else if (key === 39) // 39 = 'right'.***
	{
		
	}
	else if (key === 40) // 40 = 'down'.***
	{
		
	}
	*/
	else if (key === 49) // 49 = '1'.***
	{
		if (this.pointsCloudWhite === undefined)
		{ this.pointsCloudWhite = true; }
		
		if (this.pointsCloudWhite)
		{ this.pointsCloudWhite = false; }
		else
		{ this.pointsCloudWhite = true; }
	}
	else if (key === 80) // 80 = 'p'.***
	{
		var projectId = "AutonomousBus";
		var dataKey = "AutonomousBus_0";
			
		// Do a test.***
		//var projectId = "3ds.json";
		//var dataKey = "GyeomjaeJeongSeon_del";
		
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
		node.data.isTrailRender = true; // test.***
		
		var geoLocDataManager = node.getNodeGeoLocDataManager();
		var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
		var geoCoords = geoLocData.getGeographicCoords();
		var currLon = geoCoords.longitude;
		var currLat = geoCoords.latitude;
		var currAlt = geoCoords.altitude;

		// Move a little.***
		var latitude = currLat + 0.001 * 10*(Math.random()*2-1);
		var longitude = currLon + 0.001 * 10*(Math.random()*2-1);
		var elevation = currAlt + 10.0 * 10*(Math.random()*2-1);
		
		latitude = currLat + 0.01;
		longitude = currLon + 0.01;
		elevation = currAlt;
		
		
		var heading;
		var pitch;
		var roll;
		var durationTimeInSeconds = 100;
		this.changeLocationAndRotation(projectId, dataKey, latitude, longitude, elevation, heading, pitch, roll, durationTimeInSeconds);
	}
	else if (key === 84) // 84 = 't'.***
	{
		// do test.***
		var excavation = this.modeler.getExcavation();
		if (excavation !== undefined)
		{
			excavation.makeExtrudeObject(this);
		}
		
		var tunnel = this.modeler.getTunnel();
		if (tunnel !== undefined)
		{
			tunnel.getProfileGeographicCoordsList(); // executed this only to create the profile.*** TEST.***
			tunnel.makeMesh(this);
			
		}
		
		// Another test: Change color by projectId & objectId.***
		var api = new API();
		api.apiName = "changeColor";
		api.setProjectId("AutonomousBus");
		api.setDataKey("AutonomousBus_0");
		api.setObjectIds("13");
		api.setColor("220,150,20");
		this.callAPI(api);
	}
	else if (key === 89) // 89 = 'y'.***
	{
		if (this.magoMode === undefined)
		{ this.magoMode = CODE.magoMode.NORMAL; }
		
		if (this.magoMode === CODE.magoMode.NORMAL)
		{ this.magoMode = CODE.magoMode.DRAWING; }
		else if (this.magoMode === CODE.magoMode.DRAWING)
		{
			this.magoMode = CODE.magoMode.NORMAL;
			this.modeler.mode = CODE.modelerMode.INACTIVE;
		}
	}
	
	
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionLeftClick = function(mouseX, mouseY) 
{
	// Note: the "mouseActionLeftClick" runs after "mouseActionLeftDown" & "mouseActionLeftUp".***
	//--------------------------------------------------------------------------------------------
	if (this.magoMode === CODE.magoMode.DRAWING)// then process to draw.***// Test code.***// Test code.***
	{
		// Test code.***
		// Test code.***// Test code.***// Test code.***// Test code.***// Test code.***// Test code.***// Test code.***
		if (this.modeler === undefined)
		{ this.modeler = new Modeler(); }
		//	CODE.modelerMode = {
		//	"INACTIVE"                 : 0,
		//	"DRAWING_POLYLINE"         : 1,
		//	"DRAWING_GEOGRAPHICPOINTS" : 2,
		//};
			
		//this.modeler.mode = CODE.modelerMode.DRAWING_GEOGRAPHICPOINTS;
		//this.modeler.mode = CODE.modelerMode.DRAWING_PLANEGRID;
		//this.modeler.mode = CODE.modelerMode.DRAWING_EXCAVATIONPOINTS;
		//this.modeler.mode = CODE.modelerMode.DRAWING_TUNNELPOINTS;
		this.modeler.mode = CODE.modelerMode.DRAWING_STATICGEOMETRY;
		
		// Calculate the geographicCoord of the click position.****
		var geoCoord;
		var strWorldPoint;
		if (this.configInformation.geo_view_library === Constant.CESIUM)
		{
			var camera = this.scene.frameState.camera;
			var scene = this.scene;
			var ray = camera.getPickRay(new Cesium.Cartesian2(mouseX, mouseY));
			strWorldPoint = scene.globe.pick(ray, scene);
		}
		else 
		{
			var mouseAction = this.sceneState.mouseAction;
			strWorldPoint = mouseAction.strWorldPoint;
		}
		geoCoord = Globe.CartesianToGeographicWgs84(strWorldPoint.x, strWorldPoint.y, strWorldPoint.z, undefined, true);
		geoCoord.absolutePoint = strWorldPoint;
		
		var modelerMode = this.modeler.mode;
		if (this.modeler.mode === CODE.modelerMode.DRAWING_PLANEGRID && this.modeler.planeGrid === undefined)
		{
			// Calculate the click position and create the planeGrid geoLocation.***
			this.modeler.createPlaneGrid();
			this.modeler.planeGrid.makeVbo(this.vboMemoryManager);
			
			if (this.modeler.planeGrid.geoLocDataManager === undefined)
			{ this.modeler.planeGrid.geoLocDataManager = new GeoLocationDataManager(); }
			
			var geoLocDataManager = this.modeler.planeGrid.geoLocDataManager;
			var geoLocData = geoLocDataManager.newGeoLocationData("noName");
			geoLocData = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude+1, undefined, undefined, undefined, geoLocData, this);
			return;
		}
		
		// For each "click" add geographicPoint to the modeler's geographicPointsList.***
		else if (this.modeler.mode === CODE.modelerMode.DRAWING_GEOGRAPHICPOINTS)
		{
			var geoLocDataManager = geoCoord.getGeoLocationDataManager();
			var geoLocData = geoLocDataManager.newGeoLocationData("noName");
			geoLocData = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude+1, undefined, undefined, undefined, geoLocData, this);
			
			var geoCoordsList = this.modeler.getGeographicCoordsList();
			geoCoordsList.addGeoCoord(geoCoord);
		}
		
		// Excavation.***
		else if (this.modeler.mode === CODE.modelerMode.DRAWING_EXCAVATIONPOINTS)
		{
			var geoLocDataManager = geoCoord.getGeoLocationDataManager();
			var geoLocData = geoLocDataManager.newGeoLocationData("noName");
			geoLocData = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude+1, undefined, undefined, undefined, geoLocData, this);
			
			var excavation = this.modeler.getExcavation();
			var geoCoordsList = excavation.getGeographicCoordsList();
			geoCoordsList.addGeoCoord(geoCoord);
			geoCoordsList.makeLines(this);
		}
		
		// Tunnel.***
		else if (this.modeler.mode === CODE.modelerMode.DRAWING_TUNNELPOINTS)
		{
			var geoLocDataManager = geoCoord.getGeoLocationDataManager();
			var geoLocData = geoLocDataManager.newGeoLocationData("noName");
			geoLocData = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude+1, undefined, undefined, undefined, geoLocData, this);
			
			var tunnel = this.modeler.getTunnel();
			var geoCoordsList = tunnel.getPathGeographicCoordsList();
			geoCoordsList.addGeoCoord(geoCoord);
			geoCoordsList.makeLines(this);
		}
		
		// StaticGeometries.***
		else if (this.modeler.mode === CODE.modelerMode.DRAWING_STATICGEOMETRY)
		{
			// create a "node" & insert into smartTile.***
			var projectId = "AutonomousBus";
			var attributes = {
				"isPhysical"         : true,
				"nodeType"           : "TEST",
				"isReference"        : true,
				"projectFolderName"  : "staticModels",
				"buildingFolderName" : "F4D_AutonomousBus",
				"heading"            : 0,
				"pitch"              : 0,
				"roll"               : 0};
				/*
			var attributes = {
				"isPhysical"         : true,
				"nodeType"           : "TEST",
				"isReference"        : true,
				"projectFolderName"  : "3ds",
				"buildingFolderName" : "F4D_GyeomjaeJeongSeon_del",
				"heading"            : 0,
				"pitch"              : 0,
				"roll"               : 0};
				
			attributes.pitch = 90.0;
			*/
			if (!this.isExistStaticModel('AutonomousBus'))
			{
				this.addStaticModel({
					projectId          : 'AutonomousBus',
					projectFolderName  : 'staticModels',
					buildingFolderName : 'F4D_AutonomousBus'
				});
			}
			
			var nodesMap = this.hierarchyManager.getNodesMap(projectId, undefined);
			var existentNodesCount = Object.keys(nodesMap).length;
			var buildingId = "AutonomousBus_" + existentNodesCount.toString();
			
			this.instantiateStaticModel({
				projectId  : 'AutonomousBus',
				instanceId : buildingId,
				longitude  : geoCoord.longitude,
				latitude   : geoCoord.latitude,
				height     : geoCoord.altitude+1
			});
			/*var geoLocDataManager = geoCoord.getGeoLocationDataManager();
			var geoLocData = geoLocDataManager.newGeoLocationData("noName");
			geoLocData = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude+1, attributes.heading, attributes.pitch, attributes.roll, geoLocData, this);
			
			// test to insert an staticGeometry AutonomousBus.***
			var staticGeometryFilePath = "";

			var nodesMap = this.hierarchyManager.getNodesMap(projectId, undefined);
			var existentNodesCount = Object.keys(nodesMap).length;
			var buildingId = "AutonomousBus_" + existentNodesCount.toString();
			
			// Do a test.***
			//var projectId = "3ds.json";
			//buildingId = "GyeomjaeJeongSeon_del";
		
			var node = this.hierarchyManager.newNode(buildingId, projectId, undefined);
			
			// Now, create the geoLocdataManager of node.***
			node.data.attributes = attributes;
			node.data.geographicCoord = geoCoord;
			node.data.rotationsDegree = new Point3D(attributes.pitch, attributes.roll, attributes.heading);
			node.data.geoLocDataManager = geoLocDataManager;
			node.data.rotationsDegree.set(attributes.pitch, attributes.roll, attributes.heading);
			var geoLocDataManager = node.data.geoLocDataManager;
			var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
			
			geoLocData.setRotationHeadingPitchRoll(attributes.heading, attributes.pitch, attributes.roll);
			
			// Now, insert node into smartTile.***
			var targetDepth = this.smartTileManager.targetDepth;
			this.smartTileManager.putNode(targetDepth, node, this);*/
		}
		
	}
	
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionLeftDown = function(mouseX, mouseY) 
{
	this.dateSC = new Date();
	this.startTimeSC = this.dateSC.getTime();

	this.mouse_x = mouseX;
	this.mouse_y = mouseY;
	this.mouseLeftDown = true;
	//this.isCameraMoving = true;
	
	MagoWorld.updateMouseStartClick(mouseX, mouseY, this);
	/*
	// Test.**********************************************************************************************************************
	var selGeneralObjects = this.selectionManager.getSelectionCandidatesFamily("general");
	if (selGeneralObjects)
	{
		var currObjectSelected = selGeneralObjects.currentSelected;
		if (currObjectSelected)
		{
			// check if is a cuttingPlane.***
			if (currObjectSelected instanceof CuttingPlane)
			{
				var mouseAction = this.sceneState.mouseAction;
				mouseAction.claculateStartPositionsAux(this);
			}
		}
	}
	*/
	// End test.-------------------------------------------------------------------------------------------------------------------
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.saveHistoryObjectMovement = function(refObject, node) 
{
	var changeHistory = new ChangeHistory();
	var refMove = changeHistory.getReferenceObjectAditionalMovement();
	var refMoveRelToBuilding = changeHistory.getReferenceObjectAditionalMovementRelToBuilding();
	
	if (refObject.moveVector === undefined)
	{ refObject.moveVector = new Point3D(); }
	
	if (refObject.moveVectorRelToBuilding === undefined)
	{ refObject.moveVectorRelToBuilding = new Point3D(); }
	
	refMove.set(refObject.moveVector.x, refObject.moveVector.y, refObject.moveVector.z);
	refMoveRelToBuilding.set(refObject.moveVectorRelToBuilding.x, refObject.moveVectorRelToBuilding.y, refObject.moveVectorRelToBuilding.z);
	if (node === undefined)
	{ return; }

	var projectId = node.data.projectId;
	var dataKey = node.data.nodeId;
	var objectIndex = refObject._id;
	
	changeHistory.setProjectId(projectId);
	changeHistory.setDataKey(dataKey);
	changeHistory.setObjectIndexOrder(objectIndex);
	MagoConfig.saveMovingHistory(projectId, dataKey, objectIndex, changeHistory);
};



/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionMiddleDown = function(mouseX, mouseY) 
{
	this.dateSC = new Date();
	this.startTimeSC = this.dateSC.getTime();

	this.mouse_x = mouseX;
	this.mouse_y = mouseY;
	this.mouseMiddleDown = true;
	this.isCameraMoving = true;
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionMiddleUp = function(mouseX, mouseY) 
{
	this.isCameraMoving = false;
	this.mouseMiddleDown = false;
	this.mouseDragging = false;
	this.selObjMovePlane = undefined;
	this.mustCheckIfDragging = true;
	this.thereAreStartMovePoint = false;
	this.setCameraMotion(false);
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionRightDown = function(mouseX, mouseY) 
{
	/*
	this.dateSC = new Date();
	this.startTimeSC = this.dateSC.getTime();

	this.mouse_x = mouseX;
	this.mouse_y = mouseY;
	this.mouseRightDown = true;
	this.isCameraMoving = true;
	*/
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionRightUp = function(mouseX, mouseY) 
{
	/*
	this.isCameraMoving = false;
	this.setCameraMotion(false);
	*/
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionMove = function(mouseX, mouseY) 
{
	if (this.mouseLeftDown) 
	{
		this.manageMouseDragging(mouseX, mouseY);
	}
	else if (this.mouseMiddleDown) 
	{
		this.sceneState.camera.setDirty(true);
	}
	else if (this.mouseRightDown) 
	{
		this.sceneState.camera.setDirty(true);
	}
	else
	{
		this.mouseDragging = false;
		this.setCameraMotion(false);
		if (this.mouseMiddleDown)
		{
			this.isCameraMoving = true;
		}
		
	}
};


/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 * @param renderables_neoRefLists_array 변수
 */
MagoManager.prototype.manageMouseDragging = function(mouseX, mouseY) 
{
	this.sceneState.camera.setDirty(true);
	
	this.mouse_x = mouseX;
	this.mouse_y = mouseY;
	
	// distinguish 2 modes.******************************************************
	if (this.magoPolicy.objectMoveMode === CODE.moveMode.ALL) // blocks move.***
	{
		if (this.buildingSelected !== undefined) 
		{
			// 1rst, check if there are objects to move.***
			if (this.mustCheckIfDragging) 
			{
				if (this.isDragging()) 
				{
					this.mouseDragging = true;
					this.setCameraMotion(false);
				}
				this.mustCheckIfDragging = false;
			}
			// Display geoLocationData while moving building.***
			var nodeOwner = this.buildingSelected.nodeOwner;
			if (nodeOwner === undefined)
			{ return; }

			var geoLocDataManager = nodeOwner.data.geoLocDataManager;
			if (geoLocDataManager === undefined)
			{ return; }

			var geoLocation = geoLocDataManager.getGeoLocationData(0);
			if (geoLocation === undefined)
			{ return; }

			var geographicCoords = geoLocation.geographicCoord;
			if (geographicCoords === undefined)
			{ return; }
			
			movedDataCallback(	MagoConfig.getPolicy().geo_callback_moveddata,
				nodeOwner.data.projectId,
				nodeOwner.data.nodeId,
				null,
				geographicCoords.latitude,
				geographicCoords.longitude,
				geographicCoords.altitude,
				geoLocation.heading,
				geoLocation.pitch,
				geoLocation.roll);
								
		}
		else 
		{
			this.isCameraMoving = true; // if no object is selected.***
		}
	}
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.OBJECT) // objects move.***
	{
		if (this.objectSelected !== undefined) 
		{
			// 1rst, check if there are objects to move.***
			if (this.mustCheckIfDragging) 
			{
				if (this.isDragging()) 
				{
					this.mouseDragging = true;
					this.setCameraMotion(false);
				}
				this.mustCheckIfDragging = false;
			}
		}
		else 
		{
			this.isCameraMoving = true; // if no object is selected.***
		}
	}
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.GEOGRAPHICPOINTS) 
	{
		var currSelected = this.selectionManager.getSelectedGeneral();
		if (currSelected)
		{
			var className = currSelected.constructor.name;
			if (className === "GeographicCoord")
			{
				// 1rst, check if there are objects to move.***
				if (this.mustCheckIfDragging) 
				{
					if (this.isDragging()) 
					{
						this.mouseDragging = true;
						this.setCameraMotion(false);
					}
					this.mustCheckIfDragging = false;
				}
			}
		}
	}
	else
	{
		// 1rst, check if there are objects to move.***
		if (this.mustCheckIfDragging) 
		{
			if (this.isDragging()) 
			{
				this.mouseDragging = true;
				this.setCameraMotion(false);
			}
			this.mustCheckIfDragging = false;
		}
	}
	//---------------------------------------------------------------------------------
	this.isCameraMoving = true; // test.***
	if (this.mouseDragging) 
	{
		this.moveSelectedObjectAsimetricMode(this.sceneState.gl);
	}
};


/**
 * Moves an object.
 * @param {WebGLRenderingContext} gl WebGLRenderingContext.
 */
MagoManager.prototype.moveSelectedObjectAsimetricMode = function(gl) 
{
	if (this.magoPolicy.objectMoveMode === CODE.moveMode.ALL) // buildings move.***
	{
		if (this.selectionManager.currentNodeSelected === undefined)
		{ return; }
		
		var geoLocDataManager = this.selectionManager.currentNodeSelected.getNodeGeoLocDataManager();
		var geoLocationData = geoLocDataManager.getCurrentGeoLocationData();
		
		var mouseAction = this.sceneState.mouseAction;
	
		// create a XY_plane in the selected_pixel_position.***
		if (this.selObjMovePlane === undefined) 
		{
			this.selObjMovePlane = new Plane();
			// create a local XY plane.
			// find the pixel position relative to building.
			var tMatrixInv = geoLocationData.getGeoLocationMatrixInv();
			var pixelPosBuildingCoord = tMatrixInv.transformPoint3D(mouseAction.strWorldPoint, pixelPosBuildingCoord);
			this.selObjMovePlane.setPointAndNormal(pixelPosBuildingCoord.x, pixelPosBuildingCoord.y, pixelPosBuildingCoord.z,    0.0, 0.0, 1.0); 
		}

		if (this.lineSC === undefined)
		{ this.lineSC = new Line(); }
		
		this.lineSC = ManagerUtils.getRayWorldSpace(gl, this.mouse_x, this.mouse_y, this.lineSC, this); // rayWorldSpace.***

		// transform world_ray to building_ray.***
		var camPosBuilding = new Point3D();
		var camDirBuilding = new Point3D();
		
		var geoLocMatrixInv = geoLocationData.getGeoLocationMatrixInv();
		camPosBuilding = geoLocMatrixInv.transformPoint3D(this.lineSC.point, camPosBuilding);
		this.pointSC = geoLocMatrixInv.rotatePoint3D(this.lineSC.direction, this.pointSC);
		camDirBuilding.x = this.pointSC.x;
		camDirBuilding.y = this.pointSC.y;
		camDirBuilding.z = this.pointSC.z;

		// now, intersect building_ray with the selObjMovePlane.***
		var line = new Line();
		line.setPointAndDir(camPosBuilding.x, camPosBuilding.y, camPosBuilding.z,       camDirBuilding.x, camDirBuilding.y, camDirBuilding.z);

		var intersectionPoint = new Point3D();
		intersectionPoint = this.selObjMovePlane.intersectionLine(line, intersectionPoint);
		intersectionPoint.set(-intersectionPoint.x, -intersectionPoint.y, -intersectionPoint.z);
		
		// Now, calculate the intersectionPoint in world coordinates.***
		var intersectionPointWC = new Point3D();
		intersectionPointWC = geoLocationData.geoLocMatrix.transformPoint3D(intersectionPoint, intersectionPointWC);

		// register the movement.***
		if (!this.thereAreStartMovePoint) 
		{
			var cartographic = ManagerUtils.pointToGeographicCoord(intersectionPointWC, cartographic, this);
			this.startMovPoint.x = cartographic.longitude;
			this.startMovPoint.y = cartographic.latitude;
			this.thereAreStartMovePoint = true;
		}
		else 
		{
			var cartographic = ManagerUtils.pointToGeographicCoord(intersectionPointWC, cartographic, this);
			var difX = cartographic.longitude - this.startMovPoint.x;
			var difY = cartographic.latitude - this.startMovPoint.y;

			var newLongitude = geoLocationData.geographicCoord.longitude - difX;
			var newlatitude = geoLocationData.geographicCoord.latitude - difY;

			this.changeLocationAndRotationNode(this.selectionManager.currentNodeSelected, newlatitude, newLongitude, undefined, undefined, undefined, undefined);
			this.displayLocationAndRotation(this.buildingSelected);
			
			this.startMovPoint.x -= difX;
			this.startMovPoint.y -= difY;
		}
	}
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.OBJECT) // objects move.***
	{
		if (this.objectSelected === undefined)
		{ return; }

		// create a XY_plane in the selected_pixel_position.***
		if (this.selObjMovePlane === undefined) 
		{
			this.selObjMovePlane = this.calculateSelObjMovePlaneAsimetricMode(gl, this.mouse_x, this.mouse_y, this.selObjMovePlane);
		}
		
		var geoLocDataManager = this.selectionManager.currentNodeSelected.getNodeGeoLocDataManager();

		// world ray = camPos + lambda*camDir.***
		if (this.lineSC === undefined)
		{ this.lineSC = new Line(); }
		
		this.lineSC = ManagerUtils.getRayWorldSpace(gl, this.mouse_x, this.mouse_y, this.lineSC, this); // rayWorldSpace.***
		var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		var camPosBuilding = new Point3D();
		var camDirBuilding = new Point3D();
		var tMatrixInv = buildingGeoLocation.getTMatrixInv();
		camPosBuilding = tMatrixInv.transformPoint3D(this.lineSC.point, camPosBuilding);
		camDirBuilding = tMatrixInv.rotatePoint3D(this.lineSC.direction, camDirBuilding);
	
		// now, intersect building_ray with the selObjMovePlane.***
		var line = new Line();
		line.setPointAndDir(camPosBuilding.x, camPosBuilding.y, camPosBuilding.z,       camDirBuilding.x, camDirBuilding.y, camDirBuilding.z);// original.***

		var intersectionPoint = new Point3D();
		intersectionPoint = this.selObjMovePlane.intersectionLine(line, intersectionPoint);

		//the movement of an object must multiply by buildingRotMatrix.***
		if (this.objectSelected.moveVectorRelToBuilding === undefined)
		{ this.objectSelected.moveVectorRelToBuilding = new Point3D(); }
	
		// move vector rel to building.
		if (!this.thereAreStartMovePoint) 
		{
			this.startMovPoint = intersectionPoint;
			this.startMovPoint.add(-this.objectSelected.moveVectorRelToBuilding.x, -this.objectSelected.moveVectorRelToBuilding.y, -this.objectSelected.moveVectorRelToBuilding.z);
			this.thereAreStartMovePoint = true;
		}
		else 
		{
			var difX = intersectionPoint.x - this.startMovPoint.x;
			var difY = intersectionPoint.y - this.startMovPoint.y;
			var difZ = intersectionPoint.z - this.startMovPoint.z;

			this.objectSelected.moveVectorRelToBuilding.set(difX, difY, difZ);
			this.objectSelected.moveVector = buildingGeoLocation.tMatrix.rotatePoint3D(this.objectSelected.moveVectorRelToBuilding, this.objectSelected.moveVector); 
		}
		
		var projectId = this.selectionManager.currentNodeSelected.data.projectId;
		var data_key = this.selectionManager.currentNodeSelected.data.nodeId;
		var objectIndexOrder = this.objectSelected._id;
		
		MagoConfig.deleteMovingHistoryObject(projectId, data_key, objectIndexOrder);
		this.objectMoved = true; // this provoques that on leftMouseUp -> saveHistoryObjectMovement
		
	}
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.GEOGRAPHICPOINTS) 
	{
		// Move the current geographic point selected.***
		var currSelected = this.selectionManager.getSelectedGeneral();
		if (currSelected)
		{
			var className = currSelected.constructor.name;
			if (className === "GeographicCoord")
			{
				var geoLocDataManager = currSelected.getGeoLocationDataManager();
				var geoLocationData = geoLocDataManager.getCurrentGeoLocationData();
				
				var geoCoord;
				var strWorldPoint;
				if (this.configInformation.geo_view_library === Constant.CESIUM)
				{
					var camera = this.scene.frameState.camera;
					var scene = this.scene;
					var ray = camera.getPickRay(new Cesium.Cartesian2(this.mouse_x, this.mouse_y));
					strWorldPoint = scene.globe.pick(ray, scene);
					geoCoord = Globe.CartesianToGeographicWgs84(strWorldPoint.x, strWorldPoint.y, strWorldPoint.z, undefined, true);
				}
				else 
				{
					var mouseAction = this.sceneState.mouseAction;
					strWorldPoint = mouseAction.strWorldPoint;
					geoCoord = Globe.CartesianToGeographicWgs84(strWorldPoint.x, strWorldPoint.y, strWorldPoint.z, undefined, true);
				}
				
				currSelected.setLonLatAlt(geoCoord.longitude, geoCoord.latitude, undefined); // no set altitude.***
				
				var geoLocDataManager = currSelected.getGeoLocationDataManager();
				var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
				geoLocData = ManagerUtils.calculateGeoLocationData(currSelected.longitude, currSelected.latitude, currSelected.altitude, undefined, undefined, undefined, geoLocData, this);
				
				// Now, must check the moved object's owner.***
				var owner = currSelected.owner;
				if (owner)
				{
					// 1rst, check if is a geoCoordsList.***
					if (owner.constructor.name === "GeographicCoordsList")
					{
						owner.makeLines(this);
					}
					
					var owner2 = owner.owner;
					if (owner2)
					{
						if (owner2.constructor.name === "Excavation")
						{
							owner2.remakeExtrudeObject(this);
						}
						else if (owner2.constructor.name === "Tunnel")
						{
							owner2.remakeMesh(this);
						}
					}
				}
			}
		}

	}
	else
	{
		if (this.weatherStation)
		{
			// Test. Check if there are cuttingPlanes to move.***
			var selGeneralObjects = this.selectionManager.getSelectionCandidatesFamily("general");
			if (selGeneralObjects)
			{
				var currObjectSelected = selGeneralObjects.currentSelected;
				if (currObjectSelected)
				{
					// check if is a cuttingPlane.***
					if (currObjectSelected instanceof CuttingPlane)
					{
						// Move the cuttingPlane.***
						var geoLocDataManager = currObjectSelected.geoLocDataManager;
						var geoLocationData = geoLocDataManager.getCurrentGeoLocationData();
						
						var mouseAction = this.sceneState.mouseAction;
						
						// New Test.*******************************************************
						var camRay = ManagerUtils.getRayWorldSpace(gl, this.mouse_x, this.mouse_y, undefined, this); // rayWorldSpace.***
						var strWorldPoint = mouseAction.strWorldPointAux; // original.***
						////var strWorldPoint = mouseAction.strWorldPoint;
						if (strWorldPoint)
						{
							var strEarthRadius = strWorldPoint.getModul();
							
							var curWorldPosAux;
							curWorldPosAux = this.globe.intersectionLineWgs84(camRay, curWorldPosAux, strEarthRadius);
							if (curWorldPosAux)
							{
								var curWorldPointAux = new Point3D(curWorldPosAux[0], curWorldPosAux[1], curWorldPosAux[2]);
								var curLocation = ManagerUtils.pointToGeographicCoord(curWorldPointAux, undefined, this);
								var strLocation = mouseAction.strLocationAux;
								var objectGeoLoc = geoLocationData.geographicCoord;
								
								var difLocation = new GeographicCoord();
								difLocation.setLonLatAlt(curLocation.longitude - strLocation.longitude, curLocation.latitude - strLocation.latitude, curLocation.altitude - strLocation.altitude);
								var newLongitude = objectGeoLoc.longitude + difLocation.longitude;
								var newlatitude = objectGeoLoc.latitude + difLocation.latitude;
								
								geoLocationData = ManagerUtils.calculateGeoLocationData(newLongitude, newlatitude, undefined, undefined, undefined, undefined, geoLocationData, this);
								mouseAction.strLocationAux.setLonLatAlt(curLocation.longitude, curLocation.latitude, curLocation.altitude);
							}
						}
					}
				}
			}
		}
	}
};

MagoManager.prototype.test_renderDepth_objectSelected = function(currObjectSelected) 
{
	// Test function. Provisional.***
	// Test function. Provisional.***
	// Test function. Provisional.***
	// Test. Render depth only for the selected object.***************************
	var gl = this.sceneState.gl;
	
	if (this.depthFboAux === undefined)
	{
		this.depthFboAux = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight);
	}
	if (this.sceneState.drawingBufferWidth[0] !== this.depthFboAux.width[0] || this.sceneState.drawingBufferHeight[0] !== this.depthFboAux.height[0])
	{
		// move this to onResize.***
		this.depthFboAux.deleteObjects(gl);
		this.depthFboAux = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight);
	}
	this.depthFboAux.bind(); 
	
	if (this.isFarestFrustum())
	{
		gl.clearColor(1, 1, 1, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	}
	gl.disable(gl.BLEND);
	
	gl.frontFace(gl.CCW);	
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	gl.enable(gl.CULL_FACE);
	
	// Now, renderDepth the selected object. Fix the frustumFar for adequate precision on depthPacking.***
	var shader = this.postFxShadersManager.getShader("modelRefDepth"); 
	shader.useProgram();
	shader.bindUniformGenerals();
	shader.enableVertexAttribArray(shader.position3_loc);
		
	var geoLocDataManager = currObjectSelected.geoLocDataManager;
	var geoLocationData = geoLocDataManager.getCurrentGeoLocationData();
		
	// test: in depth, set frustumFar = 1000000000(100M).***
	var frustumFarLoc = shader.uniformsMapGeneral.frustumFar.uniformLocation;
	gl.uniform1f(frustumFarLoc, new Float32Array([100000000.0]));
			
	var renderType = 0;
	//this.weatherStation.test_renderCuttingPlanes(this, renderType);
			
	geoLocationData.bindGeoLocationUniforms(gl, shader);
	gl.uniform3fv(shader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
	currObjectSelected.render(this, shader, renderType);
			
	
	this.depthFboAux.unbind(); 
	// End test.------------------------------------------------------------------
};


/**
 * Frustum 안의 VisibleOctree 를 검색하여 currentVisibleOctreesControler 를 준비
 * 
 * @param {any} gl 
 * @param {any} scene 
 * @param {any} neoBuilding 
 * @param {VisibleObjectsController} visibleObjControlerOctrees 
 * @param {any} lod 
 */
MagoManager.prototype.getRenderablesDetailedNeoBuildingAsimetricVersion = function(gl, node, globalVisibleObjControlerOctrees, lod) 
{
	var data = node.data;
	var neoBuilding = data.neoBuilding;
	var currentLod = data.currentLod;
	
	// chaek if the neoBuilding has availableLod_0.***
	if (neoBuilding === undefined || neoBuilding.octree === undefined) { return false; }
	
	// Check if for the current lod, the building is modelRefType.***
	var lodBuildingData = neoBuilding.getLodBuildingData(data.currentLod);
	if (lodBuildingData === undefined)
	{ return false; }
	
	if (!lodBuildingData.isModelRef)
	{ return true; } // return true, bcos the caller pops the building from the "visibleObjControlerNodes" if return false.***

	var rootGeoLocDataManager = node.getNodeGeoLocDataManager();
	var rootGeoLoc = rootGeoLocDataManager.getCurrentGeoLocationData();
	
	//var nodeGeoLocation = geoLocDataManager.getCurrentGeoLocationData(); // original.***
	var nodeGeoLocation = rootGeoLocDataManager.getCurrentGeoLocationData();
	if (nodeGeoLocation === undefined)
	{ return false; }

	// Create if necessary, the visibleObjectsControler of the node.***
	if (data.currentVisibleOctreesControler === undefined)
	{ data.currentVisibleOctreesControler = new VisibleObjectsController(); }	

	var distLod0 = this.magoPolicy.getLod0DistInMeters();
	var distLod1 = this.magoPolicy.getLod1DistInMeters();
	var distLod2 = this.magoPolicy.getLod2DistInMeters();
	var distLod3 = this.magoPolicy.getLod3DistInMeters();
	var distLod4 = this.magoPolicy.getLod4DistInMeters();
	var distLod5 = this.magoPolicy.getLod5DistInMeters();

	var find = false;
	if (data.myCameraRelative === undefined)
	{ data.myCameraRelative = new Camera(); }
	
	data.myCameraRelative.frustum.copyParametersFrom(this.myCameraSCX.bigFrustum);
	data.myCameraRelative = nodeGeoLocation.getTransformedRelativeCamera(this.sceneState.camera, data.myCameraRelative);
	//var isCameraInsideOfBuilding = neoBuilding.isCameraInsideOfBuilding(data.myCameraRelative.position.x, data.myCameraRelative.position.y, data.myCameraRelative.position.z); // old.***
	
	data.currentVisibleOctreesControler.clear();
	
	if (lod === 2)
	{
		// In this case is not necessary calculate the frustum planes.
		neoBuilding.octree.extractLowestOctreesByLOD(data.currentVisibleOctreesControler, globalVisibleObjControlerOctrees, this.boundingSphere_Aux,
			data.myCameraRelative.position, distLod0, distLod1, distLod5);
		find = true;
	}
	else 
	{
		// Must calculate the frustum planes.
		data.myCameraRelative.calculateFrustumsPlanes();
		
		// 1rst, check if there are octrees very close.
		var frustum0 = data.myCameraRelative.bigFrustum;
		find = neoBuilding.octree.getFrustumVisibleLowestOctreesByLOD(	frustum0, data.currentVisibleOctreesControler, globalVisibleObjControlerOctrees, this.boundingSphere_Aux,
			data.myCameraRelative.position, distLod0, distLod1, distLod2*100);
	}

	if (!find) 
	{
		// If the building is far to camera, then delete it.
		if (data.distToCam > 100) // default: 60.***
		{ this.processQueue.putNodeToDeleteModelReferences(node, 1); }
		
		// TODO: must check if some part of the building is in parseQueue.***
		return false;
	}
	else 
	{
		this.processQueue.eraseNodeToDeleteModelReferences(node);
	}
	
	return true;
};


/**
 * LOD0, LOD1 에 대한 F4D ModelData, ReferenceData 를 요청
 * 
 * @param {any} gl 
 * @param {any} scene 
 * @param {any} neoBuilding 
 */
MagoManager.prototype.manageQueue = function() 
{
	var gl = this.sceneState.gl;
	
	
	
	
	// 1rst, manage deleting queue.***************
	this.processQueue.manageDeleteQueue(this);
	
	
	
	// 2nd, parse pendent data.**********************************************************************************
	// is desirable to parse octrees references ordered by the current eye distance.
	// in the "visibleObjControlerOctrees" there are the octrees sorted by distance, so must use it.
	this.parseQueue.initCounters();
	
	// parse octrees lod0 & lod1 references.***
	this.parseQueue.parseArrayOctreesLod0References(gl, this.visibleObjControlerOctrees.currentVisibles0, this);
	this.parseQueue.parseArrayOctreesLod0References(gl, this.visibleObjControlerOctrees.currentVisibles1, this);
	
	

	// parse octrees lod0 & lod1 models.***
	this.parseQueue.parseArrayOctreesLod0Models(gl, this.visibleObjControlerOctrees.currentVisibles0, this);
	this.parseQueue.parseArrayOctreesLod0Models(gl, this.visibleObjControlerOctrees.currentVisibles1, this);
	
	
	
	// parse octrees lod2 (lego).***
	this.parseQueue.parseArrayOctreesLod2Legos(gl, this.visibleObjControlerOctrees.currentVisibles2, this);

	// parse PCloud octree.***
	this.parseQueue.parseArrayOctreesPCloud(gl, this.visibleObjControlerOctrees.currentVisiblesAux, this);
	this.parseQueue.parseArrayOctreesPCloudPartition(gl, this.visibleObjControlerOctrees.currentVisiblesAux, this);

	// parse skin-lego.***
	this.parseQueue.parseArraySkins(gl, this.visibleObjControlerNodes.currentVisibles0, this);
	this.parseQueue.parseArraySkins(gl, this.visibleObjControlerNodes.currentVisibles2, this);
	this.parseQueue.parseArraySkins(gl, this.visibleObjControlerNodes.currentVisibles3, this);
	
	

	// parse TinTerrain.***
	var tinTerrain;
	var parsedsCount = 0;
	for (var key in this.parseQueue.tinTerrainsToParseMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.parseQueue.tinTerrainsToParseMap, key))
		{
			var tinTerrain = this.parseQueue.tinTerrainsToParseMap[key];
			if (tinTerrain !== undefined)
			{
				if (this.parseQueue.eraseTinTerrainToParse(tinTerrain)) // check if is inside of the queue to parse.***
				{
					tinTerrain.parseData(tinTerrain.dataArrayBuffer);
					parsedsCount++;
				}
			}
			
			if (parsedsCount > 1)
			{ break; }
		}
	}
	/*
	var visibleTilesArray = this.tinTerrainManager.visibleTilesArray;
	var visiblesTilesCount = visibleTilesArray.length;
	for(var i=0; i<visiblesTilesCount; i++)
	{
		tinTerrain = visibleTilesArray[i];
		if (tinTerrain !== undefined)
		{
			if (this.parseQueue.eraseTinTerrainToParse(tinTerrain)) // check if is inside of the queue to parse.***
			{
				tinTerrain.parseData(tinTerrain.dataArrayBuffer);
			}
		}
	}
	*/
	
	
};

/**
 */
MagoManager.prototype.prepareVisibleOctreesSortedByDistancePointsCloudType = function(gl, globalVisibleObjControlerOctrees, fileRequestExtraCount) 
{
	var lod2DataInQueueCount = Object.keys(this.loadQueue.lod2PCloudDataMap).length;
	if (lod2DataInQueueCount > 5)
	{ return; }
	
	var extraCount = fileRequestExtraCount;
		
	var currentVisibles = globalVisibleObjControlerOctrees.getAllVisibles();
	//var currentVisibles = globalVisibleObjControlerOctrees.currentVisiblesAux;

	if (currentVisibles === undefined)
	{ return; }

	var geometryDataPath = this.readerWriter.geometryDataPath;
	var projectFolderName;
	var neoBuilding;
	var buildingFolderName;

	// LOD2
	// Check if the lod2lowestOctrees must load and parse data
	var lowestOctree;
	for (var i=0, length = currentVisibles.length; i<length; i++) 
	{	
		if (this.fileRequestControler.isFullPlus(extraCount))	
		{ return; }
		
		lowestOctree = currentVisibles[i];
		
		if (lowestOctree.octree_number_name === undefined)
		{ continue; }
		
		if (lowestOctree.lego === undefined) 
		{
			lowestOctree.lego = new Lego();
			lowestOctree.lego.fileLoadState = CODE.fileLoadState.READY;
			lowestOctree.lego.legoKey = lowestOctree.octreeKey + "_lego";
		}
	
		neoBuilding = lowestOctree.neoBuildingOwner;
		if (neoBuilding === undefined)
		{ continue; }
	
		var projectDataType = neoBuilding.metaData.projectDataType;
		
		if (projectDataType !== undefined && projectDataType === 4) // projectDataType = 4 (pointsCloudType building).***
		{
			projectFolderName = neoBuilding.projectFolderName;
			buildingFolderName = neoBuilding.buildingFileName;

			if (lowestOctree.lego.fileLoadState === CODE.fileLoadState.READY)
			{
				var subOctreeNumberName = lowestOctree.octree_number_name.toString();
				var references_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/References";
				var filePathInServer = references_folderPath + "/" + subOctreeNumberName + "_Ref";
				this.loadQueue.putLod2PCloudData(lowestOctree, filePathInServer, undefined, undefined, 0);

			}
			
			if (Object.keys(this.loadQueue.lod2PCloudDataMap).length > 5)
			{ return; }
		}
	} 
};

/**
 * LOD0, LOD1 에 대한 F4D ModelData, ReferenceData 를 요청
 * 
 * @param {any} gl 
 * @param {any} scene 
 * @param {any} neoBuilding 
 */
MagoManager.prototype.prepareVisibleOctreesSortedByDistance = function(gl, globalVisibleObjControlerOctrees) 
{
	if (this.readerWriter.referencesList_requested > 5)
	{ return; }

	// LOD0 & LOD1
	// Check if the lod0lowestOctrees, lod1lowestOctrees must load and parse data
	var currentVisibleOctrees = [].concat(globalVisibleObjControlerOctrees.currentVisibles0, globalVisibleObjControlerOctrees.currentVisibles1);
	var lowestOctree;
	this.thereAreUrgentOctrees = false;

	// now, prepare the ocree normally.
	var maxFilesLoad = 2;
	var filesLoadCounter = 0;
	
	for (var i=0, length = currentVisibleOctrees.length; i<length; i++) 
	{
		lowestOctree = currentVisibleOctrees[i];
		var neoBuilding = lowestOctree.neoBuildingOwner;
		var version = neoBuilding.getHeaderVersion();
		
		
		// 1rst, check if lod2 is loaded. If lod2 is no loaded yet, then load first lod2.***
		if (this.readerWriter.octreesSkinLegos_requested < 5)
		{
			if (lowestOctree.lego === undefined || !lowestOctree.lego.isReadyToRender())
			{
				lowestOctree.prepareSkinData(this);
			}
		}

		if (this.readerWriter.referencesList_requested < 5)
		{
			if (lowestOctree.neoReferencesMotherAndIndices === undefined || !lowestOctree.neoReferencesMotherAndIndices.isReadyToRender())
			{
				lowestOctree.prepareModelReferencesListData(this);
			}
			else 
			{
				if (version === "0.0.2")
				{
					var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList; 
					if (blocksList)
					{ blocksList.prepareData(this, lowestOctree); }
				}
			}
		}
		

		if (this.readerWriter.referencesList_requested > 5)
		{ return; }
		
		if (filesLoadCounter > maxFilesLoad)
		{ return; }
	}
	
	
};

/**
 * LOD2 에 대한 F4D LegoData 를 요청
 * 
 * @param {any} gl 
 * @param {any} scene 
 * @param {any} neoBuilding 
 */
MagoManager.prototype.prepareVisibleOctreesSortedByDistanceLOD2 = function(gl, currentVisibles) 
{
	if (this.readerWriter.octreesSkinLegos_requested > 5)
	{ return; }

	if (currentVisibles === undefined)
	{ return; }

	// LOD2
	// Check if the lod2lowestOctrees must load and parse data
	var lowestOctree;
	for (var i=0, length = currentVisibles.length; i<length; i++) 
	{	
		lowestOctree = currentVisibles[i];
		lowestOctree.prepareSkinData(this);

		if (this.readerWriter.octreesSkinLegos_requested > 5)
		{ return; }
	} 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param cameraPosition 카메라 입장에서 화면에 그리기 전에 객체를 그릴 필요가 있는지 유무를 판단하는 값
 * @param scene 변수
 * @param shader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 * @param neoRefLists_array 변수
 */

MagoManager.prototype.checkChangesHistoryMovements = function(nodesArray) 
{
	var nodesCount = nodesArray.length;
	var node;
	var rootNode;	
	var projectId;
	var dataKey;
	var moveHistoryMap;
	var colorChangedHistoryMap;
	var objectIndexOrder;
	var neoBuilding;
	var refObject;
	var moveVector;
	var moveVectorRelToBuilding;
	var geoLocdataManager;
	var geoLoc;
	
	// check movement of objects.
	for (var i=0; i<nodesCount; i++)
	{
		node = nodesArray[i];
		rootNode = node.getRoot();
		if (rootNode === undefined)
		{ continue; }
		
		geoLocdataManager = rootNode.getNodeGeoLocDataManager();
		geoLoc = geoLocdataManager.getCurrentGeoLocationData();
		projectId = node.data.projectId;
		dataKey = node.data.nodeId;
		
		// objects movement.
		moveHistoryMap = MagoConfig.getMovingHistoryObjects(projectId, dataKey);
		if (moveHistoryMap)
		{
			node.data.moveHistoryMap = moveHistoryMap;
			/*
			neoBuilding = node.data.neoBuilding;
			///for (var changeHistory of moveHistoryMap.values()) 
			for (var key in moveHistoryMap)
			{
				if (Object.prototype.hasOwnProperty.call(moveHistoryMap, key)) 
				{
					var changeHistory = moveHistoryMap[key];
					objectIndexOrder = changeHistory.getObjectIndexOrder();
					refObject = neoBuilding.getReferenceObject(objectIndexOrder);
					if (refObject === undefined)
					{ continue; }
					
					if (refObject.moveVector === undefined)
					{ refObject.moveVector = new Point3D(); }
					
					if (refObject.moveVectorRelToBuilding === undefined)
					{ refObject.moveVectorRelToBuilding = new Point3D(); }
					
					moveVector = changeHistory.getReferenceObjectAditionalMovement();
					moveVectorRelToBuilding = changeHistory.getReferenceObjectAditionalMovementRelToBuilding();
					refObject.moveVectorRelToBuilding.set(moveVectorRelToBuilding.x, moveVectorRelToBuilding.y, moveVectorRelToBuilding.z);
					refObject.moveVector.set(moveVector.x, moveVector.y, moveVector.z);
					
					// now check if the building was rotated.
					// if was rotated then recalculate the move vector.
					refObject.moveVector = geoLoc.tMatrix.rotatePoint3D(refObject.moveVectorRelToBuilding, refObject.moveVector); 
					
					// if was no rotated, then set the moveVector of the changeHistory.
					//refObject.moveVectorRelToBuilding.set(moveVectorRelToBuilding.x, moveVectorRelToBuilding.y, moveVectorRelToBuilding.z);	
				}
			}
			*/
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */

MagoManager.prototype.checkPropertyFilters = function(nodesArray) 
{
	if (this.propertyFilterSC === undefined)
	{ return; }
	
	var nodesCount = nodesArray.length;
	var node;	
	var projectId;
	var propertyKey = this.propertyFilterSC.propertyKey;
	var propertyValue = this.propertyFilterSC.propertyValue;
	var visible = this.propertyFilterSC.visible;
	
	for (var i=0; i<nodesCount; i++)
	{
		node = nodesArray[i];
		projectId = node.data.projectId;
		if (projectId === this.propertyFilterSC.projectId)
		{
			if (node.data.attributes)
			{
				if (node.data.attributes[propertyKey] !== undefined && node.data.attributes[propertyKey].toString() === propertyValue)
				{
					if (visible === "true")
					{
						// do nothing.
					}
					else
					{
						nodesArray.splice(i, 1);
						i--;
						nodesCount = nodesArray.length;
					}
				}
				else
				{
					if (visible === "true")
					{
						nodesArray.splice(i, 1);
						i--;
						nodesCount = nodesArray.length;
					}
					else 
					{
						// do nothing.
					}
				}
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */

MagoManager.prototype.checkChangesHistoryColors = function(nodesArray) 
{
	var nodesCount = nodesArray.length;
	var node;
	var rootNode;	
	var projectId;
	var dataKey;
	var moveHistoryMap;
	var colorChangedHistoryMap;
	var objectIndexOrder;
	var neoBuilding;
	var refObject;
	
	// check movement of objects.
	for (var i=0; i<nodesCount; i++)
	{
		node = nodesArray[i];
		rootNode = node.getRoot();
		if (rootNode === undefined)
		{ continue; }
		
		projectId = node.data.projectId;
		dataKey = node.data.nodeId;

		colorChangedHistoryMap = MagoConfig.getColorHistorys(projectId, dataKey);
		if (colorChangedHistoryMap)
		{
			var data = node.data;
			
			// Set the colorChangedHistoryMap into data of the node.***
			data.colorChangedHistoryMap = colorChangedHistoryMap;
		}
	}
	
	var allColorHistoryMap = MagoConfig.getAllColorHistory();
	if (allColorHistoryMap)
	{
		for (var key in allColorHistoryMap) 
		{
			if (Object.prototype.hasOwnProperty.call(allColorHistoryMap, key))
			{
				var colorChangedHistoryMap = allColorHistoryMap[key];
				//for (var colorChangedHistoryMap of allColorHistoryMap.values()) 
				//{
				// now check nodes that is no physical.
				for (var key2 in colorChangedHistoryMap) 
				{
					if (Object.prototype.hasOwnProperty.call(colorChangedHistoryMap, key2))
					{
						var changeHistoryMap = colorChangedHistoryMap[key2];
						//for (var changeHistoryMap of colorChangedHistoryMap.values()) 
						//{
						for (var key3 in changeHistoryMap) 
						{
							if (Object.prototype.hasOwnProperty.call(changeHistoryMap, key3))
							{
								var changeHistory = changeHistoryMap[key3];
								//for (var changeHistory of changeHistoryMap.values()) 
								//{
								var projectId = changeHistory.projectId;
								var nodesMap = this.hierarchyManager.getNodesMap(projectId);
								var aNode = nodesMap[changeHistory.dataKey];
								if (aNode && aNode.data.attributes.isPhysical !== undefined && aNode.data.attributes.isPhysical === false)
								{
									// must check if there are filters.
									if (changeHistory.property === null || changeHistory.property === undefined || changeHistory.property === "" )
									{
										// this is a no physical node, so must check children.
										var nodesArray = [];
										aNode.extractNodes(nodesArray);
										var nodesCount = nodesArray.length;
										for (var i=0; i<nodesCount; i++)
										{
											var aNode2 = nodesArray[i];
											var data = aNode2.data;
											//neoBuilding = aNode2.data.neoBuilding;
											if (data)
											{
												data.isColorChanged = true;
												if (data.aditionalColor === undefined)
												{ data.aditionalColor = new Color(); }
												
												data.aditionalColor.setRGB(changeHistory.rgbColor[0], changeHistory.rgbColor[1], changeHistory.rgbColor[2]);
											}
										}
									}
									else 
									{
										var propertyKey = changeHistory.propertyKey;
										var propertyValue = changeHistory.propertyValue;
											
										// this is a no physical node, so must check children.
										var nodesArray = [];
										aNode.extractNodes(nodesArray);
										var nodesCount = nodesArray.length;
										for (var i=0; i<nodesCount; i++)
										{
											var aNode2 = nodesArray[i];
											var data = aNode2.data;
											//neoBuilding = aNode2.data.neoBuilding;
											if (data)
											{
												if (aNode2.data.attributes[propertyKey] !== undefined && aNode2.data.attributes[propertyKey].toString() === propertyValue)
												{
													data.isColorChanged = true;
													if (data.aditionalColor === undefined)
													{ data.aditionalColor = new Color(); }
													
													data.aditionalColor.setRGB(changeHistory.rgbColor[0], changeHistory.rgbColor[1], changeHistory.rgbColor[2]);
												}
											}
										}
									}
								}	
							}
						}	
					}
				}	
			}
		}
	}
};


/**
 * Draw building names on scene.
 */
MagoManager.prototype.getObjectLabel = function() 
{
	if (this.canvasObjectLabel === undefined)
	{
		this.canvasObjectLabel = document.getElementById("objectLabel");
		if (this.canvasObjectLabel === undefined)
		{ return; }

		var magoDiv = document.getElementById('magoContainer');
		var offsetLeft = magoDiv.offsetLeft;
		var offsetTop = magoDiv.offsetTop;
		var offsetWidth = magoDiv.offsetWidth;
		var offsetHeight = magoDiv.offsetHeight;
		
		this.canvasObjectLabel.style.opacity = 1.0;
		this.canvasObjectLabel.width = this.sceneState.drawingBufferWidth;
		this.canvasObjectLabel.height = this.sceneState.drawingBufferHeight;
		var canvasStyleLeft = offsetLeft.toString()+"px";
		var canvasStyleTop = offsetTop.toString()+"px";
		this.canvasObjectLabel.style.left = canvasStyleLeft;
		this.canvasObjectLabel.style.top = canvasStyleTop;
		this.canvasObjectLabel.style.position = "absolute";
		
		this.canvasObjectLabel.style.opacity = 1.0;
		this.canvasObjectLabel.width = this.sceneState.drawingBufferWidth;
		this.canvasObjectLabel.height = this.sceneState.drawingBufferHeight;
		var ctx = this.canvasObjectLabel.getContext("2d");
		//ctx.strokeStyle = 'SlateGrey';
		//ctx.strokeStyle = 'MidnightBlue';
		ctx.strokeStyle = 'DarkSlateGray'; 
		//ctx.fillStyle= "white";
		ctx.fillStyle= "PapayaWhip";
		ctx.lineWidth = 4;
		ctx.font = "20px Arial";
		ctx.textAlign = 'center';
		//ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		ctx.save();
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

		var lineHeight = ctx.measureText("M").width * 1.1;
	}
	
	return this.canvasObjectLabel;
};

/**
 * Draw building names on scene.
 */
MagoManager.prototype.drawCCTVNames = function(cctvArray) 
{
	var canvas = this.getObjectLabel();
	var ctx = canvas.getContext("2d");
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

	// lod2.
	var gl = this.sceneState.gl;
	var node;
	var nodeRoot;
	var geoLocDataManager;
	var geoLoc;
	var neoBuilding;
	var worldPosition;
	var screenCoord;
	var cctv;
	
	var cctvCount = cctvArray.length;
	for (var i=0; i<cctvCount; i++)
	{
		cctv = cctvArray[i];
		geoLoc = cctv.geoLocationData;
		worldPosition = geoLoc.position;
		//screenCoord = this.calculateWorldPositionToScreenCoord(gl, worldPosition.x, worldPosition.y, worldPosition.z, screenCoord);
		screenCoord = ManagerUtils.calculateWorldPositionToScreenCoord(gl, worldPosition.x, worldPosition.y, worldPosition.z, screenCoord, this);
		//screenCoord.x += 250;
		//screenCoord.y += 150;
		
		if (screenCoord.x >= 0 && screenCoord.y >= 0)
		{
			ctx.font = "13px Arial";
			ctx.strokeText(cctv.name, screenCoord.x, screenCoord.y);
			ctx.fillText(cctv.name, screenCoord.x, screenCoord.y);
		}
		
	}

	ctx.restore();
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
MagoManager.prototype.createDefaultShaders = function(gl) 
{
	// here creates the necessary shaders for mago3d.***
	// 1) ModelReferences ssaoShader.******************************************************************************
	var shaderName = "modelRefSsao";
	var shader = this.postFxShadersManager.newShader(shaderName);
	var ssao_vs_source = ShaderSource.ModelRefSsaoVS;
	var ssao_fs_source = ShaderSource.ModelRefSsaoFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	
	// 1.1) ModelReferences depthShader.******************************************************************************
	var shaderName = "modelRefDepth";
	var shader = this.postFxShadersManager.newShader(shaderName);
	var showDepth_vs_source = ShaderSource.RenderShowDepthVS;
	var showDepth_fs_source = ShaderSource.RenderShowDepthFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, showDepth_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, showDepth_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");
	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	
	// 2) ModelReferences colorCoding shader.***********************************************************************
	var shaderName = "modelRefColorCoding";
	var shader = this.postFxShadersManager.newShader(shaderName);
	var showDepth_vs_source = ShaderSource.ColorSelectionSsaoVS;
	var showDepth_fs_source = ShaderSource.ColorSelectionSsaoFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, showDepth_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, showDepth_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");
	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	
	// 3) TinTerrain shader.****************************************************************************************
	shaderName = "tinTerrain";
	shader = this.postFxShadersManager.newShader(shaderName);
	ssao_vs_source = ShaderSource.TinTerrainVS;
	ssao_fs_source = ShaderSource.TinTerrainFS;
	
	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	shader.bIsMakingDepth_loc = gl.getUniformLocation(shader.program, "bIsMakingDepth");
	
	// 4) PointsCloud shader.****************************************************************************************
	shaderName = "pointsCloud";
	shader = this.postFxShadersManager.newShader(shaderName);
	ssao_vs_source = ShaderSource.PointCloudVS;
	ssao_fs_source = ShaderSource.PointCloudFS;
	
	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	
	// pointsCloud shader locals.***
	shader.bPositionCompressed_loc = gl.getUniformLocation(shader.program, "bPositionCompressed");
	shader.minPosition_loc = gl.getUniformLocation(shader.program, "minPosition");
	shader.bboxSize_loc = gl.getUniformLocation(shader.program, "bboxSize");
	
	// 5) Test Quad shader.****************************************************************************************
	shaderName = "testQuad"; // used by temperatura layer.***
	shader = this.postFxShadersManager.newShader(shaderName);
	ssao_vs_source = ShaderSource.Test_QuadVS;
	ssao_fs_source = ShaderSource.Test_QuadFS;
	
	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	
	// 6) Filter silhouette shader.*************************************************************************************
	shaderName = "filterSilhouette"; 
	shader = this.postFxShadersManager.newShader(shaderName);
	ssao_vs_source = ShaderSource.wgs84_volumVS; // simple screen quad v-shader.***
	ssao_fs_source = ShaderSource.filterSilhouetteFS;
	
	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	
	// 7) PointsCloud Depth shader.****************************************************************************************
	shaderName = "pointsCloudDepth";
	shader = this.postFxShadersManager.newShader(shaderName);
	ssao_vs_source = ShaderSource.PointCloudDepthVS;
	ssao_fs_source = ShaderSource.RenderShowDepthFS;
	
	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	
	// pointsCloud shader locals.***
	shader.bPositionCompressed_loc = gl.getUniformLocation(shader.program, "bPositionCompressed");
	shader.minPosition_loc = gl.getUniformLocation(shader.program, "minPosition");
	shader.bboxSize_loc = gl.getUniformLocation(shader.program, "bboxSize");
	
	// 8) PointsCloud shader.****************************************************************************************
	shaderName = "pointsCloudSsao";
	shader = this.postFxShadersManager.newShader(shaderName);
	ssao_vs_source = ShaderSource.PointCloudVS;
	ssao_fs_source = ShaderSource.PointCloudSsaoFS;
	
	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	
	// pointsCloud shader locals.***
	shader.bPositionCompressed_loc = gl.getUniformLocation(shader.program, "bPositionCompressed");
	shader.minPosition_loc = gl.getUniformLocation(shader.program, "minPosition");
	shader.bboxSize_loc = gl.getUniformLocation(shader.program, "bboxSize");
};

/**
 * 카메라 영역에 벗어난 오브젝트의 렌더링은 비 활성화
 */
MagoManager.prototype.isFarestFrustum = function() 
{
	if (this.numFrustums - this.currentFrustumIdx - 1 === 0)
	{ return true; }
	else
	{ return false; }
};

/**
 * 카메라 영역에 벗어난 오브젝트의 렌더링은 비 활성화
 * 
 * @param frustumVolume 변수
 * @param cameraPosition 변수
 */
MagoManager.prototype.doMultiFrustumCullingSmartTiles = function(camera) 
{
	// Here uses a frustum that is the sum of all frustums.***
	var frustumVolume = this.myCameraSCX.bigFrustum;
	
	// This makes the visible buildings array.
	var smartTile1 = this.smartTileManager.tilesArray[0]; // America side tile.
	var smartTile2 = this.smartTileManager.tilesArray[1]; // Asia side tile.
	
	if (this.frustumVolumeControl === undefined)
	{ this.frustumVolumeControl = new FrustumVolumeControl(); }
	
	if (this.fullyIntersectedLowestTilesArray === undefined)
	{ this.fullyIntersectedLowestTilesArray = []; }

	if (this.partiallyIntersectedLowestTilesArray === undefined)
	{ this.partiallyIntersectedLowestTilesArray = []; }
	
	if (this.lastIntersectedLowestTilesArray === undefined)
	{ this.lastIntersectedLowestTilesArray = []; }
	
	// save the last frustumCulled lowestTiles to delete if necessary.
	this.lastIntersectedLowestTilesArray.push.apply(this.lastIntersectedLowestTilesArray, this.fullyIntersectedLowestTilesArray);
	this.lastIntersectedLowestTilesArray.push.apply(this.lastIntersectedLowestTilesArray, this.partiallyIntersectedLowestTilesArray);
	
	// mark all last_tiles as "no visible".
	var lastLowestTilesCount = this.lastIntersectedLowestTilesArray.length;
	var lowestTile;
	for (var i=0; i<lastLowestTilesCount; i++)
	{
		lowestTile = this.lastIntersectedLowestTilesArray[i];
		lowestTile.isVisible = false;
	}
	
	// do frustum culling for Asia_side_tile and America_side_tile.
	this.fullyIntersectedLowestTilesArray.length = 0; // init array.
	this.partiallyIntersectedLowestTilesArray.length = 0; // init array.
	smartTile1.getFrustumIntersectedLowestTiles(frustumVolume, this.fullyIntersectedLowestTilesArray, this.partiallyIntersectedLowestTilesArray);
	smartTile2.getFrustumIntersectedLowestTiles(frustumVolume, this.fullyIntersectedLowestTilesArray, this.partiallyIntersectedLowestTilesArray);
	
	// Now, store the culled tiles into corresponding frustums, and mark all current_tiles as "visible".***
	this.frustumVolumeControl.initArrays(); // init.***
	var frustumsCount = this.myCameraSCX.frustumsArray.length;
	var frustum;
	var lowestTile;
	var currentLowestTilesCount = this.fullyIntersectedLowestTilesArray.length;
	for (var i=0; i<currentLowestTilesCount; i++)
	{
		lowestTile = this.fullyIntersectedLowestTilesArray[i];
		if (lowestTile.sphereExtent === undefined)
		{ continue; }
		
		lowestTile.isVisible = true;
		for (var j=frustumsCount-1; j>= 0 ; j--)
		{
			frustum = this.myCameraSCX.frustumsArray[j];
			if (frustum.intersectionNearFarSphere(lowestTile.sphereExtent) !== Constant.INTERSECTION_OUTSIDE)
			{
				var frustumVolumeControlObject = this.frustumVolumeControl.getFrustumVolumeCulling(j); 
				frustumVolumeControlObject.fullyIntersectedLowestTilesArray.push(lowestTile);
				//break;
			}
		}
	}
	
	currentLowestTilesCount = this.partiallyIntersectedLowestTilesArray.length;
	for (var i=0; i<currentLowestTilesCount; i++)
	{
		lowestTile = this.partiallyIntersectedLowestTilesArray[i];
		if (lowestTile.sphereExtent === undefined)
		{ continue; }
		
		lowestTile.isVisible = true;
		for (var j=frustumsCount-1; j>= 0 ; j--)
		{
			frustum = this.myCameraSCX.frustumsArray[j];
			if (frustum.intersectionNearFarSphere(lowestTile.sphereExtent) !== Constant.INTERSECTION_OUTSIDE)
			{
				var frustumVolumeControlObject = this.frustumVolumeControl.getFrustumVolumeCulling(j); 
				frustumVolumeControlObject.partiallyIntersectedLowestTilesArray.push(lowestTile);
				//break;
			}
		}
	}
	
	// Now, delete all tiles that is no visible in the all frustumVolumes.***
	// Put to deleting queue.***
	var lastLowestTilesCount = this.lastIntersectedLowestTilesArray.length;
	var lowestTile;
	for (var i=0; i<lastLowestTilesCount; i++)
	{
		lowestTile = this.lastIntersectedLowestTilesArray[i];
		if (!lowestTile.isVisible)
		{
			this.processQueue.putNodesArrayToDelete(lowestTile.nodesArray);
			lowestTile.clearNodesArray();
		}
	}
	
	this.lastIntersectedLowestTilesArray.length = 0;
	
	
	// TinTerranTiles.*************************************************************************
	// Provisionally:
	if (this.tinTerrainManager !== undefined)
	{ this.tinTerrainManager.doFrustumCulling(frustumVolume, camera.position, this); }
};

/**
 * dataKey 이용해서 data 검색
 * @param dataKey
 */
MagoManager.prototype.tilesMultiFrustumCullingFinished = function(intersectedLowestTilesArray, visibleNodes, cameraPosition, frustumVolume, doFrustumCullingToBuildings) 
{
	var tilesCount = intersectedLowestTilesArray.length;
	
	if (tilesCount === 0)
	{ return; }
	
	var distToCamera;
	var magoPolicy = this.magoPolicy;
	
	
	
	var lod0_minDist = magoPolicy.getLod1DistInMeters();
	var lod1_minDist = 1;
	var lod2_minDist = magoPolicy.getLod2DistInMeters();
	var lod5_minDist = magoPolicy.getLod5DistInMeters();
	var lod3_minDist;
	
	// get lodDistances for determine the real lod of the building.***
	var lod0Dist = magoPolicy.getLod0DistInMeters();
	var lod1Dist = magoPolicy.getLod1DistInMeters();
	var lod2Dist = magoPolicy.getLod2DistInMeters();
	var lod3Dist = magoPolicy.getLod3DistInMeters();
	var lod4Dist = magoPolicy.getLod4DistInMeters();
	var lod5Dist = magoPolicy.getLod5DistInMeters();

	var maxNumberOfCalculatingPositions = 100;
	var currentCalculatingPositionsCount = 0;
	
	var lowestTile;
	var buildingSeedsCount;
	var buildingSeed;
	var neoBuilding;
	var node;
	var nodeRoot;
	var nodeBbox;
	var geoLoc;
	var geoLocDataManager;
	var realBuildingPos;
	var longitude, latitude, altitude, heading, pitch, roll;

	for (var i=0; i<tilesCount; i++)
	{
		lowestTile = intersectedLowestTilesArray[i];
		if (lowestTile.sphereExtent === undefined)
		{ continue; }
	
	
	
		distToCamera = cameraPosition.distToSphere(lowestTile.sphereExtent);
		if (distToCamera > Number(lod5_minDist))
		{ continue; }

		if (lowestTile.nodesArray && lowestTile.nodesArray.length > 0)
		{
			// the neoBuildings are made.
			var nodesCount = lowestTile.nodesArray.length;
			for (var j=0; j<nodesCount; j++)
			{
				// determine LOD for each building.
				node = lowestTile.nodesArray[j];
				nodeRoot = node.getRoot();

				// now, create a geoLocDataManager for node if no exist.
				if (nodeRoot.data.geoLocDataManager === undefined)
				{
					geoLoc = node.calculateGeoLocData(this);
					continue;
				}
				neoBuilding = node.data.neoBuilding;
				
				if (neoBuilding === undefined)
				{
					// This node is a reference node.***
					visibleNodes.currentVisiblesAux.push(node);
					continue;
				}
				
				if (this.boundingSphere_Aux === undefined)
				{ this.boundingSphere_Aux = new Sphere(); }
			
				distToCamera = node.getDistToCamera(cameraPosition, this.boundingSphere_Aux);
				
				var data = node.data;
				data.currentLod;
				data.distToCam = distToCamera;
				
				
				if (data.distToCam < lod0Dist)
				{ data.currentLod = 0; }
				else if (data.distToCam < lod1Dist)
				{ data.currentLod = 1; }
				else if (data.distToCam < lod2Dist)
				{ data.currentLod = 2; }
				else if (data.distToCam < lod3Dist)
				{ data.currentLod = 3; }
				else if (data.distToCam < lod4Dist)
				{ data.currentLod = 4; }
				else if (data.distToCam < lod5Dist)
				{ data.currentLod = 5; }
				
				var frustumFar = magoPolicy.getFrustumFarDistance();
				if (distToCamera > frustumFar)
				{ 
					// put this node to delete into queue.***
					this.processQueue.putNodeToDelete(node, 0);
					continue; 
				}
				
				
				
				// If necessary do frustum culling.*************************************************************************
				if (doFrustumCullingToBuildings)
				{
					var frustumCull = frustumVolume.intersectionSphere(this.boundingSphere_Aux); // cesium.***
					// intersect with Frustum
					if (frustumCull === Constant.INTERSECTION_OUTSIDE) 
					{
						// put this node to delete into queue.***
						//this.processQueue.putNodeToDeleteModelReferences(node, 0);
						this.processQueue.putNodeToDeleteLessThanLod3(node, 0);
						continue;
					}
				}
				
				
				//-------------------------------------------------------------------------------------------
				
				
				
				// provisionally fork versions.***
				var version = neoBuilding.getHeaderVersion();
				if (version === undefined)
				{ continue; }
				
				if (version[0] === 'v')
				{
					if (distToCamera < lod0_minDist) 
					{
						visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles0, node);
					}
					else if (distToCamera < lod1_minDist) 
					{
						visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles1, node);
					}
					else if (distToCamera < lod2_minDist) 
					{
						visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles2, node);
					}
					else if (distToCamera < lod5_minDist) 
					{
						visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles3, node);
					}
				}
				else 
				{
					// provisional test for pointsCloud data.************
					var metaData = neoBuilding.metaData;
					var projectsType = metaData.projectDataType;
					if (projectsType && (projectsType === 4 || projectsType === 5))
					{
						// Project_data_type (new in version 002).***
						// 1 = 3d model data type (normal 3d with interior & exterior data).***
						// 2 = single building skin data type (as vWorld or googleEarth data).***
						// 3 = multi building skin data type (as Shibuya & Odaiba data).***
						// 4 = pointsCloud data type.***
						visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisiblesAux, node);
					}
					// end provisional test.-----------------------------
					else
					{
						if (distToCamera < lod0_minDist) 
						{
							// check if the lod0, lod1, lod2 are modelReference type.***
							var lodBuildingData = neoBuilding.getLodBuildingData(0);
							if (lodBuildingData && lodBuildingData.isModelRef)
							{ 
								visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles0, node);
							}
							else
							{ 
								//visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles3, node);
								visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles0, node);
							}
						}
						else if (distToCamera < lod1_minDist) 
						{
							var lodBuildingData = neoBuilding.getLodBuildingData(1);
							if (lodBuildingData && lodBuildingData.isModelRef)
							{ 
								visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles1, node);
							}
							else
							{ 
								//visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles3, node);
								visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles1, node);
							}
						}
						else if (distToCamera < lod2_minDist) 
						{
							var lodBuildingData = neoBuilding.getLodBuildingData(2);
							if (lodBuildingData && lodBuildingData.isModelRef)
							{ 
								visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles2, node);
							}
							else
							{ 
								visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles3, node);
							}
						}
						else if (distToCamera < lod5_minDist) 
						{
							visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles3, node);
						}
					}
				}
			}
			
			if (lowestTile.nodesArray.length !== lowestTile.nodeSeedsArray.length)
			{
				// create the buildings by buildingSeeds.
				this.createBuildingsByBuildingSeedsOnLowestTile(lowestTile);
				
			}
			
			
		}
		else
		{
			// create the buildings by buildingSeeds.
			this.createBuildingsByBuildingSeedsOnLowestTile(lowestTile);
			
		}
		
		
	}
	
};


/**
 */
MagoManager.prototype.createBuildingsByBuildingSeedsOnLowestTile = function(lowestTile) 
{
	// create the buildings by buildingSeeds.
	var node;
	var neoBuilding;
	var nodeBbox;
	var buildingSeed;
	var startIndex = 0;
	
	// if exist nodesArray (there are buildings) and add a nodeSeed, we must make nodes of the added nodeSeeds.***
	if (lowestTile.nodesArray)
	{ startIndex = lowestTile.nodesArray.length; }

	if (lowestTile.nodesArray === undefined)
	{ lowestTile.nodesArray = []; }
	
	var nodeSeedsCount = lowestTile.nodeSeedsArray.length;
	for (var j=startIndex; j<nodeSeedsCount; j++)
	{
		node = lowestTile.nodeSeedsArray[j];
		
		if (node.data.neoBuilding !== undefined)
		{
			lowestTile.nodesArray.push(node);
			continue;
		}
		
		neoBuilding = new NeoBuilding();
		
		neoBuilding.nodeOwner = node;
		node.data.neoBuilding = neoBuilding;
		if (node.data.bbox === undefined)
		{ node.data.bbox = new BoundingBox(); }
		nodeBbox = node.data.bbox;
		buildingSeed = node.data.buildingSeed;
		
		lowestTile.nodesArray.push(node);
		
		if (neoBuilding.metaData === undefined) 
		{ neoBuilding.metaData = new MetaData(); }

		if (neoBuilding.metaData.geographicCoord === undefined)
		{ neoBuilding.metaData.geographicCoord = new GeographicCoord(); }

		if (neoBuilding.metaData.bbox === undefined) 
		{ neoBuilding.metaData.bbox = new BoundingBox(); }

		// create a building and set the location.***
		neoBuilding.name = buildingSeed.name;
		neoBuilding.buildingId = buildingSeed.buildingId;
	
		neoBuilding.buildingType = "basicBuilding";
		neoBuilding.buildingFileName = buildingSeed.buildingFileName;
		neoBuilding.metaData.geographicCoord.setLonLatAlt(buildingSeed.geographicCoord.longitude, buildingSeed.geographicCoord.latitude, buildingSeed.geographicCoord.altitude);
		neoBuilding.metaData.bbox.copyFrom(buildingSeed.bBox);
		nodeBbox.copyFrom(buildingSeed.bBox); // initially copy from building.
		if (neoBuilding.bbox === undefined)
		{ neoBuilding.bbox = new BoundingBox(); }
		neoBuilding.bbox.copyFrom(buildingSeed.bBox);
		neoBuilding.metaData.heading = buildingSeed.rotationsDegree.z;
		neoBuilding.metaData.pitch = buildingSeed.rotationsDegree.x;
		neoBuilding.metaData.roll = buildingSeed.rotationsDegree.y;
		neoBuilding.projectFolderName = node.data.projectFolderName;
		
	}
};

/**
 */
MagoManager.prototype.flyToTopology = function(worldPoint3d, duration) 
{
	if (MagoConfig.getPolicy().geo_view_library === Constant.CESIUM) 
	{
		this.scene.camera.flyTo({
			destination : Cesium.Cartesian3.clone(worldPoint3d),
			orientation : {
				direction : new Cesium.Cartesian3(this.scene.camera.direction.x, this.scene.camera.direction.y, this.scene.camera.direction.z),
				up        : new Cesium.Cartesian3(this.scene.camera.up.x, this.scene.camera.up.y, this.scene.camera.up.z)},
			duration: parseInt(duration)
		});
	}
	/*
	else if (MagoConfig.getPolicy().geo_view_library === Constant.WORLDWIND)
	{
		this.wwd.goToAnimator.travelTime = duration * 1000;
		this.wwd.goTo(new WorldWind.Position(parseFloat(latitude), parseFloat(longitude), parseFloat(altitude) + 50));
	}
	else if (MagoConfig.getPolicy().geo_view_library === Constant.MAGOWORLD)
	{
		this.magoWorld.goto(parseFloat(longitude),
			parseFloat(latitude),
			parseFloat(altitude) + 10);
	}
	*/
};

/**
 * dataKey 이용해서 data 검색
 * @param apiName api 이름
 * @param projectId project id
 * @param dataKey
 */
MagoManager.prototype.flyTo = function(longitude, latitude, altitude, duration) 
{
	if (MagoConfig.getPolicy().geo_view_library === Constant.CESIUM) 
	{
		this.scene.camera.flyTo({
			destination: Cesium.Cartesian3.fromDegrees(parseFloat(longitude),
				parseFloat(latitude),
				parseFloat(altitude)),
			duration: parseInt(duration)
		});
	}
	else if (MagoConfig.getPolicy().geo_view_library === Constant.MAGOWORLD)
	{
		this.magoWorld.goto(parseFloat(longitude),
			parseFloat(latitude),
			parseFloat(altitude));
	}

};

/**
 * dataKey 이용해서 data 검색
 * @param apiName api 이름
 * @param projectId project id
 * @param dataKey
 */
MagoManager.prototype.flyToBuilding = function(apiName, projectId, dataKey) 
{
	var node = this.hierarchyManager.getNodeByDataName(projectId, "nodeId", dataKey);
	if (node === undefined)
	{ 
		apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
		return; 
	}
	
	var nodeRoot = node.getRoot();
	var geoLocDataManager = nodeRoot.data.geoLocDataManager;
	var geoLoc;
	if (geoLocDataManager === undefined)
	{ 
		geoLoc = node.calculateGeoLocData(this);
		if (geoLoc === undefined)
		{
			apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
			return; 
		}
	}
	geoLocDataManager = nodeRoot.data.geoLocDataManager;
	geoLoc = geoLocDataManager.getCurrentGeoLocationData();
	var realBuildingPos = node.getBBoxCenterPositionWorldCoord(geoLoc);

	if (realBuildingPos === undefined)
	{ return; }

	this.radiusAprox_aux = nodeRoot.data.bbox.getRadiusAprox();

	if (this.boundingSphere_Aux === undefined)
	{ this.boundingSphere_Aux = new Sphere(); }
	
	this.boundingSphere_Aux.radius = this.radiusAprox_aux;

	if (this.configInformation.geo_view_library === Constant.CESIUM)
	{
		this.boundingSphere_Aux.center = Cesium.Cartesian3.clone(realBuildingPos);
		var seconds = 3;
		this.scene.camera.flyToBoundingSphere(this.boundingSphere_Aux, seconds);
	}
};

MagoManager.prototype.displayLocationAndRotation = function(neoBuilding) 
{
	//var node = this.hierarchyManager.getNodeByDataName(projectId, dataName, dataNameValue); // original.***
	var node = neoBuilding.nodeOwner;
	var geoLocDatamanager = node.getNodeGeoLocDataManager();
	if (geoLocDatamanager === undefined)
	{ return; }
	var geoLocationData = geoLocDatamanager.getCurrentGeoLocationData();
	var latitude = geoLocationData.geographicCoord.latitude;
	var longitude = geoLocationData.geographicCoord.longitude;
	var altitude = geoLocationData.geographicCoord.altitude;
	var heading = geoLocationData.heading;
	var pitch = geoLocationData.pitch;
	var roll = geoLocationData.roll;
	var dividedName = neoBuilding.buildingId.split("_");
};

/**
 * 변환 행렬
 */
MagoManager.prototype.selectedObjectNotice = function(neoBuilding) 
{
	if (neoBuilding === undefined)
	{ return; }
	
	var node = neoBuilding.nodeOwner;
	var geoLocDatamanager = node.getNodeGeoLocDataManager();
	if (geoLocDatamanager === undefined)
	{ return; }
	var geoLocationData = geoLocDatamanager.getCurrentGeoLocationData();
	var dataKey = node.data.nodeId;
	var projectId = node.data.projectId;

	if (MagoConfig.getPolicy().geo_callback_enable === "true") 
	{
		//if (this.objMarkerSC === undefined) { return; }
		var objectId = null;
		if (this.objectSelected !== undefined) { objectId = this.objectSelected.objectId; }
		
		// click object 정보를 표시
		if (this.magoPolicy.getObjectInfoViewEnable()) 
		{
			selectedObjectCallback(		MagoConfig.getPolicy().geo_callback_selectedobject,
				projectId,
				dataKey,
				objectId,
				geoLocationData.geographicCoord.latitude,
				geoLocationData.geographicCoord.longitude,
				geoLocationData.geographicCoord.altitude,
				geoLocationData.heading,
				geoLocationData.pitch,
				geoLocationData.roll);
		}
			
		// 이슈 등록 창 오픈
		if (this.magoPolicy.getIssueInsertEnable()) 
		{
			if (this.objMarkerSC === undefined) { return; }
			
			insertIssueCallback(	MagoConfig.getPolicy().geo_callback_insertissue,
				projectId,
				dataKey,
				objectId,
				geoLocationData.geographicCoord.latitude,
				geoLocationData.geographicCoord.longitude,
				(parseFloat(geoLocationData.geographicCoord.altitude)));
		}
	}
	
	
};

/**
 * 변환 행렬
 */
//MagoManager.prototype.changeLocationAndRotation = function(projectId, dataKey, latitude, longitude, elevation, heading, pitch, roll, durationTimeInSeconds)
MagoManager.prototype.changeLocationAndRotation = function(projectId, dataKey, latitude, longitude, elevation, heading, pitch, roll, animationOption) 
{
	var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
	if (node === undefined)
	{ return; }
	this.changeLocationAndRotationNode(node, latitude, longitude, elevation, heading, pitch, roll, animationOption);
};

/**
 * 변환 행렬
 */
//MagoManager.prototype.changeLocationAndRotationNode = function(node, latitude, longitude, elevation, heading, pitch, roll, durationTimeInSeconds) 
MagoManager.prototype.changeLocationAndRotationNode = function(node, latitude, longitude, elevation, heading, pitch, roll, animationOption) 
{
	if (node === undefined)
	{ return; }

	if (animationOption !== undefined)
	{
		if (this.animationManager === undefined)
		{ this.animationManager = new AnimationManager(); }
		this.animationManager.putNode(node);
		
		//For compatibility with lower versions, lower version parameter is duratiuon(number).
		node.changeLocationAndRotationAnimated(latitude, longitude, elevation, heading, pitch, roll, this, animationOption);
	}
	else 
	{
		node.changeLocationAndRotation(latitude, longitude, elevation, heading, pitch, roll, this);
	}
	
	var neoBuilding = node.data.neoBuilding;
	
	this.selectedObjectNotice(neoBuilding);
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.getObjectIndexFile = function(projectId, projectDataFolder) 
{
	if (this.configInformation === undefined)
	{
		this.configInformation = MagoConfig.getPolicy();
	}
	
	this.buildingSeedList = new BuildingSeedList();
	var fileName;
	var geometrySubDataPath = projectDataFolder;
	fileName = this.readerWriter.geometryDataPath + "/" + geometrySubDataPath + Constant.OBJECT_INDEX_FILE + Constant.CACHE_VERSION + MagoConfig.getPolicy().content_cache_version;
	this.readerWriter.getObjectIndexFileForSmartTile(fileName, this, this.buildingSeedList, projectId);
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.getObjectIndexFile_xxxx = function() 
{
	if (this.configInformation === undefined)
	{
		this.configInformation = MagoConfig.getPolicy();
	}

	this.buildingSeedList = new BuildingSeedList();
	this.readerWriter.getObjectIndexFileForSmartTile(
		this.readerWriter.getCurrentDataPath() + Constant.OBJECT_INDEX_FILE + Constant.CACHE_VERSION + MagoConfig.getPolicy().content_cache_version, this, this.buildingSeedList);
		
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.makeNode = function(jasonObject, resultPhysicalNodesArray, buildingSeedMap, projectFolderName, projectId) 
{
	var attributes = undefined;
	var children = undefined;
	var data_group_id = undefined;
	var data_group_name = undefined;
	var data_id = undefined;
	var data_key = undefined;
	var data_name = undefined;
	var heading = undefined;
	var height = undefined;
	var latitude = undefined;
	var longitude = undefined;
	var pitch = undefined;
	var roll = undefined;
	var mapping_type = undefined;
	
	if (jasonObject !== undefined)
	{
		attributes = jasonObject.attributes;
		children = jasonObject.children;
		data_group_id = jasonObject.data_group_id;
		data_group_name = jasonObject.data_group_name;
		data_id = jasonObject.data_id;
		data_key = jasonObject.data_key;
		data_name = jasonObject.data_name;
		heading = jasonObject.heading;
		height = jasonObject.height;
		latitude = jasonObject.latitude;
		longitude = jasonObject.longitude;
		pitch = jasonObject.pitch;
		roll = jasonObject.roll;
		mapping_type = jasonObject.mapping_type;
	}
	
	// now make the node.
	var buildingId;
	var buildingSeed;
	var node;
	var bbox;
	var childJason;
	var childNode;
	var childrenCount;
	if (attributes !== undefined)
	{
		if (!attributes.isReference)
		{
			buildingId = data_key;
			node = this.hierarchyManager.newNode(buildingId, projectId, attributes);
			// set main data of the node.
			node.data.projectFolderName = projectFolderName;
			node.data.projectId = projectId;
			node.data.data_name = data_name;
			node.data.attributes = attributes;
			node.data.mapping_type = mapping_type;
			var tMatrix;
			
			
			
			if (attributes.isPhysical)
			{
				// find the buildingSeed.
				buildingSeed = buildingSeedMap[buildingId];
				if (buildingSeed)
				{
					node.data.buildingSeed = buildingSeed;
					resultPhysicalNodesArray.push(node);
				}
			}

			if (longitude && latitude)
			{
				// this is root node.
				if (height === undefined)
				{ height = 0; }
				
				node.data.geographicCoord = new GeographicCoord();
				node.data.geographicCoord.setLonLatAlt(longitude, latitude, height);
				
				if (node.data.rotationsDegree === undefined)
				{ node.data.rotationsDegree = new Point3D(); }
				node.data.rotationsDegree.set(pitch, roll, heading);
				
				
				if (buildingSeed !== undefined)
				{
					if (buildingSeed.geographicCoord === undefined)
					{ buildingSeed.geographicCoord = new GeographicCoord(); }
				
					if (buildingSeed.rotationsDegree === undefined)
					{ buildingSeed.rotationsDegree = new Point3D(); }
			
					buildingSeed.geographicCoord.setLonLatAlt(longitude, latitude, height);
					buildingSeed.rotationsDegree.set(pitch, roll, heading);
					
					// now calculate the geographic coord of the center of the bbox.
					if (buildingSeed.geographicCoordOfBBox === undefined) 
					{ buildingSeed.geographicCoordOfBBox = new GeographicCoord(); }
				
					// calculate the transformation matrix at (longitude, latitude, height).
					var worldCoordPosition = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, height, worldCoordPosition, this);
					tMatrix = ManagerUtils.calculateTransformMatrixAtWorldPosition(worldCoordPosition, heading, pitch, roll, undefined, tMatrix, this);
					
					// now calculate the geographicCoord of the center of the bBox.
					var bboxCenterPoint;

					bboxCenterPoint = buildingSeed.bBox.getCenterPoint(bboxCenterPoint);
					var bboxCenterPointWorldCoord = tMatrix.transformPoint3D(bboxCenterPoint, bboxCenterPointWorldCoord);
					buildingSeed.geographicCoordOfBBox = ManagerUtils.pointToGeographicCoord(bboxCenterPointWorldCoord, buildingSeed.geographicCoordOfBBox, this); // original.
				}
			}

			// now, calculate the bbox.***
			node.data.bbox = new BoundingBox();
			
			if (node.data.buildingSeed && node.data.buildingSeed.bBox)
			{ node.data.bbox.copyFrom(buildingSeed.bBox); }
			
			if (node.data.mapping_type && node.data.mapping_type.toLowerCase() === "boundingboxcenter")
			{
				node.data.bbox.translateToOrigin();
			}
			
			// calculate the geographicCoordOfTheBBox.***
			if (tMatrix !== undefined)
			{
				bboxCenterPoint = node.data.bbox.getCenterPoint(bboxCenterPoint);
				var bboxCenterPointWorldCoord = tMatrix.transformPoint3D(bboxCenterPoint, bboxCenterPointWorldCoord);
				node.data.bbox.geographicCoord = ManagerUtils.pointToGeographicCoord(bboxCenterPointWorldCoord, node.data.bbox.geographicCoord, this);
			}

			//bbox = node.data.bbox;

			if (children !== undefined)
			{
				childrenCount = children.length;
				for (var i=0; i<childrenCount; i++)
				{
					childJason = children[i];
					childNode = this.makeNode(childJason, resultPhysicalNodesArray, buildingSeedMap, projectFolderName, projectId);
					
					// if childNode has "geographicCoord" then the childNode is in reality a root.
					if (childNode.data.geographicCoord === undefined)
					{
						node.addChildren(childNode);
					}
				}
			}
		}
		else 
		{
			/* static model 사용은 API를 통해서만... 
			attributes.projectId = projectId;
			this.addStaticModel(attributes);
			if (children !== undefined)
			{
				childrenCount = children.length;
				for (var i=0; i<childrenCount; i++)
				{
					var childrenObj = children[i];
					if (!defined(childrenObj.projectId))
					{
						childrenObj.projectId = projectId;
					}
					this.instantiateStaticModel(childrenObj);
				}
			}
			*/
		}
	}
	return node;
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.calculateBoundingBoxesNodes = function() 
{
	var node;
	var nodeRoot;
	var buildingSeed;
	var longitude, latitude, height;
	var heading, pitch, roll;
	
	// 1rst, calculate boundingBoxes of buildingSeeds of nodes.
	var nodesCount = this.hierarchyManager.nodesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		node = this.hierarchyManager.nodesArray[i];
		buildingSeed = node.data.buildingSeed;
		if (buildingSeed)
		{
			//nodeRoot = node.getRoot(); // old.***
			nodeRoot = node.getClosestParentWithData("geographicCoord");
			
			longitude = nodeRoot.data.geographicCoord.longitude; 
			latitude = nodeRoot.data.geographicCoord.latitude; 
			height = nodeRoot.data.geographicCoord.altitude;
			
			heading = nodeRoot.data.rotationsDegree.z;
			pitch = nodeRoot.data.rotationsDegree.x;
			roll = nodeRoot.data.rotationsDegree.y;
			
			if (buildingSeed.geographicCoord === undefined)
			{ buildingSeed.geographicCoord = new GeographicCoord(); }
		
			if (buildingSeed.rotationsDegree === undefined)
			{ buildingSeed.rotationsDegree = new Point3D(); }

			buildingSeed.geographicCoord.setLonLatAlt(longitude, latitude, height);
			buildingSeed.rotationsDegree.set(pitch, roll, heading);
			
			// now calculate the geographic coord of the center of the bbox.
			if (buildingSeed.geographicCoordOfBBox === undefined) 
			{ buildingSeed.geographicCoordOfBBox = new GeographicCoord(); }
		
			// calculate the transformation matrix at (longitude, latitude, height).
			var worldCoordPosition = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, height, worldCoordPosition, this);
			var tMatrix = ManagerUtils.calculateTransformMatrixAtWorldPosition(worldCoordPosition, heading, pitch, roll, undefined, tMatrix, this);
			
			// now calculate the geographicCoord of the center of the bBox.
			if (node.data.attributes.mapping_type && node.data.attributes.mapping_type === "boundingboxcenter")
			{
				var bboxCenterPoint = buildingSeed.bBox.getCenterPoint(bboxCenterPoint);
				var bboxCenterPointWorldCoord = tMatrix.transformPoint3D(bboxCenterPoint, bboxCenterPointWorldCoord);
				buildingSeed.geographicCoordOfBBox = ManagerUtils.pointToGeographicCoord(bboxCenterPointWorldCoord, buildingSeed.geographicCoordOfBBox, this); // original.
			}
			else 
			{
				buildingSeed.geographicCoordOfBBox.setLonLatAlt(longitude, latitude, height);
			}
		}
	}
	
	// now, must calculate the bbox of the root nodes.
	var rootNodesArray = [];
	var nodesArray = [];
	this.hierarchyManager.getRootNodes(rootNodesArray); // original.***
	var bboxStarted = false;
	
	var rootNodesCount = rootNodesArray.length;
	for (var i=0; i<rootNodesCount; i++)
	{
		nodeRoot = rootNodesArray[i];
		
		nodesArray.length = 0; // init.***
		nodeRoot.extractNodesByDataName(nodesArray, "buildingSeed");
		// now, take nodes that is "isMain" = true.
		bboxStarted = false;
		nodesCount =  nodesArray.length;
		for (var j=0; j<nodesCount; j++)
		{
			node = nodesArray[j];
			var nodeBBox = node.data.bbox;
			
			if (nodeBBox)
			{
				if (node.data.attributes)
				{
					if (node.data.attributes.isMain)
					{
						//buildingSeed = node.data.buildingSeed;
						if (bboxStarted === false)
						{
							nodeRoot.data.bbox.copyFrom(nodeBBox);
							bboxStarted = true;
						}
						else 
						{
							nodeRoot.data.bbox.addBox(nodeBBox);
						}
					}
					else 
					{
						if (bboxStarted === false)
						{
							nodeRoot.data.bbox.copyFrom(nodeBBox);
							bboxStarted = true;
						}
						else 
						{
							nodeRoot.data.bbox.addBox(nodeBBox);
						}
					}
				}
				else 
				{
					if (bboxStarted === false)
					{
						nodeRoot.data.bbox.copyFrom(nodeBBox);
						bboxStarted = true;
					}
					else 
					{
						nodeRoot.data.bbox.addBox(nodeBBox);
					}
				}
			}
		}
	}
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.makeSmartTile = function(buildingSeedList, projectId) 
{
	//var realTimeLocBlocksList = MagoConfig.getData().alldata; // original.***
	// "projectId" = json file name.
	var realTimeLocBlocksList = MagoConfig.getData(CODE.PROJECT_ID_PREFIX + projectId);
	var buildingSeedsCount;
	var buildingSeed;
	var buildingId;
	var newLocation;

	// now, read all hierarchyJason and make the hierarchy tree.
	var physicalNodesArray = []; // put here the nodes that has geometry data.
	// make a buildingSeedMap.
	var buildingSeedMap = {};
	var buildingSeedsCount = buildingSeedList.buildingSeedArray.length;
	for (var i=0; i<buildingSeedsCount; i++)
	{
		buildingSeed = buildingSeedList.buildingSeedArray[i];
		buildingId = buildingSeed.buildingId;
		buildingSeedMap[buildingId] = buildingSeed;
	}
	var projectFolderName = realTimeLocBlocksList.data_key;
	this.makeNode(realTimeLocBlocksList, physicalNodesArray, buildingSeedMap, projectFolderName, projectId);
	this.calculateBoundingBoxesNodes();
	
	// now, make smartTiles.
	// there are 2 general smartTiles: AsiaSide & AmericaSide.
	var targetDepth = 17;
	this.smartTileManager.makeTreeByDepth(targetDepth, physicalNodesArray, this);

	this.buildingSeedList.buildingSeedArray.length = 0; // init.

};

/**
 * instantiate static model
 * @param {instantiateOption} attributes
 */
MagoManager.prototype.instantiateStaticModel = function(attributes)
{
	if (!defined(attributes.projectId))
	{
		throw new Error('projectId is required.');
	}

	if (!this.isExistStaticModel(attributes.projectId))
	{
		throw new Error('static model is not exist.');
	}
	if (!defined(attributes.instanceId))
	{
		throw new Error('instanceId is required.');
	}

	if (!defined(attributes.longitude))
	{
		throw new Error('longitude is required.');
	}
	if (!defined(attributes.latitude))
	{
		throw new Error('latitude is required.');
	}

	if (!attributes.isReference)
	{
		attributes.isReference = true;
	}

	if (!attributes.isPhysical)
	{
		attributes.isPhysical = true;
	}

	if (!attributes.nodeType)
	{
		attributes.nodeType = "TEST";
	}

	//var nodesMap = this.hierarchyManager.getNodesMap(projectId, undefined);
	//var existentNodesCount = Object.keys(nodesMap).length;
	//var instanceId = defaultValue(attributes.instanceId, projectId + "_" + existentNodesCount.toString());
	var projectId = attributes.projectId;
	var instanceId = attributes.instanceId;
	
	var longitude = attributes.longitude;
	var latitude = attributes.latitude;
	var altitude = parseFloat(defaultValue(attributes.height, 0));
	var heading = parseFloat(defaultValue(attributes.heading, 0));
	var pitch = parseFloat(defaultValue(attributes.pitch, 0));
	var roll = parseFloat(defaultValue(attributes.roll, 0));
	
	var node = this.hierarchyManager.getNodeByDataKey(projectId, instanceId);
	if (node === undefined)
	{
		node = this.hierarchyManager.newNode(instanceId, projectId, undefined);

		var geoCoord = new GeographicCoord();
		geoCoord.latitude = parseFloat(latitude);
		geoCoord.longitude = parseFloat(longitude);
		geoCoord.altitude = parseFloat(altitude);

		var geoLocDataManager = geoCoord.getGeoLocationDataManager();
		var geoLocData = geoLocDataManager.newGeoLocationData("noName");
		geoLocData = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude+1, heading, pitch, roll, geoLocData, this);

		// Now, create the geoLocdataManager of node.***
		node.data.projectId = projectId;
		node.data.attributes = attributes;
		node.data.geographicCoord = geoCoord;
		node.data.rotationsDegree = new Point3D(pitch, roll, heading);
		node.data.geoLocDataManager = geoLocDataManager;

		// Now, insert node into smartTile.***
		var targetDepth = defaultValue(this.smartTileManager.targetDepth, 17);
		this.smartTileManager.putNode(targetDepth, node, this);
	}
	else 
	{
		this.changeLocationAndRotation(projectId, instanceId, latitude, longitude, altitude, heading, pitch, roll);
	}
};
/**
 * add static model
 * @param {staticModelOption} attributes
 */
MagoManager.prototype.addStaticModel = function(attribute)
{
	if (!defined(attribute.projectId))
	{
		throw new Error('projectId is required.');
	}

	if (!defined(attribute.projectFolderName))
	{
		throw new Error('projectFolderName is required.');
	}

	if (!defined(attribute.buildingFolderName))
	{
		throw new Error('buildingFolderName is required.');
	}
	var projectId = attribute.projectId;
	var staticModelsManager = this.hierarchyManager.getStaticModelsManager();

	var staticModel = new StaticModel();
	staticModel.guid = projectId;
	staticModel.projectFolderName = attribute.projectFolderName;
	staticModel.buildingFolderName = attribute.buildingFolderName;
	staticModel.neoBuilding = new NeoBuilding();
	
	staticModelsManager.addStaticModel(projectId, staticModel);
};
/**
 * check static model is exist
 * @param {string} projectId
 * @returns {Boolean} isExist
 */
MagoManager.prototype.isExistStaticModel = function(projectId)
{
	var isExist = false;

	if (!this.hierarchyManager.staticModelsManager || !this.hierarchyManager.staticModelsManager.staticModelsMap)
	{
		return isExist;
	}

	if (this.hierarchyManager.staticModelsManager.staticModelsMap.hasOwnProperty(projectId))
	{
		isExist = true;
	}
	return isExist;
};
/**
 * api gateway
 */
MagoManager.prototype.callAPI = function(api) 
{
	var apiName = api.getAPIName();
	if (apiName === "changeMagoState") 
	{
		this.magoPolicy.setMagoEnable(api.getMagoEnable());
	}
	else if (apiName === "searchData") 
	{
		return this.flyToBuilding(apiName, api.getProjectId(), api.getDataKey());
	}
	else if (apiName === "changeColor") 
	{
		ColorAPI.changeColor(api, this);
	}
	else if (apiName === "show") 
	{
		this.magoPolicy.setHideBuildings.length = 0;
	}
	else if (apiName === "hide") 
	{
		this.magoPolicy.setHideBuildings(api.gethideBuilds());
	}
	else if (apiName === "changeOutFitting") 
	{
		this.magoPolicy.setShowOutFitting(api.getShowOutFitting());
	} 
	else if (apiName === "changeLabel") 
	{
		this.magoPolicy.setShowLabelInfo(api.getShowLabelInfo());
		
		// clear the text canvas.
		var canvas = document.getElementById("objectLabel");
		var ctx = canvas.getContext("2d");
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

	}
	else if (apiName === "changeOrigin")
	{
		this.magoPolicy.setShowOrigin(api.getShowOrigin());
	}
	else if (apiName === "changeBoundingBox") 
	{
		this.magoPolicy.setShowBoundingBox(api.getShowBoundingBox());
	}
	else if (apiName === "changeShadow") 
	{
		this.magoPolicy.setShowShadow(api.getShowShadow());
		
	}
	else if (apiName === "changefrustumFarDistance") 
	{
		// frustum culling 가시 거리
		this.magoPolicy.setFrustumFarSquaredDistance(api.getFrustumFarDistance() * api.getFrustumFarDistance());
	}
	else if (apiName === "changeLocationAndRotation") 
	{
		LocationAndRotationAPI.changeLocationAndRotation(api, this);
	}
	else if (apiName === "changeObjectMove") 
	{
		this.magoPolicy.setObjectMoveMode(api.getObjectMoveMode());
	}
	else if (apiName === "saveObjectMove") 
	{
	//		var changeHistory = new ChangeHistory();
	//		changeHistory.setObjectMoveMode(api.getObjectMoveMode());
	//		MagoConfig.saveMovingHistory(api.getProjectId(), api.getDataKey(), api.getObjectIndexOrder(), changeHistory);
	}
	else if (apiName === "deleteAllObjectMove") 
	{
		// delete "aditionalMove" of the objects.***
		var moveHistoryMap = MagoConfig.getAllMovingHistory(); // get colorHistoryMap.***
		if (moveHistoryMap === undefined)
		{
			MagoConfig.clearMovingHistory();
			return;
		}
		
		for (var key_projectId in moveHistoryMap)
		{
			if (Object.prototype.hasOwnProperty.call(moveHistoryMap, key_projectId))
			{
				var projectId = key_projectId;
				var buildingsMap = moveHistoryMap[projectId];
				if (buildingsMap === undefined)
				{ continue; }
				
				for (var key_dataKey in buildingsMap)
				{
					if (Object.prototype.hasOwnProperty.call(buildingsMap, key_dataKey))
					{
						var dataKey = key_dataKey;
						var dataValue = buildingsMap[key_dataKey];
						
						if (dataValue === undefined)
						{ continue; }
						
						for (var objectIdx in dataValue)
						{
							if (Object.prototype.hasOwnProperty.call(dataValue, objectIdx))
							{
								var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
								if (node === undefined || node.data === undefined)
								{ continue; }
								
								var neoBuilding = node.data.neoBuilding;
								if (neoBuilding === undefined)
								{ continue; }
								
								var refObject = neoBuilding.getReferenceObject(objectIdx);
								if (refObject)
								{
									refObject.moveVector = undefined;
									refObject.moveVectorRelToBuilding = undefined;
								}	
							}
						}	
					}
				}	
			}
		}
		
		MagoConfig.clearMovingHistory();
	}
	else if (apiName === "deleteAllChangeColor") 
	{
		// 1rst, must delete the aditionalColors of objects.***
		var colorHistoryMap = MagoConfig.getAllColorHistory(); // get colorHistoryMap.***
		
		if (colorHistoryMap === undefined)
		{
			MagoConfig.clearColorHistory();
			return;
		}
		
		for (var key_projectId in colorHistoryMap)
		{
			if (Object.prototype.hasOwnProperty.call(colorHistoryMap, key_projectId))
			{
				var projectId = key_projectId;
				var buildingsMap = colorHistoryMap[projectId];
				if (buildingsMap === undefined)
				{ continue; }
				
				for (var key_dataKey in buildingsMap)
				{
					if (Object.prototype.hasOwnProperty.call(buildingsMap, key_dataKey))
					{
						var dataKey = key_dataKey;
						var dataValue = buildingsMap[key_dataKey];
						if (dataValue === undefined)
						{ continue; }
						
						for (var objectId in dataValue)
						{
							if (Object.prototype.hasOwnProperty.call(dataValue, objectId))
							{
								var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
								if (node === undefined || node.data === undefined)
								{ continue; }
							
								node.data.isColorChanged = false;
								
								var neoBuilding = node.data.neoBuilding;
								if (neoBuilding === undefined)
								{ continue; }
							
								var refObjectArray = neoBuilding.getReferenceObjectsArrayByObjectId(objectId);
								if (refObjectArray === undefined)
								{ continue; }
								
								var refObjectsCount = refObjectArray.length;
								for (var i=0; i<refObjectsCount; i++)
								{
									var refObject = refObjectArray[i];
									if (refObject)
									{
										refObject.aditionalColor = undefined;
									}
								}	
							}
						}	
					}
				}	
			}
		}
		
		MagoConfig.clearColorHistory();
	}
	else if (apiName === "changeInsertIssueMode") 
	{
		this.magoPolicy.setIssueInsertEnable(api.getIssueInsertEnable());
		//selectedObjectCallback(이걸 해 주면 될거 같음)
	}
	else if (apiName === "changeObjectInfoViewMode") 
	{
		// object info 표시
		this.magoPolicy.setObjectInfoViewEnable(api.getObjectInfoViewEnable());
	}
	else if (apiName === "changeNearGeoIssueListViewMode") 
	{
		// issue list 표시
		this.magoPolicy.setNearGeoIssueListEnable(api.getNearGeoIssueListEnable());
		if (!api.getNearGeoIssueListEnable()) 
		{
			// clear objMarkerManager objectmakersarrays 사이즈를 0 으로 하면... .됨
			this.objMarkerManager.objectMarkerArray = [];
		}
	}
	else if (apiName === "changeOcclusionCulling") 
	{
		// OcclusionCulling 적용 유무
		this.magoPolicy.setOcclusionCullingEnable(api.getOcclusionCullingEnable());
		var neoBuilding = this.selectionManager.currentBuildingSelected;
		if (neoBuilding)
		{ neoBuilding.setRenderSettingApplyOcclusionCulling(this.magoPolicy.getOcclusionCullingEnable()); }
		// dataKey 는 api.getDataKey();
	}
	else if (apiName === "drawInsertIssueImage") 
	{
		DrawAPI.drawInsertIssueImage(api, this);
	}
	else if (apiName === "changeInsertIssueState")
	{
		this.sceneState.insertIssueState = 0;
	}
	else if (apiName === "changeLod")
	{
		LodAPI.changeLod(api, this);
	}
	else if (apiName === "changeLighting")
	{
		this.magoPolicy.setAmbientReflectionCoef(api.getAmbientReflectionCoef());
		this.magoPolicy.setDiffuseReflectionCoef(api.getDiffuseReflectionCoef());
		this.magoPolicy.setSpecularReflectionCoef(api.getSpecularReflectionCoef());
		this.magoPolicy.setSpecularColor(api.getSpecularColor());
	}
	else if (apiName === "changeSsaoRadius")
	{
		this.magoPolicy.setSsaoRadius(api.getSsaoRadius());
	}	
	else if (apiName === "changeFPVMode")
	{
		if (api.getFPVMode())
		{
			if (this.cameraFPV._camera !== undefined)	{ return; }

			this.cameraFPV.init();

			 if (this.configInformation.geo_view_library === Constant.CESIUM)
			{
				var scratchLookAtMatrix4 = new Cesium.Matrix4();
				var scratchFlyToBoundingSphereCart4 = new Cesium.Cartesian4();
				var camera = this.scene.camera;

				this.cameraFPV._camera = camera;
				this.cameraFPV._cameraBAK = Cesium.Camera.clone(camera, this.cameraFPV._cameraBAK);
	
				var position = new Cesium.Cartesian3();
				var direction = new Cesium.Cartesian3();
				var up = new Cesium.Cartesian3();
	
				var cameraCartographic = this.scene.globe.ellipsoid.cartesianToCartographic(camera.position);
				cameraCartographic.height = this.scene.globe.getHeight(cameraCartographic) + 1.5;
	
				this.scene.globe.ellipsoid.cartographicToCartesian(cameraCartographic, position);
				var transform = Cesium.Transforms.eastNorthUpToFixedFrame(position, Cesium.Ellipsoid.WGS84, scratchLookAtMatrix4);
				Cesium.Cartesian3.fromCartesian4(Cesium.Matrix4.getColumn(transform, 1, scratchFlyToBoundingSphereCart4), direction);
				Cesium.Cartesian3.fromCartesian4(Cesium.Matrix4.getColumn(transform, 2, scratchFlyToBoundingSphereCart4), up);
	
				camera.flyTo({
					destination : position,
					orientation : {
						direction : direction,
						up        : up
					},
					duration: 1
				});
			}
		}
		else 
		{
			if (this.cameraFPV._cameraBAK === undefined)	{ return; }
			if (this.configInformation.geo_view_library === Constant.CESIUM)
			{
				this.scene.camera = Cesium.Camera.clone(this.cameraFPV._cameraBAK, this.scene.camera);
			}
			this.cameraFPV.release();
		}
	}
	else if (apiName === "changePropertyRendering") 
	{
		var visible = api.getShowShadow();
		var projectId = api.getProjectId();
		var property = api.getProperty();
		var splittedWords = property.split("=");
		var propertyKey = splittedWords[0];
		var propertyValue = splittedWords[1];
		
		if (this.propertyFilterSC === undefined)
		{ this.propertyFilterSC = {}; }
		
		this.propertyFilterSC.visible = visible;
		this.propertyFilterSC.projectId = projectId;
		this.propertyFilterSC.propertyKey = propertyKey;
		this.propertyFilterSC.propertyValue = propertyValue;

	}	
	else if (apiName === "drawAppendData")
	{
		DrawAPI.drawAppendData(api, this);
	}
	else if (apiName === "drawDeleteData")
	{
		this.deleteAll();
	}
	else if (apiName === "clearAllData")
	{
		this.deleteAll();
	}
	else if (apiName === "getDataInfoByDataKey")
	{
		var projectId = api.getProjectId(); // for example : 3ds, collada, ifc, etc.***
		var dataKey = api.getDataKey();
		
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
		
		if (node === undefined)
		{
			apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
			return;
		}
		
		var dataName = node.data.data_name;
		var geoLocDataManager = node.data.geoLocDataManager;
		
		if (dataName === undefined || geoLocDataManager === undefined)
		{
			apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
			return;
		}
		
		var geoLocdata = geoLocDataManager.getCurrentGeoLocationData();
		
		if (geoLocdata === undefined || geoLocdata.geographicCoord === undefined)
		{
			apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
			return;
		}
		
		var projectId = node.data.projectId;
		var latitude = geoLocdata.geographicCoord.latitude;
		var longitude = geoLocdata.geographicCoord.longitude;
		var altitude = geoLocdata.geographicCoord.altitude;
		var heading = geoLocdata.heading;
		var pitch = geoLocdata.pitch;
		var roll = geoLocdata.roll;
		
		dataInfoCallback(		MagoConfig.getPolicy().geo_callback_dataInfo,
			projectId,
			dataKey,
			dataName,
			latitude,
			longitude,
			altitude,
			heading,
			pitch,
			roll);
	}
	else if (apiName === "gotoProject")
	{
		var projectId = api.getProjectId();
		//if (!this.hierarchyManager.existProject(projectId))
		//{
		//	var projectDataFolder = api.getProjectDataFolder();
		//	this.getObjectIndexFile(projectId, projectDataFolder);
		//}
		
		var nodeMap = this.hierarchyManager.getNodesMap(projectId);
		if (Object.keys(nodeMap).length === 0)
		{
			var projectDataFolder = api.getProjectDataFolder();
			this.getObjectIndexFile(projectId, projectDataFolder);
		}
		
		
		this.flyTo(api.getLongitude(), api.getLatitude(), api.getElevation(), api.getDuration());
	}
	else if (apiName === "gotoIssue")
	{
		var projectId = api.getProjectId();
		if (!this.hierarchyManager.existProject(projectId))
		{
			var projectDataFolder = api.getProjectDataFolder();
			this.getObjectIndexFile(projectId, projectDataFolder);
		}
		
		this.flyTo(api.getLongitude(), api.getLatitude(), api.getElevation(), api.getDuration());
		
		// pin을 그림
		if (api.getIssueId() !== null && api.getIssueType() !== undefined) 
		{
			DrawAPI.drawInsertIssueImage(api, this);
		}
	}
	else if (apiName === "gotoFly")
	{
		this.flyTo(api.getLongitude(), api.getLatitude(), api.getElevation(), api.getDuration());
	}
	else if (apiName === "getCoordinateRelativeToBuilding") 
	{
		var projectId = api.getProjectId();
		var dataKey = api.getDataKey();
		var worldPoint = api.getInputPoint();
		var resultPoint = api.getResultPoint();
		
		if (projectId === undefined || dataKey === undefined || worldPoint === undefined)
		{ return undefined; }
		
		if (resultPoint === undefined)
		{ resultPoint = new Point3D(); }
		
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
		
		if (node === undefined)
		{ return undefined; }
		
		var geoLocDataManager = node.data.geoLocDataManager;
		
		if (geoLocDataManager === undefined)
		{ return undefined; }
		
		var geoLocdata = geoLocDataManager.getCurrentGeoLocationData();
		resultPoint = geoLocdata.worldCoordToLocalCoord(worldPoint, resultPoint);
		return resultPoint;
	}
	else if (apiName === "getAbsoluteCoodinateOfBuildingPoint") 
	{
		var projectId = api.getProjectId();
		var dataKey = api.getDataKey();
		var localPoint = api.getInputPoint();
		var resultPoint = api.getResultPoint();
		
		if (projectId === undefined || dataKey === undefined || localPoint === undefined)
		{ return undefined; }
		
		if (resultPoint === undefined)
		{ resultPoint = new Point3D(); }
		
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
		
		if (node === undefined)
		{ return undefined; }
		
		var geoLocDataManager = node.data.geoLocDataManager;
		
		if (geoLocDataManager === undefined)
		{ return undefined; }
		
		var geoLocdata = geoLocDataManager.getCurrentGeoLocationData();
		resultPoint = geoLocdata.localCoordToWorldCoord(localPoint, resultPoint);
		return resultPoint;
	}
	else if (apiName === "changeMagoMode") 
	{
		console.log("changeMagoMode");
	}
	else if (apiName === "getCameraCurrentPosition")
	{
		var unit = api.getUnit();
		if (this.configInformation.geo_view_library === Constant.CESIUM)
		{
			var position = this.scene.camera.position;
		
			switch (unit)
			{
			case CODE.units.METRE : return position;
			case CODE.units.RADIAN : return Cesium.Cartographic.fromCartesian(position);
			case CODE.units.DEGREE : {
				var cartographicPosition = Cesium.Cartographic.fromCartesian(position);
				return {
					lat : Cesium.Math.toDegrees(cartographicPosition.latitude),
					lon : Cesium.Math.toDegrees(cartographicPosition.longitude),
					alt : cartographicPosition.height
				};
			}
			}
		}
	}
	else if (apiName === "getCameraCurrentOrientaion")
	{
		if (MagoConfig.getPolicy().geo_view_library === Constant.CESIUM)
		{
			var camera = this.scene.camera;
			if (!camera)
			{
				throw new Error('Camera is broken.');
			}
			return {
				heading : Cesium.Math.toDegrees(camera.heading),
				pitch   : Cesium.Math.toDegrees(camera.pitch),
				roll    : Cesium.Math.toDegrees(camera.roll)
			};
		}
	}
	else if (apiName === "changeCameraOrientation")
	{	
		//수정필요, 카메라가 세슘카메라
		var camera = this.scene.camera;
		var heading = defaultValue(api.getHeading(), Cesium.Math.toDegrees(camera.heading));
		var pitch = defaultValue(api.getPitch(), Cesium.Math.toDegrees(camera.pitch));
		var roll = defaultValue(api.getRoll(), Cesium.Math.toDegrees(camera.roll));
		var duration = defaultValue(api.getDuration(), 0);

		if (MagoConfig.getPolicy().geo_view_library === Constant.CESIUM)
		{
			var camera = this.scene.camera;
			if (!camera)
			{
				throw new Error('Camera is broken.');
			}

			camera.flyTo({
				destination : camera.positionWC,
				orientation : {
					heading : Cesium.Math.toRadians(heading),
					pitch   : Cesium.Math.toRadians(pitch),
					roll    : Cesium.Math.toRadians(roll)
				},
				duration: parseInt(duration)
			});
		}
	}
	else if (apiName === "instantiateStaticModel")
	{
		var attributes = api.getInstantiateObj();
		this.instantiateStaticModel(attributes);
	}
	else if (apiName === "addStaticModel")
	{
		var attribute = api.getStaticModelAttributeObj();
		this.addStaticModel(attribute);
	}
	else if (apiName === "setTrackNode")
	{
		var node = this.hierarchyManager.getNodeByDataKey(api.getProjectId(), api.getDataKey());
		if (!defined(node))
		{
			throw new Error("This node is not exist.");
		}

		this.flyToBuilding(undefined, node.data.projectId, node.data.nodeId);
		this.sceneState.camera.setTrack(node);
	}
	else if (apiName === "stopTrack")
	{
		this.sceneState.camera.stopTrack(this);
	}
	else if (apiName === "isExistStaticModel")
	{
		return this.isExistStaticModel(api.getProjectId());
	}
	else if (apiName === "isExistData")
	{
		var projectId = api.getProjectId();
		var dataKey = api.getDataKey();
		if (!defined(projectId))
		{
			throw new Error("projectId is required.");
		}
		if (!defined(dataKey))
		{
			throw new Error("dataKey is required.");
		}
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
		if (node !== undefined)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
};

MagoManager.prototype.deleteAll = function ()
{
	// deselect.
	this.selectionManager.clearCandidates();
	this.selectionManager.clearCurrents();
	this.objectSelected = undefined;
	this.octreeSelected = undefined;
	this.buildingSelected = undefined;
	this.nodeSelected = undefined;
	
	// erase from processQueue and parseQueue. 
	this.parseQueue.clearAll();
	this.processQueue.clearAll();
	
	// clear current visibles.
	if (this.visibleObjControlerBuildings)
	{ this.visibleObjControlerBuildings.clear(); }
	if (this.visibleObjControlerNodes)
	{ this.visibleObjControlerNodes.clear(); }
	if (this.visibleObjControlerOctrees)
	{ this.visibleObjControlerOctrees.clear(); }
	
	// reset tiles.
	this.smartTileManager.resetTiles();
	
	// finally delete nodes.
	this.hierarchyManager.deleteNodes(this.sceneState.gl, this.vboMemoryManager);
};

MagoManager.prototype.checkCollision = function (position, direction)
{
	var gl = this.sceneState.gl;
	if (gl === undefined)	{ return; }

	var posX = this.sceneState.drawingBufferWidth * 0.5;
	var posY = this.sceneState.drawingBufferHeight * 0.5;
	
	var objects = this.getSelectedObjects(gl, posX, posY, this.arrayAuxSC);
	if (objects === undefined)	{ return; }

	var current_building = this.buildingSelected;
	this.buildingSelected = this.arrayAuxSC[0];

	var collisionPosition = new Point3D();
	var bottomPosition = new Point3D();

	ManagerUtils.calculatePixelPositionWorldCoord(gl, posX, posY, collisionPosition, undefined, undefined, this);
	this.swapRenderingFase();
	ManagerUtils.calculatePixelPositionWorldCoord(gl, posX, this.sceneState.drawingBufferHeight, undefined, undefined, this);

	this.buildingSelected = current_building;
	var distance = collisionPosition.squareDistTo(position.x, position.y, position.z);
	this.swapRenderingFase();

	if (distance > 3.5)
	{
		var bottomPositionCartographic = this.scene.globe.ellipsoid.cartesianToCartographic(bottomPosition);
		var currentPositionCartographic = this.scene.globe.ellipsoid.cartesianToCartographic(position);
		var currentHeight = currentPositionCartographic.height;
		var bottomHeight = bottomPositionCartographic.height + 1.5;
	
		if ( bottomHeight < currentHeight )
		{
			currentHeight -= 0.2;
		}
	
		if ( bottomHeight > currentHeight || 
			(bottomHeight < currentHeight && currentHeight - bottomHeight > 1.5))
		{
			currentHeight = bottomHeight;
		}
		var tmpLat = Cesium.Math.toDegrees(currentPositionCartographic.latitude);
		var tmpLon = Cesium.Math.toDegrees(currentPositionCartographic.longitude);
		
		this.cameraFPV.camera.position = Cesium.Cartesian3.fromDegrees(tmpLon, tmpLat, currentHeight);

		return false; 
	}

	return true;
};
'use strict';

/**
 * Factory method 패턴을 사용해서 cesium, worldwind 등을 wrapping 해 주는 클래스
 * @class ManagerFactory
 *
 * @param viewer 타 시스템과의 연동의 경우 view 객체가 생성되어서 넘어 오는 경우가 있음
 * @param containerId 뷰에서 표시할 위치 id
 * @param serverPolicy policy json object
 * @param projectIdArray json object map에 저장하기 위한 key
 * @param projectDataArray data json object
 * @param projectDataFolderArray f4d data folder path
 * @param imagePath 이미지 경로
 * @returns api
 */
var ManagerFactory = function(viewer, containerId, serverPolicy, projectIdArray, projectDataArray, projectDataFolderArray, imagePath) 
{
	if (!(this instanceof ManagerFactory)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	var magoManager = null;
	var scene = null;
	var magoManagerState = CODE.magoManagerState.INIT;
	
	//var startMousePosition = null;
	//var nowMousePosition = null;

	// 환경 설정
	MagoConfig.init(serverPolicy, projectIdArray, projectDataArray);
	
	// 카메라 행동 설정
	function disableCameraMotion(state)
	{
		viewer.scene.screenSpaceCameraController.enableRotate = state;
		viewer.scene.screenSpaceCameraController.enableZoom = state;
		viewer.scene.screenSpaceCameraController.enableLook = state;
		viewer.scene.screenSpaceCameraController.enableTilt = state;
		viewer.scene.screenSpaceCameraController.enableTranslate = state;
	}
	
	// 이벤트 확장
	function addMouseAction() 
	{
		magoManager.handler.setInputAction(function(click) 
		{
			magoManager.mouseActionLeftDown(click.position.x, click.position.y);
		}, Cesium.ScreenSpaceEventType.LEFT_DOWN);

		magoManager.handler.setInputAction(function(click) 
		{
			magoManager.mouseActionMiddleDown(click.position.x, click.position.y);
		}, Cesium.ScreenSpaceEventType.MIDDLE_DOWN);
		
		magoManager.handler.setInputAction(function(click) 
		{
			magoManager.mouseActionRightDown(click.position.x, click.position.y);
		}, Cesium.ScreenSpaceEventType.RIGHT_DOWN);

		//var mousePosition;
		magoManager.handler.setInputAction(function(movement) 
		{
			//magoManager.mouseActionMove(movement.endPosition.x, movement.endPosition.y);
			//mousePosition = movement.endPosition;
			if (magoManager.mouseLeftDown) 
			{
				if (movement.startPosition.x !== movement.endPosition.x || movement.startPosition.y !== movement.endPosition.y) 
				{
					magoManager.manageMouseDragging(movement.startPosition.x, movement.startPosition.y);
					magoManager.cameraMoved();
				}
			}
			else
			{
				magoManager.mouseDragging = false;
				disableCameraMotion(true);
				if (magoManager.mouseMiddleDown || magoManager.mouseRightDown)
				{
					magoManager.isCameraMoving = true;
					magoManager.cameraMoved();
				}
			}
			
		}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

		magoManager.handler.setInputAction(function(movement) 
		{
			magoManager.mouseActionLeftUp(movement.position.x, movement.position.y);
			// display current mouse position
			var pickPosition = {lat: null, lon: null, alt: null};
			var position = magoManager.scene.camera.pickEllipsoid(movement.position);
			if (position)
			{
				var cartographicPosition = Cesium.Cartographic.fromCartesian(position);
				pickPosition.lat = Cesium.Math.toDegrees(cartographicPosition.latitude);
				pickPosition.lon = Cesium.Math.toDegrees(cartographicPosition.longitude);
				pickPosition.alt = cartographicPosition.height;
			}
			if (MagoConfig.getPolicy().geo_callback_enable === "true") 
			{
				if (serverPolicy.geo_callback_clickposition !== '') 
				{
					clickPositionCallback(serverPolicy.geo_callback_clickposition, pickPosition);
				}
			}
	    }, Cesium.ScreenSpaceEventType.LEFT_UP);

		magoManager.handler.setInputAction(function(movement) 
		{
			magoManager.mouseActionMiddleUp(movement.position.x, movement.position.y);
	    }, Cesium.ScreenSpaceEventType.MIDDLE_UP);
		
		magoManager.handler.setInputAction(function(movement) 
		{
			magoManager.mouseActionRightUp(movement.position.x, movement.position.y);
	    }, Cesium.ScreenSpaceEventType.RIGHT_UP);
		
		magoManager.handler.setInputAction(function(movement) 
		{
			magoManager.mouseActionLeftClick(movement.position.x, movement.position.y);
	    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
	}

	// cesium을 구현체로서 이용
	function initWwwMago(manager, gl) 
	{
		//var viewport = manager.wwd.viewport;
		//manager.selection.init(gl, viewport.width, viewport.height);
		manager.postFxShadersManager.gl = gl;
		manager.postFxShadersManager.createDefaultShaders(gl); // A1-OLD.***
		manager.createDefaultShaders(gl);// A1-Use this.***

		// object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
		//manager.getObjectIndexFile(); // old.***
		//viewer.scene.magoManager.getObjectIndexFile();
		if (projectIdArray !== null && projectIdArray.length > 0) 
		{
			for (var i=0; i<projectIdArray.length; i++) 
			{
				var projectDataFolder = projectDataFolderArray[i];
				var projectData = projectDataArray[i];
				if (!(projectData.data_key === projectDataFolder && projectData.attributes.isReference))
				{
					manager.getObjectIndexFile(projectIdArray[i], projectDataFolder);
				}
			}
		}
	}

	// cesium을 구현체로서 이용
	function drawCesium() 
	{
		var gl = viewer.scene.context._gl;
		//viewer.scene.magoManager.selection.init(gl, viewer.scene.drawingBufferWidth, viewer.scene.drawingBufferHeight);
		viewer.scene.magoManager.postFxShadersManager.gl = gl;
		viewer.scene.magoManager.postFxShadersManager.createDefaultShaders(gl); // A1-OLD.***
		viewer.scene.magoManager.createDefaultShaders(gl);// A1-Use this.***
		viewer.scene.magoManager.scene = viewer.scene;

		// Start postRender version.***********************************************
		magoManager = viewer.scene.magoManager;
		scene = viewer.scene;
		//scene.copyGlobeDepth = true;
		viewer.scene.globe.depthTestAgainstTerrain = true;
		viewer.scene.logarithmicDepthBuffer = false; //do not use logarithmic buffer
		viewer.scene.highDynamicRange = false; //do not use high dynamic range
		// object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
		//viewer.scene.magoManager.getObjectIndexFile();
		if (projectIdArray !== null && projectIdArray.length > 0) 
		{
			for (var i=0; i<projectIdArray.length; i++) 
			{
				var projectDataFolder = projectDataFolderArray[i];
				var projectData = projectDataArray[i];
				if (!(projectData.data_key === projectDataFolder && projectData.attributes.isReference))
				{
					viewer.scene.magoManager.getObjectIndexFile(projectIdArray[i], projectDataFolder);
				}
			}
		}
		viewer.scene.magoManager.handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
		addMouseAction();
		viewer.clock.onTick.addEventListener(function(clock) 
		{
			magoManager.cameraFPV.update(magoManager);
		});
	}
	
	// magoworld을 구현체로서 이용
	function drawMagoWorld() 
	{
		var gl = viewer.magoManager.sceneState.gl;
		var manager = viewer.magoManager;
		manager.vboMemoryManager.gl = gl;
		manager.postFxShadersManager.gl = gl;
		manager.postFxShadersManager.createDefaultShaders(gl); // A1-OLD.***
		manager.createDefaultShaders(gl);// A1-Use this.***
		//viewer.renderTest();
	};

	// 실제 화면에 object를 rendering 하는 메인 메서드
	function draw() 
	{
		if (MagoConfig.getPolicy().geo_view_library === Constant.CESIUM) 
		{
			drawCesium();
		}
		else if (MagoConfig.getPolicy().geo_view_library === Constant.WORLDWIND) 
		{
			//initWwwMago();
		}
		else if (MagoConfig.getPolicy().geo_view_library === Constant.MAGOWORLD) 
		{
			drawMagoWorld();
		}
	}

	/**
	 * add Layers
	 */
	function addImageryLayers() 
	{
		var provider = new Cesium.WebMapServiceImageryProvider({
			url        : MagoConfig.getPolicy().geo_server_add_url,
			layers     : MagoConfig.getPolicy().geo_server_add_layers,
			parameters : {
				service     : MagoConfig.getPolicy().geo_server_add_parameters_service,
				version     : MagoConfig.getPolicy().geo_server_add_parameters_version,
				request     : MagoConfig.getPolicy().geo_server_add_parameters_request,
				transparent : MagoConfig.getPolicy().geo_server_add_parameters_transparent,
				//tiled : MagoConfig.getPolicy().backgroundProvider.parameters.tiled,
				format      : MagoConfig.getPolicy().geo_server_add_parameters_format
				//				time : MagoConfig.getPolicy().backgroundProvider.parameters.time,
				//		    	rand : MagoConfig.getPolicy().backgroundProvider.parameters.rand,
				//		    	asdf : MagoConfig.getPolicy().backgroundProvider.parameters.asdf
			}
			//,proxy: new Cesium.DefaultProxy('/proxy/')
		});

		//		if(index) viewer.imageryLayers.addImageryProvider(provider, index);
		viewer.imageryLayers.addImageryProvider(provider);
	}

	/**
	 * zoomTo 할 Entity
	 * @returns entities
	 */
	function initEntity() 
	{
		return viewer.entities.add({
			name     : "mago3D",
			position : Cesium.Cartesian3.fromDegrees(37.521168, 126.924185, 3000.0),
			box      : {
				dimensions : new Cesium.Cartesian3(300000.0*1000.0, 300000.0*1000.0, 300000.0*1000.0), // dimensions : new Cesium.Cartesian3(400000.0, 300000.0, 500000.0),
				fill       : true,
				material   : Cesium.Color.BLUE,
				outline    : false
			}
		});
	}

	// terrain 적용 유무를 설정
	function initTerrain() 
	{
		/*		if(MagoConfig.getPolicy().geoConfig.initTerrain.enable) {
			var terrainProvider = new Cesium.CesiumTerrainProvider({
				url : MagoConfig.getPolicy().geoConfig.initTerrain.url,
				requestWaterMask: MagoConfig.getPolicy().geoConfig.initTerrain.requestWaterMask,
				requestVertexNormals: MagoConfig.getPolicy().geoConfig.initTerrain.requestVertexNormals
			});
			viewer.terrainProvider = terrainProvider;
		}*/
	}

	// 최초 로딩시 이동할 카메라 위치
	function initCamera() 
	{
		viewer.camera.flyTo({
			destination: Cesium.Cartesian3.fromDegrees(parseFloat(MagoConfig.getPolicy().geo_init_longitude),
				parseFloat(MagoConfig.getPolicy().geo_init_latitude),
				parseFloat(MagoConfig.getPolicy().geo_init_height)),
			duration: parseInt(MagoConfig.getPolicy().geo_init_duration)
		});
	}

	// deploy 타입 적용
	function initRenderMode() 
	{
		var api = new API("renderMode");
		magoManager.callAPI(api);

		if (MagoConfig.getPolicy().geo_time_line_enable === "false") 
		{
			// visible <---> hidden
			$(viewer._animation.container).css("visibility", "hidden");
			$(viewer._timeline.container).css("visibility", "hidden");
			viewer.forceResize();
		}
	}
	
	var DEFALUT_IMAGE = "ESRI World Imagery";
	var DEFALUT_TERRAIN = "WGS84 Ellipsoid";
	
	// pick baseLayer
	function setDefaultDataset() 
	{
		// WGS84 Ellipsoide
		if (MagoConfig.getPolicy().geo_init_default_terrain !== null && MagoConfig.getPolicy().geo_init_default_terrain !== "") 
		{
			DEFALUT_TERRAIN = MagoConfig.getPolicy().geo_init_default_terrain;
		}
		
		// search default imageryProvider from baseLayerPicker
		var imageryProvider = null;
		var imageryProviderViewModels = viewer.baseLayerPicker.viewModel.imageryProviderViewModels; 
		for (var i in imageryProviderViewModels) 
		{
			if (!imageryProviderViewModels.hasOwnProperty(i))	{ continue; }

			var provider = imageryProviderViewModels[i];
			if (provider.name === DEFALUT_IMAGE) 
			{
				imageryProvider = provider;
				break;
			}
		}
		if (imageryProvider) { viewer.baseLayerPicker.viewModel.selectedImagery = imageryProvider; }
	  
		// search default terrainProvider from baseLayerPicker
		var terrainProvider = null;
		var terrainProviderViewModels = viewer.baseLayerPicker.viewModel.terrainProviderViewModels;
		for (var i in terrainProviderViewModels) 
		{
			if (!terrainProviderViewModels.hasOwnProperty(i))	{ continue; }
			var provider = terrainProviderViewModels[i];
			if (provider.name === DEFALUT_TERRAIN) 
			{
				terrainProvider = provider;
				break;
			}
		}
		if (terrainProvider) { viewer.baseLayerPicker.viewModel.selectedTerrain = terrainProvider; }
	}

	if (serverPolicy.geo_view_library === null ||
		serverPolicy.geo_view_library === '' ||
		serverPolicy.geo_view_library === Constant.CESIUM) 
	{
		// webgl lost events.******************************************
		var canvas = document.getElementById(containerId);
		canvas.addEventListener('webglcontextlost', function(e) 
		{
			console.log(e);
		}, false);
		
		canvas.addEventListener('webglcontextrestored', function(e) 
		{
		  console.log(e); 
		}, false);
		//-------------------------------------------------------------
		
		if (serverPolicy.geo_server_enable === "true" && serverPolicy.geo_server_url !== null && serverPolicy.geo_server_url !== '') 
		{
			var imageryProvider = new Cesium.WebMapServiceImageryProvider({
				url        : serverPolicy.geo_server_url,
				layers     : serverPolicy.geo_server_layers,
				parameters : {
					service     : serverPolicy.geo_server_parameters_service,
					version     : serverPolicy.geo_server_parameters_version,
					request     : serverPolicy.geo_server_parameters_request,
					transparent : serverPolicy.geo_server_parameters_transparent,
					format      : serverPolicy.geo_server_parameters_format
				}//,
				//proxy: new Cesium.DefaultProxy('/proxy/')
			});
			var options = {imageryProvider: imageryProvider, baseLayerPicker: false};
			if (viewer === null) { viewer = new Cesium.Viewer(containerId, options); }
		}
		else 
		{
			if (serverPolicy.geo_cesium_ion_token !== null && serverPolicy.geo_cesium_ion_token !== "") 
			{
				Cesium.Ion.defaultAccessToken = serverPolicy.geo_cesium_ion_token;
				DEFALUT_TERRAIN = "Cesium World Terrain";
			}
			if (viewer === null) { viewer = new Cesium.Viewer(containerId, {shouldAnimate: true}); }
			// 기본 지도 설정
			setDefaultDataset();
		}
			
		viewer.scene.magoManager = new MagoManager();
		viewer.scene.magoManager.sceneState.textureFlipYAxis = false;
		viewer.camera.frustum.fov = Cesium.Math.PI_OVER_THREE*1.8;
		//viewer.camera.frustum.near = 0.1;
		if (MagoConfig.getPolicy().geo_init_default_fov > 0) 
		{
			viewer.camera.frustum.fov = Cesium.Math.PI_OVER_THREE * MagoConfig.getPolicy().geo_init_default_fov;
		}

		// Layers 추가 적용
		if (serverPolicy.geo_server_enable === "true" && serverPolicy.geo_server_add_url !== null && serverPolicy.geo_server_add_url !== '') 
		{ 
			addImageryLayers(); 
		}
			
		draw();
		// build을 rendering 할 위치
		initEntity();
		// terrain 적용 여부
		/*if() {
				initTerrain();
			}*/
		// 최초 로딩시 카메라 이동 여부
		if (serverPolicy.geo_init_camera_enable === "true") { initCamera(); }
		// render Mode 적용
		initRenderMode();
	}
	else if (serverPolicy.geo_view_library === Constant.WORLDWIND) 
	{
			
		// Tell World Wind to log only warnings and errors.
		WorldWind.Logger.setLoggingLevel(WorldWind.Logger.LEVEL_WARNING);

		// set to canvas the current gl.***
		var canvas = document.getElementById(containerId);
			
		var wwd;
		if (serverPolicy.geo_server_enable === "true" && serverPolicy.geo_server_url !== null && serverPolicy.geo_server_url !== '') 
		{
			wwd = new WorldWind.WorldWindow(containerId, new WorldWind.ZeroElevationModel());
				
			// Web Map Service information
			var serviceAddress = serverPolicy.geo_server_url + "?SERVICE=WMS&REQUEST=GetCapabilities&VERSION=1.3.0";

			// Named layer displaying Average Temperature data
			var layerName = "mago3d";

			// Called asynchronously to parse and create the WMS layer
			var createLayer = function (xmlDom) 
			{
				// Create a WmsCapabilities object from the XML DOM
				var wms = new WorldWind.WmsCapabilities(xmlDom);
				// Retrieve a WmsLayerCapabilities object by the desired layer name
				var wmsLayerCapabilities = wms.getNamedLayer(layerName);
				// Form a configuration object from the WmsLayerCapability object
				var wmsConfig = WorldWind.WmsLayer.formLayerConfiguration(wmsLayerCapabilities);
				// Modify the configuration objects title property to a more user friendly title
				wmsConfig.title = "imageProvider";
				// Create the WMS Layer from the configuration object
				var wmsLayer = new WorldWind.WmsLayer(wmsConfig);

				// Add the layers to WorldWind and update the layer manager
				wwd.addLayer(wmsLayer);
			};

			// Called if an error occurs during WMS Capabilities document retrieval
			var logError = function (jqXhr, text, exception) 
			{
				console.log("There was a failure retrieving the capabilities document: " + text + " exception: " + exception);
			};

			$.get(serviceAddress).done(createLayer).fail(logError);
		}
		else 
		{
			// Create the World Window.
			wwd = new WorldWind.WorldWindow(containerId);
			//wwd.depthBits = 32;
				
			var layers = [
				{layer: new WorldWind.BMNGLayer(), enabled: true},
				{layer: new WorldWind.BMNGLandsatLayer(), enabled: false},
				{layer: new WorldWind.BingAerialWithLabelsLayer(null), enabled: true},
				{layer: new WorldWind.OpenStreetMapImageLayer(null), enabled: false},
				{layer: new WorldWind.CompassLayer(), enabled: false},
				{layer: new WorldWind.CoordinatesDisplayLayer(wwd), enabled: true},
				{layer: new WorldWind.ViewControlsLayer(wwd), enabled: true}
			];

			for (var l = 0; l < layers.length; l++) 
			{
				layers[l].layer.enabled = layers[l].enabled;
				wwd.addLayer(layers[l].layer);
			}
		}

		// Now set up to handle highlighting.
		//var highlightController = new WorldWind.HighlightController(wwd);

		magoManager = new MagoManager();
		magoManager.wwd = wwd;
		magoManager.sceneState.textureFlipYAxis = true;
			
		var newRenderableLayer = new WorldWind.RenderableLayer();
		newRenderableLayer.displayName = "F4D tiles";
		newRenderableLayer.inCurrentFrame = true; // Test.***
		wwd.addLayer(newRenderableLayer);
			
		//newRenderableLayer.addRenderable(f4d_wwwLayer);// old.***
		newRenderableLayer.addRenderable(magoManager);
		// End Create a layer to hold the f4dBuildings.-------------------------------------------------------

		var gl = wwd.drawContext.currentGlContext;
		initWwwMago(magoManager, gl);

		// Click event. 
		// The common gesture-handling function.
		var handleClick = function (recognizer) 
		{
			// Obtain the event location.
			//magoManager.mouse_x = event.layerX,
			//magoManager.mouse_y = event.layerY;
			//magoManager.bPicking = true;
				
			// Perform the pick. Must first convert from window coordinates to canvas coordinates, which are
			// relative to the upper left corner of the canvas rather than the upper left corner of the page.
			//var pickList = wwd.pick(wwd.canvasCoordinates(x, y));

			// If only one thing is picked and it is the terrain, use a go-to animator to go to the picked location.
			/*
				if (pickList.objects.length === 1 && pickList.objects[0].isTerrain) {
					var position = pickList.objects[0].position;
					//wwd.goTo(new WorldWind.Location(position.latitude, position.longitude));
					//wwd.goTo(new WorldWind.Position(37.48666, 127.05618, 500));
					wwd.goToOriented(new WorldWind.Position(37.48666, 127.05618, 500.0), 120.0, 80.0);
				}
				*/
		};

		// Listen for mouse clicks.
		var clickRecognizer = new WorldWind.ClickRecognizer(wwd, handleClick);
		clickRecognizer.button = 0;  //left mouse button
			
		var mouseDownEvent = function(event) 
		{
			if (event.button === 0) 
			{ 
				magoManager.mouseActionLeftDown(event.layerX, event.layerY); 
			}
			else if (event.button === 1) 
			{ 
				magoManager.mouseActionMiddleDown(event.layerX, event.layerY); 
			}
			else if (event.button === 2) 
			{ 
				magoManager.mouseActionRightDown(event.layerX, event.layerY); 
			}
		};
		wwd.addEventListener("mousedown", mouseDownEvent, false);
			
		var mouseUpEvent = function(event) 
		{
			if (event.button === 0) 
			{ 
				magoManager.mouseActionLeftUp(event.layerX, event.layerY);
			}
			else if (event.button === 1) 
			{ 
				magoManager.mouseActionMiddleUp(event.layerX, event.layerY);
			}
			else if (event.button === 2) 
			{ 
				magoManager.mouseActionRightUp(event.layerX, event.layerY);
			}

			// display current mouse position
				
			var terrainObject;
			var pickPosition = {lat: null, lon: null, alt: null};
			var pickPoint = wwd.canvasCoordinates(event.layerX, event.layerY);
			if (pickPoint[0] >= 0 && pickPoint[0] < wwd.canvas.width &&
					pickPoint[1] >= 0 && pickPoint[1] < wwd.canvas.height)
			{
				terrainObject = wwd.pickTerrain(pickPoint).terrainObject();
				var terrainPosition = terrainObject ? terrainObject.position : null;
				if (terrainPosition !== null)
				{
					pickPosition.lat = terrainPosition.latitude;
					pickPosition.lon = terrainPosition.longitude;
					pickPosition.alt = terrainPosition.altitude;	
				}
			}
			if (MagoConfig.getPolicy().geo_callback_enable === "true") 
			{
				if (serverPolicy.geo_callback_clickposition !== '') 
				{
					clickPositionCallback(serverPolicy.geo_callback_clickposition, pickPosition);
				}
			}
		};
		wwd.addEventListener("mouseup", mouseUpEvent, false);
			
		var mouseMoveEvent = function(event) 
		{
			magoManager.mouse_x = event.layerX,
			magoManager.mouse_y = event.layerY;
			if (magoManager.mouseLeftDown) 
			{ 
				magoManager.manageMouseDragging(event.layerX, event.layerY); 
				magoManager.cameraMoved();
			}
			else if (magoManager.mouseMiddleDown || magoManager.mouseRightDown) 
			{ 
				magoManager.cameraMoved();
			}
				
		};
		wwd.addEventListener("mousemove", mouseMoveEvent, false);
		
		
		wwd.goToAnimator.travelTime = MagoConfig.getPolicy().geo_init_duration * 1000;
		wwd.goTo(new WorldWind.Position(MagoConfig.getPolicy().geo_init_latitude, MagoConfig.getPolicy().geo_init_longitude, MagoConfig.getPolicy().geo_init_height));
	}
	if (serverPolicy.geo_view_library === Constant.MAGOWORLD) 
	{
		var canvas = document.getElementById(containerId);
		var glAttrs = {antialias: false, stencil: true};
		var gl = canvas.getContext("webgl", glAttrs);
		if (!gl)
		{ gl = canvas.getContext("experimental-webgl", glAttrs); }
		
		// Problem: canvas-width initially is 300 and canvas-height = 150.***
		canvas.width = canvas.clientWidth;
		canvas.height = canvas.clientHeight;
		
		magoManager = new MagoManager();
		var sceneState = magoManager.sceneState;
		sceneState.textureFlipYAxis = true;
		sceneState.gl = gl;
		sceneState.drawingBufferWidth[0] = canvas.clientWidth;
		sceneState.drawingBufferHeight[0] = canvas.clientHeight;
		sceneState.camera.frustum.aspectRatio = canvas.clientWidth/canvas.clientHeight;
		sceneState.camera.frustum.fovRad[0] = Math.PI/3*1.8;
		sceneState.camera.frustum.fovyRad[0] = sceneState.camera.frustum.fovRad[0]/sceneState.camera.frustum.aspectRatio;
		sceneState.camera.frustum.tangentOfHalfFovy[0] = Math.tan(sceneState.camera.frustum.fovyRad[0]/2);
		
		
		// initial camera position.***
		sceneState.camera.position.set(0.0, 0.0, 10000000.0);
		sceneState.camera.direction.set(0.0, 0.0, -1.0);
		sceneState.camera.up.set(0.0, 1.0, 0.0);
		
		// test init camera position.***
		//sphere.r = 6378137.0;
		sceneState.encodedCamPosHigh[0] = 0;
		sceneState.encodedCamPosHigh[1] = 0;
		sceneState.encodedCamPosHigh[2] = 10000000.0;
		
		sceneState.encodedCamPosLow[0] = 0;
		sceneState.encodedCamPosLow[1] = 0;
		sceneState.encodedCamPosLow[2] = 0;

		
		viewer = new MagoWorld(magoManager);
		magoManager.magoWorld = viewer;
		magoManager.globe = new Globe();
		// init matrices.***
		viewer.updateModelViewMatrixByCamera(sceneState.camera);
		//magoManager.upDateSceneStateMatrices(sceneState);
		
		// event listener.***
		canvas.addEventListener('mousedown', function(event)
		{
			viewer.mousedown(event);			
		}, false);
		
		canvas.addEventListener('mouseup', function(event)
		{
			viewer.mouseup(event);			
		}, false);
		
		canvas.addEventListener('mousewheel', function(event)
		{
			viewer.mousewheel(event); 
		}, false);
		
		canvas.addEventListener('mousemove', function(event)
		{
			viewer.mousemove(event);
		}, false);
		
		canvas.addEventListener('click', function(event)
		{
			viewer.mouseclick(event);
		}, false);
		
		canvas.addEventListener('resize', function(event)
		{
			// TODO:
			console.log("resize");
		}, false);
		
		canvas.addEventListener('keydown', function(event) // no works.***
		{
			viewer.keydown(event); // no works.***
		}, false);

		
		draw();
	}

	// 이미지 경로
	magoManager.magoPolicy.imagePath = imagePath;
	magoManagerState = CODE.magoManagerState.READY;

	// KeyPressEvents.**************************************
	document.addEventListener('keydown', function(event) 
	{
		// get current building selected
		if (magoManager.magoPolicy.issueInsertEnable)	{ return; }
		
		magoManager.keyDown(event.keyCode);

		var selectedBuilding = magoManager.buildingSelected;	
		if (selectedBuilding === undefined) 	{ return; }

		var nodeSelected = magoManager.selectionManager.currentNodeSelected;
		if (nodeSelected === undefined)
		{ return; }
		var rootNodeSelected = nodeSelected.getRoot();
		var geoLocationData = rootNodeSelected.data.geoLocDataManager.getCurrentGeoLocationData();
		if (geoLocationData === undefined)		{ return; }

		if (magoManager.magoPolicy.objectMoveMode === CODE.moveMode.ALL)
		{
			var increDeg = 3.0;
			var currentHeading = geoLocationData.heading || 0;
			var currentPitch = geoLocationData.pitch || 0;
			var currentRoll = geoLocationData.roll || 0;
			
			var increDist = 0.2;
			var currentAlt = geoLocationData.geographicCoord.altitude || 0;
			var displayData = false;
			
			// For Heading
			if (event.keyCode === 'Q'.charCodeAt(0))
			{
				currentHeading += increDeg;
				displayData = true;
			}
			else if (event.keyCode === 'A'.charCodeAt(0))
			{
				currentHeading -= increDeg;
				displayData = true;
			}
			
			// For Pitch
			if (event.keyCode === 'W'.charCodeAt(0))
			{
				currentPitch += increDeg;
				displayData = true;
			}
			else if (event.keyCode === 'S'.charCodeAt(0))
			{
				currentPitch -= increDeg;
				displayData = true;
			}

			// For Roll
			if (event.keyCode === 'E'.charCodeAt(0))
			{
				currentRoll += increDeg;
				displayData = true;
			}
			else if (event.keyCode === 'D'.charCodeAt(0))
			{
				currentRoll -= increDeg;
				displayData = true;
			}
			
			// For Altitude
			if (event.keyCode === 'Z'.charCodeAt(0))
			{
				currentAlt += increDist;
				displayData = true;
			}
			else if (event.keyCode === 'X'.charCodeAt(0))
			{
				currentAlt -= increDist;
				displayData = true;
			}
			
			

			if (displayData)
			{
				magoManager.changeLocationAndRotationNode(nodeSelected, geoLocationData.geographicCoord.latitude, geoLocationData.geographicCoord.longitude, 
					currentAlt, currentHeading, currentPitch, currentRoll); 
			}
		}

	}, false);
	
	// TODO API 객체를 생성해서 하나의 parameter로 전달하는 방식이 좀 더 깔끔할거 같지만 성능적인 부분에서 조금은 투박할거 같아서 일단 이렇게 처리
	return {
		// api gateway 역할
		callAPI: function(api) 
		{
		    if (api.getReturnable()) 
			{
		        return magoManager.callAPI(api);
			}
			else 
			{
				magoManager.callAPI(api);
			}
		},
		// flyTo: function(issueId, issueType, longitude, latitude, height, duration)
		// {
		// 	if (MagoConfig.getPolicy().geo_view_library === Constant.CESIUM)
		// 	{
		// 		viewer.camera.flyTo({
		// 			destination: Cesium.Cartesian3.fromDegrees(parseFloat(longitude),
		// 				parseFloat(latitude),
		// 				parseFloat(height) + 10),
		// 			duration: parseInt(duration)
		// 		});
		// 	}
		// 	else
		// 	{
		// 		wwd.goToAnimator.travelTime = duration * 1000;
		// 		wwd.goTo(new WorldWind.Position(parseFloat(latitude), parseFloat(longitude), parseFloat(height) + 50));
		// 	}
		// 	// pin을 그림
		// 	if (issueId !== null && issueType !== undefined)
		// 	{
		// 		var api = new API("drawInsertIssueImage");
		// 		api.setDrawType(0);
		// 		api.setIssueId(issueId);
		// 		api.setIssueType(issueType);
		// 		api.setDataKey(null);
		// 		api.setLatitude(latitude);
		// 		api.setLongitude(longitude);
		// 		api.setElevation(height);
		// 		magoManager.callAPI(api);
		// 	}
		// },
		// magoManager 상태
		getViewer: function()
		{
			return viewer;
		},
		getMagoManagerState: function() 
		{
			return magoManagerState;
		},
		getMagoManager: function() 
		{
			return magoManager;
		}
	};
};

'use strict';


/**
 * 열우선 배열 방식의 4차원 행렬
 *
 */
var Matrix4 = function() 
{
	if (!(this instanceof Matrix4)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * @type {Float32Array}
	 */
	this._floatArrays = new Float32Array([ 1, 0, 0, 0,
										   0, 1, 0, 0,
										   0, 0, 1, 0,
										   0, 0, 0, 1]);
};

/**
 * 단위행렬로 설정한다.
 */
Matrix4.prototype.Identity = function() 
{
	this._floatArrays[0] = 1.0;		// I(1,1)
	this._floatArrays[1] = 0.0;		// I(2,1)
	this._floatArrays[2] = 0.0;		// I(3,1)
	this._floatArrays[3] = 0.0;		// I(4,1)
	
	this._floatArrays[4] = 0.0;		// I(1,2)
	this._floatArrays[5] = 1.0;		// I(2,2)
	this._floatArrays[6] = 0.0;		// I(3,2)
	this._floatArrays[7] = 0.0;		// I(4,2)
	
	this._floatArrays[8] = 0.0;		// I(1,3)
	this._floatArrays[9] = 0.0;		// I(2,3)
	this._floatArrays[10] = 1.0;	// I(3,3)
	this._floatArrays[11] = 0.0;	// I(4,3)
	
	this._floatArrays[12] = 0.0;	// I(1,4)
	this._floatArrays[13] = 0.0;	// I(2,4)
	this._floatArrays[14] = 0.0;	// I(3,4)
	this._floatArrays[15] = 1.0;	// I(4,4)
};


/**
 * 행렬 정보 삭제
 */
Matrix4.prototype.deleteObjects = function() 
{
	this._floatArrays = undefined;
};


/**
 * 행우선 배열 방식의 4차원 행렬을 제공한다.
 *
 * @returns {Float32Array} 행우선 4차원 행렬
 * 
 * @see Matrix4#get
 */
Matrix4.prototype.getRowMajorMatrix = function() 
{
	var rowMajor_matrix = new Float32Array(16);

	rowMajor_matrix[0] = this.get(0, 0);
	rowMajor_matrix[1] = this.get(1, 0);
	rowMajor_matrix[2] = this.get(2, 0);
	rowMajor_matrix[3] = this.get(3, 0);

	rowMajor_matrix[4] = this.get(0, 1);
	rowMajor_matrix[5] = this.get(1, 1);
	rowMajor_matrix[6] = this.get(2, 1);
	rowMajor_matrix[7] = this.get(3, 1);

	rowMajor_matrix[8] = this.get(0, 2);
	rowMajor_matrix[9] = this.get(1, 2);
	rowMajor_matrix[10] = this.get(2, 2);
	rowMajor_matrix[11] = this.get(3, 2);

	rowMajor_matrix[12] = this.get(0, 3);
	rowMajor_matrix[13] = this.get(1, 3);
	rowMajor_matrix[14] = this.get(2, 3);
	rowMajor_matrix[15] = this.get(3, 3);

	return rowMajor_matrix;
};

/**
 * XYZ축에 대한 회전양에 따라 회전된 4차원 행렬을 구한다.
 *
 * @param {Number} zRotDeg z축에 대한 회전양(Degree)
 * @param {Number} xRotDeg x축에 대한 회전양(Degree)
 * @param {Number} yRotDeg y축에 대한 회전양(Degree)
 * @param {Matrix4} result 회전된 4차원 행렬
 * @returns {Matrix4} 회전된 4차원 행렬
 * 
 * @see Matrix4#rotationAxisAngDeg
 * @see Matrix4#getMultipliedByMatrix
 */
Matrix4.getRotationDegZXYMatrix = function(zRotDeg, xRotDeg, yRotDeg, result) 
{
	// created as identity matrix.
	if (result === undefined)
	{
		result = new Matrix4();
	}

	var xRotMatrix = new Matrix4();  // created as identity matrix.
	var yRotMatrix = new Matrix4();  // created as identity matrix.
	var zRotMatrix = new Matrix4();  // created as identity matrix.
	
	
	if (xRotDeg !== undefined && xRotDeg !== 0)
	{ xRotMatrix.rotationAxisAngDeg(xRotDeg, 1.0, 0.0, 0.0); }
	
	if (yRotDeg !== undefined && yRotDeg !== 0)
	{ yRotMatrix.rotationAxisAngDeg(yRotDeg, 0.0, 1.0, 0.0); }
	
	if (zRotDeg !== undefined && zRotDeg !== 0)
	{ zRotMatrix.rotationAxisAngDeg(zRotDeg, 0.0, 0.0, 1.0); }

	var zRotatedTMatrix;
	var zxRotatedTMatrix;
	var zxyRotatedTMatrix;

	zRotatedTMatrix = zRotMatrix;
	zxRotatedTMatrix = xRotMatrix.getMultipliedByMatrix(zRotatedTMatrix, zxRotatedTMatrix);
	zxyRotatedTMatrix = yRotMatrix.getMultipliedByMatrix(zxRotatedTMatrix, zxyRotatedTMatrix);
	
	result = zxyRotatedTMatrix;

	return result;
};

/**
 * 좌표값과 회전양을 통해 회전된 4차원 행렬을 구한다.
 *
 * @param {Number} angDeg 회전양(Degree)
 * @param {Number} axis_x X축 좌표
 * @param {Number} axis_y Y축 좌표
 * @param {Number} axis_z Z축 좌표
 * 
 * @see Quaternion
 * @see Quaternion#rotationAngDeg
 * @see Matrix4#rotationByQuaternion
 */
Matrix4.prototype.rotationAxisAngDeg = function(angDeg, axis_x, axis_y, axis_z) 
{
	var quaternion = new Quaternion();
	quaternion.rotationAngDeg(angDeg, axis_x, axis_y, axis_z);
	this.rotationByQuaternion(quaternion);
	quaternion = undefined;
};

/**
 * 좌표값과 회전양을 통해 회전된 4차원 행렬을 구한다.
 *
 * @param {Number} angRad 회전양(Radian)
 * @param {Number} axis_x X축 좌표
 * @param {Number} axis_y Y축 좌표
 * @param {Number} axis_z Z축 좌표
 * 
 * @see Quaternion
 * @see Quaternion#rotationAngRad
 * @see Matrix4#rotationByQuaternion
 */
Matrix4.prototype.rotationAxisAngRad = function(angRad, axis_x, axis_y, axis_z) 
{
	var quaternion = new Quaternion();
	quaternion.rotationAngRad(angRad, axis_x, axis_y, axis_z);
	this.rotationByQuaternion(quaternion);
	quaternion = undefined;
};

/**
 * 쿼터니언(사원수)을 통한 회전된 4차원 행렬을 구한다.
 *
 * @param {Quaternion} quaternion 사원수
 */
Matrix4.prototype.rotationByQuaternion = function(quaternion) 
{
	var x = quaternion.x;
	var y = quaternion.y;
	var z = quaternion.z;
	var w = quaternion.w;

	this._floatArrays[this.getIndexOfArray(0, 0)] = 1 - 2*y*y - 2*z*z;
	this._floatArrays[this.getIndexOfArray(0, 1)] = 2*x*y + 2*z*w;
	this._floatArrays[this.getIndexOfArray(0, 2)] = 2*x*z - 2*y*w;
	this._floatArrays[this.getIndexOfArray(0, 3)] = 0.0;

	this._floatArrays[this.getIndexOfArray(1, 0)] = 2*x*y - 2*z*w;
	this._floatArrays[this.getIndexOfArray(1, 1)] = 1 - 2*x*x - 2*z*z;
	this._floatArrays[this.getIndexOfArray(1, 2)] = 2*y*z + 2*x*w;
	this._floatArrays[this.getIndexOfArray(1, 3)] = 0.0;

	this._floatArrays[this.getIndexOfArray(2, 0)] = 2*x*z + 2*y*w;
	this._floatArrays[this.getIndexOfArray(2, 1)] = 2*y*z - 2*x*w;
	this._floatArrays[this.getIndexOfArray(2, 2)] = 1 - 2*x*x - 2*y*y;
	this._floatArrays[this.getIndexOfArray(2, 3)] = 0.0;

	this._floatArrays[this.getIndexOfArray(3, 0)] = 0.0;
	this._floatArrays[this.getIndexOfArray(3, 1)] = 0.0;
	this._floatArrays[this.getIndexOfArray(3, 2)] = 0.0;
	this._floatArrays[this.getIndexOfArray(3, 3)] = 1.0;
};

/**
 * Float32 형식의 4차원 행렬로 행렬값을 설정한다.
 *
 * @param {Float32Array} float32array
 */
Matrix4.prototype.setByFloat32Array = function(float32array) 
{
	for (var i=0; i<16; i++) 
	{
		this._floatArrays[i] = float32array[i];
	}
};

/**
 * 열우선 방식으로 행렬의 인덱스값을 계산한다.
 * 
 * @param {Number} col 열의 위치
 * @param {Number} row 행의 위치
 * @returns {Number} 행렬의 인덱스
 */
Matrix4.prototype.getIndexOfArray = function(col, row) 
{
	var _col = col || 0;
	var _row = row || 0;

	return 4 * _col + _row;
};

/**
 * 지정된 행/열의 위치에 있는 값을 구한다.
 *
 * @param {Number} col 열의 위치
 * @param {Number} row 행의 위치
 * @returns {Number} 행렬값
 */
Matrix4.prototype.get = function(col, row) 
{
	return this._floatArrays[this.getIndexOfArray(col, row)];
};

/**
 * XYZ축으로 이동한다.
 *
 * @param {Number} x X축 이동량
 * @param {Number} y Y축 이동량
 * @param {Number} z Z축 이동량
 */
Matrix4.prototype.setTranslation = function(x, y, z) 
{
	this.set(3, 0, x);
	this.set(3, 1, y);
	this.set(3, 2, z);
};


/**
 * 4차원 행렬의 특정 위치의 값을 설정한다.
 *
 * @param {Number} col 열의 위치
 * @param {Number} row 행의 위치
 * @param {Number} value 설정값
 */
Matrix4.prototype.set = function(col, row, value) 
{
	this._floatArrays[this.getIndexOfArray(col, row)] = value;
};

/**
 * 행렬연산을 통해 주어진 포인트를 이동한다.
 *
 * @param {Point3D} point3d 입력 포인트
 * @param {Point3D} result 출력 포인트
 * @returns {Point3D} 출력 포인트
 */
Matrix4.prototype.transformPoint3D = function(point3d, result) 
{
	if (result === undefined) { result = new Point3D(); }

	var x = point3d.x;
	var y = point3d.y;
	var z = point3d.z;

	result.x = x*this.get(0, 0) + y*this.get(1, 0) + z*this.get(2, 0) + this.get(3, 0);
	result.y = x*this.get(0, 1) + y*this.get(1, 1) + z*this.get(2, 1) + this.get(3, 1);
	result.z = x*this.get(0, 2) + y*this.get(1, 2) + z*this.get(2, 2) + this.get(3, 2);

	return result;
};

/**
 * 행렬연산을 통해 주어진 포인트를 회전한다.
 *
 * @param {Point3D} point3d 입력 포인트
 * @param {Point3D} result 출력 포인트
 * @returns {Point3D} 출력 포인트
 */
Matrix4.prototype.rotatePoint3D = function(point3d, result) 
{
	if (result === undefined) { result = new Point3D(); }

	var x = point3d.x;
	var y = point3d.y;
	var z = point3d.z;

	result.x = x*this.get(0, 0) + y*this.get(1, 0) + z*this.get(2, 0);
	result.y = x*this.get(0, 1) + y*this.get(1, 1) + z*this.get(2, 1);
	result.z = x*this.get(0, 2) + y*this.get(1, 2) + z*this.get(2, 2);

	return result;
};

/**
 * From gl-matrix.js
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
Matrix4.lookAt = function(out, eye, center, up) 
{
	var x0 = void 0,
		x1 = void 0,
		x2 = void 0,
		y0 = void 0,
		y1 = void 0,
		y2 = void 0,
		z0 = void 0,
		z1 = void 0,
		z2 = void 0,
		len = void 0;
	var eyex = eye[0];
	var eyey = eye[1];
	var eyez = eye[2];
	var upx = up[0];
	var upy = up[1];
	var upz = up[2];
	var centerx = center[0];
	var centery = center[1];
	var centerz = center[2];

	if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) 
	{
		return glMatrix.mat4.identity(out);
	}

	z0 = eyex - centerx;
	z1 = eyey - centery;
	z2 = eyez - centerz;

	len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
	z0 *= len;
	z1 *= len;
	z2 *= len;

	x0 = upy * z2 - upz * z1;
	x1 = upz * z0 - upx * z2;
	x2 = upx * z1 - upy * z0;
	len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
	if (!len) 
	{
		x0 = 0;
		x1 = 0;
		x2 = 0;
	}
	else 
	{
		len = 1 / len;
		x0 *= len;
		x1 *= len;
		x2 *= len;
	}

	y0 = z1 * x2 - z2 * x1;
	y1 = z2 * x0 - z0 * x2;
	y2 = z0 * x1 - z1 * x0;

	len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	if (!len) 
	{
		y0 = 0;
		y1 = 0;
		y2 = 0;
	}
	else 
	{
		len = 1 / len;
		y0 *= len;
		y1 *= len;
		y2 *= len;
	}

	out[0] = x0;
	out[1] = y0;
	out[2] = z0;
	out[3] = 0;
	out[4] = x1;
	out[5] = y1;
	out[6] = z1;
	out[7] = 0;
	out[8] = x2;
	out[9] = y2;
	out[10] = z2;
	out[11] = 0;
	out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	out[15] = 1;

	return out;
};

/**
 * 4차원 행렬의 곱셈을 계산한다.(Rm = AmBm)
 * Rm(j,i) = (AmBm)(j,i) = Sum( Am(j,k)*Bm(k,i) )(k=1,4)
 * 
 * @param {Matrix4} matrix 입력 행렬(Am)
 * @param {Matrix4} result 결과 행렬(Rm)
 * @returns {Matrix4} 결과 행렬(Rm)
 */
Matrix4.prototype.getMultipliedByMatrix = function(matrix, result) 
{

	if (result === undefined) { result = new Matrix4(); }

	for (var i=0; i<4; i++) 
	{
		for (var j=0; j<4; j++) 
		{
			var idx = this.getIndexOfArray(i, j);
			result._floatArrays[idx] = 0.0;
			for (var k=0; k<4; k++) 
			{
				result._floatArrays[idx] += matrix.get(k, j) * this.get(i, k);
			}
		}
	}
	return result;
};

/**
 * 원근 투영 행렬을 생성한다.
 * normalized device coordinates (NDC) uses the left-handed coordinate system
 * Always use right-handed coordinate system
 * 
 * @param {*} fovyrad Radian 단위의 시야각(Field of view)
 * @param {*} aspect 화면비율(Aspect Ratio:가로값/세로값)
 * @param {*} near 근거리
 * @param {*} far 원거리
 * 
 * @see http://ogldev.atspace.co.uk/www/tutorial12/tutorial12.html
 * @see https://www.gamedev.net/articles/programming/graphics/perspective-projections-in-lh-and-rh-systems-r3598/
 * @see http://www.songho.ca/opengl/gl_projectionmatrix.html
 */
Matrix4.prototype.setToPerspectiveProjection = function (fovyrad, aspect, near, far) 
{
	var yScale = 1.0 / Math.tan(fovyrad / 2);
	var xScale = yScale / aspect;
	var zRange = near - far;

	this.setByFloat32Array([xScale, 0, 0, 0,
		0, yScale, 0, 0,
		0, 0, (far + near) / zRange, -1,
		0, 0, 2*far*near / zRange, 0 ]);
};

/**
 * 입력된 4차원 행렬로부터 행렬값을 복사한다.
 *
 * @param {Matrix4} matrix 4차원 행렬
 */
Matrix4.prototype.copyFromMatrix4 = function(matrix) 
{
	for (var i=0; i<16; i++)
	{
		this._floatArrays[i] = matrix._floatArrays[i];
	}
};


/**
 * 입력된 배열로부터 4차원 행렬값을 복사한다.
 *
 * @param {Object[]} floatArrays 배열
 */
Matrix4.prototype.copyFromFloatArray = function(floatArrays) 
{
	for (var i=0; i<16; i++)
	{
		this._floatArrays[i] = floatArrays[i];
	}
};

/**
 * 행렬의 타입을 알려준다.
 *
 * @returns {Number} 행렬의 타입
 */
Matrix4.prototype.computeMatrixType = function() 
{
	// matrixType = 0 -> identity matrix.
	// matrixType = 1 -> translate matrix.
	// matrixType = 2 -> transform matrix.
	
	var error = 10E-8;
	if (this.isRotationIdentity())
	{
		// check if there are translation.
		if (this.aproxEqual(this._floatArrays[3], 0, error))
		{
			if (this.aproxEqual(this._floatArrays[7], 0, error))
			{
				if (this.aproxEqual(this._floatArrays[11], 0, error))
				{
					if (this.aproxEqual(this._floatArrays[12], 0, error))
					{
						if (this.aproxEqual(this._floatArrays[13], 0, error))
						{
							if (this.aproxEqual(this._floatArrays[14], 0, error))
							{
								if (this.aproxEqual(this._floatArrays[15], 1, error))
								{
									return 0;
								}
								else { return 1; }
							}
							else { return 1; }
						}
						else { return 1; }
					}
					else { return 1; }
				}
				else { return 1; }
			}
			else { return 1; }
		}
		else { return 1; }
	}
	else
	{
		return 2;
	}
};

/**
 * 오차범위내에 두 값의 동일 여부를 확인한다.
 * Returns if the value is aproximately equal to the valueToCompare with error.
 *
 * @param {Number} value 비교값
 * @param {Number} valueToCompare 비교값
 * @param {Number} error 오차율
 * @returns {Boolean} 비교값의 일치여부
 */
Matrix4.prototype.aproxEqual = function(value, valueToCompare, error) 
{
	if (error === undefined)
	{ error = 10E-8; }
	
	if (value === valueToCompare)
	{
		return true;
	}
	else
	{
		if (value > (valueToCompare - error) && value < (valueToCompare + error))
		{ return true; }
		else
		{ return false; }
	}
};

/**
 * 두 배열의 일치여부를 확인한다.
 * Returns if the arrayA equal to the arrayB.
 *
 * @param {Object[]} arrayA
 * @param {Object[]} arrayB
 * @returns {Boolean} 두 배열의 일치여부
 */
Matrix4.areEqualArrays = function(arrayA, arrayB) 
{
	var areEqual = true;
	var i=0;
	while (areEqual && i<16)
	{
		if (arrayA[i] !== arrayB[i])
		{
			areEqual = false;
		}
		i++;
	}
	
	return areEqual;
};

/**
 * 회전/이동을 위한 단위행렬 여부를 확인한다.
 *
 * @param {Number} error
 * @returns {Boolean}
 */
Matrix4.prototype.isRotationIdentity = function(error) 
{
	if (this.aproxEqual(this._floatArrays[0], 1, error))
	{
		if (this.aproxEqual(this._floatArrays[1], 0, error))
		{
			if (this.aproxEqual(this._floatArrays[2], 0, error))
			{
				if (this.aproxEqual(this._floatArrays[4], 0, error))
				{
					if (this.aproxEqual(this._floatArrays[5], 1, error))
					{
						if (this.aproxEqual(this._floatArrays[6], 0, error))
						{
							if (this.aproxEqual(this._floatArrays[8], 0, error))
							{
								if (this.aproxEqual(this._floatArrays[9], 0, error))
								{
									if (this.aproxEqual(this._floatArrays[10], 1, error))
									{
										return true;
									}
									else { return false; }
								}
								else { return false; }
							}
							else { return false; }
						}
						else { return false; }
					}
					else { return false; }
				}
				else { return false; }
			}
			else { return false; }
		}
		else { return false; }
	}
	else { return false; }
};

'use strict';

var Messages = {};

Messages.CONSTRUCT_ERROR = "이 객체는 new를 사용하여 생성해야 합니다.";
'use strict';

/**
 * Manages & controls all mouse actions.
 * @class MouseAction
 */
var MouseAction = function() 
{
	if (!(this instanceof MouseAction)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * Start mouse click x position in screen coordinates.
	 * @type {Number}
	 * @default 0
	 */
	this.strX;
	
	/**
	 * Start mouse click y position in screen coordinates.
	 * @type {Number}
	 * @default 0
	 */
	this.strY;
	
	/**
	 * Linear depth value of the start click point.
	 * @type {Number}
	 * @default 0
	 */
	this.strLinealDepth;
	
	/**
	 * Start click point in camera coordinates.
	 * @type {Point3D}
	 * @default (0,0,0)
	 */
	this.strCamCoordPoint;
	
	/**
	 * Start click point in world coordinates.
	 * @type {Point3D}
	 * @default (0,0,0)
	 */
	this.strWorldPoint;
	
	/**
	 * TEST var: Start click point in world coordinates.
	 * @type {Point3D}
	 * @default (0,0,0)
	 */
	this.strWorldPoint2;
	
	/**
	 * Transformation matrix of start click point location.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.strModelViewMatrix = new Matrix4();
	
	/**
	 * Transformation matrix inverse of start click point location.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.strModelViewMatrixInv = new Matrix4();
	
	/**
	 * Camera state on start click.
	 * @type {Camera}
	 * @default Camera.
	 */
	this.strCamera = new Camera();
	
	/**
	 * Camera target on start click.
	 * @type {Float32Array(3)}
	 * @default (0,0,0).
	 */
	this.strCameraTarget = new Float32Array([0.0, 0.0, 0.0]);
	
	/**
	 * Current mouse click x position in screen coordinates.
	 * @type {Number}
	 * @default 0
	 */
	this.curX;
	
	/**
	 * Current mouse click y position in screen coordinates.
	 * @type {Number}
	 * @default 0
	 */
	this.curY;
	
	/**
	 * Camera rotation point.
	 * @type {Point3D}
	 * @default (0,0,0).
	 */
	this.camRotPoint = new Point3D();
	
	/**
	 * Camera rotation axis.
	 * @type {Point3D}
	 * @default (0,0,0).
	 */
	this.camRotAxis = new Point3D();
	
	/**
	 * Aux var. Start click point in world coordinates.
	 * @type {Point3D}
	 * @default (0,0,0).
	 */
	this.strWorldPointAux;
	
	/**
	 * Aux var. Start click point location.
	 * @type {GeographicCoord}
	 * @default (0,0,0).
	 */
	this.strLocationAux;
	
};

/**
 * Deletes the auxiliary start point & location.
 */
MouseAction.prototype.clearStartPositionsAux = function()
{
	if (this.strWorldPointAux)
	{
		this.strWorldPointAux.deleteObjects();
	}
	this.strWorldPointAux = undefined;
		
	if (this.strLocationAux)
	{
		this.strLocationAux.deleteObjects();
	}
	this.strLocationAux = undefined;
};

/**
 * Calculates the camera start position in world coordinates.
 * @param {MagoManager} magoManager Main Mago3D manager.
 */
MouseAction.prototype.claculateStartPositionsAux = function(magoManager)
{
	var strLinDepth = this.strLinealDepth;
					
	// calculate the strWorldPos.
	var frustumFar = 100000000.0;
	var strRealDepth = strLinDepth*frustumFar;
	// now, find the 3d position of the pixel in camCoord.*
	magoManager.resultRaySC = magoManager.getRayCamSpace(this.strX, this.strY, magoManager.resultRaySC);
	var strCamPos = new Point3D();
	strCamPos.set(magoManager.resultRaySC[0] * strRealDepth, magoManager.resultRaySC[1] * strRealDepth, magoManager.resultRaySC[2] * strRealDepth);
	this.strWorldPointAux = magoManager.cameraCoordPositionToWorldCoord(strCamPos, this.strWorldPointAux);
	this.strLocationAux = ManagerUtils.pointToGeographicCoord(this.strWorldPointAux, undefined, magoManager);
};

/**
 * Save the current-state on start-state vars. of worldPoint and CamCoordPoint
 */
MouseAction.prototype.saveCurrentToStart = function()
{
	this.strX = this.curX;
	this.strY = this.curY;
	
	// world point.
	if (this.strWorldPoint === undefined)
	{ this.strWorldPoint = new Point3D(); }
	
	if (this.curWorldPoint)
	{
		this.strWorldPoint.copyFrom(this.curWorldPoint);
	}
	
	// camCoord point.
	if (this.strCamCoordPoint === undefined)
	{ this.strCamCoordPoint = new Point3D(); }
	
	if (this.curCamCoordPoint)
	{
		this.strCamCoordPoint.copyFrom(this.curCamCoordPoint);
	}
};







































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class ObjectMarker
 *
 */
var ObjectMarker = function() 
{
	if (!(this instanceof ObjectMarker)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.geoLocationData = new GeoLocationData();
	this.issue_id = null;
	this.issue_type = null;
	//this.latitude = 0;
	//this.longitude = 0;
	//this.height = 0;
};

ObjectMarker.prototype.copyFrom = function(objMarker) 
{
	if (objMarker === undefined) { return; }
		
	if (objMarker.geoLocationData) 
	{
		this.geoLocationData.copyFrom(objMarker.geoLocationData);
	}
	
	this.issue_id = objMarker.issue_id;
	this.issue_type = objMarker.issue_type;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class ObjectMarkerManager
 *
 */
var ObjectMarkerManager = function() 
{
	if (!(this instanceof ObjectMarkerManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.objectMarkerArray = [];

};

/**
 * 어떤 일을 하고 있습니까?
 * @class ObjectMarkerManager
 *
 */
ObjectMarkerManager.prototype.newObjectMarker = function()
{
	var objMarker = new ObjectMarker();
	this.objectMarkerArray.push(objMarker);
	return objMarker;
};
'use strict';
	
/**
 * OcclusionCullingOctree
 * @class
 * 
 * @see OcclusionCullingOctreeCell
 */
var OcclusionCullingOctree = function() 
{
	if (!(this instanceof OcclusionCullingOctree)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this._ocCulling_box = new OcclusionCullingOctreeCell(null);
	this._infinite_ocCulling_box = new OcclusionCullingOctreeCell(null);
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class
 * 
 * @param occlusionCullingOctree_Cell_Owner OcclusionCullingOctreeCell 소유자
 */
var OcclusionCullingOctreeCell = function(occlusionCullingOctree_Cell_Owner) 
{
	if (!(this instanceof OcclusionCullingOctreeCell)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this._ocCulling_Cell_owner = occlusionCullingOctree_Cell_Owner;
	this.minX = 0.0;
	this.maxX = 0.0;
	this.minY = 0.0;
	this.maxY = 0.0;
	this.minZ = 0.0;
	this.maxZ = 0.0;
	this._indicesArray = []; // Visible objects indices.
	this._subBoxesArray = [];
	this.modelReferencedGroupsList; // undefined initially.
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoRefsIndices 변수
 * @param motherNeoRefsList 변수
 */
OcclusionCullingOctreeCell.prototype.createModelReferencedGroups = function(motherNeoRefsList) 
{
	var subBoxesCount = this._subBoxesArray.length;
	if (subBoxesCount === 0)
	{
		if (this._indicesArray.length === 0)
		{ return; }
		
		if (this.modelReferencedGroupsList === undefined)
		{ this.modelReferencedGroupsList = new ModelReferencedGroupsList(); }
		
		this.modelReferencedGroupsList.createModelReferencedGroups(this._indicesArray, motherNeoRefsList);
	}
	else
	{
		for (var i=0; i<subBoxesCount; i++)
		{
			this._subBoxesArray[i].createModelReferencedGroups(motherNeoRefsList);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns subBox
 */
OcclusionCullingOctreeCell.prototype.newSubBox = function() 
{
	var subBox = new OcclusionCullingOctreeCell(this);
	this._subBoxesArray.push(subBox);
	return subBox;
};

/**
 * 어떤 일을 하고 있습니까?
 */
OcclusionCullingOctreeCell.prototype.create8SubBoxes = function() 
{
	this._subBoxesArray.length = 0;	
	for (var i=0; i<8; i++) 
	{
		this.newSubBox();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param min_x 변수
 * @param max_x 변수
 * @param min_y 변수
 * @param max_y 변수
 * @param min_z 변수
 * @param max_z 변수
 */
OcclusionCullingOctreeCell.prototype.setDimensions = function(min_x, max_x, min_y, max_y, min_z, max_z) 
{
	this.minX = min_x;
	this.maxX = max_x;
	this.minY = min_y;
	this.maxY = max_y;
	this.minZ = min_z;
	this.maxZ = max_z;
};

/**
 * 어떤 일을 하고 있습니까?
 */
OcclusionCullingOctreeCell.prototype.setSizesSubBoxes = function() 
{
	// Bottom                      Top
	// |----------|----------|     |----------|----------|
	// |          |          |     |          |          |       Y
	// |    3     |    2     |	   |    7     |    6     |       ^
	// |          |          |     |          |          |       |
	// |----------|----------|     |----------|----------|       |
	// |          |          |     |          |          |       |
	// |     0    |     1    |     |    4     |    5     |       |
	// |          |          |     |          |          |       -----------------> X
	// |----------|----------|     |----------|----------|  
	
	if (this._subBoxesArray.length > 0) 
	{
		var half_x= (this.maxX + this.minX)/2.0;
		var half_y= (this.maxY + this.minY)/2.0;
		var half_z= (this.maxZ + this.minZ)/2.0;
		
		this._subBoxesArray[0].setDimensions(this.minX, half_x,   this.minY, half_y,   this.minZ, half_z);
		this._subBoxesArray[1].setDimensions(half_x, this.maxX,   this.minY, half_y,   this.minZ, half_z);
		this._subBoxesArray[2].setDimensions(half_x, this.maxX,   half_y, this.maxY,   this.minZ, half_z);
		this._subBoxesArray[3].setDimensions(this.minX, half_x,   half_y, this.maxY,   this.minZ, half_z);

		this._subBoxesArray[4].setDimensions(this.minX, half_x,   this.minY, half_y,   half_z, this.maxZ);
		this._subBoxesArray[5].setDimensions(half_x, this.maxX,   this.minY, half_y,   half_z, this.maxZ);
		this._subBoxesArray[6].setDimensions(half_x, this.maxX,   half_y, this.maxY,   half_z, this.maxZ);
		this._subBoxesArray[7].setDimensions(this.minX, half_x,   half_y, this.maxY,   half_z, this.maxZ);
		
		for (var i=0; i<this._subBoxesArray.length; i++) 
		{
			this._subBoxesArray[i].setSizesSubBoxes();
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersects
 */
OcclusionCullingOctreeCell.prototype.intersectsWithPoint3D = function(x, y, z) 
{
	var intersects = false;
	if (x> this.minX && x<this.maxX) 
	{
		if (y> this.minY && y<this.maxY) 
		{
			if (z> this.minZ && z<this.maxZ) 
			{
				intersects = true;
			}
		}
	}
	
	return intersects;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersectedSubBox
 */
OcclusionCullingOctreeCell.prototype.getIntersectedSubBoxByPoint3D = function(x, y, z) 
{
	if (this._ocCulling_Cell_owner === undefined) 
	{
		// This is the mother_cell.
		if (!this.intersectsWithPoint3D(x, y, z)) 
		{
			return undefined;
		}
	}
	
	var intersectedSubBox = undefined;
	var subBoxes_count = this._subBoxesArray.length;
	if (subBoxes_count > 0) 
	{
		var center_x = (this.minX + this.maxX)/2.0;
		var center_y = (this.minY + this.maxY)/2.0;
		var center_z = (this.minZ + this.maxZ)/2.0;
		
		var intersectedSubBox_aux = undefined;
		var intersectedSubBox_idx;
		if (x<center_x) 
		{
			// Here are the boxes number 0, 3, 4, 7.
			if (y<center_y) 
			{
				// Here are 0, 4.
				if (z<center_z) { intersectedSubBox_idx = 0; }
				else { intersectedSubBox_idx = 4; }
			}
			else 
			{
				// Here are 3, 7.
				if (z<center_z) { intersectedSubBox_idx = 3; }
				else { intersectedSubBox_idx = 7; }
			}
		}
		else 
		{
			// Here are the boxes number 1, 2, 5, 6.
			if (y<center_y) 
			{
				// Here are 1, 5.
				if (z<center_z) { intersectedSubBox_idx = 1; }
				else { intersectedSubBox_idx = 5; }
			}
			else 
			{
				// Here are 2, 6.
				if (z<center_z) { intersectedSubBox_idx = 2; }
				else { intersectedSubBox_idx = 6; }
			}
		}
		
		intersectedSubBox_aux = this._subBoxesArray[intersectedSubBox_idx];
		intersectedSubBox = intersectedSubBox_aux.getIntersectedSubBoxByPoint3D(x, y, z);
		
	}
	else 
	{
		intersectedSubBox = this;
	}
	
	return intersectedSubBox;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param eye_x 변수
 * @param eye_y 변수
 * @param eye_z 변수
 * @param result_visibleIndicesArray 변수
 * @returns result_visibleIndicesArray
 */
OcclusionCullingOctreeCell.prototype.getIndicesVisiblesForEye = function(eye_x, eye_y, eye_z, result_visibleIndicesArray, result_modelReferencedGroup) 
{
	var intersectedSubBox = this.getIntersectedSubBoxByPoint3D(eye_x, eye_y, eye_z);
	
	if (intersectedSubBox !== undefined && intersectedSubBox._indicesArray.length > 0) 
	{
		result_visibleIndicesArray = intersectedSubBox._indicesArray;
		if (result_modelReferencedGroup)
		{
			result_modelReferencedGroup = this.modelReferencedGroupsList;
		}
	}
	
	return result_visibleIndicesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param expansionDist 변수
 */
OcclusionCullingOctreeCell.prototype.expandBox = function(expansionDist) 
{
	this.minX -= expansionDist;
	this.maxX += expansionDist;
	this.minY -= expansionDist;
	this.maxY += expansionDist;
	this.minZ -= expansionDist;
	this.maxZ += expansionDist;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param arrayBuffer 변수
 * @param bytes_readed 변수
 * @param f4dReaderWriter 변수
 * @returns bytes_readed
 */
OcclusionCullingOctreeCell.prototype.parseArrayBuffer = function(arrayBuffer, bytes_readed, f4dReaderWriter) 
{
	// Important note: this is the version of neoGeometry.
	// Important note: this is the version of neoGeometry.
	// Important note: this is the version of neoGeometry.
	var is_mother_cell = f4dReaderWriter.readInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
	if (is_mother_cell) 
	{
		// read the mother dimensions.
		var minX = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var maxX = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var minY = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var maxY = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var minZ = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var maxZ = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		
		this.setDimensions(minX, maxX, minY, maxY, minZ, maxZ);
	}
	
	var subBoxes_count = f4dReaderWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	
	if (subBoxes_count === 0) 
	{
		var objects_count = f4dReaderWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		for (var i=0; i<objects_count; i++) 
		{
			var objects_idxInList = f4dReaderWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			this._indicesArray.push(objects_idxInList);
		}
	}
	else 
	{
		for (var i=0; i<subBoxes_count; i++) 
		{
			var subOcclusionBox = this.newSubBox();
			bytes_readed = subOcclusionBox.parseArrayBuffer(arrayBuffer, bytes_readed, f4dReaderWriter);
		}
	}
	
	return bytes_readed;
};
'use strict';

/**
 * This is the pin which is created to be placed on the map
 * @class Pin
 *
 */
var Pin = function() 
{
	if (!(this instanceof Pin)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.texture; // default.
	this.texturesArray = [];
	this.positionBuffer;
	this.texcoordBuffer;
	
};

Pin.prototype.createPin = function(gl)
{
	this.positionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);

	// Put a unit quad in the buffer
	var positionsPinQuad = [
		0, 0, 0,
		1, 0, 0,
		0, 1, 0,
		0, 1, 0,
		1, 0, 0,
		1, 1, 0
	];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positionsPinQuad), gl.STATIC_DRAW);

	this.texcoordBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
	var texcoordsPinQuad = [
		0, 0,
		1, 0,
		0, 1,
		0, 1,
		1, 0,
		1, 1
	];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoordsPinQuad), gl.STATIC_DRAW);
	
};

/**
 * draw the bottom pick of the pin
 */
Pin.prototype.createPinCenterBottom = function(gl)
{
	this.positionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);

	// Put a unit quad in the buffer
	var positionsPinQuad = [
		-0.5, 0, 0,
		0.5, 0, 0,
		-0.5, 1, 0,
		-0.5, 1, 0,
		0.5, 0, 0,
		0.5, 1, 0
	];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positionsPinQuad), gl.STATIC_DRAW);

	this.texcoordBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
	var texcoordsPinQuad = [
		0, 0,
		1, 0,
		0, 1,
		0, 1,
		1, 0,
		1, 1
	];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoordsPinQuad), gl.STATIC_DRAW);
	
};
'use strict';

/**
 * The plane which can be represented as linear equation
 * Plane on 3D space. Plane equation ax+by+cz+d = 0.
 * @class Plane
 */
var Plane = function() 
{
	if (!(this instanceof Plane)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// ax+by+cz+d = 0 plane.
	this.a = 0.0;
	this.b = 0.0;
	this.c = 0.0;
	this.d = 0.0;
};

/**
 * set the point and the vector which determine this plane
 * @param px the x coordi of the point that determine this plane
 * @param py the y coordi of the point that determine this plane
 * @param pz the z coordi of the point that determine this plane
 * @param nx the x coordi of the normal vector
 * @param ny the y coordi of the normal vector
 * @param nz the z coordi of the normal vector
 */
Plane.prototype.setPointAndNormal = function(px, py, pz, nx, ny, nz) 
{
	this.a = nx;
	this.b = ny;
	this.c = nz;
	this.d = -this.a*px -this.b*py - this.c*pz;
};

/**
 * set the point which determine this plane
 * @param px the x coordi of the point that determine this plane
 * @param py the y coordi of the point that determine this plane
 * @param pz the z coordi of the point that determine this plane
 */
Plane.prototype.setPoint = function(px, py, pz) 
{
	this.d = -this.a*px -this.b*py - this.c*pz;
};

/**
 * determine this plane as normal vector and the distance from the point which determine normal vector
 * @param dist
 * @param nx the x coordi of the normal vector
 * @param ny the y coordi of the normal vector
 * @param nz the z coordi of the normal vector
 */
Plane.prototype.setNormalAndDistance = function(nx, ny, nz, dist) 
{
	this.a = nx;
	this.b = ny;
	this.c = nz;
	this.d = dist;
};

/**
 * get the point of normal vector
 */
Plane.prototype.getNormal = function(resultNormal) 
{
	if (resultNormal === undefined)
	{ resultNormal = new Point3D(); }
	
	resultNormal.set(this.a, this.b, this.c);
	
	return resultNormal;
};

/**
 * Calculate the matrix which can rotate this plane
 * @param resultMatrix the matrix which will hold the result
 */
Plane.prototype.getRotationMatrix = function(resultTMatrix) 
{
	// The initial normal is (0, 0, 1), & the planeNormal is the transformed normal, so, calculate the rotationMatrix.
	var initialNormal = new Point3D(0.0, 0.0, 1.0);
	var transformedNormal = this.getNormal(undefined);
	
	// Calculate rotation axis. CrossProduct between initialNormal and the transformedNormal.
	// Check if the "initialNormal & the transformedNormal are parallels.
	var radError = 10E-10;
	var relativeOrientation = initialNormal.getRelativeOrientationToVector(transformedNormal, radError);
	// relativeOrientation = 0 -> // there are parallels & the same sense.
	// relativeOrientation = 1 -> // there are parallels & opposite sense.
	// relativeOrientation = 2 -> // there are NO parallels.
	var matrixAux = glMatrix.mat4.create(); // creates as identityMatrix.
	if (relativeOrientation === 0)
	{
		// there are parallels & the same sense.
		// In this case, the resultMatrix is a identityMatrix, so do nothing.
	}
	else if (relativeOrientation === 1)
	{
		// there are parallels & opposite sense.
		// Rotate 180 degree in xAxis.
		var identityMat = glMatrix.mat4.create();
		matrixAux = glMatrix.mat4.rotateX(matrixAux, identityMat, Math.PI);
	}
	else if (relativeOrientation === 2)
	{
		// there are NO parallels.
		// Calculate rotation axis. CrossProduct between initialNormal and the transformedNormal.
		var rotAxis = initialNormal.crossProduct(transformedNormal, undefined);
		rotAxis.unitary();
		var angRad = initialNormal.angleRadToVector(transformedNormal);
		var axis = glMatrix.vec3.fromValues(rotAxis.x, rotAxis.y, rotAxis.z);
		var quaternion = quat.create();
		quaternion = quat.setAxisAngle(quaternion, axis, angRad);
		
		// Now, make matrix4 from quaternion.
		var identityMat = glMatrix.mat4.create();
		matrixAux = glMatrix.mat4.fromQuat(identityMat, quaternion);
	}
	
	if (resultTMatrix === undefined)
	{ resultTMatrix = new Matrix4(); }
	
	resultTMatrix._floatArrays = matrixAux;
	
	return resultTMatrix;
};

/**
 * Get the point of the intersecting point of line and this plane
 * @param line 변수
 * @param intersectionPoint 변수
 */
Plane.prototype.intersectionLine = function(line, intersectionPoint) 
{
	var r = line.point.x;
	var s = line.point.y;
	var t = line.point.z;
	
	var u = line.direction.x;
	var v = line.direction.y;
	var w = line.direction.z;
	
	var den = this.a*u + this.b*v + this.c*w;
	
	if (Math.abs(den) > 10E-8) 
	{
		var alfa = -((this.a*r + this.b*s + this.c*t + this.d)/(den));
		
		if (intersectionPoint === undefined) { intersectionPoint = new Point3D(); }
		
		intersectionPoint.set(r+alfa*u, s+alfa*v, t+alfa*w);
		return intersectionPoint;
	}
	else { return undefined; }
};

/**
 * Check whether the given sphere is intersected with this plane or not
 * @param sphere sphere
 */
Plane.prototype.intersectionSphere = function(sphere) 
{
	if (sphere === undefined || sphere.centerPoint === undefined)
	{ return Constant.INTERSECTION_OUTSIDE; }
	
	var sphereCenter = sphere.centerPoint;
	
	// calculate the distance by dotProduct.
	// sphere centerPoint = (x1, y1, z1), distance = |ax1 + by1 + cz1 + d|/sqrt(a*a +b*b + c*c*).
	// note: the module sqrt(a*a +b*b + c*c*) = 1, so no necessary divide distance by module.
	var distance = sphereCenter.x * this.a + sphereCenter.y * this.b + sphereCenter.z * this.c + this.d;

	if (distance < -sphere.r)
	{
		return Constant.INTERSECTION_OUTSIDE;
	}
	else if (distance < sphere.r)
	{
		return Constant.INTERSECTION_INTERSECT;
	}
	return Constant.INTERSECTION_INSIDE;
};






'use strict';

/**
 * 쿼터니언
 * 
 * @class
 */
var Quaternion = function() 
{
	if (!(this instanceof Quaternion)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * x 속성값
	 * @type {Number}
	 */
	this.x = 0.0;

	/**
	 * y 속성값
	 * @type {Number}
	 */
	this.y = 0.0;

	/**
	 * z 속성값
	 * @type {Number}
	 */
	this.z = 0.0;

	/**
	 * w 속성값
	 * @type {Number}
	 */
	this.w = 1.0;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z + this.w*this.w )
 */
Quaternion.prototype.Modul = function() 
{
	return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z + this.w*this.w );
};

/**
 * 어떤 일을 하고 있습니까?
 */
Quaternion.prototype.Unitary = function() 
{
	var modul = this.Modul();
	this.x /= modul;
	this.y /= modul;
	this.z /= modul;
	this.w /= modul;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param angDeg 변수
 * @param axis_x 변수
 * @param axis_y 변수
 * @param axis_z 변수
 */
Quaternion.prototype.rotationAngDeg = function(angDeg, axis_x, axis_y, axis_z) 
{
	var angRad = angDeg*Math.PI/180.0;
	this.rotationAngRad(angRad, axis_x, axis_y, axis_z);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param angRad 변수
 * @param axis_x 변수
 * @param axis_y 변수
 * @param axis_z 변수
 */
Quaternion.prototype.rotationAngRad = function(angRad, axis_x, axis_y, axis_z) 
{
	var s = Math.sqrt(axis_x*axis_x + axis_y*axis_y + axis_z*axis_z);
	var error = 10E-13;
	if (!s < error) 
	{
		var c = 1.0/s;
		var omega = 0.5 * angRad;
		s = Math.sin(omega);
		this.x = axis_x * c * s;
		this.y = axis_y * c * s;
		this.z = axis_z * c * s;
		this.w = Math.cos(omega);
		this.Unitary();
	}
	else 
	{
		this.x = 0.0;
		this.y = 0.0;
		this.z = 0.0;
		this.w = 1.0;
	}
};

'use strict';

/**
 * This class is used for color code of GL
 * @class SelectionColor
 */
var SelectionColor = function() 
{
	if (!(this instanceof SelectionColor)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * Color
	 * @type {Color}
	 */
	this.color = new Color();
};

/**
 * Initiate the color value of this feature
 */
SelectionColor.prototype.init = function() 
{
	this.color.r = 0;
	this.color.g = 0;
	this.color.b = 0;
	this.cycle = 0;
};

/**
 * get the color code of given RGB color
 * @param {Color} resultColor target color instance
 */
SelectionColor.prototype.getAvailableColor = function(resultColor) 
{
	if (resultColor === undefined)
	{ resultColor = new Color(); }
	
	resultColor.setRGB(this.color.r, this.color.g, this.color.b);
	
	this.color.b += 1;
	if (this.color.b >= 254)
	{
		this.color.b = 0;
		this.color.g += 1;
		if (this.color.g >= 254)
		{
			this.color.g = 0;
			this.color.r += 1;
			if (this.color.r >= 254)
			{
				this.color.r = 0;
				this.cycle += 1;
			}
		}
	}
	
	return resultColor;
};

/**
 * Change the RGB code to color code.
 * (255,255,255) is used to white color so 254 number is used
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @returns Color code
 */
SelectionColor.prototype.decodeColor3 = function(r, g, b) 
{
	return 64516*r + 254*g + b;
};

'use strict';

/**
 * 4분할 타일링 수행 시 타일 객체.
 * Quadtree based tile with thickness.
 * @class SmartTile
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * @param {String} smartTileName tile name;
 */
var SmartTile = function(smartTileName) 
{
	//       +-----+-----+
	//       |  3  |  2  |
	//       +-----+-----+
	//       |  0  |  1  |
	//       +-----+-----+
	
	if (!(this instanceof SmartTile)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.name;
	if (smartTileName)
	{ this.name = smartTileName; }
	this.depth; // mother tile depth = 0.
	this.minGeographicCoord; // longitude, latitude, altitude.
	this.maxGeographicCoord; // longitude, latitude, altitude.
	this.sphereExtent; // cartesian position sphere in worldCoord.
	this.subTiles; // array.
	
	this.nodeSeedsArray;
	this.nodesArray; // nodes with geometry data only (lowest nodes).
	
	this.isVisible; // var to manage the frustumCulling and delete buildings if necessary.
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.deleteObjects = function() 
{
	this.name = undefined;
	this.depth = undefined;
	if (this.minGeographicCoord)
	{ this.minGeographicCoord.deleteObjects(); } 
		
	if (this.maxGeographicCoord)
	{ this.maxGeographicCoord.deleteObjects(); } 
	
	this.minGeographicCoord = undefined; 
	this.maxGeographicCoord = undefined; 
	if (this.sphereExtent)
	{ this.sphereExtent.deleteObjects(); }
	
	this.sphereExtent = undefined;
	
	// now, erase nodeSeeds.
	if (this.nodeSeedsArray)
	{
		var nodeSeedsCount = this.nodeSeedsArray.length;
		for (var i=0; i<nodeSeedsCount; i++)
		{
			// no delete the nodeObjects. nodeObjects must be deleted by hierarchyManager.
			this.nodeSeedsArray[i] = undefined;
		}
		this.nodeSeedsArray = undefined;
	}
	
	// now, erase nodes.
	if (this.nodesArray)
	{
		var nodesCount = this.nodesArray.length;
		for (var i=0; i<nodesCount; i++)
		{
			// no delete the nodeObjects. nodeObjects must be deleted by hierarchyManager.
			this.nodesArray[i] = undefined;
		}
		this.nodesArray = undefined;
	}
	
	this.isVisible = undefined;
	
	// delete children.
	if (this.subTiles)
	{
		var subTilesCount = this.subTiles.length;
		for (var i=0; i<subTilesCount; i++)
		{
			this.subTiles[i].deleteObjects();
			this.subTiles[i] = undefined;
		}
		this.subTiles = undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.newSubTile = function(parentTile) 
{
	if (this.subTiles === undefined)
	{ this.subTiles = []; }
	
	var subTile = new SmartTile();
	subTile.depth = parentTile.depth + 1;
	subTile.targetDepth = parentTile.targetDepth;
	this.subTiles.push(subTile);
	return subTile;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.clearNodesArray = function() 
{
	if (this.nodesArray === undefined)
	{ return; }
	
	for (var i=0; i<this.nodesArray.length; i++)
	{
		this.nodesArray[i] = undefined;
	}
	this.nodesArray = undefined;
};


/**
 * 어떤 일을 하고 있습니까?
 */
/*
SmartTile.prototype.getNodeByBuildingId = function(buildingType, buildingId) 
{
	var resultNode;
	var neoBuilding;
	var node;
	var hasSubTiles = true;
	if (this.subTiles === undefined)
	{ hasSubTiles = false; }
	
	if (this.subTiles && this.subTiles.length === 0)
	{ hasSubTiles = false; }
		
	if (!hasSubTiles)
	{
		if (this.nodesArray)
		{
			var nodesCount = this.nodesArray.length;
			var find = false;
			var i=0;
			while (!find && i<nodesCount) 
			{
				node = this.nodesArray[i];
				neoBuilding = node.data.neoBuilding;
				if (buildingType)
				{
					if (neoBuilding.buildingId === buildingId && neoBuilding.buildingType === buildingType) 
					{
						find = true;
						resultNode = node;
						return resultNode;
					}
				}
				else 
				{
					if (neoBuilding.buildingId === buildingId) 
					{
						find = true;
						resultNode = node;
						return resultNode;
					}
				}
				i++;
			}
		}	
	}
	else 
	{
		for (var i=0; i<this.subTiles.length; i++)
		{
			resultNode = this.subTiles[i].getNodeByBuildingId(buildingType, buildingId);
			if (resultNode)
			{ return resultNode; }
		}
	}
	
	return resultNode;
};
*/

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.getNeoBuildingById = function(buildingType, buildingId) 
{
	var resultNeoBuilding;
	var node = this.getNodeByBuildingId(buildingType, buildingId);
	if (node !== undefined)
	{ resultNeoBuilding = node.data.neoBuilding; }

	return resultNeoBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.getBuildingSeedById = function(buildingType, buildingId) 
{
	var resultNeoBuildingSeed;
	var hasSubTiles = true;
	if (this.subTiles === undefined)
	{ hasSubTiles = false; }
	
	if (this.subTiles && this.subTiles.length === 0)
	{ hasSubTiles = false; }
		
	if (!hasSubTiles)
	{
		if (this.nodeSeedsArray)
		{
			var buildingCount = this.nodeSeedsArray.length;
			var find = false;
			var i=0;
			var buildingSeed, node;
			while (!find && i<buildingCount) 
			{
				node = this.nodeSeedsArray[i];
				buildingSeed = node.data.buildingSeed;
				if (buildingType)
				{
					if (buildingSeed.buildingId === buildingId && buildingSeed.buildingType === buildingType) 
					{
						find = true;
						resultNeoBuildingSeed = buildingSeed;
						return resultNeoBuildingSeed;
					}
				}
				else 
				{
					if (buildingSeed.buildingId === buildingId) 
					{
						find = true;
						resultNeoBuildingSeed = buildingSeed;
						return resultNeoBuildingSeed;
					}
				}
				i++;
			}
		}	
	}
	else 
	{
		for (var i=0; i<this.subTiles.length; i++)
		{
			resultNeoBuildingSeed = this.subTiles[i].getBuildingSeedById(buildingType, buildingId);
			if (resultNeoBuildingSeed)
			{ return resultNeoBuildingSeed; }
		}
	}
	
	return resultNeoBuildingSeed;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.TEST__hasLowestTiles_nodesArray = function() 
{
	
	var lowestTilesArray = [];
	this.extractLowestTiles(lowestTilesArray);
	var subTilesCount = lowestTilesArray.length;
	var find = false;
	var i=0;
	while (!find && i<subTilesCount)
	{
		if (lowestTilesArray[i].nodesArray && lowestTilesArray[i].nodesArray.length > 0)
		{
			return true;
		}
		i++;
	}
	
	return find;
	
};


/**
 * 타일의 min max coord를 이용하여 타원체를 생성 후 this.sphereExtent에 할당
 * @param {MagoManager} magoManager
 * 
 * @see SmartTile#computeSphereExtent
 */
SmartTile.prototype.makeSphereExtent = function(magoManager) 
{
	this.sphereExtent = SmartTile.computeSphereExtent(magoManager, this.minGeographicCoord, this.maxGeographicCoord, this.sphereExtent);
};

/**
 * Sphere에 반지름과 중심점을 담아서 반환.
 * @static
 * @param {MagoManager} magoManager
 * @param {GeographicCoord} minGeographicCoord
 * @param {GeographicCoord} maxGeographicCoord
 * @param {Sphere} resultSphereExtent
 * 
 * @returns {Sphere} resultSphereExtent
 */
SmartTile.computeSphereExtent = function(magoManager, minGeographicCoord, maxGeographicCoord, resultSphereExtent) 
{
	if (minGeographicCoord === undefined || maxGeographicCoord === undefined)
	{ return undefined; }
	
	if (resultSphereExtent === undefined)
	{ resultSphereExtent = new Sphere(); }
	
	// calculate worldCoord center position.
	var midLongitude = (maxGeographicCoord.longitude + minGeographicCoord.longitude)/2;
	var midLatitude = (maxGeographicCoord.latitude + minGeographicCoord.latitude)/2;
	var midAltitude = (maxGeographicCoord.altitude + minGeographicCoord.altitude)/2;
	
	resultSphereExtent.centerPoint = ManagerUtils.geographicCoordToWorldPoint(midLongitude, midLatitude, midAltitude, resultSphereExtent.centerPoint, magoManager);
	
	// calculate an aproximate radius.
	var cornerPoint;
	cornerPoint = ManagerUtils.geographicCoordToWorldPoint(minGeographicCoord.longitude, minGeographicCoord.latitude, minGeographicCoord.altitude, cornerPoint, magoManager);

	resultSphereExtent.r = resultSphereExtent.centerPoint.distTo(cornerPoint.x, cornerPoint.y, cornerPoint.z) * 1.1;
	return resultSphereExtent;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.putNode = function(targetDepth, node, magoManager) 
{
	if (this.sphereExtent === undefined)
	{ this.makeSphereExtent(magoManager); }
	
	// now, if the current depth < targetDepth, then descend.
	if (this.depth < targetDepth)
	{
		// create 4 child smartTiles.
		if (this.subTiles === undefined || this.subTiles.length === 0)
		{
			for (var i=0; i<4; i++)
			{ this.newSubTile(this); }
		}
		
		// set the sizes to subTiles (The minLongitude, MaxLongitude, etc. is constant, but the minAlt & maxAlt can will be modified every time that insert new buildingSeeds).
		this.setSizesToSubTiles();

		// intercept buildingSeeds for each subTiles.
		var subSmartTile;
		var finish = false;
		var i=0;
		while (!finish && i<4)
		{
			subSmartTile = this.subTiles[i];
			if (subSmartTile.intersectsNode(node))
			{
				subSmartTile.putNode(targetDepth, node, magoManager);
				finish = true;
			}
			
			i++;
		}
	}
	else if (this.depth === targetDepth)
	{
		if (this.nodeSeedsArray === undefined)
		{ this.nodeSeedsArray = []; }
		
		if (this.nodesArray === undefined)
		{ this.nodesArray = []; }
		
		node.data.smartTileOwner = this;
		
		this.nodeSeedsArray.push(node);
		this.nodesArray.push(node);
		
		// todo: Must recalculate the smartTile sphereExtent.
		//this.makeSphereExtent(magoManager);
		
		
		return true;
	}
};

/**
 * 목표레벨까지 각 타일의 SUB타일 생성 및 노드의 위치와 교점이 있는지 파악 후 노드를 보관.
 * @param {Number} targetDepth
 * @param {MagoManager} magoManager
 */
SmartTile.prototype.makeTreeByDepth = function(targetDepth, magoManager) 
{
	if (this.nodeSeedsArray === undefined || this.nodeSeedsArray.length === 0)
	{ return; }

	this.targetDepth = targetDepth;
	
	// if this has "nodeSeedsArray" then make sphereExtent.
	this.makeSphereExtent(magoManager);
	
	// now, if the current depth < targetDepth, then descend.
	if (this.depth < targetDepth)
	{
		// create 4 child smartTiles.
		if (this.subTiles === undefined || this.subTiles.length === 0)
		{
			for (var i=0; i<4; i++)
			{ this.newSubTile(this); }
		}
		
		// set the sizes to subTiles (The minLongitude, MaxLongitude, etc. is constant, but the minAlt & maxAlt can will be modified every time that insert new buildingSeeds).
		this.setSizesToSubTiles();

		// intercept buildingSeeds for each subTiles.
		for (var i=0; i<4; i++)
		{
			this.subTiles[i].takeIntersectedBuildingSeeds(this.nodeSeedsArray, magoManager);
		}
		
		// for each subTile that has intercepted buildingSeeds -> makeTree.
		for (var i=0; i<4; i++)
		{
			this.subTiles[i].makeTreeByDepth(targetDepth, magoManager);
		}
		
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
/*
SmartTile.prototype.getLowestTileWithNodeInside = function(node) 
{
	// this function returns the lowestTile with "node" if exist.
	if (this.subTiles === undefined)
	{
		var nodesCount = this.nodesArray.length;
		var i=0;
		while (i<nodesCount)
		{
			if (node == this.nodesArray[i])
			{
				return this;
			}
			i++;
		}
		return undefined;
	}
	else 
	{	
		var subTilesCount = this.subTiles.length;
		var lowestTile;
		for (var i=0; i<subTilesCount; i++)
		{
			lowestTile = this.subTiles[i].getLowestTileWithNodeInside(node);
			if (lowestTile)
			{ return lowestTile; }
		}
		
		return undefined;
	}
};
*/

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.intersectsNode = function(node) 
{
	var intersects = false;
	var buildingSeed = node.data.buildingSeed;
	var rootNode = node.getRoot();
	
	// Find geographicCoords as is possible.
	var longitude, latitude;
	
	if (rootNode.data.bbox !== undefined && rootNode.data.bbox.geographicCoord !== undefined)
	{
		longitude = rootNode.data.bbox.geographicCoord.longitude;
		latitude = rootNode.data.bbox.geographicCoord.latitude;
	}
	else if (buildingSeed !== undefined)
	{
		// in this case take the data from buildingSeed.
		longitude = buildingSeed.geographicCoordOfBBox.longitude;
		latitude = buildingSeed.geographicCoordOfBBox.latitude;
	}
	else
	{
		longitude = node.data.geographicCoord.longitude;
		latitude = node.data.geographicCoord.latitude;
	}
	
	if (this.intersectPoint(longitude, latitude))
	{
		intersects = true;
	}
	
	return intersects;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.takeIntersectedBuildingSeeds = function(nodeSeedsArray) 
{
	// this function intersects the buildingSeeds with this tile.
	// this function is used only one time when load a initial buildings distributions on the globe.
	var buildingSeed;
	var node, rootNode;
	var buildingSeedsCount = nodeSeedsArray.length;
	for (var i=0; i<buildingSeedsCount; i++)
	{
		node = nodeSeedsArray[i];
		if (this.intersectsNode(node))
		{
			nodeSeedsArray.splice(i, 1);
			i--;
			buildingSeedsCount = nodeSeedsArray.length;
			
			if (this.nodeSeedsArray === undefined)
			{ this.nodeSeedsArray = []; }
		
			// Set the smartTileOwner, for fast move of the node between smartTiles.
			node.data.smartTileOwner = this;
			
			this.nodeSeedsArray.push(node);
			
			// now, redefine the altitude limits of this tile.
			var buildingSeed = node.data.buildingSeed;
			var altitude = buildingSeed.geographicCoordOfBBox.altitude;
			var bboxRadius = buildingSeed.bBox.getRadiusAprox();
			if (altitude-bboxRadius < this.minGeographicCoord.altitude)
			{
				this.minGeographicCoord.altitude = altitude-bboxRadius;
			}
			if (altitude+bboxRadius > this.maxGeographicCoord.altitude)
			{
				this.maxGeographicCoord.altitude = altitude+bboxRadius;
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
/*
SmartTile.prototype.calculateAltitudeLimits = function() 
{
	// this function calculates the minAltitude and maxAltitude of the tile.
	// init the altitudes.
	this.minGeographicCoord.altitude = 0;
	this.maxGeographicCoord.altitude = 0;
	
	var buildingSeed;
	var buildingSeedsCount = this.buildingSeedsArray.length;
	for (var i=0; i<buildingSeedsCount; i++)
	{
		buildingSeed = this.buildingSeedsArray[i];

		var altitude = buildingSeed.geographicCoordOfBBox.altitude;
		var bboxRadius = buildingSeed.bBox.getRadiusAprox();
		if (altitude-bboxRadius < this.minGeographicCoord.altitude)
		{
			this.minGeographicCoord.altitude = altitude-bboxRadius;
		}
		if (altitude+bboxRadius > this.maxGeographicCoord.altitude)
		{
			this.maxGeographicCoord.altitude = altitude+bboxRadius;
		}
	}
};
*/

/**
 * 어떤 일을 하고 있습니까?
 * @param geographicCoord 변수
 */
SmartTile.prototype.intersectPoint = function(longitude, latitude) 
{
	if (longitude < this.minGeographicCoord.longitude || longitude > this.maxGeographicCoord.longitude)
	{ return false; }
	
	if (latitude < this.minGeographicCoord.latitude || latitude > this.maxGeographicCoord.latitude)
	{ return false; }
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.prototype.eraseNode = function(node) 
{
	//this.nodeSeedsArray;
	//this.nodesArray;
	
	// Erase from this.nodeSeedsArray & this.nodesArray.
	if (this.nodeSeedsArray !== undefined)
	{
		var nodeSeedsCount = this.nodeSeedsArray.length;
		var finished = false;
		var i = 0;
		while (!finished && i<nodeSeedsCount)
		{
			if (this.nodeSeedsArray[i] === node)
			{
				this.nodeSeedsArray.splice(i, 1);
				finished = true;
			}
			i++;
		}
	}
	
	if (this.nodesArray !== undefined)
	{
		var nodesCount = this.nodesArray.length;
		finished = false;
		i = 0;
		while (!finished && i<nodesCount)
		{
			if (this.nodesArray[i] === node)
			{
				this.nodesArray.splice(i, 1);
				finished = true;
			}
			i++;
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.prototype.extractLowestTiles = function(resultLowestTilesArray) 
{
	if (this.subTiles === undefined)
	{
		if (this.nodeSeedsArray && this.nodeSeedsArray.length > 0)
		{
			resultLowestTilesArray.push(this);
		}
		return;
	}
		
	var subTilesCount = this.subTiles.length;
	for (var i=0; i<subTilesCount; i++)
	{
		this.subTiles[i].extractLowestTiles(resultLowestTilesArray);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.prototype.getFrustumIntersectedLowestTiles = function(frustum, resultFullyIntersectedTilesArray, resultPartiallyIntersectedTilesArray) 
{
	var fullyIntersectedTiles = [];
	this.getFrustumIntersectedTiles(frustum, fullyIntersectedTiles, resultPartiallyIntersectedTilesArray);
	
	var intersectedTilesCount = fullyIntersectedTiles.length;
	for (var i=0; i<intersectedTilesCount; i++)
	{
		fullyIntersectedTiles[i].extractLowestTiles(resultFullyIntersectedTilesArray);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.prototype.getFrustumIntersectedTiles = function(frustum, resultFullyIntersectedTilesArray, resultPartiallyIntersectedTilesArray) 
{
	if (this.sphereExtent === undefined)
	{ return Constant.INTERSECTION_OUTSIDE; }
	
	var intersectionType = frustum.intersectionSphere(this.sphereExtent);
	
	if (intersectionType === Constant.INTERSECTION_OUTSIDE)
	{ return; }
	else if (intersectionType === Constant.INTERSECTION_INSIDE)
	{
		resultFullyIntersectedTilesArray.push(this);
		return;
	}
	else if (intersectionType === Constant.INTERSECTION_INTERSECT)
	{
		if (this.subTiles && this.subTiles.length > 0)
		{
			for (var i=0; i<this.subTiles.length; i++)
			{
				if (this.subTiles[i].sphereExtent)
				{ this.subTiles[i].getFrustumIntersectedTiles(frustum, resultFullyIntersectedTilesArray, resultPartiallyIntersectedTilesArray); }
			}
		}
		else
		{ 
			if (this.nodeSeedsArray &&  this.nodeSeedsArray.length > 0)
			{ resultPartiallyIntersectedTilesArray.push(this); } 
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.selectTileAngleRangeByDepth = function(depth) 
{
	if (depth === undefined || depth < 0 || depth > 15)
	{ return undefined; }
	
	if (depth === 0)
	{ return 180; }
	if (depth === 1)
	{ return 90; }
	if (depth === 2)
	{ return 45; }
	if (depth === 3)
	{ return 22.5; }
	if (depth === 4)
	{ return 11.25; }
	if (depth === 5)
	{ return 5.625; }
	if (depth === 6)
	{ return 2.8125; }
	if (depth === 7)
	{ return 1.40625; }
	if (depth === 8)
	{ return 0.703125; }
	if (depth === 9)
	{ return 0.3515625; }
	if (depth === 10)
	{ return 0.17578125; }
	if (depth === 11)
	{ return 0.087890625; }
	if (depth === 12)
	{ return 0.043945313; }
	if (depth === 13)
	{ return 0.021972656; }
	if (depth === 14)
	{ return 0.010986328; }
	if (depth === 15)
	{ return 0.010986328/2.0; }
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.selectTileName = function(depth, longitude, latitude, resultTileName) 
{
	var xMin = -180.0;
	var yMin = 90.0;
	var angRange = SmartTile.selectTileAngleRangeByDepth(depth) ;
	
	var xIndex = Math.floor((longitude - xMin)/angRange);
	// with yMin = -90.0;
	//var yIndex = Math.floor((latitude - yMin)/angRange);
	var yIndex = Math.floor((yMin - latitude)/angRange);
	resultTileName = depth.toString() + "\\" + xIndex.toString() + "\\" + yIndex.toString();
	return resultTileName;
};


/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
 
SmartTile.getFrustumIntersectedTilesNames = function(frustum, maxDepth, camPos, magoManager, resultFullyIntersectedTilesNamesMap) 
{
	var currMinGeographicCoords = new GeographicCoord();
	var currMaxGeographicCoords = new GeographicCoord();
	var currDepth = 0;
	
	// America side.
	currMinGeographicCoords.setLonLatAlt(-180, -90, 0);
	currMaxGeographicCoords.setLonLatAlt(0, 90, 0);
	currDepth = 0;
	SmartTile.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, magoManager.boundingSphere_Aux, 
		resultFullyIntersectedTilesNamesMap);
	
	// Asia side.
	currMinGeographicCoords.setLonLatAlt(0, -90, 0);
	currMaxGeographicCoords.setLonLatAlt(180, 90, 0);
	currDepth = 0;
	SmartTile.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, magoManager.boundingSphere_Aux, 
		resultFullyIntersectedTilesNamesMap);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
 
SmartTile.getFrustumIntersectedTilesNamesForGeographicExtent = function(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap) 
{
	// STATIC FUNCTION.
	// 1rst, make a sphereExtent.
	
	sphereExtentAux = SmartTile.computeSphereExtent(magoManager, currMinGeographicCoords, currMaxGeographicCoords, sphereExtentAux);

	var intersectionType = frustum.intersectionSphere(sphereExtentAux);
	
	if (intersectionType === Constant.INTERSECTION_OUTSIDE)
	{ return; }
	else if (intersectionType === Constant.INTERSECTION_INSIDE)
	{
		var midLon = (currMinGeographicCoords.longitude + currMaxGeographicCoords.longitude)/2;
		var midLat = (currMinGeographicCoords.latitude + currMaxGeographicCoords.latitude)/2;
		var tileName = SmartTile.selectTileName(currDepth, midLon, midLat, undefined);
		var geographicExtent = new GeographicExtent();
		geographicExtent.minGeographicCoord = new GeographicCoord(currMinGeographicCoords.longitude, currMinGeographicCoords.latitude, currMinGeographicCoords.altitude);
		geographicExtent.maxGeographicCoord = new GeographicCoord(currMaxGeographicCoords.longitude, currMaxGeographicCoords.latitude, currMaxGeographicCoords.altitude);
		resultFullyIntersectedTilesNamesMap[tileName] = geographicExtent;
		return;
	}
	else if (intersectionType === Constant.INTERSECTION_INTERSECT)
	{
		// check distance to camera.
		var distToCam = camPos.distToSphere(sphereExtentAux);
		if (distToCam > 2000)
		{
			var midLon = (currMinGeographicCoords.longitude + currMaxGeographicCoords.longitude)/2;
			var midLat = (currMinGeographicCoords.latitude + currMaxGeographicCoords.latitude)/2;
			var tileName = SmartTile.selectTileName(currDepth, midLon, midLat, undefined);
			var geographicExtent = new GeographicExtent();
			geographicExtent.minGeographicCoord = new GeographicCoord(currMinGeographicCoords.longitude, currMinGeographicCoords.latitude, currMinGeographicCoords.altitude);
			geographicExtent.maxGeographicCoord = new GeographicCoord(currMaxGeographicCoords.longitude, currMaxGeographicCoords.latitude, currMaxGeographicCoords.altitude);
			resultFullyIntersectedTilesNamesMap[tileName] = geographicExtent;
			return;
		}
		
		if (currDepth < maxDepth)
		{
			// must descend.
			currDepth += 1;
			var minLon = currMinGeographicCoords.longitude;
			var minLat = currMinGeographicCoords.latitude;
			var minAlt = currMinGeographicCoords.altitude;
			var maxLon = currMaxGeographicCoords.longitude;
			var maxLat = currMaxGeographicCoords.latitude;
			var maxAlt = currMaxGeographicCoords.altitude;
			var midLon = (minLon + maxLon)/ 2;
			var midLat = (minLat + maxLat)/ 2;
			
			// subTile 1.
			currMaxGeographicCoords.setLonLatAlt(midLon, midLat, maxAlt);
			this.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap);
			
			// subTile 2.
			currMinGeographicCoords.setLonLatAlt(midLon, minLat, minAlt);
			currMaxGeographicCoords.setLonLatAlt(maxLon, midLat, maxAlt);
			this.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap);
			
			// subTile 3.
			currMinGeographicCoords.setLonLatAlt(midLon, midLat, minAlt);
			currMaxGeographicCoords.setLonLatAlt(maxLon, maxLat, maxAlt);
			this.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap);
			
			// subTile 4.
			currMinGeographicCoords.setLonLatAlt(minLon, midLat, minAlt);
			currMaxGeographicCoords.setLonLatAlt(midLon, maxLat, maxAlt);
			this.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap);
			
		}
		else 
		{
			var midLon = (currMinGeographicCoords.longitude + currMaxGeographicCoords.longitude)/2;
			var midLat = (currMinGeographicCoords.latitude + currMaxGeographicCoords.latitude)/2;
			var tileName = SmartTile.selectTileName(currDepth, midLon, midLat, undefined);
			var geographicExtent = new GeographicExtent();
			geographicExtent.minGeographicCoord = new GeographicCoord(currMinGeographicCoords.longitude, currMinGeographicCoords.latitude, currMinGeographicCoords.altitude);
			geographicExtent.maxGeographicCoord = new GeographicCoord(currMaxGeographicCoords.longitude, currMaxGeographicCoords.latitude, currMaxGeographicCoords.altitude);
			resultFullyIntersectedTilesNamesMap[tileName] = geographicExtent;
			return;
		}
	}
	
};


/**
 * 어떤 일을 하고 있습니까?
 * Extent(범위)
 * @param frustum 변수
 */
SmartTile.prototype.getSphereExtent = function() 
{
	return this.sphereExtent;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.setSize = function(minLon, minLat, minAlt, maxLon, maxLat, maxAlt) 
{
	if (this.minGeographicCoord === undefined)
	{ this.minGeographicCoord = new GeographicCoord(); }
	if (this.maxGeographicCoord === undefined)	
	{ this.maxGeographicCoord = new GeographicCoord(); }
		
	this.minGeographicCoord.setLonLatAlt(minLon, minLat, minAlt);	
	this.maxGeographicCoord.setLonLatAlt(maxLon, maxLat, maxAlt);	
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.setSizesToSubTiles = function() 
{
	//       +-----+-----+
	//       |  3  |  2  |
	//       +-----+-----+
	//       |  0  |  1  |
	//       +-----+-----+
	
	var minLon = this.minGeographicCoord.longitude;
	var maxLon = this.maxGeographicCoord.longitude;
	var minLat = this.minGeographicCoord.latitude;
	var maxLat = this.maxGeographicCoord.latitude;
	var minAlt = this.minGeographicCoord.altitude;
	var maxAlt = this.maxGeographicCoord.altitude;
	
	var midLon = (maxLon + minLon)/2;
	var midLat = (maxLat + minLat)/2;
	
	var subTile = this.subTiles[0];
	subTile.setSize(minLon, minLat, minAlt,     midLon, midLat, maxAlt);
	
	subTile = this.subTiles[1];
	subTile.setSize(midLon, minLat, minAlt,     maxLon, midLat, maxAlt);
	
	subTile = this.subTiles[2];
	subTile.setSize(midLon, midLat, minAlt,     maxLon, maxLat, maxAlt);
	
	subTile = this.subTiles[3];
	subTile.setSize(minLon, midLat, minAlt,     midLon, maxLat, maxAlt);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.getLongitudeRangeDegree = function() 
{
	return this.maxGeographicCoord.longitude - this.minGeographicCoord.longitude;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.getLatitudeRangeDegree = function() 
{
	return this.maxGeographicCoord.latitude - this.minGeographicCoord.latitude;
};
'use strict';

/**
 * 4분할 타일링 수행 및 타일 객체 보관 객체
 * 인스턴스 생성 시 mother tile 생성
 * @class SmartTileManager
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * @see SmartTile
 */
var SmartTileManager = function() 
{
	if (!(this instanceof SmartTileManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
    
	/**
     * 타일 배열
     * has 2 tiles (Asia side and America side).
     * @type {Array.<SmartTile>}
     */
	this.tilesArray = []; 
    
	/**
     * mother 타일 생성
     */
	this.createMainTiles();
};

/**
 * 아메리카쪽 아시아쪽으로 구분하여 두개의 mother 타일 생성
 */
SmartTileManager.prototype.createMainTiles = function() 
{
	// tile 1 : longitude {-180, 0}, latitude {-90, 90}
	// tile 2 : longitude {0, 180},  latitude {-90, 90}
	
	// America side.
	var tile1 = this.newSmartTile("AmericaSide");
	if (tile1.minGeographicCoord === undefined)
	{ tile1.minGeographicCoord = new GeographicCoord(); }
	if (tile1.maxGeographicCoord === undefined)
	{ tile1.maxGeographicCoord = new GeographicCoord(); }
	
	tile1.depth = 0; // mother tile.
	tile1.minGeographicCoord.setLonLatAlt(-180, -90, 0);
	tile1.maxGeographicCoord.setLonLatAlt(0, 90, 0);
	
	// Asia side.
	var tile2 = this.newSmartTile("AsiaSide");
	if (tile2.minGeographicCoord === undefined)
	{ tile2.minGeographicCoord = new GeographicCoord(); }
	if (tile2.maxGeographicCoord === undefined)
	{ tile2.maxGeographicCoord = new GeographicCoord(); }
	
	tile2.depth = 0; // mother tile.
	tile2.minGeographicCoord.setLonLatAlt(0, -90, 0);
	tile2.maxGeographicCoord.setLonLatAlt(180, 90, 0);
};

/**
 * f4d들의 object index 파일을 읽고 생성한 물리적인 노드들을 타일에 배치.
 * @param {Number} targetDepth 없을 시 17, 일반적으로 17레벨까지 생성.
 * @param {Array.<Node>} physicalNodesArray geometry정보가 있는 화면에 표출할 수 있는 Node 배열
 * @param {MagoManager} magoManager 마고매니저.
 * 
 * @see Node
 */
SmartTileManager.prototype.makeTreeByDepth = function(targetDepth, physicalNodesArray, magoManager) 
{
	if (targetDepth === undefined)
	{ targetDepth = 17; }
	
	this.targetDepth = targetDepth;
	
	var smartTilesCount = this.tilesArray.length; // In this point, "smartTilesCount" = 2 always.
	for (var a=0; a<smartTilesCount; a++)
	{
		var smartTile = this.tilesArray[a];
		if (smartTile.nodeSeedsArray === undefined)
		{ smartTile.nodeSeedsArray = []; }
		
		smartTile.nodeSeedsArray = physicalNodesArray;
		smartTile.makeTreeByDepth(targetDepth, magoManager); // default depth = 17.
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTileManager.prototype.putNode = function(targetDepth, node, magoManager) 
{
	targetDepth = defaultValue(targetDepth, 17);
	if (this.tilesArray !== undefined)
	{
		var tilesCount = this.tilesArray.length; // allways tilesCount = 2. (Asia & America sides).
		for (var i=0; i<tilesCount; i++)
		{
			this.tilesArray[i].putNode(targetDepth, node, magoManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
SmartTileManager.prototype.deleteTiles = function() 
{
	// this function deletes all children tiles.
	if (this.tilesArray)
	{
		var tilesCount = this.tilesArray.length; // allways tilesCount = 2. (Asia & America sides).
		for (var i=0; i<tilesCount; i++)
		{
			this.tilesArray[i].deleteObjects();
			this.tilesArray[i] = undefined;
		}
		this.tilesArray.length = 0;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
SmartTileManager.prototype.resetTiles = function() 
{
	this.deleteTiles();
	
	// now create the main tiles.
	this.createMainTiles();
};

/**
 * 새로운 스마트타일을 생성하여 tilesArray에 넣고 반환.
 * @param {String} smartTileName tile name\
 * @returns {SmartTile}
 */
SmartTileManager.prototype.newSmartTile = function(smartTileName) 
{
	if (this.tilesArray === undefined)
	{ this.tilesArray = []; }
	
	var smartTile = new SmartTile(smartTileName);
	this.tilesArray.push(smartTile);
	return smartTile;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTileManager.prototype.getNeoBuildingById = function(buildingType, buildingId) 
{
	var resultNeoBuilding;
	var i = 0;
	var smartTilesCount = this.tilesArray.length;
	while (resultNeoBuilding === undefined && i<smartTilesCount)
	{
		resultNeoBuilding = this.tilesArray[i].getNeoBuildingById(buildingType, buildingId); 
		i++;
	}
	
	return resultNeoBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTileManager.prototype.getBuildingSeedById = function(buildingType, buildingId) 
{
	var resultNeoBuilding;
	var i = 0;
	var smartTilesCount = this.tilesArray.length;
	while (resultNeoBuilding === undefined && i<smartTilesCount)
	{
		resultNeoBuilding = this.tilesArray[i].getBuildingSeedById(buildingType, buildingId);
		i++;
	}
	
	return resultNeoBuilding;
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Sphere
 */
var Sphere = function() 
{
	if (!(this instanceof Sphere)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.r = 0.0;
	this.centerPoint = new Point3D();
	
	this.vboKeyContainer; // class: VBOVertexIdxCacheKeyContainer.
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Sphere.prototype.setCenterPoint = function(x, y, z) 
{
	this.centerPoint.set(x, y, z);
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Sphere.prototype.setRadius = function(radius) 
{
	this.r = radius;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Sphere.prototype.deleteObjects = function() 
{
	this.r = undefined;
	this.centerPoint.deleteObjects();
	this.centerPoint = undefined;
};

/**
 */
Sphere.prototype.getVbo = function(resultVboContainer, bTexCoords)
{
	if (resultVboContainer === undefined)
	{ resultVboContainer = new VBOVertexIdxCacheKeysContainer(); }

	var pMesh;

	// make vbo.
	pMesh = this.makePMesh(pMesh);
	var bIncludeBottomCap = false;
	var bIncludeTopCap = false;
	
	var surfIndepMesh = pMesh.getSurfaceIndependentMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	
	// now rotate in X axis.
	var rotMatAux = new Matrix4();
	rotMatAux.rotationAxisAngDeg(90.0, 1.0, 0.0, 0.0);
	surfIndepMesh.transformByMatrix4(rotMatAux);
	
	surfIndepMesh.setColor(0.0, 0.5, 0.9, 0.3);
	surfIndepMesh.calculateVerticesNormals();
	if (bTexCoords !== undefined && bTexCoords === true)
	{
		// calculate spherical texCoords.
		surfIndepMesh.calculateTexCoordsSpherical();
	}
	surfIndepMesh.getVbo(resultVboContainer);

	return resultVboContainer;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Sphere.prototype.makePMesh = function(resultPMesh) 
{
	if (resultPMesh === undefined)
	{ resultPMesh = new ParametricMesh(); }

	resultPMesh.profile = new Profile(); 
	var profileAux = resultPMesh.profile; 
	
	// Outer ring.**
	var outerRing = profileAux.newOuterRing();
	var polyLine, point3d, arc;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-this.r*0.01, -this.r); // 0
	point3d = polyLine.newPoint2d(-this.r*0.01, this.r); // 1
	
	var startAngDeg = 95.00;
	var endAngDeg = 265.00;
	arc = outerRing.newElement("ARC");
	this.sweepSense = 1;
	arc.setCenterPosition(0.0, 0.0);
	arc.setRadius(this.r);
	arc.setStartAngleDegree(startAngDeg);
	arc.setSweepAngleDegree(endAngDeg - startAngDeg);
	arc.numPointsFor360Deg = 48;
	
	// now revolve.
	var revolveAngDeg, revolveSegmentsCount, revolveSegment2d;
	revolveAngDeg = 360;
	revolveSegment2d = new Segment2D();
	var strPoint2d = new Point2D(0, -1);
	var endPoint2d = new Point2D(0, 1);
	revolveSegment2d.setPoints(strPoint2d, endPoint2d);
	revolveSegmentsCount = 48;
	resultPMesh.revolve(profileAux, revolveAngDeg, revolveSegmentsCount, revolveSegment2d);
	/*
	var extrusionVector
	var extrudeSegmentsCount = 2;
	var extrusionDist = 15.0;
		resultPMesh.extrude(profileAux, extrusionDist, extrudeSegmentsCount, extrusionVector);
	*/
	
	return resultPMesh;
};











































'use strict';

/**
 * ??
 * @class SceneState
 */

var SplitValue = function()
{
	this.high = undefined;
	this.low = undefined;
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class TerranTile
 */
var TerranTile = function() 
{
	if (!(this instanceof TerranTile)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	//           +-----+-----+
	//           |  3  |  2  |
	//           +-----+-----+
	//           |  0  |  1  |
	//           +-----+-----+

	this._depth = 0; // qudtree depth. 0 => mother_quadtree.
	this._numberName = 1; // mother quadtree.
	this._terranTile_owner;
	//------------------------------------------------------------
	this.projectsArray = [];
	
	this._BR_buildingsArray = []; // Old.
	this._boundingBox; // dont use this.
	this._pCloudMesh_array = []; // 1rst aproximation to the pointCloud data. Test.

	this.position; // absolute position, for do frustum culling.
	this.radius; // aprox radius for this tile.

	this.leftDown_position;
	this.rightDown_position;
	this.rightUp_position;
	this.leftUp_position;
	this.visibilityType;

	this.subTiles_array = [];
	this.terranIndexFile_readed = false;
	this.empty_tile = false;

	// File.
	this.fileReading_started = false;
	this.fileReading_finished = false;
	this.fileArrayBuffer;
	this.fileBytesReaded = 0;
	this.fileParsingFinished = false;
	this.projectsParsed_count = 0;

	this.current_BRProject_parsing;
	this.current_BRProject_parsing_state = 0;

	this.readWriter;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns br_buildingProject
 */
TerranTile.prototype.newBRProject = function() 
{
	// Old. Old. Old. Old. Old. Old. Old. Old.
	// dont use this. delete this.
	var br_buildingProject = new BRBuildingProject();
	this._BR_buildingsArray.push(br_buildingProject);
	return br_buildingProject;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns subTile
 */
TerranTile.prototype.newSubTerranTile = function() 
{
	var subTiles_count = this.subTiles_array.length;
	var subTile = new TerranTile();
	subTile._depth = this._depth + 1;
	subTile._numberName = this._numberName*10 + subTiles_count + 1;
	this.subTiles_array.push(subTile);
	return subTile;
};

/**
 * 어떤 일을 하고 있습니까?
 */
TerranTile.prototype.make4subTiles = function() 
{
	for (var i = 0; i < 4; i++) 
	{
		this.newSubTerranTile();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param lonMin 변수
 * @param lonMax 변수
 * @param latMin 변수
 * @param latMax 변수
 */
TerranTile.prototype.setDimensions = function(lonMin, lonMax, latMin, latMax) 
{
	this.longitudeMin = lonMin;
	this.longitudeMax = lonMax;
	this.latitudeMin = latMin;
	this.latitudeMax = latMax;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param maxDepth 변수
 */
TerranTile.prototype.makeTree = function(maxDepth) 
{
	if (this._depth < maxDepth)
	{
		var subTileAux;
		for (var i = 0; i < 4; i++)
		{
			subTileAux = this.newSubTerranTile();
			subTileAux.makeTree(maxDepth);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
TerranTile.prototype.calculatePositionByLonLat = function() 
{
	var lon_mid = (this.longitudeMax + this.longitudeMin)/2.0;
	var lat_mid = (this.latitudeMax + this.latitudeMin)/2.0;

	this.position = Cesium.Cartesian3.fromDegrees(lon_mid, lat_mid, 0.0);

	this.leftDown_position = Cesium.Cartesian3.fromDegrees(this.longitudeMin, this.latitudeMin, 0.0);
	this.rightDown_position = Cesium.Cartesian3.fromDegrees(this.longitudeMax, this.latitudeMin, 0.0);
	this.rightUp_position = Cesium.Cartesian3.fromDegrees(this.longitudeMax, this.latitudeMax, 0.0);
	this.leftUp_position = Cesium.Cartesian3.fromDegrees(this.longitudeMin, this.latitudeMax, 0.0);

	this.radius = Cesium.Cartesian3.distance(this.leftDown_position, this.rightUp_position)/2.0 * 0.9;
};

/**
 * 어떤 일을 하고 있습니까?
 */
TerranTile.prototype.calculatePositionByLonLatSubTiles = function() 
{
	this.calculatePositionByLonLat();

	var subTile;
	var subTiles_count = this.subTiles_array.length; // subTiles_count must be 4.

	for (var i=0; i<subTiles_count; i++)
	{
		this.subTiles_array[i].calculatePositionByLonLatSubTiles();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param BR_Project 변수
 */
TerranTile.prototype.parseFileHeader = function(BR_Project) 
{
	var fileLegth = this.fileArrayBuffer.byteLength;
	if (this.fileBytesReaded >= fileLegth)
	{ return; }

	var version_string_length = 5;
	var intAux_scratch = 0;
	//var auxScratch;
	var header = BR_Project._header;
	var arrayBuffer = this.fileArrayBuffer;
	var bytes_readed = this.fileBytesReaded;

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	// 1) Version(5 chars).**
	for (var j=0; j<version_string_length; j++)
	{
		header._version += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1;
	}

	header._f4d_version = 2;

	// 3) Global unique ID.
	intAux_scratch = this.readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	for (var j=0; j<intAux_scratch; j++)
	{
		header._global_unique_id += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1;
	}

	// 4) Location.*
	header._longitude = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
	header._latitude = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
	header._elevation = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;

	//header._elevation += 70.0; // delete this. TEST.!!!

	// 6) BoundingBox.
	header._boundingBox.minX = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.minY = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.minZ = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.maxX = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.maxY = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.maxZ = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;

	var semiHeight = (header._boundingBox.maxZ - header._boundingBox.minZ )/2.0;
	header._elevation = 45.0 + semiHeight-0.5;

	var isLarge = false;
	if (header._boundingBox.maxX - header._boundingBox.minX > 40.0 || header._boundingBox.maxY - header._boundingBox.minY > 40.0)
	{
		isLarge = true;
	}

	if (!isLarge && header._boundingBox.maxZ - header._boundingBox.minZ < 30.0)
	{
		header.isSmall = true;
	}

	var imageLODs_count = this.readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

	// Now, must calculate some params of the project.*
	// 0) PositionMatrix.
	// Determine the elevation of the position.**
	var position = Cesium.Cartesian3.fromDegrees(header._longitude, header._latitude, header._elevation);
	var cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
	var height = cartographic.height;
	// End Determine the elevation of the position.-------------------------------------------------------

	//var position = Cesium.Cartesian3.fromDegrees(header._longitude, header._latitude, header._elevation);  // Original.
	position = Cesium.Cartesian3.fromDegrees(header._longitude, header._latitude, height);

	BR_Project.buildingPosition = position;

	// High and Low values of the position.*
	var splitValue = Cesium.EncodedCartesian3.encode(position);
	var splitVelue_X  = Cesium.EncodedCartesian3.encode(position.x);
	var splitVelue_Y  = Cesium.EncodedCartesian3.encode(position.y);
	var splitVelue_Z  = Cesium.EncodedCartesian3.encode(position.z);

	BR_Project.buildingPositionHIGH = new Float32Array(3);
	BR_Project.buildingPositionHIGH[0] = splitVelue_X.high;
	BR_Project.buildingPositionHIGH[1] = splitVelue_Y.high;
	BR_Project.buildingPositionHIGH[2] = splitVelue_Z.high;

	BR_Project.buildingPositionLOW = new Float32Array(3);
	BR_Project.buildingPositionLOW[0] = splitVelue_X.low;
	BR_Project.buildingPositionLOW[1] = splitVelue_Y.low;
	BR_Project.buildingPositionLOW[2] = splitVelue_Z.low;

	this.fileBytesReaded = bytes_readed;
};


/**
 * 어떤 일을 하고 있습니까?
 * @param BR_Project 변수
 */
TerranTile.prototype.parseFileSimpleBuilding = function(BR_Project) 
{
	var fileLegth = this.fileArrayBuffer.byteLength;
	if (this.fileBytesReaded >= fileLegth)
	{ return; }

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	var bytes_readed = this.fileBytesReaded;
	var startBuff;
	var endBuff;
	var arrayBuffer = this.fileArrayBuffer;

	if (BR_Project._simpleBuilding_v1 === undefined)
	{ BR_Project._simpleBuilding_v1 = new SimpleBuildingV1(); }

	var simpBuildingV1 = BR_Project._simpleBuilding_v1;
	var vbo_objects_count = this.readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4; // Almost allways is 1.

	// single interleaved buffer mode.
	for (var i=0; i<vbo_objects_count; i++) // Almost allways is 1.
	{
		var simpObj = simpBuildingV1.newSimpleObject();
		var vt_cacheKey = simpObj._vtCacheKeys_container.newVertexTexcoordsArraysCacheKey();

		var iDatas_count = this.readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		startBuff = bytes_readed;
		endBuff = bytes_readed + (4*3+2*2+1*4)*iDatas_count; // fPos_usTex_bNor.*
		vt_cacheKey.verticesArrayBuffer = arrayBuffer.slice(startBuff, endBuff);

		bytes_readed = bytes_readed + (4*3+2*2+1*4)*iDatas_count; // updating data.

		vt_cacheKey._vertices_count = iDatas_count;

	}

	// Finally read the 4byte color.
	var color_4byte_temp = this.readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

	//var b = color_4byte_temp & 0xFF;
	//var g = (color_4byte_temp & 0xFF00) >>> 8;
	//var r = (color_4byte_temp & 0xFF0000) >>> 16;
	//var a = ( (color_4byte_temp & 0xFF000000) >>> 24 ) / 255 ;

	this.fileBytesReaded = bytes_readed;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param BR_Project 변수
 * @param magoManager 변수
 */
TerranTile.prototype.parseFileNailImage = function(BR_Project, magoManager) 
{
	//BR_Project._f4d_nailImage_readed = true;

	if (BR_Project._simpleBuilding_v1 === undefined)
	{ BR_Project._simpleBuilding_v1 = new SimpleBuildingV1(); }

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	var simpBuildingV1 = BR_Project._simpleBuilding_v1;

	// Read the image.*
	var bytes_readed = this.fileBytesReaded;
	var arrayBuffer = this.fileArrayBuffer;

	var nailImageSize = this.readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	var startBuff = bytes_readed;
	var endBuff = bytes_readed + nailImageSize;
	simpBuildingV1.textureArrayBuffer = new Uint8Array(arrayBuffer.slice(startBuff, endBuff));

	bytes_readed += nailImageSize;

	this.fileBytesReaded = bytes_readed;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param magoManager 변수
 */
TerranTile.prototype.parseFileAllBuildings = function(magoManager) 
{
	var fileLegth = this.fileArrayBuffer.byteLength;
	if (this.fileBytesReaded >= fileLegth)
	{
		this.fileParsingFinished = true;
		return;
	}

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	var arrayBuffer = this.fileArrayBuffer;
	var projects_count = this.readWriter.readInt32(arrayBuffer, 0, 4); this.fileBytesReaded += 4;

	if (projects_count === 0)
	{ this.empty_tile = true; }

	for (var i=0; i<projects_count; i++)
	{
		/*
		// 1rst, read the relative rawFile_path.
		var rawFileNamePath_length = this.readWriter.readInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;// only debug test.
		var rawFileNamePath = "";

		for(var j=0; j<rawFileNamePath_length; j++){
			rawFileNamePath += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1;
		}
		*/
		var bytes_readed = this.fileBytesReaded;
		this.fileBytesReaded = bytes_readed;

		this.current_BRProject_parsing = this.newBRProject();
		//this.current_BRProject_parsing._f4d_rawPathName = rawFileNamePath;

		this.parseFileHeader(this.current_BRProject_parsing);
		this.parseFileSimpleBuilding(this.current_BRProject_parsing);
		this.parseFileNailImage(this.current_BRProject_parsing, magoManager);
	}
	this.fileParsingFinished = true;
	this.fileArrayBuffer = null;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param magoManager 변수
 */
TerranTile.prototype.parseFileOneBuilding = function(gl, magoManager) 
{
	var fileLegth = this.fileArrayBuffer.byteLength;
	if (this.fileBytesReaded >= fileLegth)
	{
		this.fileParsingFinished = true;
		return;
	}

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	var projects_count = this.readWriter.readInt32(this.fileArrayBuffer, 0, 4); // only debug test.

	if (this.projectsParsed_count >= projects_count)
	{
		this.fileParsingFinished = true;
		this.fileBytesReaded = null;
		return;
	}

	if (this.current_BRProject_parsing_state === 0)
	{
		if (this.projectsParsed_count === 0)
		{ this.fileBytesReaded = 4; }

		this.current_BRProject_parsing = this.newBRProject();
	}

	var BR_Project = this.current_BRProject_parsing;

	// Read header, simpleBuilding, and the nailImage.
	if (this.current_BRProject_parsing_state === 0) 
	{
		this.parseFileHeader(BR_Project);
		this.current_BRProject_parsing_state=1;
	}
	else if (this.current_BRProject_parsing_state === 1) 
	{
		if (magoManager.backGround_imageReadings_count < 1) 
		{
			this.parseFile_simpleBuilding_old(gl, BR_Project);
			this.current_BRProject_parsing_state=2;
		}
	}
	else if (this.current_BRProject_parsing_state === 2) 
	{
		if (magoManager.backGround_imageReadings_count < 1) 
		{
			this.parseFile_nailImage_old(gl, BR_Project, magoManager);
			this.current_BRProject_parsing_state=0;
			this.projectsParsed_count++;
			magoManager.backGround_imageReadings_count ++;
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
TerranTile.prototype.setDimensionsSubTiles = function() 
{
	var subTile;
	var subTiles_count = this.subTiles_array.length; // subTiles_count must be 4.
	if (subTiles_count === 4) 
	{
		var lon_mid = (this.longitudeMax + this.longitudeMin)/2.0;
		var lat_mid = (this.latitudeMax + this.latitudeMin)/2.0;

		subTile = this.subTiles_array[0];
		subTile.setDimensions(this.longitudeMin, lon_mid, this.latitudeMin, lat_mid);

		subTile = this.subTiles_array[1];
		subTile.setDimensions(lon_mid, this.longitudeMax, this.latitudeMin, lat_mid);

		subTile = this.subTiles_array[2];
		subTile.setDimensions(lon_mid, this.longitudeMax, lat_mid, this.latitudeMax);

		subTile = this.subTiles_array[3];
		subTile.setDimensions(this.longitudeMin, lon_mid, lat_mid, this.latitudeMax);

		for (var i=0; i<subTiles_count; i++) 
		{
			this.subTiles_array[i].setDimensionsSubTiles();
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param smallefstTiles_array 변수
 */
TerranTile.prototype.getSmallestTiles = function(smallestTiles_array) 
{
	// this returns smallestTiles, if the smallestTile has buildingd inside.
	if (this.subTiles_array.length > 0) 
	{
		for (var i=0; i<this.subTiles_array.length; i++) 
		{
			this.subTiles_array[i].visibilityType = this.visibilityType;
			this.subTiles_array[i].getSmallestTiles(smallestTiles_array);
		}
	}
	else 
	{
		if (!this.empty_tile.length) { smallestTiles_array.push(this); }
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustumVolume 변수
 * @param intersectedSmallestTiles_array 변수
 * @param boundingSphere_Aux 변수
 */
TerranTile.prototype.getIntersectedSmallestTiles = function(frustumVolume, intersectedSmallestTiles_array, boundingSphere_Aux) 
{
	var intersectedTiles_array = [];
	this.getIntersectedTiles(frustumVolume, intersectedTiles_array, boundingSphere_Aux);

	var intersectedTiles_count = intersectedTiles_array.length;
	for (var i=0; i<intersectedTiles_count; i++) 
	{
		intersectedTiles_array[i].getSmallestTiles(intersectedSmallestTiles_array);
	}
	intersectedTiles_array.length = 0;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustumVolume 변수
 * @param intersectedTiles_array 변수
 * @param boundingSphere_Aux 변수
 */
TerranTile.prototype.getIntersectedTiles = function(frustumVolume, intersectedTiles_array, boundingSphere_Aux) 
{
	// Cesium dependency.
	if (this.position === undefined) { return; }

	if (boundingSphere_Aux === undefined) { boundingSphere_Aux = new Cesium.BoundingSphere(); }

	//var intersectedPoints_count = 0;
	boundingSphere_Aux.radius = this.radius;
	boundingSphere_Aux.center.x = this.position.x;
	boundingSphere_Aux.center.y = this.position.y;
	boundingSphere_Aux.center.z = this.position.z;
	this.visibilityType = frustumVolume.computeVisibility(boundingSphere_Aux); // old. change for intersectionSphere.
	/*
	boundingSphere_Aux.center = this.leftDown_position;
	if(frustumVolume.computeVisibility(boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE)
		intersectedPoints_count++;

	boundingSphere_Aux.center = this.rightDown_position;
	if(frustumVolume.computeVisibility(boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE)
		intersectedPoints_count++;

	boundingSphere_Aux.center = this.rightUp_position;
	if(frustumVolume.computeVisibility(boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE)
		intersectedPoints_count++;

	boundingSphere_Aux.center = this.leftUp_position;
	if(frustumVolume.computeVisibility(boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE)
		intersectedPoints_count++;
	*/

	if (this.visibilityType === Cesium.Intersect.OUTSIDE) 
	{
		// OUTSIDE.
		// do nothing.
	}
	else if (this.visibilityType === Cesium.Intersect.INSIDE) 
	{
		// INSIDE.
		intersectedTiles_array.push(this);
	}
	else 
	{
		// INTERSECTED.
		if (this.subTiles_array.length > 0) 
		{
			for (var i=0; i<this.subTiles_array.length; i++) 
			{
				this.subTiles_array[i].getIntersectedTiles(frustumVolume, intersectedTiles_array);
			}
		}
		else 
		{
			intersectedTiles_array.push(this);
		}
	}
};

'use strict';


/**
 * 맵 이미지. 머티리얼에는 텍스처에 대한 참조가 포함될 수 있으므로 머티리얼의 셰이더는 객체의 표면색을 계산하는 동안 텍스처를 사용할 수 있습니다.
 * 오브제의 표면의 기본 색상 (알베도) 외에도 텍스쳐는 반사율이나 거칠기와 같은 재질 표면의 많은 다른면을 나타낼 수 있습니다.
 * This class deals the image of the map which will express the texture
 * @class Texture
 */
var Texture = function() 
{
	if (!(this instanceof Texture)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.textureTypeName = "";
	this.textureImageFileName = "";
	this.texId;
	this.fileLoadState = CODE.fileLoadState.READY;
};

/**
 * Delete the texture Id and clear the data of this instance
 * @param gl
 */
Texture.prototype.deleteObjects = function(gl)
{
	this.textureTypeName = undefined;
	this.textureImageFileName = undefined;
	if (this.texId)
	{
		gl.deleteTexture(this.texId);
	}
	this.texId = undefined;
	this.fileLoadState = undefined;
};

/**
 * Create the instance of texture
 * @param gl
 * @param filter the filter of this texture
 * @param data the data of image source
 * @param width the width of the texture image
 * @param height the height of the texture image
 */
Texture.createTexture = function(gl, filter, data, width, height) 
{
	// static function.
	// example of filter: gl.NEAREST
	var texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
	if (data instanceof Uint8Array) 
	{
		//Reference : https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	}
	else 
	{
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);
	}
	gl.bindTexture(gl.TEXTURE_2D, null);
	return texture;
};

'use strict';

/**
 * Manages textures of the Mago3D.
 * @class TexturesManager
 */
var TexturesManager = function(magoManager) 
{
	if (!(this instanceof TexturesManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * Main Mago3D manager.
	 * @type {MagoManager}
	 * @default undefined.
	 */
	this._magoManager = magoManager;
	
	/**
	 * WebGL rendering context.
	 * @type {WebGLRenderingContext}
	 * @default undefined.
	 */
	this._gl = this._magoManager.getGl();

	/**
	 * Auxiliar texture 1x1 pixel.
	 * @type {WebGLTexture}
	 * @default undefined.
	 */
	this._textureAux_1x1;
	
	/**
	 * Noise texture 4x4 pixels used for ssao.
	 * @type {WebGLTexture}
	 * @default undefined.
	 */
	this._noiseTexture_4x4;
};

/**
 * Returns WebGL Rendering Context.
 */
TexturesManager.prototype.getGl = function()
{
	if (this._gl === undefined)
	{
		this._gl = this._magoManager.getGl();
	}
	
	return this._gl;
};


/**
 * Handles the loaded image.
 * 
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {image} image 
 * @param {WebGLTexture} texture 
 * @param {Boolean} flip_y_texCoords //if need vertical mirror of the image
 */
function handleTextureLoaded(gl, image, texture, flip_y_texCoords) 
{
	if (flip_y_texCoords === undefined)
	{ flip_y_texCoords = true; }
	
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flip_y_texCoords); // if need vertical mirror of the image.
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); // Original.
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
	gl.generateMipmap(gl.TEXTURE_2D);
	gl.bindTexture(gl.TEXTURE_2D, null);
};


/**
 * Returns the auxiliar texture 1x1 pixel. If is undefined, then creates it.
 */
TexturesManager.prototype.getTextureAux1x1 = function() 
{
	if (this._textureAux_1x1 === undefined)
	{
		var gl = this.getGl();
		this._textureAux_1x1 = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this._textureAux_1x1);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([150, 150, 150, 255])); // clear grey
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
	
	return this._textureAux_1x1;
};




/**
 * Generates a noise texture.
 * It detects the coner or the area which need to be shaded by the distance to camera
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {Number} w The width of the texture.
 * @param {Number} h The height of the texture.
 * @param {Uint8Array} pixels Optional.
 * @returns {WebGLTexture} texture Returns WebGLTexture.
 */
function genNoiseTextureRGBA(gl, w, h, pixels) 
{
	var texture = gl.createTexture();
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, texture);

	if (pixels === undefined)
	{ pixels = new Uint8Array(4*4*4); }
	
	if (w === 4 && h === 4) 
	{
		var i = 0;
		pixels[i] = 50; i++;
		pixels[i] = 58; i++;
		pixels[i] = 229; i++;
		pixels[i] = 120; i++;
		pixels[i] = 212; i++;
		pixels[i] = 236; i++;
		pixels[i] = 251; i++;
		pixels[i] = 148; i++;
		pixels[i] = 75; i++;
		pixels[i] = 92; i++;
		pixels[i] = 246; i++;
		pixels[i] = 59; i++;
		pixels[i] = 197; i++;
		pixels[i] = 95; i++;
		pixels[i] = 235; i++;
		pixels[i] = 216; i++;
		pixels[i] = 130; i++;
		pixels[i] = 124; i++;
		pixels[i] = 215; i++;
		pixels[i] = 154; i++;
		pixels[i] = 25; i++;
		pixels[i] = 41; i++;
		pixels[i] = 221; i++;
		pixels[i] = 146; i++;
		pixels[i] = 187; i++;
		pixels[i] = 217; i++;
		pixels[i] = 130; i++;
		pixels[i] = 199; i++;
		pixels[i] = 142; i++;
		pixels[i] = 112; i++;
		pixels[i] = 61; i++;
		pixels[i] = 135; i++;
		pixels[i] = 67; i++;
		pixels[i] = 125; i++;
		pixels[i] = 159; i++;
		pixels[i] = 153; i++;
		pixels[i] = 215; i++;
		pixels[i] = 49; i++;
		pixels[i] = 49; i++;
		pixels[i] = 69; i++;
		pixels[i] = 126; i++;
		pixels[i] = 168; i++;
		pixels[i] = 61; i++;
		pixels[i] = 215; i++;
		pixels[i] = 21; i++;
		pixels[i] = 93; i++;
		pixels[i] = 183; i++;
		pixels[i] = 1; i++;
		pixels[i] = 125; i++;
		pixels[i] = 44; i++;
		pixels[i] = 22; i++;
		pixels[i] = 130; i++;
		pixels[i] = 197; i++;
		pixels[i] = 118; i++;
		pixels[i] = 109; i++;
		pixels[i] = 23; i++;
		pixels[i] = 195; i++;
		pixels[i] = 4; i++;
		pixels[i] = 148; i++;
		pixels[i] = 245; i++;
		pixels[i] = 124; i++;
		pixels[i] = 125; i++;
		pixels[i] = 185; i++;
		pixels[i] = 28; i++;
	}
	else 
	{
		for (var y=0; y<h; y++) 
		{
			for (var x=0; x<w; x++) 
			{
				pixels[(y*w + x)*4+0] = Math.floor(255 * Math.random());
				pixels[(y*w + x)*4+1] = Math.floor(255 * Math.random());
				pixels[(y*w + x)*4+2] = Math.floor(255 * Math.random());
				pixels[(y*w + x)*4+3] = Math.floor(255 * Math.random());
			}
		}
	}

	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	gl.bindTexture(gl.TEXTURE_2D, null);

	texture.width = w;
	texture.height = h;
	return texture;
};

/**
 * Returns the noise texture 4x4 pixels. If is undefined, then creates it. This texture is used when ssao.
 */
TexturesManager.prototype.getNoiseTexture4x4 = function() 
{
	if (this._noiseTexture_4x4 === undefined)
	{
		var gl = this.getGl();
		this._noiseTexture_4x4 = genNoiseTextureRGBA(gl, 4, 4, undefined);
	}
	
	return this._noiseTexture_4x4;
};






































'use strict';

/**
 * Triangular mesh
 * @class TriPolyhedron
 */
var TriPolyhedron = function() 
{
	if (!(this instanceof TriPolyhedron)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.vertexMatrix = new VertexMatrix();
	this.vertexList = this.vertexMatrix.newVertexList(); //the list of the vertexs which consist of this feature
	this.triSurfacesArray = []; //triSurfaceArray is a list of TriSurfaces which consist of this feature
};

TriPolyhedron.prototype.newTriSurface = function() 
{
	var triSurface = new TriSurface();
	this.triSurfacesArray.push(triSurface);
	return triSurface;
};

/**
 * Inverse the direction sense of the triangle meshes
 */
TriPolyhedron.prototype.invertTrianglesSenses = function() 
{
	var triSurfacesCount = this.triSurfacesArray.length;
	for (var i=0; i<triSurfacesCount; i++)
	{
		this.triSurfacesArray[i].invertTrianglesSenses();
	}
};

/**
 * Get the information of the VBO key of the triangles which consist of the TriPolyhedron
 * @param {VBOVertexIdxCacheKey} resultVBOVertexIdxCacheKey the array which will hold the VBO key of the triangular meshes
 * @param {VBOMemoryManager} vboMemManager 
 * @returns {VBOVertexIdxCacheKey}
 */
TriPolyhedron.prototype.getVBOArrayModePosNorCol = function(resultVBOVertexIdxCacheKey, vboMemManager) 
{
	// there are "arrayMode" and the "elementMode". "elementMode" uses indices.
	if (resultVBOVertexIdxCacheKey === undefined)
	{ resultVBOVertexIdxCacheKey = new VBOVertexIdxCacheKey(); }

	if (resultVBOVertexIdxCacheKey.posVboDataArray === undefined)
	{ resultVBOVertexIdxCacheKey.posVboDataArray = []; }

	if (resultVBOVertexIdxCacheKey.norVboDataArray === undefined)
	{ resultVBOVertexIdxCacheKey.norVboDataArray = []; }

	if (resultVBOVertexIdxCacheKey.colVboDataArray === undefined)
	{ resultVBOVertexIdxCacheKey.colVboDataArray = []; }

	var positionArray = [];
	var normalsArray = [];
	var colorsArray = [];


	resultVBOVertexIdxCacheKey.vertexCount = 0;

	var vertex0, vertex1, vertex2;
	var triangle;
	var trianglesCount;
	var triSurface;
	var triSurfacesCount = this.triSurfacesArray.length;
	for (var i = 0; i < triSurfacesCount; i++) 
	{
		triSurface = this.triSurfacesArray[i];
		trianglesCount = triSurface.trianglesArray.length;
		for (var j = 0; j < trianglesCount; j++) 
		{
			triangle = triSurface.trianglesArray[j];
			if (triangle.normal === undefined)
			{ triangle.calculatePlaneNormal(); }

			// position.
			vertex0 = triangle.vertex0;
			vertex1 = triangle.vertex1;
			vertex2 = triangle.vertex2;

			positionArray.push(vertex0.point3d.x);
			positionArray.push(vertex0.point3d.y);
			positionArray.push(vertex0.point3d.z);

			positionArray.push(vertex1.point3d.x);
			positionArray.push(vertex1.point3d.y);
			positionArray.push(vertex1.point3d.z);

			positionArray.push(vertex2.point3d.x);
			positionArray.push(vertex2.point3d.y);
			positionArray.push(vertex2.point3d.z);

			// normal (use planeNormal).
			normalsArray.push(triangle.normal.x);
			normalsArray.push(triangle.normal.y);
			normalsArray.push(triangle.normal.z);

			normalsArray.push(triangle.normal.x);
			normalsArray.push(triangle.normal.y);
			normalsArray.push(triangle.normal.z);

			normalsArray.push(triangle.normal.x);
			normalsArray.push(triangle.normal.y);
			normalsArray.push(triangle.normal.z);

			// colors.
			if (vertex0.color4 === undefined) 
			{
				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);

				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);

				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);
			}
			else 
			{
				colorsArray.push(vertex0.color4.r);
				colorsArray.push(vertex0.color4.g);
				colorsArray.push(vertex0.color4.b);
				colorsArray.push(vertex0.color4.a);

				colorsArray.push(vertex1.color4.r);
				colorsArray.push(vertex1.color4.g);
				colorsArray.push(vertex1.color4.b);
				colorsArray.push(vertex1.color4.a);

				colorsArray.push(vertex2.color4.r);
				colorsArray.push(vertex2.color4.g);
				colorsArray.push(vertex2.color4.b);
				colorsArray.push(vertex2.color4.a);
			}

			resultVBOVertexIdxCacheKey.vertexCount += 3;
		}
	}

	var vertexCount = resultVBOVertexIdxCacheKey.vertexCount;
	
	var float32PosArray = new Float32Array(vertexCount*3);
	float32PosArray.set(positionArray);
	
	var int8NorArray = new Int8Array(vertexCount*3);
	int8NorArray.set(normalsArray);
	
	var uint8ColArray = new Uint8Array(vertexCount*4);
	uint8ColArray.set(colorsArray);
	
	////////////////////////////////////////////////////////////////////////////////
	// Positions
	resultVBOVertexIdxCacheKey.setDataArrayPos(float32PosArray, vboMemManager);
	
	// Normals.
	resultVBOVertexIdxCacheKey.setDataArrayNor(int8NorArray, vboMemManager);
	
	// Colors.
	resultVBOVertexIdxCacheKey.setDataArrayCol(uint8ColArray, vboMemManager);
	////////////////////////////////////////////////////////////////////////////////

	return resultVBOVertexIdxCacheKey;
};
















'use strict';

/**
 * This feature consists of TriPolyhedron
 * Using this feature, we can save the lid, bottom, and side surface.
 * @class TriSurface
 */
var TriSurface = function() 
{
	if (!(this instanceof TriSurface)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vertexList;
	this.trianglesArray; //The array of triangles which consist of the surface
	this.trianglesList; 
};

TriSurface.prototype.newTriangle = function() 
{
	if (this.trianglesArray === undefined)
	{ this.trianglesArray = []; }
	
	var triangle = new Triangle();
	this.trianglesArray.push(triangle);
	return triangle;
};

TriSurface.prototype.invertTrianglesSenses = function() 
{
	var trianglesCount = this.trianglesArray.length;
	for (var i=0; i<trianglesCount; i++)
	{
		this.trianglesArray[i].invertSense();
	}
};



'use strict';

/**
 * VBO.
 * 
 * @class VboBuffer
 * @constructor 
 */
var VboBuffer = function(dataTarget) 
{
	if (!(this instanceof VboBuffer)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * VBO data array.
	 * @type {TypedArray}
	 * @default undefined
	 */
	this.dataArray;
	
	/**
	 * VBO data array length.
	 * @type {Number}
	 * @default undefined
	 */
	this.dataLength; 
	
	/**
	 * VBO data array type. (5120 : signed byte), (5121 : unsigned byte), (5122 : signed short), (5123 : unsigned short), (5126 : float).
	 * @type {Number}
	 * @default undefined
	 */
	this.dataGlType; 
	
	/**
	 * Webgl vbo identifier.
	 * @type {WebGLBuffer}
	 * @default undefined
	 */
	this.key; 
	
	/**
	 * Webgl data target. It can be gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER. In WebGl2 added(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, gl.TRANSFORM_FEEDBACK_BUFFER, gl.UNIFORM_BUFFER, gl.PIXEL_PACK_BUFFER, gl.PIXEL_UNPACK_BUFFER).
	 * @type {Number}
	 * @default 34962 gl.ARRAY_BUFFER
	 */
	this.dataTarget; 

	if (dataTarget !== undefined)
	{ this.dataTarget = dataTarget; }
	else 
	{ this.dataTarget = 34962; } // 34962 = gl.ARRAY_BUFFER. Default value.
};

/**
 * Deletes all objects.
 * @param {VboMemoryManager} vboMemManager.
 */
VboBuffer.prototype.deleteGlObjects = function(vboMemManager) 
{
	if (this.key !== undefined)
	{
		var gl = vboMemManager.gl;
		
		if (this.dataTarget === gl.ARRAY_BUFFER)
		{ vboMemManager.storeClassifiedBufferKey(gl, this.key, this.dataLength); }
		else if (this.dataTarget === gl.ELEMENT_ARRAY_BUFFER)
		{ vboMemManager.storeClassifiedElementKey(gl, this.key, this.dataLength); }
	}
	
	this.dataArray = undefined;
	this.dataLength = undefined; 
	this.dataGlType = undefined; 
	this.key = undefined;
	this.dataTarget = undefined;
};

/**
 * Sets the data array.
 * @param {TypedArray} dataArray The heading value in degrees.
 * @param {VboMemoryManager} vboMemManager.
 */
VboBuffer.prototype.setDataArray = function(dataArray, vboMemManager) 
{
	if (dataArray === undefined)
	{ return; }
	
	this.dataGlType = VboBuffer.getGlTypeOfArray(dataArray);
	
	var arrayElemsCount = dataArray.length;
	var classifiedPosByteSize = arrayElemsCount; // Init value.
	if (vboMemManager.enableMemoryManagement)
	{
		classifiedPosByteSize = vboMemManager.getClassifiedBufferSize(arrayElemsCount);
		this.dataArray = VboBuffer.newTypedArray(classifiedPosByteSize, this.dataGlType);
		this.dataArray.set(dataArray);
	}
	else 
	{
		this.dataArray = dataArray;
	}
	this.dataLength = arrayElemsCount;
};


/**
 * 어떤 일을 하고 있습니까?
 */
 
VboBuffer.prototype.isReady = function(gl, vboMemManager) 
{
	if (this.key === undefined) 
	{
		if (this.dataArray === undefined) { return false; }
		if (this.dataLength === undefined)
		{
			this.dataLength = this.dataArray.length;
		}
		this.key = vboMemManager.getClassifiedBufferKey(gl, this.dataLength);
		if (this.key === undefined)
		{ return false; }
		gl.bindBuffer(this.dataTarget, this.key);
		gl.bufferData(this.dataTarget, this.dataArray, gl.STATIC_DRAW);
		this.dataArray = undefined;
		return true;
	}
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VboBuffer.getGlTypeOfArray = function(dataArray) 
{
	var glType = -1;
	if (dataArray.constructor === Float32Array)
	{ glType = 5126; } // gl.FLOAT.
	else if (dataArray.constructor === Int16Array)
	{ glType = 5122; } // gl.SHORT.
	else if (dataArray.constructor === Uint16Array)
	{ glType = 5123; } // gl.UNSIGNED_SHORT.
	else if (dataArray.constructor === Int8Array)
	{ glType = 5120; } // gl.BYTE.
	else if (dataArray.constructor === Uint8Array)
	{ glType = 5121; } // gl.UNSIGNED_BYTE.
	
	return glType;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VboBuffer.newTypedArray = function(arrayLength, glType) 
{
	var typedArray;
	if (glType === 5126)// gl.FLOAT.
	{ typedArray = new Float32Array(arrayLength); }
	else if (glType === 5122)// gl.SHORT.
	{ typedArray = new Int16Array(arrayLength); }
	else if (glType === 5123)// gl.UNSIGNED_SHORT.
	{ typedArray = new Uint16Array(arrayLength); }
	else if (glType === 5120)// gl.BYTE.
	{ typedArray = new Int8Array(arrayLength); }
	else if (glType === 5121)// gl.UNSIGNED_BYTE.
	{ typedArray = new Uint8Array(arrayLength); }
		
	return typedArray;
};
'use strict';
/**
 * 어떤 일을 하고 있습니까?
 * @class VBOKeysNation
 */
var VBOKeysNation = function(bufferSizes, minSize) 
{
	if (!(this instanceof VBOKeysNation)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// buffer sizes are in bytes.
	this.vboKeysStoreMap = {};
	this.bufferSizes = bufferSizes;
	this.minSize = minSize;
	this.maxSize = bufferSizes[bufferSizes.length-1];
	this.totalBytesUsed = 0;
	
	var vboKeysStore;
	var sizesCount = bufferSizes.length;
	for (var i=0; i<sizesCount; i++)
	{
		vboKeysStore = new VBOKeysStore(bufferSizes[i]);
		this.vboKeysStoreMap[bufferSizes[i]] = vboKeysStore;

		if (bufferSizes[i] > this.maxSize) { this.maxSize = bufferSizes[i]; }
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferKey. 
 */
VBOKeysNation.prototype.getClassifiedBufferKey = function(gl, bufferSize, keyWorld, onlyReuse) 
{
	// 1rst find the vboKeyStore for this bufferSize.
	var closestBufferSize = this.getClosestBufferSize(bufferSize);
	var vboKeyStore = this.vboKeysStoreMap[closestBufferSize];
	
	if (vboKeyStore)
	{
		return vboKeyStore.getBufferKey(gl, this, keyWorld, onlyReuse);
	}
	else { return -1; }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferKey. 
 */
VBOKeysNation.prototype.storeClassifiedBufferKey = function(bufferKey, bufferSize) 
{
	// 1rst find the vboKeyStore for this bufferSize.
	var vboKeyStore = this.vboKeysStoreMap[bufferSize];
	if (vboKeyStore)
	{
		vboKeyStore.storeBufferKey(bufferKey);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns boolean. true if the currentBufferSize is in the range of this nation.
 */
VBOKeysNation.prototype.getClosestBufferSize = function(currentBufferSize) 
{
	if (!this.isInsideRange(currentBufferSize))
	{ return -1; }
	
	var sizesCount = this.bufferSizes.length;
	for (var i=0; i<sizesCount; i++)
	{
		if (currentBufferSize <= this.bufferSizes[i])
		{
			return this.bufferSizes[i];
		}
	}
	return -1;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns boolean. true if the currentBufferSize is in the range of this nation.
 */
VBOKeysNation.prototype.isInsideRange = function(bufferSize) 
{
	if (bufferSize > this.maxSize || bufferSize < this.minSize)
	{ return false; }

	return true;
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class VBOKeysStore
 */
var VBOKeysStore = function(bufferSize) 
{
	if (!(this instanceof VBOKeysStore)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.classifiedSize = bufferSize;
	this.vboKeysArray = [];
	this.keysCreated = 0; // total keys created for this size.
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns boolean. 
 */
VBOKeysStore.prototype.getBufferKey = function(gl, keyNation, keyWorld, onlyReuse) 
{
	if (this.vboKeysArray.length > 0)
	{
		var vboKey = this.vboKeysArray.pop();
		return vboKey;
	}
	else 
	{
		if (!onlyReuse)
		{
			// there are no free key, so create one.
			var vboKey = gl.createBuffer();
			this.keysCreated += 1; // increment key created counter.
			keyNation.totalBytesUsed += this.classifiedSize;
			keyWorld.totalBytesUsed += this.classifiedSize;
			return vboKey;
		}
		return undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns boolean. 
 */
VBOKeysStore.prototype.storeBufferKey = function(bufferKey) 
{
	this.vboKeysArray.push(bufferKey);
};

'use strict';
/**
 * 어떤 일을 하고 있습니까?
 */
var VBOKeysWorld = function() 
{
	if (!(this instanceof VBOKeysWorld)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.totalBytesUsed = 0;
	this.bytesLimit = 1000;
	
	this.vboKeysNationsArray = [];
	this.vboKeyNation12to128 = new VBOKeysNation(new Uint32Array([12, 16, 32, 48, 64, 76, 92, 128]), 0);
	this.vboKeysNationsArray.push(this.vboKeyNation12to128);
	this.vboKeyNation200to1000 = new VBOKeysNation(new Uint32Array([200, 300, 400, 500, 600, 700, 800, 900, 1000]), 129);
	this.vboKeysNationsArray.push(this.vboKeyNation200to1000);
	this.vboKeyNation1500to6000 = new VBOKeysNation(new Uint32Array([1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000, 5500, 6000]), 1001);
	this.vboKeysNationsArray.push(this.vboKeyNation1500to6000);
	this.vboKeyNation7000to16000 = new VBOKeysNation(new Uint32Array([7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]), 6001);
	this.vboKeysNationsArray.push(this.vboKeyNation7000to16000);
	this.vboKeyNation20000to56000 = new VBOKeysNation(new Uint32Array([20000, 24000, 28000, 32000, 36000, 40000, 44000, 48000, 52000, 56000]), 16001);
	this.vboKeysNationsArray.push(this.vboKeyNation20000to56000);
	this.vboKeyNation60000to150000 = new VBOKeysNation(new Uint32Array([60000, 70000, 80000, 90000, 100000, 110000, 120000, 130000, 140000, 150000]), 56001);
	this.vboKeysNationsArray.push(this.vboKeyNation60000to150000);
	this.vboKeyNation200000to1100000 = new VBOKeysNation(new Uint32Array([200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000, 1000000, 1100000]), 150001);
	this.vboKeysNationsArray.push(this.vboKeyNation200000to1100000);
	this.vboKeyNation1500000to3000000 = new VBOKeysNation(new Uint32Array([1500000, 2000000, 2500000, 3000000, 6000000, 12000000, 24000000, 36000000, 60000000]), 1100001);
	this.vboKeysNationsArray.push(this.vboKeyNation1500000to3000000);
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOKeysWorld.prototype.getClassifiedBufferKey = function(gl, bufferSize) 
{
	// check gpuMemory limit.
	// If current totalBytesUsed is greater than bytesLimit, then enters in mode "onlyReuse".
	// "onlyReuse" = no allocate GPU memory, only use the existent
	var onlyReuse = false;
	if (this.totalBytesUsed > this.bytesLimit)
	{
		onlyReuse = true;
	}
	
	// 1rst, find the Nation for this bufferSize.
	var keyNation = this.getKeyNationBySize(bufferSize);
	var vboBufferKey = undefined;
	if (keyNation)
	{
		vboBufferKey = keyNation.getClassifiedBufferKey(gl, bufferSize, this, onlyReuse);
	}
	return vboBufferKey;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOKeysWorld.prototype.storeClassifiedBufferKey = function(bufferKey, bufferSize) 
{
	// 1rst, find the Nation for this bufferSize.
	var keyNation = this.getKeyNationBySize(bufferSize);
	if (keyNation)
	{ keyNation.storeClassifiedBufferKey(bufferKey, bufferSize); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOKeysWorld.prototype.getKeyNationBySize = function(bufferSize) 
{
	// 1rst, find the Nation for this bufferSize.
	var nationsCount = this.vboKeysNationsArray.length;
	var i=0;
	var vboBufferKey = -1;
	while (i<nationsCount)
	{
		if (this.vboKeysNationsArray[i].isInsideRange(bufferSize))
		{
			return this.vboKeysNationsArray[i];
		}
		i++;
	}
	return vboBufferKey;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferStandardSize
 */
VBOKeysWorld.prototype.getClassifiedBufferSize = function(currentBufferSize) 
{
	// 1rst, find the Nation for this bufferSize.
	var keyNation = this.getKeyNationBySize(currentBufferSize);
	var classifiedSize = -1;

	if (keyNation !== -1)
	{ classifiedSize = keyNation.getClosestBufferSize(currentBufferSize); }
	return classifiedSize;
};

'use strict';
/**
 * 어떤 일을 하고 있습니까?
 * @class VBOMemoryManager
 */
var VBOMemoryManager = function() 
{
	if (!(this instanceof VBOMemoryManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl;
	
	// if "enableMemoryManagement" == false -> no management of the gpu memory.
	this.enableMemoryManagement = false;
	
	this.buffersKeyWorld = new VBOKeysWorld();
	this.elementKeyWorld = new VBOKeysWorld();
	
	this.buffersKeyWorld.bytesLimit = 800000000;
	this.elementKeyWorld.bytesLimit = 300000000;
	
	this.currentMemoryUsage = 0.0;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.isGpuMemFull = function() 
{
	if (this.buffersKeyWorld.totalBytesUsed > this.buffersKeyWorld.bytesLimit || this.elementKeyWorld.totalBytesUsed > this.elementKeyWorld.bytesLimit)
	{ return true; }
	else { return false; }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.getClassifiedBufferKey = function(gl, bufferSize) 
{
	if (this.enableMemoryManagement)
	{ 
		var bufferKey = this.buffersKeyWorld.getClassifiedBufferKey(gl, bufferSize);
		if (bufferKey !== undefined)
		{ this.currentMemoryUsage += bufferSize; }
		return bufferKey; 
	}
	else
	{ 
		this.currentMemoryUsage += bufferSize;
		return gl.createBuffer(); 
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.storeClassifiedBufferKey = function(gl, bufferKey, bufferSize) 
{
	if (this.enableMemoryManagement)
	{ this.buffersKeyWorld.storeClassifiedBufferKey(bufferKey, bufferSize); }
	else
	{ gl.deleteBuffer(bufferKey); }

	this.currentMemoryUsage -= bufferSize;
	if (this.currentMemoryUsage < 0.0)
	{ this.currentMemoryUsage = 0.0; }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.getClassifiedElementKey = function(gl, bufferSize) 
{
	if (this.enableMemoryManagement)
	{ return this.elementKeyWorld.getClassifiedBufferKey(gl, bufferSize); }
	else
	{ return gl.createBuffer(); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.storeClassifiedElementKey = function(gl, bufferKey, bufferSize) 
{
	if (this.enableMemoryManagement)
	{ this.elementKeyWorld.storeClassifiedBufferKey(bufferKey, bufferSize); }
	else
	{ gl.deleteBuffer(bufferKey); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferStandardSize
 */
VBOMemoryManager.prototype.getClassifiedBufferSize = function(currentBufferSize) 
{
	if (this.enableMemoryManagement)
	{ return this.buffersKeyWorld.getClassifiedBufferSize(currentBufferSize); } 
	else
	{ return currentBufferSize; }
};
'use strict';
/**
 * 어떤 일을 하고 있습니까?
 * @class VBOVertexIdxCacheKey
 */
var VBOVertexIdxCacheKey = function() 
{
	if (!(this instanceof VBOVertexIdxCacheKey)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.indicesCount = -1;
	this.vertexCount = -1;
	this.bigTrianglesIndicesCount = -1;
	
	this.vboBufferPos;
	this.vboBufferNor;
	this.vboBufferIdx;
	this.vboBufferCol;
	this.vboBufferTCoord;

};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.stepOverPosNorIdx = function(arrayBuffer, readWriter, vboMemManager, bytesReaded) 
{
	var startBuff, endBuff;
	
	// 1) Positions array.
	var vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);
	bytesReaded += 4;
	var verticesFloatValuesCount = vertexCount * 3;
	startBuff = bytesReaded;
	endBuff = bytesReaded + 4 * verticesFloatValuesCount;
	bytesReaded = bytesReaded + 4 * verticesFloatValuesCount; // updating data.
	
	// 2) Normals.
	vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);
	bytesReaded += 4;
	var normalByteValuesCount = vertexCount * 3;
	startBuff = bytesReaded;
	endBuff = bytesReaded + 1 * normalByteValuesCount;
	bytesReaded = bytesReaded + 1 * normalByteValuesCount; // updating data.
	
	// 3) Indices.
	var shortIndicesValuesCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);

	bytesReaded += 4;
	var sizeLevels = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1);
	bytesReaded +=1;
	//var sizeThresholds = [];
	for ( var k = 0; k < sizeLevels; k++ )
	{
		//sizeThresholds.push(new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)));
		bytesReaded += 4;
	}
	//var indexMarkers = [];
	for ( var k = 0; k < sizeLevels; k++ )
	{
		//indexMarkers.push(readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4));
		bytesReaded += 4;
	}
	//var bigTrianglesShortIndicesValues_count = indexMarkers[sizeLevels-1];
	//this.bigTrianglesIndicesCount = bigTrianglesShortIndicesValues_count;
	startBuff = bytesReaded;
	endBuff = bytesReaded + 2 * shortIndicesValuesCount;
	//var idxDataArray = new Uint16Array(arrayBuffer.slice(startBuff, endBuff));
	//this.setDataArrayIdx(idxDataArray, vboMemManager);

	bytesReaded = bytesReaded + 2 * shortIndicesValuesCount; // updating data.
	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.readPosNorIdx = function(arrayBuffer, readWriter, vboMemManager, bytesReaded) 
{
	var startBuff, endBuff;
	
	// 1) Positions array.
	var vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);
	this.vertexCount = vertexCount;
	bytesReaded += 4;
	var verticesFloatValuesCount = vertexCount * 3;
	
	startBuff = bytesReaded;
	endBuff = bytesReaded + 4 * verticesFloatValuesCount;
	var posDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff));
	this.setDataArrayPos(posDataArray, vboMemManager);

	bytesReaded = bytesReaded + 4 * verticesFloatValuesCount; // updating data.
	
	// 2) Normals.
	vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);
	bytesReaded += 4;
	var normalByteValuesCount = vertexCount * 3;
	startBuff = bytesReaded;
	endBuff = bytesReaded + 1 * normalByteValuesCount;
	var norDataArray = new Int8Array(arrayBuffer.slice(startBuff, endBuff));
	this.setDataArrayNor(norDataArray, vboMemManager);
	
	bytesReaded = bytesReaded + 1 * normalByteValuesCount; // updating data.
	
	// 3) Indices.
	var shortIndicesValuesCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);

	bytesReaded += 4;
	var sizeLevels = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1);
	bytesReaded +=1;
	var sizeThresholds = [];
	for ( var k = 0; k < sizeLevels; k++ )
	{
		sizeThresholds.push(new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)));
		bytesReaded += 4;
	}
	var indexMarkers = [];
	for ( var k = 0; k < sizeLevels; k++ )
	{
		indexMarkers.push(readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4));
		bytesReaded += 4;
	}
	var bigTrianglesShortIndicesValues_count = indexMarkers[sizeLevels-1];
	this.bigTrianglesIndicesCount = bigTrianglesShortIndicesValues_count;
	startBuff = bytesReaded;
	endBuff = bytesReaded + 2 * shortIndicesValuesCount;
	var idxDataArray = new Uint16Array(arrayBuffer.slice(startBuff, endBuff));
	this.setDataArrayIdx(idxDataArray, vboMemManager);

	bytesReaded = bytesReaded + 2 * shortIndicesValuesCount; // updating data.
	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.bindDataPosition = function(shader, vboMemManager) 
{
	if (shader === undefined)
	{ return false; }
	
	var gl = shader.gl;
	var vboBufferPos = this.vboBufferPos;
	if (!vboBufferPos.isReady(gl, vboMemManager))
	{ return false; }
	
	if (shader.position3_loc !== undefined && shader.position3_loc !== -1) 
	{
		shader.enableVertexAttribArray(shader.position3_loc);
		if (vboBufferPos.key !== shader.last_vboPos_binded)
		{
			gl.bindBuffer(vboBufferPos.dataTarget, vboBufferPos.key);
			gl.vertexAttribPointer(shader.position3_loc, 3, vboBufferPos.dataGlType, false, 0, 0);
			shader.last_vboPos_binded = vboBufferPos.key;
		}
		return true;
	}
	else { shader.disableVertexAttribArray(shader.position3_loc); }
	return false;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.bindDataNormal = function(shader, vboMemManager) 
{
	if (shader === undefined)
	{ return false; }
	
	var vboBufferNor = this.vboBufferNor;
	if (vboBufferNor === undefined)
	{
		shader.disableVertexAttribArray(shader.normal3_loc);
		return true; // Return "true" bcos there are no "normal" data, that is different that having "normal" data and not prepared yet.
	}
	
	var gl = shader.gl;
	if (!vboBufferNor.isReady(gl, vboMemManager))
	{ return false; }
	
	if (shader.normal3_loc !== undefined && shader.normal3_loc !== -1) 
	{
		shader.enableVertexAttribArray(shader.normal3_loc);
		if (vboBufferNor.key !== shader.last_vboNor_binded)
		{
			gl.bindBuffer(vboBufferNor.dataTarget, vboBufferNor.key);
			gl.vertexAttribPointer(shader.normal3_loc, 3, vboBufferNor.dataGlType, true, 0, 0);
			shader.last_vboNor_binded = vboBufferNor.key;
		}
		return true;
	}
	else { shader.disableVertexAttribArray(shader.normal3_loc); }
	return false;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.bindDataTexCoord = function(shader, vboMemManager) 
{
	if (shader === undefined)
	{ return false; }
	
	var vboBufferTCoord = this.vboBufferTCoord;
	if (vboBufferTCoord === undefined)
	{
		shader.disableVertexAttribArray(shader.texCoord2_loc);
		return true; // Return "true" bcos there are no "tCoord" data, that is different that having "tCoord" data and not prepared yet.
	}
	
	var gl = shader.gl;
	if (!vboBufferTCoord.isReady(gl, vboMemManager))
	{ return false; }
	if (shader.texCoord2_loc !== undefined && shader.texCoord2_loc !== -1) 
	{
		shader.enableVertexAttribArray(shader.texCoord2_loc);
		if (vboBufferTCoord.key !== shader.last_vboTexCoord_binded)
		{
			gl.bindBuffer(vboBufferTCoord.dataTarget, vboBufferTCoord.key);
			gl.vertexAttribPointer(shader.texCoord2_loc, 2, vboBufferTCoord.dataGlType, false, 0, 0);
			shader.last_vboTexCoord_binded = vboBufferTCoord.key;
		}
		return true;
	}
	else { shader.disableVertexAttribArray(shader.texCoord2_loc); }
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.bindDataColor = function(shader, vboMemManager) 
{
	if (shader === undefined)
	{ return false; }
	
	var vboBufferCol = this.vboBufferCol;
	if (vboBufferCol === undefined)
	{
		shader.disableVertexAttribArray(shader.color4_loc);
		return true; // Return "true" bcos there are no "color" data, that is different that having "color" data and not prepared yet.
	}
	
	var gl = shader.gl;
	if (!vboBufferCol.isReady(gl, vboMemManager))
	{ return false; }

	if (shader.color4_loc !== undefined && shader.color4_loc !== -1) 
	{
		shader.enableVertexAttribArray(shader.color4_loc);
		if (vboBufferCol.key !== shader.last_vboCol_binded)
		{
			gl.bindBuffer(vboBufferCol.dataTarget, vboBufferCol.key);
			gl.vertexAttribPointer(shader.color4_loc, 4, vboBufferCol.dataGlType, true, 0, 0);
			shader.last_vboCol_binded = vboBufferCol.key;
		}
		return true;
	}
	else { shader.disableVertexAttribArray(shader.color4_loc); }
	return false;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.bindDataIndice = function(shader, vboMemManager) 
{
	if (shader === undefined)
	{ return false; }
	
	var gl = shader.gl;
	
	var vboBufferIdx = this.vboBufferIdx;
	if (!vboBufferIdx.isReady(gl, vboMemManager))
	{ return false; }
	
	if (vboBufferIdx.key !== shader.last_vboIdx_binded)
	{
		gl.bindBuffer(vboBufferIdx.dataTarget, vboBufferIdx.key);
		shader.last_vboIdx_binded = vboBufferIdx.key;
	}
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.setDataArrayPos = function(posDataArray, vboMemManager) 
{
	if (posDataArray === undefined)
	{ return; }
	
	var gl = vboMemManager.gl;
	if (this.vboBufferPos === undefined)
	{ this.vboBufferPos = new VboBuffer(gl.ARRAY_BUFFER); }
	
	this.vboBufferPos.setDataArray(posDataArray, vboMemManager);
	this.vertexCount = this.vboBufferPos.dataLength/3;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.setDataArrayNor = function(norDataArray, vboMemManager) 
{
	var gl = vboMemManager.gl;
	if (this.vboBufferNor === undefined)
	{ this.vboBufferNor = new VboBuffer(gl.ARRAY_BUFFER); }
	
	this.vboBufferNor.setDataArray(norDataArray, vboMemManager);
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.setDataArrayIdx = function(idxDataArray, vboMemManager) 
{
	var gl = vboMemManager.gl;
	if (this.vboBufferIdx === undefined)
	{ this.vboBufferIdx = new VboBuffer(gl.ELEMENT_ARRAY_BUFFER); }
	
	this.vboBufferIdx.setDataArray(idxDataArray, vboMemManager);
	this.indicesCount = this.vboBufferIdx.dataLength;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.setDataArrayCol = function(colDataArray, vboMemManager) 
{
	
	var gl = vboMemManager.gl;
	if (this.vboBufferCol === undefined)
	{ this.vboBufferCol = new VboBuffer(gl.ARRAY_BUFFER); }
	
	this.vboBufferCol.setDataArray(colDataArray, vboMemManager);
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.setDataArrayTexCoord = function(texCoordDataArray, vboMemManager) 
{
	var gl = vboMemManager.gl;
	
	if (this.vboBufferTCoord === undefined)
	{ this.vboBufferTCoord = new VboBuffer(gl.ARRAY_BUFFER); }
	
	this.vboBufferTCoord.setDataArray(texCoordDataArray, vboMemManager);
};


/**
 * 어떤 일을 하고 있습니까?
 * @returns vboViCacheKey
 */
VBOVertexIdxCacheKey.prototype.deleteGlObjects = function(gl, vboMemManager) 
{
	if (this.vboBufferPos !== undefined)
	{
		this.vboBufferPos.deleteGlObjects(vboMemManager);	
		this.vboBufferPos = undefined;
	}
	if (this.vboBufferNor !== undefined)
	{
		this.vboBufferNor.deleteGlObjects(vboMemManager);	
		this.vboBufferNor = undefined;
	}
	if (this.vboBufferIdx !== undefined)
	{
		this.vboBufferIdx.deleteGlObjects(vboMemManager);	
		this.vboBufferIdx = undefined;
	}
	if (this.vboBufferCol !== undefined)
	{
		this.vboBufferCol.deleteGlObjects(vboMemManager);	
		this.vboBufferCol = undefined;
	}
	if (this.vboBufferTCoord !== undefined)
	{
		this.vboBufferTCoord.deleteGlObjects(vboMemManager);	
		this.vboBufferTCoord = undefined;
	}
};

'use strict';


/**
 * This class is the container which holds the VBO Cache Keys
 * @class VBOVertexIdxCacheKeysContainer
 */
var VBOVertexIdxCacheKeysContainer = function() 
{
	if (!(this instanceof VBOVertexIdxCacheKeysContainer)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vboCacheKeysArray = []; //the container of vbo keys
};

/**
 * Create the default VBO instance
 * @returns {VBOVertexIdxCacheKey} vboVertexIdxCacheKey
 */
VBOVertexIdxCacheKeysContainer.prototype.newVBOVertexIdxCacheKey = function() 
{
	if (this.vboCacheKeysArray === undefined)
	{ this.vboCacheKeysArray = []; }
	
	var vboVertexIdxCacheKey = new VBOVertexIdxCacheKey();
	this.vboCacheKeysArray.push(vboVertexIdxCacheKey);
	return vboVertexIdxCacheKey;
};

/**
 * Clear the data of this instance
 * @param gl
 * @param {VBOMemoryManager} vboMemManager
 */
VBOVertexIdxCacheKeysContainer.prototype.deleteGlObjects = function(gl, vboMemManager) 
{
	if (this.vboCacheKeysArray === undefined)
	{ return; }
	
	var vboDatasCount = this.vboCacheKeysArray.length;
	for (var j = 0; j < vboDatasCount; j++) 
	{
		this.vboCacheKeysArray[j].deleteGlObjects(gl, vboMemManager);
		this.vboCacheKeysArray[j] = undefined;
	}
	this.vboCacheKeysArray.length = 0;
	this.vboCacheKeysArray = undefined;
};

/**
 * 
 * @returns {Number} the number of the key that this instance holds
 */
VBOVertexIdxCacheKeysContainer.prototype.getVbosCount = function() 
{
	if (this.vboCacheKeysArray === undefined) { return 0; }
	
	return this.vboCacheKeysArray.length;
};

/**
 * Get the VBO key by the index
 * @param {Number} idx
 * @returns {VBOVertexIdxCacheKey}
 */
VBOVertexIdxCacheKeysContainer.prototype.getVboKey = function(idx) 
{
	if (this.vboCacheKeysArray === undefined)
	{ return undefined; }
	
	var vbo = this.vboCacheKeysArray[idx];
	return vbo;
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class VisibleObjectsController
 */
var VisibleObjectsController = function() 
{
	if (!(this instanceof VisibleObjectsController)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// This object works with FrustumVolumeControl.
	this.currentVisibles0 = []; //frustum 0
	this.currentVisibles1 = []; //frustum 1
	this.currentVisibles2 = []; //frustum 2
	this.currentVisibles3 = []; //frustum 3
	this.currentVisiblesAux = [];
};
VisibleObjectsController.prototype.initArrays = function() 
{
	this.currentVisibles0 = [];
	this.currentVisibles1 = [];
	this.currentVisibles2 = [];
	this.currentVisibles3 = [];
	this.currentVisiblesAux = [];
};
/**Clear all of the volumn's data */

VisibleObjectsController.prototype.clear = function() 
{
	this.currentVisibles0.length = 0;
	this.currentVisibles1.length = 0;
	this.currentVisibles2.length = 0;
	this.currentVisibles3.length = 0;
	this.currentVisiblesAux.length = 0;
};

/**
 * Make all volumns visible
 */
VisibleObjectsController.prototype.getAllVisibles = function() 
{
	var resultVisiblesArray = [].concat(this.currentVisibles0, this.currentVisibles1, this.currentVisibles2, this.currentVisibles3);
	return resultVisiblesArray;
};

/**
 * Make two volumns : 0, 1
 */
VisibleObjectsController.prototype.get01Visibles = function() 
{
	var resultVisiblesArray = [].concat(this.currentVisibles0, this.currentVisibles1);
	return resultVisiblesArray;
};

/**
 * 
 */
VisibleObjectsController.prototype.getObjectIdxSortedByDist = function(objectsArray, startIdx, endIdx, object) 
{
	// this do a dicotomic search of idx in a ordered table.
	// 1rst, check the range.
	var range = endIdx - startIdx;
	if (range < 6)
	{
		// in this case do a lineal search.
		var finished = false;
		var i = startIdx;
		var idx;

		while (!finished && i<=endIdx)
		{
			var anObject = objectsArray[i];
			if (object.distToCamera < anObject.distToCamera)
			{
				idx = i;
				finished = true;
			}
			i++;
		}
		
		if (finished)
		{ return idx; }
		else 
		{ return endIdx+1; }
	}
	else 
	{
		// in this case do the dicotomic search.
		var middleIdx = startIdx + Math.floor(range/2);
		var newStartIdx;
		var newEndIdx;
		var middleObject = objectsArray[middleIdx];
		if (middleObject.distToCamera > object.distToCamera)
		{
			newStartIdx = startIdx;
			newEndIdx = middleIdx;
		}
		else 
		{
			newStartIdx = middleIdx;
			newEndIdx = endIdx;
		}
		return this.getObjectIdxSortedByDist(objectsArray, newStartIdx, newEndIdx, object);
	}
};

/**
 * Put the object by distance from camera
 * @param {VisibleObjectsController}objectsArray
 * @param {Octree}object 
 */
VisibleObjectsController.prototype.putObjectToArraySortedByDist = function(objectsArray, object) 
{
	if (objectsArray.length > 0)
	{
		var startIdx = 0;
		var endIdx = objectsArray.length - 1;
		var idx = this.getObjectIdxSortedByDist(objectsArray, startIdx, endIdx, object);
		               
		
		objectsArray.splice(idx, 0, object);
	}
	else 
	{
		objectsArray.push(object);
	}
};

/**
 * Get the index of the node which is in nodesArray
 * @param nodesArray
 * @param {Number} startIdx
 * @param {Number} endIdx
 * @param node
 */
VisibleObjectsController.prototype.getNodeIdxSortedByDist = function(nodesArray, startIdx, endIdx, node) 
{
	// Note: Function exclusive to use with Node class objects.
	// this do a dicotomic search of idx in a ordered table.
	// 1rst, check the range.
	var neoBuilding = node.data.neoBuilding;
	var range = endIdx - startIdx;
	if (range < 6)
	{
		// in this case do a lineal search.
		var finished = false;
		var i = startIdx;
		var idx;

		while (!finished && i<=endIdx)
		{
			var aNode = nodesArray[i];
			if (node.data.distToCam < aNode.data.distToCam)
			{
				idx = i;
				finished = true;
			}
			i++;
		}
		
		if (finished)
		{ return idx; }
		else 
		{ return endIdx+1; }
	}
	else 
	{
		// in this case do the dicotomic search.
		var middleIdx = startIdx + Math.floor(range/2);
		var newStartIdx;
		var newEndIdx;
		var middleNode = nodesArray[middleIdx];
		if (middleNode.data.distToCam > node.data.distToCam)
		{
			newStartIdx = startIdx;
			newEndIdx = middleIdx;
		}
		else 
		{
			newStartIdx = middleIdx;
			newEndIdx = endIdx;
		}
		return this.getNodeIdxSortedByDist(nodesArray, newStartIdx, newEndIdx, node);
	}
};

/**
 * Put the node to given node array
 * @param nodesArray
 * @param node
 */
VisibleObjectsController.prototype.putNodeToArraySortedByDist = function(nodesArray, node) 
{
	// Note: Function exclusive to use with Node class objects.
	if (nodesArray.length > 0)
	{
		var startIdx = 0;
		var endIdx = nodesArray.length - 1;
		var idx = this.getNodeIdxSortedByDist(nodesArray, startIdx, endIdx, node);
		
		nodesArray.splice(idx, 0, node);
	}
	else 
	{
		nodesArray.push(node);
	}
};
















'use strict';

/**
 * mago3djs API
 * 
 * @alias API
 * @class API
 * 
 * @param {any} apiName api이름
 */
function API(apiName)
{
	if (!(this instanceof API)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// mago3d 활성화/비활성화 여부
	this.magoEnable = true;
	// return
	this.returnable = false;

	// api 이름
	this.apiName = apiName;
	
	// project id
	this.projectId = null;
	this.projectDataFolder = null;
	// objectIds
	this.objectIds = null;
	// data_key
	this.dataKey = null;
	// issueId
	this.issueId = null;
	// issueType
	this.issueType = null;
	// drawType 이미지를 그리는 유형 0 : DB, 1 : 이슈등록
	this.drawType = 0;

	// 위도
	this.latitude = 0;
	// 경도
	this.longitude = 0;
	// 높이
	this.elevation = 0;
	// heading
	this.heading = 0;
	// pitch
	this.pitch = 0;
	// roll
	this.roll = 0;
	// duration
	this.duration = 0;

	// 속성
	this.property = null;
	// 색깔
	this.color = 0;
	// structs = MSP, outfitting = MOP
	this.blockType = null;
	// outfitting 표시/비표시
	this.showOutFitting = false;
	// label 표시/비표시
	this.showLabelInfo = true;
	// origin 표시/비표시
	this.showOrigin = false;
	// boundingBox 표시/비표시
	this.showBoundingBox = false;
	// 그림자 표시/비표시
	this.showShadow = false;
	// frustum culling 가시 거리(M단위)
	this.frustumFarDistance = 0;
	// move mode 
	this.objectMoveMode = CODE.moveMode.NONE;
	// 이슈 등록 표시
	this.issueInsertEnable = false;
	// object 정보 표시
	this.objectInfoViewEnable = false;
	// 이슈 목록 표시
	this.nearGeoIssueListEnable = false;
	// occlusion culling
	this.occlusionCullingEnable = false;
	//
	this.insertIssueState = 0;
	
	// LOD1
	this.lod0DistInMeters = null;
	this.lod1DistInMeters = null;
	this.lod2DistInMeters = null;
	this.lod3DistInMeters = null;
	this.lod4DistInMeters = null;
	this.lod5DistInMeters = null;
	
	// Lighting
	this.ambientReflectionCoef = null;
	this.diffuseReflectionCoef = null;
	this.specularReflectionCoef = null;
	this.ambientColor = null;
	this.specularColor = null;
	
	this.ssaoRadius = null;
	//
	this.FPVMode = false;

	// input x, y, z
	this.inputPoint = null;
	// result x, y, z
	this.resultPoint = null;
	
	// General magoMode.
	this.magoMode = CODE.magoMode.NORMAL;

	//position unit
	this.unit = CODE.units.DEGREE;

	//for staticModel instantiate
	this.instantiateObj = null;

	//for staticModel add
	this.staticModelAttributeObj = null;

	//animation option. 
	this.animationOption = null;
};

API.prototype.getMagoEnable = function() 
{
	return this.magoEnable;
};
API.prototype.setMagoEnable = function(magoEnable) 
{
	this.magoEnable = magoEnable;
};

API.prototype.getReturnable = function()
{
	return this.returnable;
};
API.prototype.setReturnable = function(returnable)
{
	this.returnable = returnable;
};

API.prototype.getAPIName = function() 
{
	return this.apiName;
};

API.prototype.getProjectId = function() 
{
	return this.projectId;
};
API.prototype.setProjectId = function(projectId) 
{
	this.projectId = projectId;
};

API.prototype.getProjectDataFolder = function() 
{
	return this.projectDataFolder;
};
API.prototype.setProjectDataFolder = function(projectDataFolder) 
{
	this.projectDataFolder = projectDataFolder;
};

API.prototype.getObjectIds = function() 
{
	return this.objectIds;
};
API.prototype.setObjectIds = function(objectIds) 
{
	this.objectIds = objectIds;
};

API.prototype.getIssueId = function() 
{
	return this.issueId;
};
API.prototype.setIssueId = function(issueId) 
{
	this.issueId = issueId;
};
API.prototype.getIssueType = function() 
{
	return this.issueType;
};
API.prototype.setIssueType = function(issueType) 
{
	this.issueId = issueType;
};

API.prototype.getDataKey = function() 
{
	return this.dataKey;
};
API.prototype.setDataKey = function(dataKey) 
{
	this.dataKey = dataKey;
};

API.prototype.getLatitude = function() 
{
	return this.latitude;
};
API.prototype.setLatitude = function(latitude) 
{
	this.latitude = latitude;
};

API.prototype.getLongitude = function() 
{
	return this.longitude;
};
API.prototype.setLongitude = function(longitude) 
{
	this.longitude = longitude;
};

API.prototype.getElevation = function() 
{
	return this.elevation;
};
API.prototype.setElevation = function(elevation) 
{
	this.elevation = elevation;
};

API.prototype.getHeading = function() 
{
	return this.heading;
};
API.prototype.setHeading = function(heading) 
{
	this.heading = heading;
};

API.prototype.getPitch = function() 
{
	return this.pitch;
};
API.prototype.setPitch = function(pitch) 
{
	this.pitch = pitch;
};

API.prototype.getRoll = function() 
{
	return this.roll;
};
API.prototype.setRoll = function(roll) 
{
	this.roll = roll;
};

API.prototype.getProperty = function() 
{
	return this.property;
};
API.prototype.setProperty = function(property) 
{
	this.property = property;
};

API.prototype.getColor = function() 
{
	return this.color;
};
API.prototype.setColor = function(color) 
{
	this.color = color;
};

API.prototype.getBlockType = function() 
{
	return this.blockType;
};
API.prototype.setBlockType = function(blockType) 
{
	this.blockType = blockType;
};

API.prototype.getShowOutFitting = function() 
{
	return this.showOutFitting;
};
API.prototype.setShowOutFitting = function(showOutFitting) 
{
	this.showOutFitting = showOutFitting;
};


API.prototype.getShowLabelInfo = function() 
{
	return this.showLabelInfo;
};
API.prototype.setShowLabelInfo = function(showLabelInfo) 
{
	this.showLabelInfo = showLabelInfo;
};

API.prototype.getShowOrigin = function()
{
	return this.showOrigin;
};
API.prototype.setShowOrigin = function(showOrigin)
{
	this.showOrigin = showOrigin;
};

API.prototype.getShowBoundingBox = function() 
{
	return this.showBoundingBox;
};
API.prototype.setShowBoundingBox = function(showBoundingBox) 
{
	this.showBoundingBox = showBoundingBox;
};

API.prototype.getShowShadow = function() 
{
	return this.showShadow;
};
API.prototype.setShowShadow = function(showShadow) 
{
	this.showShadow = showShadow;
};

API.prototype.getFrustumFarDistance = function() 
{
	return this.frustumFarDistance;
};
API.prototype.setFrustumFarDistance = function(frustumFarDistance) 
{
	this.frustumFarDistance = frustumFarDistance;
};

API.prototype.getObjectMoveMode = function() 
{
	return this.objectMoveMode;
};
API.prototype.setObjectMoveMode = function(objectMoveMode) 
{
	this.objectMoveMode = objectMoveMode;
};

API.prototype.getIssueInsertEnable = function() 
{
	return this.issueInsertEnable;
};
API.prototype.setIssueInsertEnable = function(issueInsertEnable) 
{
	this.issueInsertEnable = issueInsertEnable;
};
API.prototype.getObjectInfoViewEnable = function() 
{
	return this.objectInfoViewEnable;
};
API.prototype.setObjectInfoViewEnable = function(objectInfoViewEnable) 
{
	this.objectInfoViewEnable = objectInfoViewEnable;
};
API.prototype.getOcclusionCullingEnable = function() 
{
	return this.occlusionCullingEnable;
};
API.prototype.setOcclusionCullingEnable = function(occlusionCullingEnable) 
{
	this.occlusionCullingEnable = occlusionCullingEnable;
};
API.prototype.getNearGeoIssueListEnable = function() 
{
	return this.nearGeoIssueListEnable;
};
API.prototype.setNearGeoIssueListEnable = function(nearGeoIssueListEnable) 
{
	this.nearGeoIssueListEnable = nearGeoIssueListEnable;
};

API.prototype.getInsertIssueState = function() 
{
	return this.insertIssueState;
};
API.prototype.setInsertIssueState = function(insertIssueState) 
{
	this.insertIssueState = insertIssueState;
};

API.prototype.getDrawType = function() 
{
	return this.drawType;
};
API.prototype.setDrawType = function(drawType) 
{
	this.drawType = drawType;
};

API.prototype.getLod0DistInMeters = function() 
{
	return this.lod0DistInMeters;
};
API.prototype.setLod0DistInMeters = function(lod0DistInMeters) 
{
	this.lod0DistInMeters = lod0DistInMeters;
};
API.prototype.getLod1DistInMeters = function() 
{
	return this.lod1DistInMeters;
};
API.prototype.setLod1DistInMeters = function(lod1DistInMeters) 
{
	this.lod1DistInMeters = lod1DistInMeters;
};
API.prototype.getLod2DistInMeters = function() 
{
	return this.lod2DistInMeters;
};
API.prototype.setLod2DistInMeters = function(lod2DistInMeters) 
{
	this.lod2DistInMeters = lod2DistInMeters;
};
API.prototype.getLod3DistInMeters = function() 
{
	return this.lod3DistInMeters;
};
API.prototype.setLod3DistInMeters = function(lod3DistInMeters) 
{
	this.lod3DistInMeters = lod3DistInMeters;
};
API.prototype.getLod4DistInMeters = function() 
{
	return this.lod4DistInMeters;
};
API.prototype.setLod4DistInMeters = function(lod4DistInMeters) 
{
	this.lod4DistInMeters = lod4DistInMeters;
};
API.prototype.getLod5DistInMeters = function() 
{
	return this.lod5DistInMeters;
};
API.prototype.setLod5DistInMeters = function(lod5DistInMeters) 
{
	this.lod5DistInMeters = lod5DistInMeters;
};

API.prototype.getAmbientReflectionCoef = function() 
{
	return this.ambientReflectionCoef;
};
API.prototype.setAmbientReflectionCoef = function(ambientReflectionCoef) 
{
	this.ambientReflectionCoef = ambientReflectionCoef;
};
API.prototype.getDiffuseReflectionCoef = function() 
{
	return this.diffuseReflectionCoef;
};
API.prototype.setDiffuseReflectionCoef = function(diffuseReflectionCoef) 
{
	this.diffuseReflectionCoef = diffuseReflectionCoef;
};
API.prototype.getSpecularReflectionCoef = function() 
{
	return this.specularReflectionCoef;
};
API.prototype.setSpecularReflectionCoef = function(specularReflectionCoef) 
{
	this.specularReflectionCoef = specularReflectionCoef;
};
API.prototype.getAmbientColor = function() 
{
	return this.ambientColor;
};
API.prototype.setAmbientColor = function(ambientColor) 
{
	this.ambientColor = ambientColor;
};
API.prototype.getSpecularColor = function() 
{
	return this.specularColor;
};
API.prototype.setSpecularColor = function(specularColor) 
{
	this.specularColor = specularColor;
};
API.prototype.getSsaoRadius = function() 
{
	return this.ssaoRadius;
};
API.prototype.setSsaoRadius = function(ssaoRadius) 
{
	this.ssaoRadius = ssaoRadius;
};
API.prototype.getFPVMode = function()
{
	return this.FPVMode;
};
API.prototype.setFPVMode = function(value)
{
	this.FPVMode = value;
};
API.prototype.getMagoMode = function()
{
	return this.magoMode;
};
API.prototype.setMagoMode = function(value)
{
	this.magoMode = value;
};
API.prototype.getDuration = function()
{
	return this.duration;
};
API.prototype.setDuration = function(duration)
{
	this.duration = duration;
};

API.prototype.getInputPoint = function()
{
	return this.inputPoint;
};
API.prototype.setInputPoint = function(inputPoint)
{
	this.inputPoint = inputPoint;
};

API.prototype.getResultPoint = function()
{
	return this.resultPoint;
};
API.prototype.setResultPoint = function(resultPoint)
{
	this.resultPoint = resultPoint;
};

API.prototype.getUnit = function()
{
	return this.unit;
};
API.prototype.setUnit = function(unit)
{
	if (unit !== undefined)
	{
		if (isNaN(unit) || unit > CODE.units.RADIAN)
		{
			throw new Error('unit parameter needs CODE.units');
		}
		this.unit = unit;
	}
};

API.prototype.getInstantiateObj = function()
{
	return this.instantiateObj;
};
API.prototype.setInstantiateObj = function(instantiateObj)
{
	this.instantiateObj = instantiateObj;
};

API.prototype.getStaticModelAttributeObj = function()
{
	return this.staticModelAttributeObj;
};
API.prototype.setStaticModelAttributeObj = function(staticModelAttributeObj)
{
	this.staticModelAttributeObj = staticModelAttributeObj;
};

API.prototype.getAnimationOption = function()
{
	return this.animationOption;
};
API.prototype.setAnimationOption = function(animationOption)
{
	this.animationOption = animationOption;
};
'use strict';

/**
 * 사용자가 변경한 moving, color, rotation 등 이력 정보를 위한 domain
 * @class Policy
 */
var ChangeHistory = function() 
{
	if (!(this instanceof ChangeHistory)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.moveHistory = false;
	this.colorHistory = false;
	this.rotationHistory = false;
	
	// move mode. ALL : 0 , OBJECT : 1, NONE : 2
	this.objectMoveMode = null;
	
	// project id
	this.projectId = null;
	// project data folder
	this.projectDataFolder = null;
	// data_key
	this.dataKey = null;	
	// objectId
	this.objectId = null;
	// objectIndexOrder
	this.objectIndexOrder = 0;
	
	// referenceObject aditional movement.
	this.refObjectAditionalMove;
	this.refObjectAditionalMoveRelToBuilding;
	
	// 위도
	this.latitude = 0.0;
	// 경도
	this.longitude = 0.0;
	// 높이
	this.elevation = 0.0;
	// heading
	this.heading = 0.0;
	// pitch
	this.pitch = 0.0;
	// roll
	this.roll = 0.0;
	// duration
	this.duration = 0;
	// 색깔
	this.color = 0;
	// color rgb
	this.rgbColor = [];
	// 속성
	this.property = null;
	this.propertyKey = null;
	this.propertyValue = null;
};

ChangeHistory.prototype.getReferenceObjectAditionalMovement = function() 
{
	if (this.refObjectAditionalMove === undefined)
	{ this.refObjectAditionalMove = new Point3D(); }
	
	return this.refObjectAditionalMove;
};

ChangeHistory.prototype.getReferenceObjectAditionalMovementRelToBuilding = function() 
{
	if (this.refObjectAditionalMoveRelToBuilding === undefined)
	{ this.refObjectAditionalMoveRelToBuilding = new Point3D(); }
	
	return this.refObjectAditionalMoveRelToBuilding;
};

ChangeHistory.prototype.getProjectId = function() 
{
	return this.projectId;
};
ChangeHistory.prototype.setProjectId = function(projectId) 
{
	this.projectId = projectId;
};

ChangeHistory.prototype.getProjectDataFolder = function() 
{
	return this.projectDataFolder;
};
ChangeHistory.prototype.setProjectDataFolder = function(projectDataFolder) 
{
	this.projectDataFolder = projectDataFolder;
};

ChangeHistory.prototype.getDataKey = function() 
{
	return this.dataKey;
};
ChangeHistory.prototype.setDataKey = function(dataKey) 
{
	this.dataKey = dataKey;
};

ChangeHistory.prototype.getObjectId = function() 
{
	return this.objectId;
};
ChangeHistory.prototype.setObjectId = function(objectId) 
{
	this.objectId = objectId;
};

ChangeHistory.prototype.getObjectIndexOrder = function() 
{
	return this.objectIndexOrder;
};
ChangeHistory.prototype.setObjectIndexOrder = function(objectIndexOrder) 
{
	this.objectIndexOrder = objectIndexOrder;
};

ChangeHistory.prototype.getLatitude = function() 
{
	return this.latitude;
};
ChangeHistory.prototype.setLatitude = function(latitude) 
{
	this.latitude = latitude;
};

ChangeHistory.prototype.getLongitude = function() 
{
	return this.longitude;
};
ChangeHistory.prototype.setLongitude = function(longitude) 
{
	this.longitude = longitude;
};

ChangeHistory.prototype.getElevation = function() 
{
	return this.elevation;
};
ChangeHistory.prototype.setElevation = function(elevation) 
{
	this.elevation = elevation;
};

ChangeHistory.prototype.getHeading = function() 
{
	return this.heading;
};
ChangeHistory.prototype.setHeading = function(heading) 
{
	this.heading = heading;
};

ChangeHistory.prototype.getPitch = function() 
{
	return this.pitch;
};
ChangeHistory.prototype.setPitch = function(pitch) 
{
	this.pitch = pitch;
};

ChangeHistory.prototype.getRoll = function() 
{
	return this.roll;
};
ChangeHistory.prototype.setRoll = function(roll) 
{
	this.roll = roll;
};

ChangeHistory.prototype.getColor = function() 
{
	return this.color;
};
ChangeHistory.prototype.setColor = function(color) 
{
	this.color = color;
};
ChangeHistory.prototype.getRgbColor = function() 
{
	return this.rgbColor;
};
ChangeHistory.prototype.setRgbColor = function(rgbColor) 
{
	this.rgbColor = rgbColor;
};

ChangeHistory.prototype.getProperty = function() 
{
	return this.property;
};
ChangeHistory.prototype.setProperty = function(property) 
{
	this.property = property;
};
ChangeHistory.prototype.getPropertyKey = function() 
{
	return this.propertyKey;
};
ChangeHistory.prototype.setPropertyKey = function(propertyKey) 
{
	this.propertyKey = propertyKey;
};
ChangeHistory.prototype.getPropertyValue = function() 
{
	return this.propertyValue;
};
ChangeHistory.prototype.setPropertyValue = function(propertyValue) 
{
	this.propertyValue = propertyValue;
};

ChangeHistory.prototype.getDuration = function()
{
	return this.duration;
};
ChangeHistory.prototype.setDuration = function(duration)
{
	this.duration = duration;
};

ChangeHistory.prototype.getObjectMoveMode = function() 
{
	return this.objectMoveMode;
};
ChangeHistory.prototype.setObjectMoveMode = function(objectMoveMode) 
{
	this.objectMoveMode = objectMoveMode;
};
"use strict";

var CODE = {};

// magoManager가 다 로딩 되지 않은 상태에서 화면으로 부터 호출 되는 것을 막기 위해
CODE.magoManagerState = {
	"INIT"   	: 0,
	"STARTED"	: 1,
	"READY"   : 2
};

//0 = no started to load. 1 = started loading. 2 = finished loading. 3 = parse started. 4 = parse finished.
CODE.fileLoadState = {
	"READY"            : 0,
	"LOADING_STARTED"  : 1,
	"LOADING_FINISHED" : 2,
	"PARSE_STARTED"    : 3,
	"PARSE_FINISHED"   : 4,
	"IN_QUEUE"         : 5,
	"LOAD_FAILED"      : 6
};

CODE.moveMode = {
	"ALL"              : "0",
	"OBJECT"           : "1",
	"GEOGRAPHICPOINTS" : "2",
	"NONE"             : "3"
};

CODE.magoMode = {
	"NORMAL"  : 0,
	"DRAWING" : 1
};

CODE.modelerMode = {
	"INACTIVE"                 : 0,
	"DRAWING_POLYLINE"         : 1,
	"DRAWING_PLANEGRID"        : 2,
	"DRAWING_GEOGRAPHICPOINTS" : 3,
	"DRAWING_EXCAVATIONPOINTS" : 4,
	"DRAWING_TUNNELPOINTS"     : 5,
	"DRAWING_STATICGEOMETRY"   : 6
};

CODE.modelerDrawingState = {
	"NO_STARTED" : 0,
	"STARTED"    : 1
};

CODE.modelerDrawingElement = {
	"NOTHING"          : 0,
	"POINTS"           : 1,
	"LINES"            : 2,
	"POLYLINES"        : 3,
	"GEOGRAPHICPOINTS" : 4,
};

CODE.units = {
	"METRE"  : 0,
	"DEGREE" : 1,
	"RADIAN" : 2
};

CODE.PROJECT_ID_PREFIX = "projectId_";
CODE.PROJECT_DATA_FOLDER_PREFIX = "projectDataFolder_";

'use strict';

/**
 * 상수 설정
 * @class Constant
 */
var Constant = {};

Constant.CESIUM = "cesium";
Constant.WORLDWIND = "worldwind";
Constant.MAGOWORLD = "magoworld";
Constant.OBJECT_INDEX_FILE = "/objectIndexFile.ihe";
Constant.CACHE_VERSION = "?cache_version=";
Constant.SIMPLE_BUILDING_TEXTURE3x3_BMP = "/SimpleBuildingTexture3x3.bmp";
Constant.RESULT_XDO2F4D = "/Result_xdo2f4d/Images/";
Constant.RESULT_XDO2F4D_TERRAINTILES = "/Result_xdo2f4d/F4D_TerrainTiles/";
Constant.RESULT_XDO2F4D_TERRAINTILEFILE_TXT = "/Result_xdo2f4d/f4dTerranTileFile.txt";

Constant.INTERSECTION_OUTSIDE = 0;
Constant.INTERSECTION_INTERSECT= 1;
Constant.INTERSECTION_INSIDE = 2;
Constant.INTERSECTION_POINT_A = 3;
Constant.INTERSECTION_POINT_B = 4;

'use strict';

/**
 * mago3D 전체 환경 설정을 관리
 * @class MagoConfig
 */
var MagoConfig = {};

MagoConfig.getPolicy = function() 
{
	return this.serverPolicy;
};

MagoConfig.getData = function(key) 
{
	return this.dataObject[key];
};

MagoConfig.isDataExist = function(key) 
{
	return this.dataObject.hasOwnProperty(key);
};

MagoConfig.deleteData = function(key) 
{
	return delete this.dataObject[key];
};

/**
 * data 를 map에 저장
 * @param key map에 저장될 key
 * @param value map에 저장될 value
 */
MagoConfig.setData = function(key, value) 
{
	if (!this.isDataExist(key)) 
	{
		this.dataObject[key] = value;
	}
};

/**
 * F4D Converter 실행 결과물이 저장된 project data folder 명을 획득
 * @param projectDataFolder data folder
 */
MagoConfig.getProjectDataFolder = function(projectDataFolder) 
{
	var key = CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder;
	return this.dataObject[key];
};

/**
 * project map에 data folder명의 존재 유무를 검사
 * @param projectDataFolder
 */
MagoConfig.isProjectDataFolderExist = function(projectDataFolder) 
{
	var key = CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder;
	return this.dataObject.hasOwnProperty(key);
};

/**
 * project data folder명을 map에서 삭제
 * @param projectDataFolder
 */
MagoConfig.deleteProjectDataFolder = function(projectDataFolder) 
{
	var key = CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder;
	return delete this.dataObject[key];
};

/**
 * project data folder명을 Object에서 삭제
 * @param projectDataFolder Object에 저장될 key
 * @param value Object에 저장될 value
 */
MagoConfig.setProjectDataFolder = function(projectDataFolder, value) 
{
	var key = CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder;
	if (!this.isProjectDataFolderExist(key))
	{
		this.dataObject[key] = value;
	}
};

/**
 * 환경설정 초기화
 * @param serverPolicy mago3d policy(json)
 * @param projectIdArray data 정보를 map 저장할 key name
 * @param projectDataArray data 정보(json)
 */
MagoConfig.init = function(serverPolicy, projectIdArray, projectDataArray) 
{
	this.dataObject = {};
	
	this.selectHistoryObject = {};
	this.movingHistoryObject = {};
	this.colorHistoryObject = {};
	this.locationAndRotationHistoryObject = {};
	
	this.serverPolicy = serverPolicy;
	if (projectIdArray !== null && projectIdArray.length > 0) 
	{
		for (var i=0; i<projectIdArray.length; i++) 
		{
			if (!this.isDataExist(CODE.PROJECT_ID_PREFIX + projectIdArray[i])) 
			{
				this.setData(CODE.PROJECT_ID_PREFIX + projectIdArray[i], projectDataArray[i]);
				this.setProjectDataFolder(CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataArray[i].data_key, projectDataArray[i].data_key);
			}
		}
	}
};

/**
 * 모든 데이터를 삭제함
 */
MagoConfig.clearAllData = function() 
{
	this.dataObject = {};
};

/**
 * 모든 선택 히스토리 삭제
 */
MagoConfig.clearSelectHistory = function() 
{
	this.selectHistoryObject = {};
};

/**
 * 모든 object 선택 내용 이력을 취득
 */
MagoConfig.getAllSelectHistory = function()
{
	return this.selectHistoryObject;
};

/**
 * project 별 해당 키에 해당하는 모든 object 선택 내용 이력을 취득
 */
MagoConfig.getSelectHistoryObjects = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.selectHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	return dataKeyObject;
};

/**
 * object 선택 내용 이력을 취득
 */
MagoConfig.getSelectHistoryObject = function(projectId, dataKey, objectIndexOrder)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.selectHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return dataKeyObject[objectIndexOrder];
};

/**
 * object 선택 내용을 저장
 */
MagoConfig.saveSelectHistory = function(projectId, dataKey, objectIndexOrder, changeHistory) 
{
	// projectId 별 Object을 검사
	var projectIdObject = this.selectHistoryObject.get(projectId);
	if (projectIdObject === undefined)
	{
		projectIdObject = {};
		this.selectHistoryObject[projectId] = projectIdObject;
	}
	
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined)
	{
		dataKeyObject = {};
		projectIdObject[dataKey] = dataKeyObject;
	}
	
	// objectIndexOrder 를 저장
	dataKeyObject[objectIndexOrder] = changeHistory;
};

/**
 * object 선택 내용을 삭제
 */
MagoConfig.deleteSelectHistoryObject = function(projectId, dataKey, objectIndexOrder)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.selectHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return delete dataKeyObject[objectIndexOrder];
};

/**
 * 모든 이동 히스토리 삭제
 */
MagoConfig.clearMovingHistory = function() 
{
	this.movingHistoryObject = {};
};

/**
 * 모든 object 선택 내용 이력을 취득
 */
MagoConfig.getAllMovingHistory = function()
{
	return this.movingHistoryObject;
};

/**
 * project별 입력키 값과 일치하는 object 이동 내용 이력을 취득
 */
MagoConfig.getMovingHistoryObjects = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.movingHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	return dataKeyObject;
};

/**
 * object 이동 내용 이력을 취득
 */
MagoConfig.getMovingHistoryObject = function(projectId, dataKey, objectIndexOrder)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.movingHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return dataKeyObject[objectIndexOrder];
};

/**
 * object 이동 내용을 저장
 */
MagoConfig.saveMovingHistory = function(projectId, dataKey, objectIndexOrder, changeHistory) 
{
	// projectId 별 Object을 검사
	var projectIdObject = this.movingHistoryObject[projectId];
	if (projectIdObject === undefined)
	{
		projectIdObject = {};
		this.movingHistoryObject[projectId] = projectIdObject;
	}
	
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined)
	{
		dataKeyObject = {};
		projectIdObject[dataKey] = dataKeyObject;
	}
	
	// objectIndexOrder 를 저장
	dataKeyObject[objectIndexOrder] = changeHistory;
};

/**
 * object 이동 내용을 삭제
 */
MagoConfig.deleteMovingHistoryObject = function(projectId, dataKey, objectIndexOrder)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.movingHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return delete dataKeyObject[objectIndexOrder];
};

/**
 * 모든 색깔 변경 이력을 획득
 */
MagoConfig.getAllColorHistory = function() 
{
	return this.colorHistoryObject;
};

/**
 * 모든 색깔변경 히스토리 삭제
 */
MagoConfig.clearColorHistory = function() 
{
	this.colorHistoryObject = {};
};

/**
 * project별 키에 해당하는 모든 색깔 변경 이력을 획득
 */
MagoConfig.getColorHistorys = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.colorHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	return dataKeyObject;
};

/**
 * 색깝 변경 이력을 획득
 */
MagoConfig.getColorHistory = function(projectId, dataKey, objectId)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.colorHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectId 를 저장
	return dataKeyObject[objectId];
};

/**
 * 색깝 변경 내용을 저장
 */
MagoConfig.saveColorHistory = function(projectId, dataKey, objectId, changeHistory) 
{
	// projectId 별 Object을 검사
	var projectIdObject = this.colorHistoryObject[projectId];
	if (projectIdObject === undefined)
	{
		projectIdObject = {};
		this.colorHistoryObject[projectId] = projectIdObject;
	}
	
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined)
	{
		dataKeyObject = {};
		projectIdObject[dataKey] = dataKeyObject;
	}

	if (objectId === null || objectId === "") 
	{
		dataKeyObject[dataKey] = changeHistory;
	}
	else 
	{
		dataKeyObject[objectId] = changeHistory;
	}
};

/**
 * 색깔 변경 이력을 삭제
 */
MagoConfig.deleteColorHistory = function(projectId, dataKey, objectId)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.colorHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return delete dataKeyObject[objectId];
};

/**
 * 모든 색깔변경 히스토리 삭제
 */
MagoConfig.clearColorHistory = function() 
{
	this.colorHistoryObject = {};
};

/**
 * 모든 location and rotation 변경 이력을 획득
 */
MagoConfig.getAllLocationAndRotationHistory = function() 
{
	return this.locationAndRotationHistoryObject;
};

/**
 * 프로젝트별 해당 키 값을 갖는 모든 location and rotation 이력을 획득
 */
MagoConfig.getLocationAndRotationHistorys = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.locationAndRotationHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	return dataKeyObject;
};

/**
 * location and rotation 이력을 획득
 */
MagoConfig.getLocationAndRotationHistory = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.locationAndRotationHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	
	return dataKeyObject;
};

/**
 * location and rotation 내용을 저장
 */
MagoConfig.saveLocationAndRotationHistory = function(projectId, dataKey, changeHistory) 
{
	// projectId 별 Object을 검사
	var projectIdObject = this.locationAndRotationHistoryObject[projectId];
	if (projectIdObject === undefined)
	{
		projectIdObject = {};
		this.locationAndRotationHistoryObject[projectId] = projectIdObject;
	}
	
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined)
	{
		dataKeyObject = {};
	}

	dataKeyObject[dataKey] = changeHistory;
};

/**
 * location and rotation 이력을 삭제
 */
MagoConfig.deleteLocationAndRotationHistory = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.locationAndRotationHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = delete projectIdObject[dataKey];
};

/**
 * 모든 location and rotation 히스토리 삭제
 */
MagoConfig.clearLocationAndRotationHistory = function() 
{
	this.locationAndRotationHistoryObject = {};
};
	
/**
 * TODO 이건 나중에 활요. 사용하지 않음
 * check 되지 않은 데이터들을 삭제함
 * @param keyObject 비교할 맵
 */
/*MagoConfig.clearUnSelectedData = function(keyObject)
{
	for (var key of this.dataObject.keys())
	{
		if (!keyObject.hasxxxxx(key))
		{
			// data folder path가 존재하면....
			if (key.indexOf(CODE.PROJECT_DATA_FOLDER_PREFIX) >= 0) 
			{
				// 지우는 처리가 있어야 함
			}
			this.dataObject.delete(key);
		}
	}
};*/

'use strict';

/**
 * Policy
 * @class Policy
 */
var Policy = function() 
{
	if (!(this instanceof Policy)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// mago3d 활성화/비활성화 여부
	this.magoEnable = true;

	// outfitting 표시 여부
	this.showOutFitting = false;
	// label 표시/비표시
	this.showLabelInfo = false;
	// boundingBox 표시/비표시
	this.showBoundingBox = false;
	// 그림자 표시/비표시
	this.showShadow = false;
	// squared far frustum 거리
	this.frustumFarSquaredDistance = 5000000;
	// far frustum
	this.frustumFarDistance = 20000;

	// highlighting
	this.highLightedBuildings = [];
	// color
	this.colorBuildings = [];
	// color
	this.color = [];
	// show/hide
	this.hideBuildings = [];
	// move mode
	this.objectMoveMode = CODE.moveMode.NONE;
	// 이슈 등록 표시
	this.issueInsertEnable = false;
	// object 정보 표시
	this.objectInfoViewEnable = false;
	// 이슈 목록 표시
	this.nearGeoIssueListEnable = false;
	// occlusion culling
	this.occlusionCullingEnable = false;
	// origin axis XYZ
	this.showOrigin = false;
	// mago generalMode
	this.magoMode = CODE.magoMode.NORMAL;
	
	// 이미지 경로
	this.imagePath = "";
	
	// provisional.
	this.colorChangedObjectId;
	
	// LOD1
	this.lod0DistInMeters = 15;
	this.lod1DistInMeters = 50;
	this.lod2DistInMeters = 90;
	this.lod3DistInMeters = 200;
	this.lod4DistInMeters = 1000;
	this.lod5DistInMeters = 50000;
	
	// Lighting
	this.ambientReflectionCoef = 0.45; // 0.2.
	this.diffuseReflectionCoef = 0.75; // 1.0
	this.specularReflectionCoef = 0.6; // 0.7
	this.ambientColor = null;
	this.specularColor = new Float32Array([0.6, 0.6, 0.6]);
	
	this.ssaoRadius = 0.15;
	
	// PointsCloud.
	this.pointsCloudSettings = {};
	this.pointsCloudSettings.maxPartitionsLod0 = 8;
	this.pointsCloudSettings.maxPartitionsLod1 = 4;
	this.pointsCloudSettings.maxPartitionsLod2orLess = 1;
	this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam0m = 1.0;
	this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam100m = 1.0/6.0;
	this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam200m = 1.0/12.0;
	this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam400m = 1.0/24.0;
	this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam800m = 1.0/48.0;
	this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam1600m = 1.0/128.0;
	this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCamMoreThan1600m = 1.0/256.0;
	
};

Policy.prototype.getPointsCloudSettings = function() 
{
	return this.pointsCloudSettings;
};

Policy.prototype.getShowOrigin = function() 
{
	return this.showOrigin;
};
Policy.prototype.setShowOrigin = function(showOrigin) 
{
	this.showOrigin = showOrigin;
};

Policy.prototype.getMagoEnable = function() 
{
	return this.magoEnable;
};
Policy.prototype.setMagoEnable = function(magoEnable) 
{
	this.magoEnable = magoEnable;
};

Policy.prototype.getShowOutFitting = function() 
{
	return this.showOutFitting;
};
Policy.prototype.setShowOutFitting = function(showOutFitting) 
{
	this.showOutFitting = showOutFitting;
};
Policy.prototype.getShowLabelInfo = function() 
{
	return this.showLabelInfo;
};
Policy.prototype.setShowLabelInfo = function(showLabelInfo) 
{
	this.showLabelInfo = showLabelInfo;
};
Policy.prototype.getShowBoundingBox = function() 
{
	return this.showBoundingBox;
};
Policy.prototype.setShowBoundingBox = function(showBoundingBox) 
{
	this.showBoundingBox = showBoundingBox;
};

Policy.prototype.getShowShadow = function() 
{
	return this.showShadow;
};
Policy.prototype.setShowShadow = function(showShadow) 
{
	this.showShadow = showShadow;
};

Policy.prototype.getFrustumFarSquaredDistance = function() 
{
	return this.frustumFarSquaredDistance;
};
Policy.prototype.setFrustumFarSquaredDistance = function(frustumFarSquaredDistance) 
{
	this.frustumFarSquaredDistance = frustumFarSquaredDistance;
};

Policy.prototype.getFrustumFarDistance = function() 
{
	return this.frustumFarDistance;
};
Policy.prototype.setFrustumFarDistance = function(frustumFarDistance) 
{
	this.frustumFarDistance = frustumFarDistance;
};

Policy.prototype.getHighLightedBuildings = function() 
{
	return this.highLightedBuildings;
};
Policy.prototype.setHighLightedBuildings = function(highLightedBuildings) 
{
	this.highLightedBuildings = highLightedBuildings;
};

Policy.prototype.getColorBuildings = function() 
{
	return this.colorBuildings;
};
Policy.prototype.setColorBuildings = function(colorBuildings) 
{
	this.colorBuildings = colorBuildings;
};

Policy.prototype.getColor = function() 
{
	return this.color;
};
Policy.prototype.setColor = function(color) 
{
	this.color = color;
};

Policy.prototype.getHideBuildings = function() 
{
	return this.hideBuildings;
};
Policy.prototype.setHideBuildings = function(hideBuildings) 
{
	this.hideBuildings = hideBuildings;
};

Policy.prototype.getObjectMoveMode = function() 
{
	return this.objectMoveMode;
};
Policy.prototype.setObjectMoveMode = function(objectMoveMode) 
{
	this.objectMoveMode = objectMoveMode;
};

Policy.prototype.getMagoMode = function() 
{
	return this.magoMode;
};
Policy.prototype.setMagoMode = function(magoMode) 
{
	this.magoMode = magoMode;
};

Policy.prototype.getIssueInsertEnable = function() 
{
	return this.issueInsertEnable;
};
Policy.prototype.setIssueInsertEnable = function(issueInsertEnable) 
{
	this.issueInsertEnable = issueInsertEnable;
};
Policy.prototype.getObjectInfoViewEnable = function() 
{
	return this.objectInfoViewEnable;
};
Policy.prototype.setObjectInfoViewEnable = function(objectInfoViewEnable) 
{
	this.objectInfoViewEnable = objectInfoViewEnable;
};
Policy.prototype.getOcclusionCullingEnable = function() 
{
	return this.occlusionCullingEnable;
};
Policy.prototype.setOcclusionCullingEnable = function(occlusionCullingEnable) 
{
	this.occlusionCullingEnable = occlusionCullingEnable;
};
Policy.prototype.getNearGeoIssueListEnable = function() 
{
	return this.nearGeoIssueListEnable;
};
Policy.prototype.setNearGeoIssueListEnable = function(nearGeoIssueListEnable) 
{
	this.nearGeoIssueListEnable = nearGeoIssueListEnable;
};

Policy.prototype.getImagePath = function() 
{
	return this.imagePath;
};
Policy.prototype.setImagePath = function(imagePath) 
{
	this.imagePath = imagePath;
};

Policy.prototype.getLod = function(distInMeters) 
{
	var lod = -1;
	if (distInMeters < this.lod0DistInMeters)
	{ lod = 0; }
	else if (distInMeters < this.lod1DistInMeters)
	{ lod = 1; }
	else if (distInMeters < this.lod2DistInMeters)
	{ lod = 2; }
	else if (distInMeters < this.lod3DistInMeters)
	{ lod = 3; }
	else if (distInMeters < this.lod4DistInMeters)
	{ lod = 4; }
	else 
	{ lod = 5; }
	
	return lod;	
};
Policy.prototype.getLod0DistInMeters = function() 
{
	return this.lod0DistInMeters;
};
Policy.prototype.setLod0DistInMeters = function(lod0DistInMeters) 
{
	this.lod0DistInMeters = lod0DistInMeters;
};
Policy.prototype.getLod1DistInMeters = function() 
{
	return this.lod1DistInMeters;
};
Policy.prototype.setLod1DistInMeters = function(lod1DistInMeters) 
{
	this.lod1DistInMeters = lod1DistInMeters;
};
Policy.prototype.getLod2DistInMeters = function() 
{
	return this.lod2DistInMeters;
};
Policy.prototype.setLod2DistInMeters = function(lod2DistInMeters) 
{
	this.lod2DistInMeters = lod2DistInMeters;
};
Policy.prototype.getLod3DistInMeters = function() 
{
	return this.lod3DistInMeters;
};
Policy.prototype.setLod3DistInMeters = function(lod3DistInMeters) 
{
	this.lod3DistInMeters = lod3DistInMeters;
};
Policy.prototype.getLod4DistInMeters = function() 
{
	return this.lod4DistInMeters;
};
Policy.prototype.setLod4DistInMeters = function(lod4DistInMeters) 
{
	this.lod4DistInMeters = lod4DistInMeters;
};
Policy.prototype.getLod5DistInMeters = function() 
{
	return this.lod5DistInMeters;
};
Policy.prototype.setLod5DistInMeters = function(lod5DistInMeters) 
{
	this.lod5DistInMeters = lod5DistInMeters;
};
Policy.prototype.getAmbientReflectionCoef = function() 
{
	return this.ambientReflectionCoef;
};
Policy.prototype.setAmbientReflectionCoef = function(ambientReflectionCoef) 
{
	this.ambientReflectionCoef = ambientReflectionCoef;
};
Policy.prototype.getDiffuseReflectionCoef = function() 
{
	return this.diffuseReflectionCoef;
};
Policy.prototype.setDiffuseReflectionCoef = function(diffuseReflectionCoef) 
{
	this.diffuseReflectionCoef = diffuseReflectionCoef;
};
Policy.prototype.getSpecularReflectionCoef = function() 
{
	return this.specularReflectionCoef;
};
Policy.prototype.setSpecularReflectionCoef = function(specularReflectionCoef) 
{
	this.specularReflectionCoef = specularReflectionCoef;
};
Policy.prototype.getAmbientColor = function() 
{
	return this.ambientColor;
};
Policy.prototype.setAmbientColor = function(ambientColor) 
{
	this.ambientColor = ambientColor;
};
Policy.prototype.getSpecularColor = function() 
{
	return this.specularColor;
};
Policy.prototype.setSpecularColor = function(specularColor) 
{
	this.specularColor = specularColor;
};
Policy.prototype.getSsaoRadius = function() 
{
	return this.ssaoRadius;
};
Policy.prototype.setSsaoRadius = function(ssaoRadius) 
{
	this.ssaoRadius = ssaoRadius;
};
'use strict';

/**
 * 버퍼 안의 데이터를 어떻게 읽어야 할지 키가 되는 객체
 * @deprecated NeoSimpleBuilding에서 인스턴스 생성하는 부분이 있으나 NeoSimpleBuilding도 사용하지 않고 있음
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @alias Accessor
 * @class Accessor
 */
var Accessor = function () 
{

	if (!(this instanceof Accessor)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.bufferId;
	// 0= position, 1= normal, 2= color, 3= texcoord.
	this.accesorType;
	this.bufferStart;
	// 버퍼의 시작 시점
	this.stride;
	// character, int 등
	this.dataType;
	// 2차원, 3차원
	this.dimension;

	// 데이터가 포함되어 있는 x,y,z의 한계를 바운드라고 한다. 바운드 좌표
	this.minX = 0.0;
	this.minY = 0.0;
	this.minZ = 0.0;
	this.maxX = 0.0;
	this.maxY = 0.0;
	this.maxZ = 0.0;
};

'use strict';

/**
 * 블럭 모델
 * 
 * @class Block
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 아래 문서의 1.3 Models Folder의 항목 참조
 * @link https://github.com/Gaia3D/F4DConverter/blob/master/doc/F4D_SpecificationV1.pdf
 */
var Block = function() 
{
	if (!(this instanceof Block)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * This has "VertexIdxVBOArraysContainer" because the "indices" cannot to be greater than 65000, because indices are short type.
	 * Change this for "vbo_VertexIdx_CacheKeys_Container__idx"
	 * @type {VBOVertexIdxCacheKeysContainer}
	 */
	this.vBOVertexIdxCacheKeysContainer = new VBOVertexIdxCacheKeysContainer();

	/**
	 * @deprecated
	 * @type {number}
	 * @default -1
	 */
	this.mIFCEntityType = -1;

	/**
	 * small object flag. 
	 * if bbox.getMaxLength() < 0.5, isSmallObj = true
	 * 
	 * @type {Boolean} 
	 * @default false
	 */
	this.isSmallObj = false;

	/**
	 * block radius
	 * 일반적으로 bbox.getMaxLength() / 2.0 로 선언됨.
	 * 
	 * @type {Boolean} 
	 * @default 10
	 */
	this.radius = 10;

	/**
	 * only for test.delete this.
	 * @deprecated
	 */
	this.vertexCount = 0;

	/**
	 * 각각의 사물중 복잡한 모델이 있을 경우 Lego로 처리
	 * 현재는 사용하지 않으나 추후에 필요할 수 있어서 그대로 둠.
	 * legoBlock.
	 * @type {Lego}
	 */
	this.lego;
};

/**
 * block 초기화. gl에서 해당 block 및 lego 삭제
 * 
 * @param {WebGLRenderingContext} gl 
 * @param {VboManager} vboMemManager 
 */
Block.prototype.deleteObjects = function(gl, vboMemManager) 
{
	this.vBOVertexIdxCacheKeysContainer.deleteGlObjects(gl, vboMemManager);
	this.vBOVertexIdxCacheKeysContainer = undefined;
	this.mIFCEntityType = undefined;
	this.isSmallObj = undefined;
	this.radius = undefined;
	// only for test. delete this.
	this.vertexCount = undefined;

	if (this.lego) { this.lego.deleteGlObjects(gl); }

	this.lego = undefined;
};

/**
 * render할 준비가 됬는지 체크
 * 
 * @param {NeoReference} neoReference magoManager의 objectSelected와 비교 하기 위한 neoReference 객체
 * @param {MagoManager} magoManager 
 * @param {Number} maxSizeToRender block의 radius와 비교하기 위한 ref number.
 * @returns {Boolean} block의 radius가 maxSizeToRender보다 크고, block의 radius가 magoManager의 보다 크고, 카메라가 움직이고 있지 않고, magoManager의 objectSelected와 neoReference가 같을 경우 true 반환
 */ 
Block.prototype.isReadyToRender = function(neoReference, magoManager, maxSizeToRender) 
{
	if (maxSizeToRender && (this.radius < maxSizeToRender))
	{ return false; }
	
	if (magoManager.isCameraMoving && this.radius < magoManager.smallObjectSize && magoManager.objectSelected !== neoReference)
	{ return false; }

	return true;
};

'use strict';

/**
 * 블록의 내용이 엄청 많아서 나눠서 받아야 할 경우 사용하기 위한 객체. 현재는 미구현 상태. 추후 f4d v0.0.2 이상부터 적용 될 예정
 * 
 * @class BlocksArrayPartition
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 */
var BlocksArrayPartition = function(version) 
{
	if (!(this instanceof BlocksArrayPartition)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// 0 = no started to load. 1 = started loading. 2 = finished loading. 3 = parse started. 4 = parse finished.
	this.fileLoadState = CODE.fileLoadState.READY;
	this.dataArraybuffer; // file loaded data, that is no parsed yet.

};
'use strict';

/**
 * 블록 리스트 객체
 * - 이 클래스는 Octree 클래스의 prepareModelReferencesListData 호출 통해 생성된다
 * 
 * @class BlocksList
 * 
 * @param {String} version
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @see Octree#prepareModelReferencesListData
 */
var BlocksList = function(version) 
{
	if (!(this instanceof BlocksList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * 블록 리스트 명
	 * @type {String}
	 * @default ''
	 */
	this.name = "";

	/**
	 * f4d 버전
	 * @type {String}
	 */
	this.version = version || "";

	/**
	 * 블락 리스트
	 * @type {Block[]}
	 */
	this.blocksArray;

	/**
	 *  block file load state. Default is 0(READY)
	 * "READY"            : 0,
	 * "LOADING_STARTED"  : 1,
	 * "LOADING_FINISHED" : 2,
	 * "PARSE_STARTED"    : 3,
	 * "PARSE_FINISHED"   : 4,
	 * "IN_QUEUE"         : 5,
	 * "LOAD_FAILED"      : 6
	 * @type {Number}
	 * 
	 * @see CODE#fileLoadState
	 */
	this.fileLoadState = CODE.fileLoadState.READY;

	/**
	 * block data array buffer.
	 * file loaded data, that is no parsed yet.
	 * @type {ArrayBuffer}
	 */
	this.dataArraybuffer;

	/**
	 * file request.
	 */
	this.xhr;
	
	/**
	 * BlocksArrayPartition 리스트 관련 변수들.
	 * f4d 버전 0.0.2 이후 부터 사용 계획있음 현재는 개발중
	 */
	this.blocksArrayPartitionsCount;
	this.blocksArrayPartitionsArray;
	this.blocksArrayPartitionsMasterPathName;
};

/**
 * 새 블록 생성 후 blocksArray에 푸쉬 및 반환
 * 
 * @returns {Block}
 */
BlocksList.prototype.newBlock = function() 
{
	if (this.blocksArray === undefined) { this.blocksArray = []; }

	var block = new Block();
	this.blocksArray.push(block);
	return block;
};

/**
 * 인덱스에 해당하는 블록 획득
 * @param {Number} idx
 * @returns {Block|null}
 */
BlocksList.prototype.getBlock = function(idx) 
{
	if (this.blocksArray === undefined) { return null; }

	if (idx >= 0 && idx < this.blocksArray.length) 
	{
		return this.blocksArray[idx];
	}
	return null;
};

/**
 * 블록 리스트 초기화. gl에서 해당 블록 리스트의 블록 및 lego 삭제
 * 
 * @param {WebGLRenderingContext} gl 
 * @param {VboManager} vboMemManager 
 */
BlocksList.prototype.deleteGlObjects = function(gl, vboMemManager) 
{
	if (this.xhr !== undefined)
	{
		this.xhr.abort();
		this.xhr = undefined;
	}
	
	if (this.blocksArray === undefined) { return; }

	for (var i = 0, blocksCount = this.blocksArray.length; i < blocksCount; i++ ) 
	{
		var block = this.blocksArray[i];
		block.vBOVertexIdxCacheKeysContainer.deleteGlObjects(gl, vboMemManager);
		block.vBOVertexIdxCacheKeysContainer = undefined; // Change this for "vbo_VertexIdx_CacheKeys_Container__idx".
		block.mIFCEntityType = undefined;
		block.isSmallObj = undefined;
		block.radius = undefined;
		block.vertexCount = undefined; // only for test. delete this.
		if (block.lego) 
		{
			block.lego.vbo_vicks_container.deleteGlObjects(gl, vboMemManager);
			block.lego.vbo_vicks_container = undefined;
		}
		block.lego = undefined; // legoBlock.
		this.blocksArray[i] = undefined;
	}
	this.blocksArray = undefined;
	this.name = undefined;
	this.fileLoadState = undefined;
	this.dataArraybuffer = undefined; // file loaded data, that is no parsed yet.
};

/**
 * 사용하지 않는 부분들 계산하기 위한 파싱과정. stepOver
 * 파싱을 위한 파싱..
 * 블록리스트 버퍼를 파싱(비대칭적)하는 과정.
 * F4D 버전이 0.0.1일 경우 사용
 * This function parses the geometry data from binary arrayBuffer.
 * 
 * @param {ArrayBuffer} arrayBuffer Binary data to parse.
 * @param {Number} bytesReaded readed bytes.
 * @param {ReaderWriter} readWriter Helper to read inside of the arrayBuffer.
 */
BlocksList.prototype.stepOverBlockVersioned = function(arrayBuffer, bytesReaded, readWriter) 
{
	var vertexCount;
	var verticesFloatValuesCount;
	var normalByteValuesCount;
	var shortIndicesValuesCount;
	var sizeLevels;
	var startBuff, endBuff;
	
	// Spec document Table 3-1
	// vboCount
	var vboDatasCount = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4);
	bytesReaded += 4;
	for ( var j = 0; j < vboDatasCount; j++ ) 
	{
		// 1) Positions array.
		// Spec document Table 3-2
		// vertexCount
		vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);bytesReaded += 4;
		verticesFloatValuesCount = vertexCount * 3;
		startBuff = bytesReaded;
		endBuff = bytesReaded + 4 * verticesFloatValuesCount;
		bytesReaded = bytesReaded + 4 * verticesFloatValuesCount; // updating data.

		// 2) Normals.
		// Spec document Table 3-2
		// normalCount
		vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);bytesReaded += 4;
		normalByteValuesCount = vertexCount * 3;
		bytesReaded = bytesReaded + 1 * normalByteValuesCount; // updating data.

		// 3) Indices.
		// Spec document Table 3-2
		// indexCount
		shortIndicesValuesCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);bytesReaded += 4;
		sizeLevels = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1);bytesReaded += 1;
		bytesReaded = bytesReaded + sizeLevels * 4;
		bytesReaded = bytesReaded + sizeLevels * 4;
		bytesReaded = bytesReaded + 2 * shortIndicesValuesCount; // updating data.
	}
	
	return bytesReaded;
};

/**
 * 블록리스트 버퍼를 파싱(비대칭적)
 * vboData 파싱 부분
 * Spec document Table 3-1
 * This function parses the geometry data from binary arrayBuffer.
 * 
 * @param {ArrayBuffer} arrayBuffer Binary data to parse.
 * @param {Number} bytesReaded 지금까지 읽은 바이트 길이
 * @param {Block} block 정보를 담을 block.
 * @param {ReaderWriter} readWriter
 * @param {MagoManager} magoManager
 * 
 * @see VBOVertexIdxCacheKey#readPosNorIdx
 */
BlocksList.prototype.parseBlockVersioned = function(arrayBuffer, bytesReaded, block, readWriter, magoManager) 
{
	var vboMemManager = magoManager.vboMemoryManager;
	var vboDatasCount = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
	for ( var j = 0; j < vboDatasCount; j++ ) 
	{
		var vboViCacheKey = block.vBOVertexIdxCacheKeysContainer.newVBOVertexIdxCacheKey();
		bytesReaded = vboViCacheKey.readPosNorIdx(arrayBuffer, readWriter, vboMemManager, bytesReaded);
		block.vertexCount = vboViCacheKey.vertexCount;
	}
	
	return bytesReaded;
};

/**
 * 블록리스트 버퍼를 파싱(비대칭적)
 * F4D 버전이 0.0.1일 경우 사용
 * This function parses the geometry data from binary arrayBuffer.
 * 
 * @param {ArrayBuffer} arrayBuffer Binary data to parse.
 * @param {ReaderWriter} readWriter Helper to read inside of the arrayBuffer.
 * @param {Array.<Block>} motherBlocksArray Global blocks array.
 * @param {MagoManager} magoManager
 */
BlocksList.prototype.parseBlocksListVersioned_v001 = function(arrayBuffer, readWriter, motherBlocksArray, magoManager) 
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;
	var bytesReaded = 0;
	var succesfullyGpuDataBinded = true;
	
	// read the version.
	var versionLength = 5;
	bytesReaded += versionLength;
	
	
	// modelCount
	var blocksCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded + 4); bytesReaded += 4;
	for ( var i = 0; i< blocksCount; i++ ) 
	{
		// modelIndex
		var blockIdx = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		
		// Check if block exist.
		if (motherBlocksArray[blockIdx]) 
		{
			// The block exists, then read data but no create a new block.
			bytesReaded += 4 * 6; // boundingBox.
			// step over vbo datas of the model.
			bytesReaded = this.stepOverBlockVersioned(arrayBuffer, bytesReaded, readWriter) ;
			
			// read lego if exist. (note: lego is exactly same of a model, is a mesh).
			var existLego = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded += 1;
			if (existLego)
			{
				bytesReaded = this.stepOverBlockVersioned(arrayBuffer, bytesReaded, readWriter) ;
			}
			
			continue;
		}
		
		// The block doesn't exist, so creates a new block and read data.
		var block = new Block();
		block.idx = blockIdx;
		motherBlocksArray[blockIdx] = block;

		// 1rst, read bbox.
		var bbox = new BoundingBox();
		bbox.minX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
		bbox.minY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
		bbox.minZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;

		bbox.maxX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
		bbox.maxY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
		bbox.maxZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;

		var maxLength = bbox.getMaxLength();
		if (maxLength < 0.5) { block.isSmallObj = true; }
		else { block.isSmallObj = false; }

		block.radius = maxLength/2.0;

		bytesReaded = this.parseBlockVersioned(arrayBuffer, bytesReaded, block, readWriter, magoManager) ;
		
		// parse lego if exist.
		var existLego = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded += 1;
		if (existLego)
		{
			if (block.lego === undefined)
			{ 
				// TODO : this is no used. delete this.
				block.lego = new Lego(); 
			}
			bytesReaded = this.parseBlockVersioned(arrayBuffer, bytesReaded, block.lego, readWriter, magoManager) ;
		}
	}
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	return succesfullyGpuDataBinded;
};

/**
 * 블록리스트 버퍼를 파싱(비대칭적)
 * F4D 버전이 0.0.2일 경우 사용
 * 매개변수로 arrayBuffer 전달받지 않고 blocksArrayPartition에 있는 arrayBuffer를 이용.
 * 
 * @param {ReaderWriter} readWriter Helper to read inside of the arrayBuffer.
 * @param {Array.<Block>} motherBlocksArray Global blocks array.
 * @param {MagoManager} magoManager
 */
BlocksList.prototype.parseBlocksListVersioned_v002 = function(readWriter, motherBlocksArray, magoManager) 
{
	// 1rst, find the blocksArrayPartition to parse.
	var blocksArrayPartitionsCount = this.blocksArrayPartitionsArray.length;
	var blocksArrayPartition = this.blocksArrayPartitionsArray[blocksArrayPartitionsCount-1];
	if (blocksArrayPartition.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
	{ return; }
	
	var arrayBuffer = blocksArrayPartition.dataArraybuffer;
	blocksArrayPartition.fileLoadState = CODE.fileLoadState.PARSE_STARTED;
	var bytesReaded = 0;
	var vboMemManager = magoManager.vboMemoryManager;
	var succesfullyGpuDataBinded = true;
	
	var blocksCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded + 4); bytesReaded += 4;
	for ( var i = 0; i< blocksCount; i++ ) 
	{
		var blockIdx = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var block;
		
		// Check if block exist.
		if (motherBlocksArray[blockIdx]) 
		{
			block = motherBlocksArray[blockIdx];
		}
		else 
		{
			// The block doesn't exist, so creates a new block and read data.
			block = new Block();
			block.idx = blockIdx;
			motherBlocksArray[blockIdx] = block;
		}
		
		// Now, read the blocks vbo's idx.
		var vboIdx = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		
		if (vboIdx === 0)
		{
			// Only if the vboIdx = 0 -> read the bbox.
			var bbox = new BoundingBox();
			bbox.minX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
			bbox.minY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
			bbox.minZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;

			bbox.maxX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
			bbox.maxY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
			bbox.maxZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;

			var maxLength = bbox.getMaxLength();
			if (maxLength < 0.5) { block.isSmallObj = true; }
			else { block.isSmallObj = false; }

			block.radius = maxLength/2.0;
		}
		
		// check if the vbo exists.
		var vboViCacheKey = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray[vboIdx];
		if (vboViCacheKey === undefined)
		{
			// Now, read the vbo (Pos-Nor-Idx).
			vboViCacheKey = new VBOVertexIdxCacheKey();
			block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray[vboIdx] = vboViCacheKey;
			bytesReaded = vboViCacheKey.readPosNorIdx(arrayBuffer, readWriter, vboMemManager, bytesReaded);
			block.vertexCount = vboViCacheKey.vertexCount;
		}
		else 
		{
			// step over.
			if (blocksCount > 1)
			{ bytesReaded = vboViCacheKey.stepOverPosNorIdx(arrayBuffer, readWriter, vboMemManager, bytesReaded); }
		}
	}
	blocksArrayPartition.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED; // test.
	return succesfullyGpuDataBinded;
};

/**
 * 블록리스트 버퍼를 파싱(비대칭적)
 * This function parses the geometry data from binary arrayBuffer.
 * @deprecated f4d 0.0.1 이전 버전에서 사용
 * 
 * @param {ArrayBuffer} arrayBuffer Binary data to parse.
 * @param {ReaderWriter} readWriter Helper to read inside of the arrayBuffer.
 * @param {Array.<Block>} motherBlocksArray Global blocks array.
 */
BlocksList.prototype.parseBlocksList = function(arrayBuffer, readWriter, motherBlocksArray, magoManager) 
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;
	var bytesReaded = 0;
	var blocksCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded + 4); bytesReaded += 4;
	
	var vboMemManager = magoManager.vboMemoryManager;
	var succesfullyGpuDataBinded = true;

	for ( var i = 0; i< blocksCount; i++ ) 
	{
		var blockIdx = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		
		// Check if block exist.
		if (motherBlocksArray[blockIdx]) 
		{
			// The block exists, then read data but no create a new block.
			bytesReaded += 4 * 6; // boundingBox.
			// Read vbo datas (indices cannot superate 65535 value).
			var vboDatasCount = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
			
			for ( var j = 0; j < vboDatasCount; j++ ) 
			{
				// 1) Positions array.
				var vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
				var verticesFloatValuesCount = vertexCount * 3;
				startBuff = bytesReaded;
				endBuff = bytesReaded + 4 * verticesFloatValuesCount;
				bytesReaded = bytesReaded + 4 * verticesFloatValuesCount; // updating data.

				// 2) Normals.
				vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
				var normalByteValuesCount = vertexCount * 3;
				bytesReaded = bytesReaded + 1 * normalByteValuesCount; // updating data.

				// 3) Indices.
				var shortIndicesValuesCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
				var sizeLevels = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded += 1;
				
				bytesReaded = bytesReaded + sizeLevels * 4;
				bytesReaded = bytesReaded + sizeLevels * 4;
				bytesReaded = bytesReaded + 2 * shortIndicesValuesCount; // updating data.
			}
			// Pendent to load the block's lego.
			continue;
		}
		
		// The block doesn't exist, so creates a new block and read data.
		var block = new Block();
		block.idx = blockIdx;
		motherBlocksArray[blockIdx] = block;
		
		// 1rst, read bbox.
		var bbox = new BoundingBox();
		bbox.minX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;
		bbox.minY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;
		bbox.minZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;

		bbox.maxX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;
		bbox.maxY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;
		bbox.maxZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;

		var maxLength = bbox.getMaxLength();
		if (maxLength < 0.5) { block.isSmallObj = true; }
		else { block.isSmallObj = false; }

		block.radius = maxLength/2.0;

		bbox.deleteObjects();
		bbox = undefined;

		// New for read multiple vbo datas (indices cannot superate 65535 value).
		var vboDatasCount = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4);
		bytesReaded += 4;
		for ( var j = 0; j < vboDatasCount; j++ ) 
		{
			var vboViCacheKey = block.vBOVertexIdxCacheKeysContainer.newVBOVertexIdxCacheKey();
			bytesReaded = vboViCacheKey.readPosNorIdx(arrayBuffer, readWriter, vboMemManager, bytesReaded);
			block.vertexCount = vboViCacheKey.vertexCount;
		}
		// Pendent to load the block's lego.
	}
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	return succesfullyGpuDataBinded;
};

/**
 * 블록리스트의 blocksArrayPartition정보를 할당 및 체크.
 * F4D 버전이 0.0.2일 경우 사용
 * 
 * @param {MagoManager} magoManager
 * @param {MagoManager} octreeOwner
 */
BlocksList.prototype.prepareData = function(magoManager, octreeOwner) 
{
	if (this.version === "0.0.1")
	{
		// Provisionally this function is into octree.prepareModelReferencesListData(...).
	}
	else if (this.version === "0.0.2")
	{
		// Check the current loading state.
		if (this.blocksArrayPartitionsArray === undefined)
		{ this.blocksArrayPartitionsArray = []; }
		
		var currPartitionsCount = this.blocksArrayPartitionsArray.length;
		if (currPartitionsCount === 0)
		{
			// Proceed to load the 1rst partition.
			var partitionIdx = 0;
			var filePathInServer = this.blocksArrayPartitionsMasterPathName + partitionIdx.toString();
			var blocksArrayPartition = new BlocksArrayPartition();
			this.blocksArrayPartitionsArray.push(blocksArrayPartition);
			magoManager.readerWriter.getNeoBlocksArraybuffer_partition(filePathInServer, octreeOwner, blocksArrayPartition, magoManager);
		}
		else
		{
			// Check the last partition.
			var lastBlocksArrayPartition = this.blocksArrayPartitionsArray[currPartitionsCount-1];
			if (lastBlocksArrayPartition.fileLoadState === CODE.fileLoadState.PARSE_FINISHED)
			{
				if (currPartitionsCount < this.blocksArrayPartitionsCount)
				{
					// Proceed to load another partition.
					var partitionIdx = currPartitionsCount;
					var filePathInServer = this.blocksArrayPartitionsMasterPathName + partitionIdx.toString();
					var blocksArrayPartition = new BlocksArrayPartition();
					this.blocksArrayPartitionsArray.push(blocksArrayPartition);
					magoManager.readerWriter.getNeoBlocksArraybuffer_partition(filePathInServer, octreeOwner, blocksArrayPartition, magoManager);
				}
			}
		}
	
	}
};
'use strict';
/**
 * 프로젝트와 노드 목록 관리 객체.
 * 실질적으로 화면에 표출될 프로젝트와 노드들을 보관하고 있음.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class HierarchyManager
 */
var HierarchyManager = function() 
{
	if (!(this instanceof HierarchyManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * lowest nodes array. initial array to create tiles global distribution.
	 * @type {Array.<Node>}
	 */
	this.nodesArray = [];

	/**
	 * 프로젝트 보관 객체
	 * @type {Object}
	 */
	this.projectsMap = {};
	
	/**
	 * StaticModelManager
	 * @type {StaticModelManager}
	 */
	this.staticModelsManager;
};

/**
 * node array와 prjectMap을 초기화. gl Context에서 그려진 내용들 제거
 */
HierarchyManager.prototype.deleteNodes = function(gl, vboMemoryManager) 
{
	this.projectsMap = {};
	
	var nodesCount = this.nodesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		if (this.nodesArray[i])
		{
			this.nodesArray[i].deleteObjects(gl, vboMemoryManager);
			this.nodesArray[i] = undefined;
		}
	}
	this.nodesArray.length = 0;
};

/**
 * StaticModelsManager 반환
 * @returns {StaticModelsManager} 선언된 StaticModelsManager가 없을 시 인스턴스 생성하여 등록 후 반환.
 */
HierarchyManager.prototype.getStaticModelsManager = function() 
{
	if (this.staticModelsManager === undefined)
	{ this.staticModelsManager = new StaticModelsManager(); }
	
	return this.staticModelsManager;
};

/**
 * nodesMap에 있는 Node의 data의 attribute에 해당하는 값을 가진 Node를 반환.
 * @param {String} projectId
 * @param {String} dataName attribute 이름, 보통 nodeId 사용.
 * @param {String} dataNameValue attribute 값
 * 
 * @returns {Node}
 */
HierarchyManager.prototype.getNodeByDataName = function(projectId, dataName, dataNameValue) 
{
	// note: here "dataName" refers "nodeId", or other datas that can be inside of"data".
	var nodesMap = this.getNodesMap(projectId);
	
	if (nodesMap === undefined)
	{ return undefined; }
	
	var resultNode;
	
	//for (var value of nodesMap.values()) 
	for (var key in nodesMap)
	{
		if (Object.prototype.hasOwnProperty.call(nodesMap, key))
		{
			var value = nodesMap[key];
			if (value.data !== undefined && value.data[dataName] === dataNameValue)
			{
				resultNode = value;
				break;
			}
		}
	}
	
	return resultNode;
};

/**
 * projectId와 dataKey를 이용하여 nodesMap에 있는 Node를 반환.
 * @param {String} projectId
 * @param {String} dataKey
 * 
 * @returns {Node|undefined} nodesMap이 선언되지 않았을 경우 undefined반환.
 */
HierarchyManager.prototype.getNodeByDataKey = function(projectId, dataKey) 
{
	var nodesMap = this.getNodesMap(projectId);
	
	if (nodesMap === undefined)
	{ return undefined; }
	
	var resultNode = nodesMap[dataKey];
	
	return resultNode;
};

/**
 * node의 parent 속성이 비어있는 root node들을 반환.
 * @param {Array.<Node>} resultRootNodesArray
 * @returns {Array.<Node>}
 */
HierarchyManager.prototype.getRootNodes = function(resultRootNodesArray) 
{
	if (resultRootNodesArray === undefined)
	{ resultRootNodesArray = []; }
	
	var nodesCount = this.nodesArray.length;
	var node;
	for (var i=0; i<nodesCount; i++)
	{
		node = this.nodesArray[i];
		
		if (node.parent === undefined)
		{
			resultRootNodesArray.push(node);
		}
	}
	
	return resultRootNodesArray;
};

/**
 * 넘겨받은 projectId에 해당하는 project가 projectMap에 등록되있는지 유무 반환.
 * @param {String} projectId
 * @returns {Boolean}
 */
HierarchyManager.prototype.existProject = function(projectId) 
{
	return this.projectsMap.hasOwnProperty(projectId);
};

/**
 * 넘겨받은 projectId에 해당하는 nodesMap을 반환.
 * @param {String} projectId
 * @param {Object} attributes undefined가 아닐 경우 해당 nodesMap에 등록.
 * @returns {Object} projectId에 해당하는 nodesMap 없으면 생성 후 반환.
 */
HierarchyManager.prototype.getNodesMap = function(projectId, attributes) 
{
	// 1rst, check if exist.
	var nodesMap = this.projectsMap[projectId];
	if (nodesMap === undefined)
	{
		nodesMap = {};
		if (attributes !== undefined)
		{ nodesMap.attributes = attributes; }
		this.projectsMap[projectId] = nodesMap;
	}
	else 
	{
		if (attributes !== undefined && nodesMap.attributes === undefined)
		{ nodesMap.attributes = attributes; }
	}
	return nodesMap;
};


/**
 * 넘겨받은 projectId와 id, attribute로 Node를 생성 후 반환. Node 생성 후 nodesArray와 nodesMap에 등록
 * @param {String} id datakey
 * @param {String} projectId
 * @param {Object} attributes undefined가 아닐 경우 해당 nodesMap에 등록.
 * @returns {Node}
 */
HierarchyManager.prototype.newNode = function(id, projectId, attributes) 
{
	var nodesMap = this.getNodesMap(projectId, attributes);
	
	var node = new Node();
	node.data = {"nodeId": id};
	this.nodesArray.push(node);
	nodesMap[id] = node;
	return node;
};


'use strict';

/**
 * @deprecated 사용안함.
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class InspectorBox
 */
var InspectorBox = function() 
{
	if (!(this instanceof InspectorBox)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
};
'use strict';

/**
 * F4D Lego 클래스
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @alias Lego
 * @class Lego
 * 
 * 아래 문서의 Table 2 (Overall Structure of LOD2 file) 참조
 * @link https://github.com/Gaia3D/F4DConverter/blob/master/doc/F4D_SpecificationV1.pdf
 */
var Lego = function() 
{
	if (!(this instanceof Lego)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * @type {VBOVertexIdxCacheKeysContainer}
	 */
	this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer();

	/**
	 * lego file load state. Default is 0(READY)
	 * "READY"            : 0,
	 * "LOADING_STARTED"  : 1,
	 * "LOADING_FINISHED" : 2,
	 * "PARSE_STARTED"    : 3,
	 * "PARSE_FINISHED"   : 4,
	 * "IN_QUEUE"         : 5,
	 * "LOAD_FAILED"      : 6
	 * @type {Number}
	 */
	this.fileLoadState = CODE.fileLoadState.READY;

	/**
	 * lego bounding box
	 * @type {BoundingBox}
	 */
	this.bbox;

	/**
	 * lego data array buffer. parse가 끝난 후 undefined.
	 * @type {ArrayBuffer}
	 */
	this.dataArrayBuffer;

	/**
	 * lego data color. not used
	 * @deprecated
	 * @type {Color}
	 */
	this.selColor4;

	/**
	 * 텍스쳐 coord 유무
	 * @type {Boolean}
	 */
	this.hasTexCoords;

	/**
	 * 텍스쳐
	 * @type {Texture}
	 */
	this.texture;

	/**
	 * 텍스쳐 이름
	 * @type {String}
	 */
	this.textureName;

	/**
	 * lego key
	 * @type {String}
	 */
	this.legoKey;
	this.xhr;
	
	/**
	 * not use
	 * @deprecated
	 * @type {String}
	 */
	this.renderableType; // triangles, lines, points, etc.

	/**
	 * 칼라값 유무
	 * @type {Boolean}
	 */
	this.hasColors;

	/**
	 * blendAlpha
	 * @type {Number}
	 */
	this.blendAlpha = 0.0;

	/**
	 * birthTime
	 * @type {Date}
	 */
	this.birthTime;

	/**
	 * not use
	 * @deprecated
	 * @type {Boolean}
	 */
	this.isAdult = false;
};

/**
 * F4D Lego 자료를 읽어서 가져온 ArrayBuffer를 파싱.
 * 
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {ArrayBuffer} dataArraybuffer 
 * @param {MagoManager} magoManager 
 */
Lego.prototype.parseArrayBuffer = function(gl, dataArraybuffer, magoManager)
{
	this.parseLegoData(dataArraybuffer, gl, magoManager);
};

/**
 * BlendAlpha 반환
 * 
 * @param {Date} currTime not use
 * @returns {Number} always return 1.0
 */
Lego.prototype.getBlendAlpha = function(currTime) 
{
	return 1.0;
	/*
	if(!this.isAdult)
	{
		if(this.birthTime === undefined)
			this.birthTime = currTime;
		var increAlpha = (currTime - this.birthTime)*0.0001;
		this.blendAlpha += increAlpha;
		
		if(this.blendAlpha >= 1.0)
		{
			this.isAdult = true;
		}
	}
	else
		return 1.0;
	
	return this.blendAlpha;
	*/
};

/**
 * render할 준비가 됬는지 체크
 * @returns {Boolean} this.fileLoadState가 CODE.fileLoadState.PARSE_FINISHED(4)이거나 this.texture, this.texture.texId가 존재할때 true 반환
 */
Lego.prototype.isReadyToRender = function()
{
	if (this.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
	{ return false; }
	
	if (this.texture === undefined || this.texture.texId === undefined) // In the future, a skin can has no texture. TODO:
	{ return false; }
	
	return true;
};

/**
 * lego 초기화. gl에서 해당 lego 삭제
 * 
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {VboManager} vboMemManager 
 */
Lego.prototype.deleteObjects = function(gl, vboMemManager)
{
	/*
	if(this.xhr !== undefined)// && this.fileLoadState === CODE.fileLoadState.LOADING_STARTED)
	{
		this.xhr.abort();
		this.xhr = undefined;
	}
	*/
	
	if (this.vbo_vicks_container !== undefined)
	{
		this.vbo_vicks_container.deleteGlObjects(gl, vboMemManager);
		this.vbo_vicks_container = undefined;
	}
	this.fileLoadState = undefined;
	this.dataArrayBuffer = undefined;
	if (this.selColor4 !== undefined)
	{
		this.selColor4.deleteObjects();
		this.selColor4 = undefined;
	}
	
	this.textureName = undefined;
	if (this.texture)
	{
		this.texture.deleteObjects(gl);
	}
	this.texture = undefined;
	if (this.bbox)
	{
		this.bbox.deleteObjects();
	}
	this.bbox = undefined;
};

/**
 * F4D Lego 자료(point cloude data)를 읽어서 가져온 ArrayBuffer를 파싱.
 * vertex index cache key를 생성하여 담는다.
 * LOADING_FINISHED 상태일때 실행.
 * normal, texCoord는 없음
 * 
 * @param {ArrayBuffer} dataArraybuffer 
 * @param {WebGLRenderingContext} gl not use
 * @param {MagoManager} magoManager 
 */
Lego.prototype.parsePointsCloudData = function(buffer, gl, magoManager)
{
	// Provisional.
	if (this.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)	{ return; }
	var stream = new DataStream(buffer, 0, DataStream.LITTLE_ENDIAN);
	
	var verticesCount = stream.readInt32();
	
	var vboMemManager = magoManager.vboMemoryManager;
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;

	this.bbox = new BoundingBox();
	var bbox = this.bbox;
	var vboCacheKey = this.vbo_vicks_container.newVBOVertexIdxCacheKey();

	// BoundingBox in float values.
	bbox.minX = stream.readFloat32();
	bbox.minY = stream.readFloat32();
	bbox.minZ = stream.readFloat32();
	bbox.maxX = stream.readFloat32();
	bbox.maxY = stream.readFloat32();
	bbox.maxZ = stream.readFloat32();
	
	// positionsBuffer.
	// read bPositionsCompressed. If this var is true -> positions is in uShort).
	this.bPositionsCompressed = stream.readInt8();
	var posByteSize = verticesCount * 3;
	var positionBuffer;
	
	
	if (this.bPositionsCompressed)
	{
		vboCacheKey.setDataArrayPos(stream.readUint16Array(verticesCount * 3), vboMemManager);
	}
	else 
	{
		vboCacheKey.setDataArrayPos(stream.readFloat32Array(verticesCount * 3), vboMemManager);
	}

	// normals.
	this.hasNormals = stream.readInt8();
	if (this.hasNormals)
	{
		// todo:
	}
	
	// colors.
	this.hasColors = stream.readInt8();
	if (this.hasColors)
	{
		var numColors = verticesCount;
		vboCacheKey.setDataArrayCol(stream.readUint8Array(numColors * 4), vboMemManager);
	}
	
	// texCoords.
	this.hasTexCoords = stream.readInt8();
	if (this.hasTexCoords)
	{
		// todo:
	}
	
	// indices.
	this.hasIndices = stream.readInt8();
	if (this.hasIndices)
	{
		// todo:
	}
	
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
};

/**
 * F4D Lego 자료를 읽어서 가져온 ArrayBuffer를 파싱.
 * vertex index cache key를 생성하여 담는다.
 * LOADING_FINISHED 상태일때 실행.
 * 
 * @param {ArrayBuffer} dataArraybuffer 
 * @param {WebGLRenderingContext} gl not use
 * @param {MagoManager} magoManager 
 */
Lego.prototype.parseLegoData = function(buffer, gl, magoManager)
{
	if (this.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)	{ return; }
	
	var vboMemManager = magoManager.vboMemoryManager;

	var stream = new DataStream(buffer, 0, DataStream.LITTLE_ENDIAN);
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;

	this.bbox = new BoundingBox();
	var bbox = this.bbox;
	var vboCacheKey = this.vbo_vicks_container.newVBOVertexIdxCacheKey();

	// BoundingBox
	bbox.minX = stream.readFloat32();
	bbox.minY = stream.readFloat32();
	bbox.minZ = stream.readFloat32();
	bbox.maxX = stream.readFloat32();
	bbox.maxY = stream.readFloat32();
	bbox.maxZ = stream.readFloat32();

	// VBO(Position Buffer) - x,y,z
	var numPositions = stream.readUint32();
	var posDataArray = stream.readFloat32Array(numPositions * 3);
	vboCacheKey.setDataArrayPos(posDataArray, vboMemManager);


	// VBO(Normal Buffer) - i,j,k
	var hasNormals = stream.readUint8();
	if (hasNormals) 
	{
		var numNormals = stream.readUint32();
		var norDataArray = stream.readInt8Array(numNormals * 3);
		vboCacheKey.setDataArrayNor(norDataArray, vboMemManager);
	}

	// VBO(Color Buffer) - r,g,b,a
	var hasColors = stream.readUint8();
	if (hasColors)
	{
		var numColors = stream.readUint32();
		var colDataArray = stream.readUint8Array(numColors * 4);
		vboCacheKey.setDataArrayCol(colDataArray, vboMemManager);
	}

	// VBO(TextureCoord Buffer) - u,v
	this.hasTexCoords = stream.readUint8();
	if (this.hasTexCoords)
	{
		var dataType = stream.readUint16();
		var numCoords = stream.readUint32();
		var texCoordDataArray = stream.readFloat32Array(numCoords * 2);
		vboCacheKey.setDataArrayTexCoord(texCoordDataArray, vboMemManager);
	}

	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	
	return true;
};

/**
 * F4D Lego 자료를 gl에 렌더
 * 
 * @param {MagoManager} magoManager
 * @param {Number} renderType
 * @param {Boolean} renderTexture
 * @param {PostFxShader} shader 
 */
Lego.prototype.render = function(magoManager, renderType, renderTexture, shader)
{
	var rendered = false;
	var gl = magoManager.sceneState.gl;
	
	if (this.vbo_vicks_container.vboCacheKeysArray.length === 0) 
	{
		return false;
	}
	gl.frontFace(gl.CCW);
	
	// renderType = 0 -> depth render.
	// renderType = 1 -> normal render.
	// renderType = 2 -> colorSelection render.
	//--------------------------------------------
	
	var vbo_vicky = this.vbo_vicks_container.vboCacheKeysArray[0]; // there are only one.

	var vertices_count = vbo_vicky.vertexCount;
	if (vertices_count === 0) 
	{
		return false;
	}

	if (renderType === 0 || renderType === 2) // depth or colorSelection.
	{
		shader.disableVertexAttribArray(shader.texCoord2_loc);
		shader.disableVertexAttribArray(shader.normal3_loc);
		shader.disableVertexAttribArray(shader.color4_loc);
		
		// 1) Position.
		if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }

		gl.drawArrays(gl.TRIANGLES, 0, vertices_count);
		rendered = true;
		
	}
	else if (renderType === 1) // color.
	{
		// Test external alpha.
		if (magoManager.isTrailRender === undefined || magoManager.isTrailRender === false) // check if mago is not rendering special effects.
		{
			var blendAlpha = this.getBlendAlpha(magoManager.currTime);
			gl.uniform1f(shader.externalAlpha_loc, blendAlpha);
		}
		// End test.---
	
		// 4) Texcoord.
		if (renderTexture)
		{
			if (!vbo_vicky.bindDataTexCoord(shader, magoManager.vboMemoryManager))
			{ return false; }
		}
		else 
		{
			gl.uniform1i(shader.bUse1Color_loc, false);
			shader.disableVertexAttribArray(shader.texCoord2_loc);
		}

		if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }
		
		if (!vbo_vicky.bindDataNormal(shader, magoManager.vboMemoryManager))
		{ return false; }

		// TODO:
		//if (vbo_vicky.meshColorCacheKey !== undefined )
		//{
		//if(shader.color4_loc != -1)shader.enableVertexAttribArray(shader.color4_loc);
		//gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshColorCacheKey);
		//gl.vertexAttribPointer(shader.color4_loc, 4, gl.UNSIGNED_BYTE, true, 0, 0);
		//}
		
		if (renderTexture && vbo_vicky.vboBufferTCoord !== undefined)
		{
			// Provisionally flip tex coords here.
			if (magoManager.configInformation.geo_view_library === Constant.CESIUM)
			{ gl.uniform1i(shader.textureFlipYAxis_loc, false); }//.ppp
			else
			{ gl.uniform1i(shader.textureFlipYAxis_loc, true); }//.ppp
			//---------------------------------------------------------------------------
			
			shader.disableVertexAttribArray(shader.color4_loc); 
			
			if (!vbo_vicky.bindDataTexCoord(shader, magoManager.vboMemoryManager))
			{ return false; }
		}

		gl.drawArrays(gl.TRIANGLES, 0, vertices_count);
		
		
		rendered = true;
		shader.disableVertexAttribArray(shader.color4_loc);
	}
	
	return rendered;
};




















'use strict';

/**
 * LoadData
 * @deprecated 삭제예정
 * @alias LoadData
 * @class LoadData
 */
var LoadData = function() 
{
	if (!(this instanceof LoadData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// dataType:
	// 1. referencesArray.
	// 2. blocksArray.
	// 3. skinData. (octree's skinData & lod3,4,5 skinData).
	// 4. skinTexture.
	
	this.dataType;
	this.distToCam;
	this.lod;
	this.filePath;
	this.texFilePath;
	this.skinMesh;
	this.octree;
	this.texture;
};

LoadData.prototype.deleteObjects = function()
{
	// here deletes deletable objects.
	this.dataType = undefined;
	this.distToCam = undefined;
	this.lod = undefined;
	this.filePath = undefined;
	this.texFilePath = undefined;
	this.skinMesh = undefined;
	this.octree = undefined;
	this.texture = undefined;
};

/**
 * LoadQueue
 * @deprecated 삭제예정
 * 
 * @alias LoadQueue
 * @class LoadQueue
 */
var LoadQueue = function(magoManager) 
{
	if (!(this instanceof LoadQueue)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.magoManager;
	
	if (magoManager !== undefined)
	{ this.magoManager = magoManager; }
	
	this.lod2PCloudDataMap = {}; 

	this.tinTerrainDataMap = {};
};

LoadQueue.prototype.putLod2PCloudData = function(octree, filePath, texture, texFilePath, aValue)
{
	// "aValue" no used yet.
	octree.lego.fileLoadState = CODE.fileLoadState.IN_QUEUE;
	var loadData = new LoadData();
	loadData.filePath = filePath;
	loadData.octree = octree;
	
	loadData.texFilePath = texFilePath;
	loadData.texture = texture;
	
	this.lod2PCloudDataMap[filePath] = loadData;
};


LoadQueue.prototype.resetQueue = function()
{	
	for (var key in this.lod2PCloudDataMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.lod2PCloudDataMap, key))
		{
			var loadData = this.lod2PCloudDataMap[key];
			if (loadData.octree === undefined || loadData.octree.lego === undefined)
			{ continue; }
			
			loadData.octree.lego.fileLoadState = CODE.fileLoadState.READY;
		}
	}
	
	this.lod2PCloudDataMap = {};
};

LoadQueue.prototype.manageQueue = function()
{
	var maxFileLoad = 1;
	var readerWriter = this.magoManager.readerWriter;
	var gl = this.magoManager.sceneState.gl;
	var counter = 0;
	var remainLod2 = false;


	
	// Lod2 meshes, 1rst load texture..
	if (this.magoManager.fileRequestControler.isFullPlusLowLodImages())	
	{ 
		return; 
	}
	
	// pCloud data.
	counter = 0;
	for (var key in this.lod2PCloudDataMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.lod2PCloudDataMap, key))
		{
			var loadData = this.lod2PCloudDataMap[key];
			var octree = loadData.octree;
			var filePath = loadData.filePath;
			
			if (octree.lego !== undefined)
			{
				readerWriter.getOctreePCloudArraybuffer(filePath, octree, this.magoManager);
			}
			
			delete this.lod2PCloudDataMap[key];
			loadData.deleteObjects();
			loadData = undefined;
	
			counter++;
			if (counter > 4)
			{
				//this.lod2PCloudDataMap = {};
				remainLod2 = true;
				break;
			}
		}
	}
	
	this.resetQueue();
};
'use strict';

/**
 * F4D LodBuildingData 클래스
 * Node의 NeoBuilding안에서 사용.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @alias LodBuildingData
 * @class LodBuildingData
 * 
 * 아래 문서의 Table 1-3 (lodInfo) 참조
 * @link https://github.com/Gaia3D/F4DConverter/blob/master/doc/F4D_SpecificationV1.pdf
 */
var LodBuildingData = function() 
{
	if (!(this instanceof LodBuildingData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * lod of this data.
	 * @type {Number}
	 */
	this.lod;

	/**
	 * 모델 레퍼런스 유무 0 : false, 1 : true
	 * @type {Number}
	 */
	this.isModelRef;

	/**
	 * geometry 파일명, isModelRef가 0일 경우 선언.
	 * @type {String}
	 * 
	 * @example lod0, lod1
	 */
	this.geometryFileName;

	/**
	 * texture 파일명 lod가 2일 경우 혹은 isModelRef가 0일 경우 선언
	 * @type {String}
	 * 
	 * @example mosaicTextureLod0.jpg
	 */
	this.textureFileName;
	//this.dataType; // no used yet.
};
'use strict';

/**
 * F4D MetaData class.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @alias MetaData
 * @class MetaData
 * 
 * 아래 문서의 Table 1 참조
 * @link https://github.com/Gaia3D/F4DConverter/blob/master/doc/F4D_SpecificationV1.pdf
 */
var MetaData = function() 
{
	if (!(this instanceof MetaData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * guid. must be undefined initially.
	 * @type {String} 
	 */
	this.guid;

	/**
	 * f4d version
	 * @type {String} 
	 */
	this.version = "";

	/**
	 * f4d origin geographic coord. longitude, latitude, altitude.
	 * @type {GeographicCoord} 
	 */
	this.geographicCoord;

	/**
	 * heading. unit is degree.
	 * @type {Number} 
	 */
	this.heading;

	/**
	 * pitch. unit is degree.
	 * @type {Number} 
	 */
	this.pitch;

	/**
	 * roll. unit is degree.
	 * @type {Number} 
	 */
	this.roll;

	/**
	 * BoundingBox
	 * @type {BoundingBox} 
	 */
	this.bbox;

	/**
	 * not used
	 * @deprecated
	 */
	this.imageLodCount;

	/**
	 * Project_data_type (new in version 002).
	 * 1 = 3d model data type (normal 3d with interior & exterior data).
	 * 2 = single building skin data type (as vWorld or googleEarth data).
	 * 3 = multi building skin data type (as Shibuya & Odaiba data).
	 * 4 = pointsCloud data type.
	 * 5 = pointsCloud data type pyramidOctree test.
	 * @type {Number} 
	 */
	this.projectDataType;
	//-------------------------------------------------------------------------------
	
	/**
	 * offset x. Added since version 0.02
	 * @type {Number} 
	 */
	this.offSetX;

	/**
	 * offset y. Added since version 0.02
	 * @type {Number} 
	 */
	this.offSetY;

	/**
	 * offset z. Added since version 0.02
	 * @type {Number} 
	 */
	this.offSetZ;

	/**
	 * Buildings octree mother size.
	 * 
	 * @see Octree#setBoxSize
	 * @see ReaderWriter#getNeoHeaderAsimetricVersion
	 */ 

	 /**
	 * octree min x. octree.centerPos.x - octree.half_dx
	 * @type {Number} 
	 * @default 0.0
	 */
	this.oct_min_x = 0.0;

	 /**
	 * octree max x. octree.centerPos.x + octree.half_dx
	 * @type {Number} 
	 * @default 0.0
	 */
	this.oct_max_x = 0.0;

	/**
	 * octree min y. octree.centerPos.y - octree.half_dy
	 * @type {Number} 
	 * @default 0.0
	 */
	this.oct_min_y = 0.0;

	/**
	 * octree min y. octree.centerPos.y + octree.half_dy
	 * @type {Number} 
	 * @default 0.0
	 */
	this.oct_max_y = 0.0;

	/**
	 * octree min z. octree.centerPos.z - octree.half_dz
	 * @type {Number} 
	 * @default 0.0
	 */
	this.oct_min_z = 0.0;

	/**
	 * octree max z. octree.centerPos.z + octree.half_dz
	 * @type {Number} 
	 * @default 0.0
	 */
	this.oct_max_z = 0.0;

	/**
	 * small flag. 
	 * 
	 * when under condition, set true.
	 * bbox.maxX - bbox.minX < 40.0 && bbox.maxY - bbox.minY < 40.0 && bbox.maxZ - bbox.minZ < 30.0
	 * @deprecated
	 * 
	 * @type {Boolean} 
	 * @default false
	 */
	this.isSmall = false;

	/**
	 * lego file load state. Default is 0(READY)
	 * "READY"            : 0,
	 * "LOADING_STARTED"  : 1,
	 * "LOADING_FINISHED" : 2,
	 * "PARSE_STARTED"    : 3,
	 * "PARSE_FINISHED"   : 4,
	 * "IN_QUEUE"         : 5,
	 * "LOAD_FAILED"      : 6
	 * @type {Number}
	 */
	this.fileLoadState = CODE.fileLoadState.READY;
};

/**
 * MetaData 초기화
 */
MetaData.prototype.deleteObjects = function() 
{
	this.guid = undefined; // must be undefined initially.
	//this.version = undefined;
	if (this.geographicCoord)
	{ this.geographicCoord.deleteObjects(); }
	this.geographicCoord = undefined; // longitude, latitude, altitude.

	this.heading = undefined;
	this.pitch = undefined;
	this.roll = undefined;

	if (this.bbox)
	{ this.bbox.deleteObjects(); }
	this.bbox = undefined; // BoundingBox.
	this.imageLodCount = undefined;

	// Buildings octree mother size.
	this.oct_min_x = undefined;
	this.oct_max_x = undefined;
	this.oct_min_y = undefined;
	this.oct_max_y = undefined;
	this.oct_min_z = undefined;
	this.oct_max_z = undefined;

	this.isSmall = undefined;
	this.fileLoadState = undefined;
};

/**
 * HeaderAsimetric.hed 파일을 불러와서 metadata 부분을 파싱.
 * @param {ArrayBuffer} arrayBuffer
 * @param {ReaderWriter} readWriter 
 */
MetaData.prototype.parseFileHeaderAsimetricVersion = function(arrayBuffer, readWriter) 
{
	var version_string_length = 5;
	var intAux_scratch = 0;
	var bytes_readed = 0;

	if (readWriter === undefined) { readWriter = new ReaderWriter(); }

	// 1) Version(5 chars).
	this.version = "";
	for (var j=0; j<version_string_length; j++)
	{
		this.version += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1))[0]);bytes_readed += 1;
	}

	// 3) Global unique ID.
	if (this.guid === undefined) { this.guid =""; }

	intAux_scratch = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	for (var j=0; j<intAux_scratch; j++)
	{
		this.guid += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1))[0]);bytes_readed += 1;
	}

	// 4) Location.
	if (this.longitude === undefined) 
	{
		this.longitude = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
	}
	else { bytes_readed += 8; }

	if (this.latitude === undefined) 
	{
		this.latitude = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
	}
	else { bytes_readed += 8; }

	if (this.altitude === undefined) 
	{
		this.altitude = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	}
	else { bytes_readed += 4; }

	if (this.bbox === undefined) { this.bbox = new BoundingBox(); }

	// 6) BoundingBox.
	this.bbox.minX = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	this.bbox.minY = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	this.bbox.minZ = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	this.bbox.maxX = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	this.bbox.maxY = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	this.bbox.maxZ = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;

	var isLarge = false;
	if (this.bbox.maxX - this.bbox.minX > 40.0 || this.bbox.maxY - this.bbox.minY > 40.0) 
	{
		isLarge = true;
	}

	if (!isLarge && this.bbox.maxZ - this.bbox.minZ < 30.0) 
	{
		this.isSmall = true;
	}
	
	// if header version is "0.0.2", then must read extra parameters.
	if (this.version === "0.0.2")
	{
		// parse dataType (unsigned short).
		this.projectDataType = (new Uint16Array(arrayBuffer.slice(bytes_readed, bytes_readed+2)))[0]; bytes_readed += 2;
		
		// parse Project's offSet (double x 6).
		this.offSetX = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
		this.offSetY = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
		this.offSetZ = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
	}

	return bytes_readed;
};


























'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class ModelReferencedGroup
 */
var ModelReferencedGroup = function() 
{
	if (!(this instanceof ModelReferencedGroup)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.modelIdx; // there are only one model.
	this.referencesIdxArray = []; // all references has the same model.
};


/**
 * 어떤 일을 하고 있습니까?
 * @class ModelReferencedGroupsList
 */
var ModelReferencedGroupsList = function() 
{
	if (!(this instanceof ModelReferencedGroupsList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.modelReferencedGroupsMap = [];
	this.modelReferencedGroupsArray = [];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
ModelReferencedGroupsList.prototype.getModelReferencedGroup = function(modelIdx) 
{
	var modelReferencedGroup = this.modelReferencedGroupsMap[modelIdx];
	
	if (modelReferencedGroup === undefined)
	{
		modelReferencedGroup = new ModelReferencedGroup();
		modelReferencedGroup.modelIdx = modelIdx;
		this.modelReferencedGroupsMap[modelIdx] = modelReferencedGroup;
	}
	
	return modelReferencedGroup;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
ModelReferencedGroupsList.prototype.makeModelReferencedGroupsArray = function() 
{
	this.modelReferencedGroupsArray.length = 0;
	
	var modelRefGroupsCount = this.modelReferencedGroupsMap.length;
	for (var i=0; i<modelRefGroupsCount; i++)
	{
		if (this.modelReferencedGroupsMap[i] !== undefined)
		{ this.modelReferencedGroupsArray.push(this.modelReferencedGroupsMap[i]); }
	}
	this.modelReferencedGroupsMap.length = 0;
	
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
ModelReferencedGroupsList.prototype.createModelReferencedGroups = function(neoRefsIndices, motherNeoRefsList) 
{
	// Group all the references that has the same model.
	if (neoRefsIndices === undefined)
	{ return; }
	
	if (motherNeoRefsList === undefined)
	{ return; }
	
	var referenceIdx;
	var modelIdx;
	var modelRefGroup;
	var referencesCount = neoRefsIndices.length;
	for (var i=0; i<referencesCount; i++)
	{
		referenceIdx = neoRefsIndices[i];
		modelIdx = motherNeoRefsList[referenceIdx]._block_idx;
		modelRefGroup = this.getModelReferencedGroup(modelIdx);
		modelRefGroup.referencesIdxArray.push(referenceIdx);
	}
	
	// Now, delete the "modelReferencedGroupsMap" and make a simple array.
	this.makeModelReferencedGroupsArray();
	
};





'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoBuilding
 */
var NeoBuilding = function() 
{
	if (!(this instanceof NeoBuilding)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.name = "";
	this.metaData;
	this.buildingId;
	this.buildingType; // use this for classify a building.
	this.buildingFileName = "";
	
	// Bounding box.
	this.bbox;
	this.bboxAbsoluteCenterPos;
	
	// References and Models.
	this.motherNeoReferencesArray = []; 
	this.motherNeoReferencesMap; 
	this.motherBlocksArray = []; 
	
	// Aditional Color.
	this.isHighLighted;
	this.isColorChanged;
	this.aditionalColor; // use for colorChanged.

	// Textures loaded.
	this.texturesLoaded; // material textures.

	// The octree.**
	this.octree; // f4d_octree. 

	// Auxiliar vars. This vars must be updated before to call render.
	this.currentLod; // Must be updated before to call render.
	this.currentVisibleOctreesControler; // Must be updated before to call render.
	this.myCameraRelative; // Must be updated before to call render.

	// The simple building.**
	this.simpleBuilding3x3Texture; // old version.
	
	// In version 001, there are 6 lods.
	this.lodMeshesMap;
	this.lodBuildingDatasMap;
	
	// Render settings.
	// provisionally put this here.
	this.applyOcclusionCulling;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.getImageFileNameForLOD = function(lod) 
{
	var lodBuildingData = this.getLodBuildingData(lod);
	
	if (lodBuildingData === undefined)
	{ return undefined; }
	
	return lodBuildingData.textureFileName;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.getReferenceObject = function(refObjectIndex) 
{
	if (this.motherNeoReferencesArray === undefined)
	{ return undefined; }
	return this.motherNeoReferencesArray[refObjectIndex];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.getReferenceObjectsArrayByObjectId = function(objectId) 
{
	if (this.motherNeoReferencesMap === undefined)
	{ return undefined; }

	var refObject = this.motherNeoReferencesMap[objectId];
	return refObject;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.putReferenceObject = function(refObject, refObjectIdx) 
{
	// function called by "NeoReferencesMotherAndIndices.prototype.parseArrayBufferReferencesVersioned".
	if (this.motherNeoReferencesArray === undefined)
	{ this.motherNeoReferencesArray = []; }

	this.motherNeoReferencesArray[refObjectIdx] = refObject;
	
	// Additionally, make a objects map.
	if (this.motherNeoReferencesMap === undefined)
	{ this.motherNeoReferencesMap = {}; }
	
	var objectsArray = this.motherNeoReferencesMap[refObject.objectId];
	if (objectsArray === undefined)
	{ objectsArray = []; }
	
	objectsArray.push(refObject);
	
	this.motherNeoReferencesMap[refObject.objectId] = objectsArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.getRenderSettingApplyOcclusionCulling = function() 
{
	return this.applyOcclusionCulling;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.setRenderSettingApplyOcclusionCulling = function(applyOcclusionCulling) 
{
	this.applyOcclusionCulling = applyOcclusionCulling;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteObjectsModelReferences = function(gl, vboMemoryManager) 
{
	// 1rst, clear this.motherNeoReferencesMap.
	if (this.motherNeoReferencesMap)
	{ 
		this.motherNeoReferencesMap = {}; 
		this.motherNeoReferencesMap = undefined;
	}
	
	var blocksCount = this.motherBlocksArray.length;
	for (var i=0; i<blocksCount; i++)
	{
		if (this.motherBlocksArray[i])
		{ this.motherBlocksArray[i].deleteObjects(gl, vboMemoryManager); }
		this.motherBlocksArray[i] = undefined;
	}
	this.motherBlocksArray = [];

	var referencesCount = this.motherNeoReferencesArray.length;
	for (var i=0; i<referencesCount; i++)
	{
		if (this.motherNeoReferencesArray[i])
		{ this.motherNeoReferencesArray[i].deleteObjects(gl, vboMemoryManager); }
		this.motherNeoReferencesArray[i] = undefined;
	}
	this.motherNeoReferencesArray = [];
	
	// delete textures on the GPU..
	if (this.texturesLoaded)
	{
		var texture;
		var texturesCount = this.texturesLoaded.length;
		for (var i=0; i<texturesCount; i++)
		{
			texture = this.texturesLoaded[i];
			if (texture)
			{
				if (texture.texId)
				{
					gl.deleteTexture(texture.texId);
					texture.texId = undefined;
					texture.fileLoadState = CODE.fileLoadState.READY;
				}
			}
		}
	}

};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteObjectsLodMesh = function(gl, vboMemoryManager, lodMeshKey) 
{
	// TEST delete lod 3.
	if (this.lodMeshesMap !== undefined)
	{
		if (Object.prototype.hasOwnProperty.call(this.lodMeshesMap, lodMeshKey))
		{
			var legoSkin = this.lodMeshesMap[lodMeshKey];
			if (legoSkin === undefined)
			{ return; }
			
			delete this.lodMeshesMap[lodMeshKey];
			legoSkin.deleteObjects(gl, vboMemoryManager);
			legoSkin = undefined;
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteObjectsLod2 = function(gl, vboMemoryManager) 
{
	if (this.octree !== undefined)
	{ 
		// deletes the geometry and the texture.
		this.octree.deleteObjectsLego(gl, vboMemoryManager); 
	}
	
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteObjects = function(gl, vboMemoryManager, deleteMetadata) 
{
	if (deleteMetadata)
	{
		this.metaData.deleteObjects();
		//this.metaData.fileLoadState = CODE.fileLoadState.READY;
	}
	
	// Must set ( fileLoadState = CODE.fileLoadState.READY ) bcos here deletes octree, so, must reload header 
	// and remake the octree if necessary.
	this.metaData.fileLoadState = CODE.fileLoadState.READY;

	this.deleteObjectsModelReferences(gl, vboMemoryManager);

	// The octree.
	if (this.octree !== undefined)
	{ this.octree.deleteObjects(gl, vboMemoryManager); }
	this.octree = undefined; // f4d_octree. Interior objects.
	
	//this.buildingFileName = "";

	this.allFilesLoaded = false;
	this.isReadyToRender = false;

	// delete textures.
	if (this.texturesLoaded)
	{
		var texturesCount = this.texturesLoaded.length;
		for (var i=0; i<texturesCount; i++)
		{
			if (this.texturesLoaded[i])
			{
				this.texturesLoaded[i].deleteObjects(gl);
			}
			this.texturesLoaded[i] = undefined;
		}
		this.texturesLoaded.length = 0;
	}
	this.texturesLoaded = undefined;
	
	// delete lod3, lod4, lod5.
	if (this.lodMeshesMap !== undefined)
	{
		for (var key in this.lodMeshesMap)
		{
			if (Object.prototype.hasOwnProperty.call(this.lodMeshesMap, key))
			{
				var legoSkin = this.lodMeshesMap[key];
				if (legoSkin === undefined)
				{ continue; }
				legoSkin.deleteObjects(gl, vboMemoryManager);
				legoSkin = undefined;
			}
		}
		this.lodMeshesMap = undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteLodMesh = function(gl, lod, vboMemoryManager) 
{
	if (this.lodMeshesMap !== undefined)
	{
		var legoSkin = this.lodMeshesMap[lod];
		if (legoSkin !== undefined)
		{
			legoSkin.deleteObjects(gl, vboMemoryManager);
			legoSkin = undefined;
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.getBBoxCenterPositionWorldCoord = function(geoLoc) 
{
	if (this.bboxAbsoluteCenterPos === undefined)
	{
		this.calculateBBoxCenterPositionWorldCoord(geoLoc);
	}
	
	return this.bboxAbsoluteCenterPos;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.calculateBBoxCenterPositionWorldCoord = function(geoLoc) 
{
	var bboxCenterPoint;
	
	bboxCenterPoint = this.bbox.getCenterPoint(bboxCenterPoint); // local bbox.
	this.bboxAbsoluteCenterPos = geoLoc.tMatrix.transformPoint3D(bboxCenterPoint, this.bboxAbsoluteCenterPos);
	
	// Now, must applicate the aditional translation vector. Aditional translation is made when we translate the pivot point.
	if (geoLoc.pivotPointTraslation)
	{
		var traslationVector;
		traslationVector = geoLoc.tMatrix.rotatePoint3D(geoLoc.pivotPointTraslation, traslationVector );
		this.bboxAbsoluteCenterPos.add(traslationVector.x, traslationVector.y, traslationVector.z);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.getTextureId = function(texture) 
{
	var texId;
	var texturesLoadedCount = this.texturesLoaded.length;
	var find = false;
	var i=0;
	while (!find && i < texturesLoadedCount ) 
	{
		if (this.texturesLoaded[i].textureImageFileName === texture.textureImageFileName) 
		{
			find = true;
			texId = this.texturesLoaded[i].texId;
		}
		i++;
	}

	return texId;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.getSameTexture = function(texture) 
{
	var sameTexture;
	var texturesLoadedCount = this.texturesLoaded.length;
	var find = false;
	var i=0;
	while (!find && i < texturesLoadedCount ) 
	{
		if (this.texturesLoaded[i].textureImageFileName === texture.textureImageFileName) 
		{
			find = true;
			sameTexture = this.texturesLoaded[i];
		}
		i++;
	}

	return sameTexture;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param eyeX 변수
 * @param eyeY 변수
 * @param eyeZ 변수
 */
NeoBuilding.prototype.updateCurrentVisibleIndicesExterior = function(eyeX, eyeY, eyeZ) 
{
	this._neoRefLists_Container.updateCurrentVisibleIndicesOfLists(eyeX, eyeY, eyeZ);
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.updateCurrentAllIndicesExterior = function() 
{
	this._neoRefLists_Container.updateCurrentAllIndicesOfLists();
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns metaData.bbox.isPoint3dInside(eyeX, eyeY, eyeZ);
 */
NeoBuilding.prototype.isCameraInsideOfBuilding = function(eyeX, eyeY, eyeZ) 
{
	return this.metaData.bbox.isPoint3dInside(eyeX, eyeY, eyeZ);
	/*
	var intersectedOctree = this.octree.getIntersectedSubBoxByPoint3D(eyeX, eyeY, eyeZ);
	if(intersectedOctree)
	{
		if(intersectedOctree.triPolyhedronsCount > 0)
			return true;
		else
			return false;
	}
	else
		return false;
	*/
};

/**
 * 어떤 일을 하고 있습니까?
 * @param absoluteEyeX 변수
 * @param absoluteEyeY 변수
 * @param absoluteEyeZ 변수
 * @returns point3dScrath2
 */
NeoBuilding.prototype.getTransformedRelativeEyePositionToBuilding = function(absoluteEyeX, absoluteEyeY, absoluteEyeZ, resultRelEyePosToBuilding) 
{
	// 1rst, calculate the relative eye position.
	var buildingPosition = this.buildingPosition;
	var relativeEyePosX = absoluteEyeX - buildingPosition.x;
	var relativeEyePosY = absoluteEyeY - buildingPosition.y;
	var relativeEyePosZ = absoluteEyeZ - buildingPosition.z;

	if (this.buildingPosMatInv === undefined) 
	{
		this.buildingPosMatInv = new Matrix4();
		this.buildingPosMatInv.setByFloat32Array(this.moveMatrixInv);
	}

	var point3dScratch = new Point3D();
	
	if (resultRelEyePosToBuilding === undefined)
	{ resultRelEyePosToBuilding = new Point3D(); }
	
	point3dScratch.set(relativeEyePosX, relativeEyePosY, relativeEyePosZ);
	resultRelEyePosToBuilding = this.buildingPosMatInv.transformPoint3D(point3dScratch, resultRelEyePosToBuilding);

	return resultRelEyePosToBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.getHeaderVersion = function() 
{
	if (this.metaData)
	{ return this.metaData.version; }
	else
	{ return undefined; }
};


/**
 * 어떤 일을 하고 있습니까?
 * @param lod 변수
 */
NeoBuilding.prototype.getLodBuildingData = function(lod) 
{
	if (this.lodBuildingDatasMap === undefined)
	{ return undefined; }
	
	return this.lodBuildingDatasMap[lod];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.getCurrentLodString = function() 
{
	var currentLodString = undefined;
	var lodBuildingData = this.getLodBuildingData(this.currentLod);
	currentLodString = lodBuildingData.geometryFileName;
	return currentLodString;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.getLowerSkinLodToLoad = function(currentLod) 
{
	// When load buildingSkin, must load respecting the LOD-order. Load 1rst lowerLod.
	// This function returns the lowerLod that is no loaded from currentLod.
	var lodToLoad;
	
	for (var lod = 5; lod >= 0; lod--)
	{
		var lodBuildingDataAux = this.getLodBuildingData(lod);
		
		if (lodBuildingDataAux === undefined)
		{ continue; }
	
		if (lodBuildingDataAux.isModelRef)
		{ continue; }
	
		var lodStringAux = lodBuildingDataAux.geometryFileName;
		var lowLodMeshAux = this.lodMeshesMap[lodStringAux];
		
		// Check if lowLodMeshAux if finished loading data.
		if (lowLodMeshAux === undefined || lowLodMeshAux.fileLoadState === CODE.fileLoadState.READY)
		{
			lodToLoad = lod;
			break;
		}
		else if (lowLodMeshAux.vbo_vicks_container.vboCacheKeysArray === undefined)
		{
			lodToLoad = lod;
			break;
		}
		if (lowLodMeshAux.vbo_vicks_container.vboCacheKeysArray[0] && lowLodMeshAux.vbo_vicks_container.vboCacheKeysArray[0].vboBufferTCoord)
		{
			// this is the new version.
			if (lowLodMeshAux.texture === undefined)
			{
				lodToLoad = lod;
				break;
			}
		}
	}

	return lodToLoad;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.getCurrentSkin = function() 
{
	if (this.lodMeshesMap === undefined)
	{ return undefined; }
	
	var skinLego;
	var lodBuildingData = this.getLodBuildingData(this.currentLod);
	if (lodBuildingData === undefined)
	{ return; }
		
	//textureFileName = lodBuildingData.textureFileName;
	var lodString = lodBuildingData.geometryFileName;
	skinLego = this.lodMeshesMap[lodString];
		
	if (skinLego !== undefined && skinLego.isReadyToRender())
	{ return skinLego; }
		
	
	if (this.currentLod === 0)
	{
		skinLego = this.lodMeshesMap.lod0;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod1;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod2;
				if (skinLego === undefined || !skinLego.isReadyToRender())
				{
					skinLego = this.lodMeshesMap.lod3;
					if (skinLego === undefined || !skinLego.isReadyToRender())
					{
						skinLego = this.lodMeshesMap.lod4;
						if (skinLego === undefined || !skinLego.isReadyToRender())
						{
							skinLego = this.lodMeshesMap.lod5;
						}
					}
				}
			}
		}
		
	}
	else if (this.currentLod === 1)
	{
		skinLego = this.lodMeshesMap.lod1;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod2;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod3;
				if (skinLego === undefined || !skinLego.isReadyToRender())
				{
					skinLego = this.lodMeshesMap.lod4;
					if (skinLego === undefined || !skinLego.isReadyToRender())
					{
						skinLego = this.lodMeshesMap.lod5;
					}
				}
			}
		}
		
	}
	else if (this.currentLod === 2)
	{
		skinLego = this.lodMeshesMap.lod2;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod3;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod4;
				if (skinLego === undefined || !skinLego.isReadyToRender())
				{
					skinLego = this.lodMeshesMap.lod5;
				}
			}
		}
		
	}
	else if (this.currentLod === 3)
	{
		skinLego = this.lodMeshesMap.lod3;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod4;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod5;
			}
		}
		
	}
	else if (this.currentLod === 4)
	{
		skinLego = this.lodMeshesMap.lod4;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod5;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod3;
			}
		}
		
	}
	else if (this.currentLod === 5)
	{
		skinLego = this.lodMeshesMap.lod5;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod4;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod3;
			}
		}
		
	}

	return skinLego;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.manageNeoReferenceTexture = function(neoReference, magoManager) 
{
	var texture = undefined;
	
	if (this.metaData.version[0] === "v")
	{
		// this is the version beta.
		if (neoReference.texture === undefined)
		{ return undefined; }
		
		if (neoReference.texture.texId === undefined && neoReference.texture.textureImageFileName !== "") 
		{
			// 1rst, check if the texture is loaded.
			if (this.texturesLoaded === undefined)
			{ this.texturesLoaded = []; }
			
			var sameTexture = this.getSameTexture(neoReference.texture);
			if (sameTexture === undefined)
			{
				if (magoManager.backGround_fileReadings_count > 10) 
				{ return; }
			
				if (neoReference.texture.fileLoadState === CODE.fileLoadState.READY) 
				{
					var gl = magoManager.sceneState.gl;
					neoReference.texture.texId = gl.createTexture();
					// Load the texture.
					var projectFolderName = this.projectFolderName;
					var geometryDataPath = magoManager.readerWriter.geometryDataPath;
					var filePath_inServer = geometryDataPath + "/" + projectFolderName + "/" + this.buildingFileName + "/Images_Resized/" + neoReference.texture.textureImageFileName;

					this.texturesLoaded.push(neoReference.texture);
					magoManager.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, neoReference.texture, this, magoManager);
					magoManager.backGround_fileReadings_count ++;
				}
			}
			else 
			{
				if (sameTexture.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
				{
					neoReference.texture = sameTexture;
				}
			}
		}
		
		return neoReference.texture.fileLoadState;
	}
	else if (this.metaData.version[0] === '0' && this.metaData.version[2] === '0' && this.metaData.version[4] === '1' )
	{
		if (neoReference.texture === undefined || neoReference.texture.fileLoadState === CODE.fileLoadState.READY)
		{
			// provisionally use materialId as textureId.
			var textureId = neoReference.materialId;
			texture = this.texturesLoaded[textureId];
			neoReference.texture = texture;
			
			if (texture.texId === undefined && texture.textureImageFileName !== "")
			{
				if (magoManager.backGround_fileReadings_count > 10) 
				{ return undefined; }
	
				if (texture.fileLoadState === CODE.fileLoadState.READY) 
				{
					var gl = magoManager.sceneState.gl;
					texture.texId = gl.createTexture();
					// Load the texture.
					var projectFolderName = this.projectFolderName;
					var geometryDataPath = magoManager.readerWriter.getCurrentDataPath();
					var filePath_inServer = geometryDataPath + "/" + projectFolderName + "/" + this.buildingFileName + "/Images_Resized/" + texture.textureImageFileName;

					magoManager.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, texture, this, magoManager);
					magoManager.backGround_fileReadings_count ++;
				}
			}
		}
		
		return neoReference.texture.fileLoadState;
	}
	else if (this.metaData.version[0] === '0' && this.metaData.version[2] === '0' && this.metaData.version[4] === '2' )
	{
		// Project_data_type (new in version 002).
		// 1 = 3d model data type (normal 3d with interior & exterior data).
		// 2 = single building skin data type (as vWorld or googleEarth data).
		// 3 = multi building skin data type (as Shibuya & Odaiba data).
		// 4 = pointsCloud data type.
		// 5 = pointsCloud data type pyramidOctree test.	
		if (this.metaData.projectDataType === undefined || this.metaData.projectDataType > 3)
		{ return neoReference.texture.fileLoadState; }
	
		if (neoReference.texture === undefined || neoReference.texture.fileLoadState === CODE.fileLoadState.READY)
		{
			// provisionally use materialId as textureId.
			var textureId = neoReference.materialId;
			texture = this.texturesLoaded[textureId];
			neoReference.texture = texture;
			
			if (texture.texId === undefined && texture.textureImageFileName !== "")
			{
				if (magoManager.backGround_fileReadings_count > 10) 
				{ return undefined; }
	
				if (texture.fileLoadState === CODE.fileLoadState.READY) 
				{
					var gl = magoManager.sceneState.gl;
					texture.texId = gl.createTexture();
					// Load the texture.
					var projectFolderName = this.projectFolderName;
					var geometryDataPath = magoManager.readerWriter.getCurrentDataPath();
					var filePath_inServer = geometryDataPath + "/" + projectFolderName + "/" + this.buildingFileName + "/Images_Resized/" + texture.textureImageFileName;

					magoManager.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, texture, this, magoManager);
					magoManager.backGround_fileReadings_count ++;
				}
			}
		}
		
		return neoReference.texture.fileLoadState;
	}
	
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.getShaderName = function(lod, projectType, renderType) 
{
	var shaderName;
	
	// renderType = 0 -> depth render.
	// renderType = 1 -> normal render.
	// renderType = 2 -> colorSelection render.
	//--------------------------------------------
	
	if (renderType === 0)
	{
		if (lod <= 1)
		{
			shaderName = "modelRefDepth";
		}
	}
	else if (renderType === 1)
	{
		if (lod <= 2)
		{
			shaderName = "modelRefSsao";
		}
	}
	else if (renderType === 2)
	{
		if (lod <= 1)
		{
			shaderName = "modelRefSsao";
		}
	}

	return shaderName;
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.prepareSkin = function(magoManager) 
{
	var headerVersion = this.getHeaderVersion();
	if (headerVersion === undefined)
	{ return false; }
	
	if (headerVersion[0] !== "0")
	{
		return false;
	}

	if (this.lodMeshesMap === undefined)
	{ this.lodMeshesMap = {}; } 
	
	var projectFolderName = this.projectFolderName;
	var buildingFolderName = this.buildingFileName;
	var geometryDataPath = magoManager.readerWriter.geometryDataPath;
	
	// Must respect the lodLoading order: must load the lowerLod if is not loaded.
	var lodToLoad;
	lodToLoad = this.getLowerSkinLodToLoad(this.currentLod);
	var lodBuildingData = this.getLodBuildingData(lodToLoad);
	if (lodBuildingData === undefined)
	{ return false; }

	if (lodBuildingData.isModelRef)
	{ return false; }
	
	var textureFileName = lodBuildingData.textureFileName;
	var lodString = lodBuildingData.geometryFileName;
	
	///lowLodMesh = this.lodMeshesMap.get(lodString); // code if "lodMeshesMap" is a map.
	var lowLodMesh = this.lodMeshesMap[lodString];
	if (lowLodMesh === undefined)
	{
		lowLodMesh = new Lego();
		lowLodMesh.fileLoadState = CODE.fileLoadState.READY;
		lowLodMesh.textureName = textureFileName;
		lowLodMesh.legoKey = this.buildingId + "_" + lodString;
		this.lodMeshesMap[lodString] = lowLodMesh;
	}
	
	if (lowLodMesh.fileLoadState === -1)
	{
		// if a lodObject has "fileLoadState" = -1 means that there are no file in server.
		return false;
	}
	
	if (lowLodMesh.fileLoadState === CODE.fileLoadState.READY) 
	{
		// put it into fileLoadQueue.
		var lodMeshFilePath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/" + lodString;
		magoManager.readerWriter.getLegoArraybuffer(lodMeshFilePath, lowLodMesh, magoManager);
		if (lowLodMesh.vbo_vicks_container.vboCacheKeysArray === undefined)
		{ lowLodMesh.vbo_vicks_container.vboCacheKeysArray = []; }
		
	}
	
	if (lowLodMesh.vbo_vicks_container.vboCacheKeysArray[0] && lowLodMesh.vbo_vicks_container.vboCacheKeysArray[0].vboBufferTCoord)
	{
		// this is the new version.
		if (lowLodMesh.texture === undefined)
		{
			lowLodMesh.texture = new Texture();
			var filePath_inServer = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/" + textureFileName;
			var gl = magoManager.sceneState.gl;
			magoManager.readerWriter.readLegoSimpleBuildingTexture(gl, filePath_inServer, lowLodMesh.texture, magoManager); 
		}
	}
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.render = function(magoManager, shader, renderType, refMatrixIdxKey, flipYTexCoord, currentLod) 
{
	var gl = magoManager.sceneState.gl;
	//gl.uniform1f(shader.externalAlpha_loc, 1.0);
	
	if (currentLod !== undefined)
	{ this.currentLod = currentLod; }
	
	// Check metaData.projectDataType.
	if (this.metaData.projectDataType === 5)
	{
		// Render pointsCloud pyramidMode.
		return;
	}
	
	if (this.currentLod <= 2)
	{
		// There are buildings that are only skin, so check projectType of the building.
		var lodBuildingData = this.getLodBuildingData(this.currentLod);
		if (lodBuildingData && !lodBuildingData.isModelRef)
		{
			// This building is skinType data.
			this.renderSkin(magoManager, shader, renderType);
		}
		else
		{
			// This building is octree divided type data.
			var octreesRenderedCount = this.renderDetailed(magoManager, shader, renderType, refMatrixIdxKey, flipYTexCoord);
			
			if (this.currentVisibleOctreesControler === undefined)
			{
				this.renderSkin(magoManager, shader, renderType);
			}
			else
			{
				var lowestOctreesCount0 = this.currentVisibleOctreesControler.currentVisibles0.length;
				var lowestOctreesCount1 = this.currentVisibleOctreesControler.currentVisibles1.length;
				var lowestOctreesCount2 = this.currentVisibleOctreesControler.currentVisibles2.length;
				
				// If octreesRenderedsCount is minor than 60% of total of visibleOctrees, then render the buildingSkin.
				if (octreesRenderedCount < (lowestOctreesCount0 + lowestOctreesCount1 + lowestOctreesCount2)*0.4)
				{ this.renderSkin(magoManager, shader, renderType); }
			}
		}
		
		// Now, check how many octrees are rendered. If rendered only a few, then render the buildingSkin.
		
	}
	else if (this.currentLod > 2)
	{
		this.renderSkin(magoManager, shader, renderType);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.renderSkin = function(magoManager, shader, renderType) 
{
	var skinLego = this.getCurrentSkin();
		
	if (skinLego === undefined)
	{ return; }

	if (skinLego.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
	{ return; }

	var gl = magoManager.sceneState.gl;

	if (renderType === 1 && magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected === this)
	{
		// active stencil buffer to draw silhouette.
		magoManager.renderer.enableStencilBuffer(gl);
	}
	
	magoManager.renderer.currentObjectsRendering.curOctree = this;
	
	var currentObjectsRendering = magoManager.renderer.currentObjectsRendering;
	var selCandidates;
	var selectionColor;
	var currentNode;
	var currentOctree;
	
	if (renderType === 2)
	{
		selCandidates = magoManager.selectionManager;
		selectionColor = magoManager.selectionColor;
		renderTexture = false; // reassign value for this var.
		currentNode = currentObjectsRendering.curNode;
		currentOctree = currentObjectsRendering.curOctree;
	}
	
	var renderTexture = true;
	
	// if the building is highlighted, the use highlight oneColor4.
	if (renderType === 1)
	{
		if (this.isHighLighted)
		{
			//gl.uniform1i(shader.bUse1Color_loc, true);
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			gl.uniform4fv(shader.oneColor4_loc, this.highLightColor4); //.
			renderTexture = false;
		}
		else if (this.isColorChanged)
		{
			//gl.uniform1i(shader.bUse1Color_loc, true);
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			gl.uniform4fv(shader.oneColor4_loc, [this.aditionalColor.r, this.aditionalColor.g, this.aditionalColor.b, this.aditionalColor.a]); //.
			renderTexture = false;
		}
		else
		{
			//gl.uniform1i(shader.bUse1Color_loc, false);
		}
		//----------------------------------------------------------------------------------
		if (skinLego.texture !== undefined && skinLego.texture.texId && renderTexture)
		{
			
			shader.enableVertexAttribArray(shader.texCoord2_loc);
			gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
			if (shader.last_tex_id !== skinLego.texture.texId)
			{
				gl.bindTexture(gl.TEXTURE_2D, skinLego.texture.texId);
				shader.last_tex_id = skinLego.texture.texId;
			}
		}
		else 
		{
			//return;
			if (magoManager.textureAux_1x1 !== undefined && renderTexture)
			{
				shader.enableVertexAttribArray(shader.texCoord2_loc);
				gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
				gl.bindTexture(gl.TEXTURE_2D, magoManager.textureAux_1x1);
			}
			else 
			{
				gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			}
		}
	}
	else if (renderType === 2)
	{
		// Color selction mode.
		var colorAux;
		colorAux = magoManager.selectionColor.getAvailableColor(colorAux);
		var idxKey = magoManager.selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
		magoManager.selectionManager.setCandidates(idxKey, undefined, undefined, this, currentNode);
		
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
	}
	
	gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
	skinLego.render(magoManager, renderType, renderTexture, shader);
	
	if (renderType === 1 && magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected === this)
	{
		// active stencil buffer to draw silhouette.
		magoManager.renderer.disableStencilBuffer(gl);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.renderDetailed = function(magoManager, shader, renderType, refMatrixIdxKey, flipYTexCoord) 
{	
	var octreesRenderedCount = 0;
	if (this.currentVisibleOctreesControler === undefined)
	{ return octreesRenderedCount; }
	
	var renderTexture = false;	
	var gl = magoManager.sceneState.gl;
	
	if (renderType === 0)
	{
		renderTexture = false;
	}
	else if (renderType === 1)
	{
		if (this.texturesLoaded && this.texturesLoaded.length>0)
		{
			renderTexture = true;
		}
		else { renderTexture = false; }
		
		if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected === this)
		{
			// active stencil buffer to draw silhouette.
			magoManager.renderer.enableStencilBuffer(gl);
		}
	}
	//else if (renderType === 2) // No need to do any function.
	
	// set the currentObjectsRendering.
	magoManager.renderer.currentObjectsRendering.curBuilding = this;
	
	var lowestOctree;
	var refMatrixIdxKey = 0;
	var isInterior = false; // old var.
	
	var applyOcclusionCulling = this.getRenderSettingApplyOcclusionCulling();
	if (applyOcclusionCulling === undefined)
	{ applyOcclusionCulling = true; }
	
	var relCamPosX, relCamPosY, relCamPosZ; 
	if (applyOcclusionCulling)
	{
		relCamPosX = this.myCameraRelative.position.x;
		relCamPosY = this.myCameraRelative.position.y;
		relCamPosZ = this.myCameraRelative.position.z;
	}
	
	// LOD0.
	var minSize = 0.0;
	var lowestOctreesCount = this.currentVisibleOctreesControler.currentVisibles0.length;
	for (var j=0; j<lowestOctreesCount; j++) 
	{
		lowestOctree = this.currentVisibleOctreesControler.currentVisibles0[j];
		if (lowestOctree.neoReferencesMotherAndIndices === undefined) 
		{ continue; }
		
		if (applyOcclusionCulling)
		{ lowestOctree.neoReferencesMotherAndIndices.updateCurrentVisibleIndices(relCamPosX, relCamPosY, relCamPosZ, applyOcclusionCulling); }
		
		lowestOctree.lod = 0; // set current lod to octree.
		if (lowestOctree.renderContent(magoManager, this, renderType, renderTexture, shader, minSize, refMatrixIdxKey, flipYTexCoord))
		{ octreesRenderedCount++; }
	}
	
	// LOD1.
	minSize = 0.45;
	lowestOctreesCount = this.currentVisibleOctreesControler.currentVisibles1.length;
	for (var j=0; j<lowestOctreesCount; j++) 
	{
		lowestOctree = this.currentVisibleOctreesControler.currentVisibles1[j];
		if (lowestOctree.neoReferencesMotherAndIndices === undefined) 
		{ continue; }
	
		if (applyOcclusionCulling)
		{ lowestOctree.neoReferencesMotherAndIndices.updateCurrentVisibleIndices(relCamPosX, relCamPosY, relCamPosZ, applyOcclusionCulling); }
		
		lowestOctree.lod = 1; // set current lod to octree.
		if (lowestOctree.renderContent(magoManager, this, renderType, renderTexture, shader, minSize, refMatrixIdxKey, flipYTexCoord))
		{ octreesRenderedCount++; }
	}
	
	// LOD2.
	shader.disableVertexAttribArray(shader.color4_loc);
	lowestOctreesCount = this.currentVisibleOctreesControler.currentVisibles2.length;
	for (var j=0; j<lowestOctreesCount; j++) 
	{
		// Render the lowestOctree.lego.
		lowestOctree = this.currentVisibleOctreesControler.currentVisibles2[j];
		if (lowestOctree.lego === undefined) 
		{ continue; }
		
		lowestOctree.lod = 2; // set current lod to octree.
		if (lowestOctree.renderContent(magoManager, this, renderType, renderTexture, shader, minSize, refMatrixIdxKey, flipYTexCoord))
		{ octreesRenderedCount++; }
	}
	
	// Finally:
	if (renderType === 1)
	{
		if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected === this)
		{
			// deactive stencil buffer to draw silhouette.
			magoManager.renderer.disableStencilBuffer(gl);
		}
	}
	
	return octreesRenderedCount;
};






































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoBuildingsList
 */
var NeoBuildingsList = function() 
{
	if (!(this instanceof NeoBuildingsList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	//Array.apply(this, arguments);

	this.neoBuildingsArray = [];
};
//NeoBuildingsList.prototype = Object.create(Array.prototype);

/**
 * 어떤 일을 하고 있습니까?
 * @returns neoBuilding
 */
NeoBuildingsList.prototype.newNeoBuilding = function() 
{
	var neoBuilding = new NeoBuilding();
	this.neoBuildingsArray.push(neoBuilding);
	return neoBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns neoBuilding
 */
NeoBuildingsList.prototype.getNeoBuildingByTypeId = function(buildingType, buildingId) 
{
	var resultBuilding;
	var buildingsCount = this.neoBuildingsArray.length;
	var found = false;
	var i=0;
	while (!found && i < buildingsCount)
	{
		if (this.neoBuildingsArray[i].buildingType === buildingType && this.neoBuildingsArray[i].buildingId === buildingId)
		{
			found = true;
			resultBuilding = this.neoBuildingsArray[i];
		}
		i++;
	}

	return resultBuilding;
};


NeoBuildingsList.prototype.get = function (index)
{
	return this.neoBuildingsArray[index];
};

NeoBuildingsList.prototype.add = function (item)
{
	if (item !== undefined)	{ this.neoBuildingsArray.push(item); }
};
'use strict';

/**
 * Reference 파일에 대한 객체
 * lod1일 경우 model과 Reference파일을 참조.
 * 
 * Geometry object. The real geometry data is a model, and this referenceObject has the model's index.
 * 
 * @class NeoReference
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * 아래 문서 1.4 Reference Folder 참조
 * @link https://github.com/Gaia3D/F4DConverter/blob/master/doc/F4D_SpecificationV1.pdf
 */
var NeoReference = function() 
{
	if (!(this instanceof NeoReference)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * The object's index on motherReferenceArray.
	 * @type {Number}
	 * @default 0
	 */
	this._id = 0;

	/**
	 * The object's identifier.
	 * @type {String}
	 * @default ""
	 */
	this.objectId = "";

	/**
	 * The model's index.
	 * @type {Number}
	 * @default -1
	 */
	this._block_idx = -1;
	
	/**
	 * The model-reference transformation matrix.(do not modify).
	 * @type {Matrix4}
	 * @default Identity matrix
	 */
	this._originalMatrix4 = new Matrix4(); 

	/**
	 * The final transformation matrix. Is calculated by multiplication between model-reference-matrix and building-matrix.
	 * @type {Matrix4}
	 * @default Identity matrix
	 */
	this._matrix4 = new Matrix4(); 
	
	/**
	 * Array used to store finalTransformationMatrices, chronological transformations, or two positions mode for example.
	 * @type {Array}
	 * @default undefined
	 */
	this.tMatrixAuxArray; 
	
	/**
	 * Parameter that specifies the type of the transformation matrix. 0 = identity matrix, 1 = translation matrix, 2 = transformation matrix.
	 * @type {Number}
	 * @default 2
	 */
	this.refMatrixType = 2; 
	
	/**
	 * Position vector of the translation matrix. Use this if "refMatrixType" = 1.
	 * @type {Float32Array(3)}
	 * @default undefined
	 */
	this.refTranslationVec; 
	
	/**
	 * VBOs container.
	 * @type {VBOVertexIdxCacheKeysContainer}
	 * @default undefined
	 */
	this.vBOVertexIdxCacheKeysContainer; 

	/**
	 * Material index.
	 * @type {Number}
	 * @default undefined
	 */
	this.materialId;
	
	/**
	 * Parameter that indicates if this object has texture.
	 * @type {Boolean}
	 * @default false
	 */
	this.hasTexture = false;
	
	/**
	 * Texture object.
	 * @type {Texture}
	 * @default undefined
	 */
	this.texture; 

	/**
	 * Object's color if has not texture.
	 * @type {Color}
	 * @default undefined
	 */
	this.color4; 
	
	/**
	 * Object's aditional color. Used when object color was changed.
	 * @type {Color}
	 * @default undefined
	 */
	this.aditionalColor; 

	/**
	 * Object's movement vector in local coordinates.
	 * @type {Point3D}
	 * @default undefined
	 */
	this.moveVectorRelToBuilding; 
	
	/**
	 * Object's movement vector in world coordinates.
	 * @type {Point3D}
	 * @default undefined
	 */
	this.moveVector; 

	/**
	 * Object's current rendering phase. Parameter to avoid duplicated render on scene.
	 * @type {Boolean}
	 * @default false
	 */
	this.renderingFase = false;
	
	/**
	 * Object's translucent alpha. Used when born the reference object until adult.
	 * @type {Number}
	 * @default false
	 */
	this.blendAlpha = 0.0;
	
	/**
	 * Object's born date.
	 * @type {Number}
	 * @default undefined
	 */
	this.birthTime;
	
	/**
	 * Parameter that indicates if the object is adult. If is adult, then do no apply blendAlpha.
	 * @type {Number}
	 * @default undefined
	 */
	this.isAdult = false;
};

/**
 * Commutate the renderingFase value: true - false.
 */
NeoReference.prototype.swapRenderingFase = function() 
{
	this.renderingFase = !this.renderingFase;
};

/**
 * Returns the blending alpha value in current time.
 * 
 * @param {Number} currTime The current time.
 */
NeoReference.prototype.getBlendAlpha = function(currTime) 
{
	if (!this.isAdult)
	{
		if (this.birthTime === undefined)
		{ this.birthTime = currTime; }
		
		var increAlpha = (currTime - this.birthTime)*0.0001;
		this.blendAlpha += increAlpha;
		
		if (this.blendAlpha >= 1.0)
		{
			this.isAdult = true;
		}
	}
	else
	{ return 1.0; }
	
	return this.blendAlpha;
};

/**
 * _originalMatrix4와 파라미터로 받은 matrix를 4차원 행렬의 곱셈을 계산한 결과를 _matrix4에 할당
 * 
 * @param {Matrix4} matrix
 */
NeoReference.prototype.multiplyTransformMatrix = function(matrix) 
{
	this._matrix4 = this._originalMatrix4.getMultipliedByMatrix(matrix); // Original.
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoReference.prototype.multiplyKeyTransformMatrix = function(idxKey, matrix) 
{
	// this function multiplies the originalMatrix by "matrix" and stores it in the "idxKey" position.
	if (this.tMatrixAuxArray === undefined)
	{ this.tMatrixAuxArray = []; }

	this.tMatrixAuxArray[idxKey] = this._originalMatrix4.getMultipliedByMatrix(matrix, this.tMatrixAuxArray[idxKey]);
	
	if (this.moveVectorRelToBuilding)
	{
		this.moveVector = matrix.rotatePoint3D(this.moveVectorRelToBuilding, this.moveVector); 
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoReference.prototype.hasKeyMatrix = function(idxKey) 
{
	if (this.tMatrixAuxArray === undefined)
	{ return false; }

	if (this.tMatrixAuxArray[idxKey] === undefined)
	{ return false; }
	else
	{ return true; }
};

/**{Boolean}
 * 어떤 일을 하고 있습니까?
 * 
  * @returns {Boolean} returns if the neoReference is ready to render.
 */
NeoReference.prototype.isReadyToRender = function() 
{
	if (this.tMatrixAuxArray === undefined)
	{
		//this.multiplyKeyTransformMatrix(refMatrixIdxKey, neoBuilding.geoLocationDataAux.rotMatrix);
		// we must collect all the neoReferences that has no tMatrixAuxArray and make it.
		return false;
	}
	
	return true;
};

/**
 * Renders the content.
 */
NeoReference.prototype.solveReferenceColorOrTexture = function(magoManager, neoBuilding, shader, currentObjectsRendering) 
{
	var gl = magoManager.sceneState.gl;
	
	// Check if we are under a selected data structure.
	var selectionManager = magoManager.selectionManager;
	var referenceObjectIsSelected = false;
	if (selectionManager.parentSelected && magoManager.objectSelected === this)
	{
		referenceObjectIsSelected = true;
		
		if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.OBJECT) 
		{
			// Active stencil if the object is selected.
			magoManager.renderer.enableStencilBuffer(gl);
		}
	}
	
	// Check the color or texture of reference object.
	if (neoBuilding.isHighLighted)
	{
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, magoManager.highLightColor4);
	}
	else if (neoBuilding.isColorChanged)
	{
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		if (referenceObjectIsSelected) 
		{
			gl.uniform4fv(shader.oneColor4_loc, [255.0/255.0, 0/255.0, 0/255.0, 255.0/255.0]);
		}
		else
		{
			gl.uniform4fv(shader.oneColor4_loc, [neoBuilding.aditionalColor.r, neoBuilding.aditionalColor.g, neoBuilding.aditionalColor.b, neoBuilding.aditionalColor.a] );
		}
	}
	else if (this.aditionalColor)
	{
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		if (referenceObjectIsSelected) 
		{
			gl.uniform4fv(shader.oneColor4_loc, [255.0/255.0, 0/255.0, 0/255.0, 255.0/255.0]);
		}
		else
		{
			gl.uniform4fv(shader.oneColor4_loc, [this.aditionalColor.r, this.aditionalColor.g, this.aditionalColor.b, this.aditionalColor.a] );
		}
	}
	else
	{
		// Normal rendering.
		if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.OBJECT && referenceObjectIsSelected) 
		{
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			gl.uniform4fv(shader.oneColor4_loc, [255.0/255.0, 0/255.0, 0/255.0, 255.0/255.0]);
		}
		else if (magoManager.magoPolicy.colorChangedObjectId === this.objectId)
		{
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			gl.uniform4fv(shader.oneColor4_loc, [magoManager.magoPolicy.color[0], magoManager.magoPolicy.color[1], magoManager.magoPolicy.color[2], 1.0]);
		}
		else
		{
			if (this.hasTexture) 
			{
				if (this.texture !== undefined && this.texture.texId !== undefined) 
				{
					gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
					if (shader.last_tex_id !== this.texture.texId) 
					{
						gl.bindTexture(gl.TEXTURE_2D, this.texture.texId);
						shader.last_tex_id = this.texture.texId;
					}
				}
				else 
				{
					gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
					gl.uniform4fv(shader.oneColor4_loc, [0.8, 0.0, 0.8, 1.0]);
				}
			}
			else 
			{
				// if no render texture, then use a color.
				gl.uniform1i(shader.bUse1Color_loc, true); //.
				if (this.color4) 
				{
					gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
					gl.uniform4fv(shader.oneColor4_loc, [this.color4.r/255.0, this.color4.g/255.0, this.color4.b/255.0, this.color4.a/255.0]);
				}
				else
				{
					gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
					gl.uniform4fv(shader.oneColor4_loc, [0.8, 0.8, 0.8, 1.0]);
				}
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * 
 * @param mag{Boolean}
 * @returns {Boolean} returns if the neoReference was rendered.
 */
NeoReference.prototype.render = function(magoManager, neoBuilding, renderType, renderTexture, shader, refMatrixIdxKey, minSizeToRender) 
{
	var neoReference = this;
	
	if (!neoReference.isReadyToRender())
	{ return false; }

	// Check if the texture is loaded.
	//if (neoReference.texture !== undefined || neoReference.materialId != -1)
	if (neoReference.hasTexture)// && neoReference.texture !== undefined)
	{
		// note: in the future use only "neoReference.materialId".
		var texFileLoadState = neoBuilding.manageNeoReferenceTexture(neoReference, magoManager);
		if (texFileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
		{ return false; }
	
		if (neoReference.texture === undefined)
		{ return false; }
	
		if (neoReference.texture.texId === undefined)
		{ return false; }
	}
	
	var currentObjectsRendering = magoManager.renderer.currentObjectsRendering;
	var selectionManager;
	var selectionColor;
	var currentNode;
	var currentOctree;
	
	if (renderType === 2)
	{
		selectionManager = magoManager.selectionManager;
		selectionColor = magoManager.selectionColor;
		renderTexture = false; // reassign value for this var.
		currentNode = currentObjectsRendering.curNode;
		currentOctree = currentObjectsRendering.curOctree;
	}
	
	var gl = magoManager.sceneState.gl;
	
	var block_idx = neoReference._block_idx;
	var block = neoBuilding.motherBlocksArray[block_idx];
	
	if (block === undefined)
	{ return false; }
	
	if (magoManager.mouseLeftDown || magoManager.mouseMiddleDown)
	{ minSizeToRender = 0.5; }
	
	if (!block.isReadyToRender(neoReference, magoManager, minSizeToRender))
	{ return false; }

	// Check the color or texture of reference object.
	if (renderType === 1)
	{
		neoReference.solveReferenceColorOrTexture(magoManager, neoBuilding, shader, currentObjectsRendering);
	}
	else if (renderType === 2)
	{
		neoReference.selColor4 = selectionColor.getAvailableColor(neoReference.selColor4); 
		var idxKey = selectionColor.decodeColor3(neoReference.selColor4.r, neoReference.selColor4.g, neoReference.selColor4.b);

		selectionManager.setCandidates(idxKey, neoReference, currentOctree, neoBuilding, currentNode);
		if (neoReference.selColor4) 
		{
			gl.uniform4fv(shader.oneColor4_loc, [neoReference.selColor4.r/255.0, neoReference.selColor4.g/255.0, neoReference.selColor4.b/255.0, 1.0]);
		}
	}
	// End check color or texture of reference object.-----------------------------------------------------------------------------
	
	//Now erase the aditional information (aditionalColor & moveVector).
	this.aditionalColor = undefined;
	
	// Test external alpha.
	if (magoManager.isTrailRender === undefined || magoManager.isTrailRender === false) // check if mago is not rendering special effects.
	{
		var blendAlpha = neoReference.getBlendAlpha(magoManager.currTime);
		gl.uniform1f(shader.externalAlpha_loc, blendAlpha);
	}
	
	// End test.---
	
	var cacheKeys_count = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray.length;
	// Must applicate the transformMatrix of the reference object.

	gl.uniform1i(shader.refMatrixType_loc, neoReference.refMatrixType);

	if (neoReference.refMatrixType === 1)
	{ gl.uniform3fv(shader.refTranslationVec_loc, neoReference.refTranslationVec); }
	else if (neoReference.refMatrixType === 2)
	{ gl.uniformMatrix4fv(shader.refMatrix_loc, false, neoReference.tMatrixAuxArray[refMatrixIdxKey]._floatArrays); }
	

	if (neoReference.moveVector !== undefined) 
	{
		gl.uniform1i(shader.hasAditionalMov_loc, true);
		gl.uniform3fv(shader.aditionalMov_loc, [neoReference.moveVector.x, neoReference.moveVector.y, neoReference.moveVector.z]); //.
		shader.last_isAditionalMovedZero = false;
	}
	else 
	{
		if (!shader.last_isAditionalMovedZero)
		{
			gl.uniform1i(shader.hasAditionalMov_loc, false);
			gl.uniform3fv(shader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.
			shader.last_isAditionalMovedZero = true;
		}
	}
	
	var vboKey;
	for (var n=0; n<cacheKeys_count; n++) // Original.
	{
		//var mesh_array = block.viArraysContainer._meshaderrays[n];
		vboKey = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray[n];
		
		// Positions.
		if (!vboKey.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }

		if (renderType === 1)
		{
			// Normals.
			if (!vboKey.bindDataNormal(shader, magoManager.vboMemoryManager))
			{ return false; }

			// TexCoords.
			if (renderTexture && neoReference.hasTexture) 
			{
				if (block.vertexCount <= neoReference.vertexCount) 
				{
					var refVboData = neoReference.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray[n];
					if (!refVboData.bindDataTexCoord(shader, magoManager.vboMemoryManager))
					{ return false; }
				}
				else 
				{
					shader.disableVertexAttribArray(shader.texCoord2_loc); 
				}
			}
			else 
			{
				shader.disableVertexAttribArray(shader.texCoord2_loc); 
			}
		}

		// Indices.
		var indicesCount;
		if (magoManager.isCameraMoving)// && !isInterior && magoManager.isCameraInsideBuilding)
		{
			indicesCount = vboKey.indicesCount;
		}
		else
		{
			if (magoManager.thereAreUrgentOctrees)
			{
				indicesCount = vboKey.bigTrianglesIndicesCount;
				if (indicesCount > vboKey.indicesCount)
				{ indicesCount = vboKey.indicesCount; }
			}
			else 
			{
				indicesCount = vboKey.indicesCount;
			}
		}
		if (!vboKey.bindDataIndice(shader, magoManager.vboMemoryManager))
		{ return false; }
		gl.drawElements(gl.TRIANGLES, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.
	}
		
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoReference.prototype.deleteObjects = function(gl, vboMemManager) 
{
	// 1) Object ID.
	this._id = undefined;

	// 2) Block Idx.
	this._block_idx = undefined;

	// 3) Transformation Matrix.
	this._matrix4._floatArrays = undefined;
	this._matrix4 = undefined;
	this._originalMatrix4._floatArrays = undefined;
	this._originalMatrix4 = undefined; //

	// 5) The texture image.
	this.hasTexture = undefined;
	// no delete the texture, only break the referencing.
	this.texture = undefined; // Texture

	// 6) 1 color.
	if (this.color4)
	{ this.color4.deleteObjects(); }
	this.color4 = undefined; //new Color();

	// 7) selection color.
	if (this.selColor4)
	{ this.selColor4.deleteObjects(); }
	this.selColor4 = undefined; //new Color(); // use for selection only.

	// 8) movement of the object.
	if (this.moveVector)
	{ this.moveVector.deleteObjects(); }
	this.moveVector = undefined; // Point3D.

	this.bRendered = undefined;
	
	if (this.vBOVertexIdxCacheKeysContainer !== undefined)
	{
		this.vBOVertexIdxCacheKeysContainer.deleteGlObjects(gl, vboMemManager);
		this.vBOVertexIdxCacheKeysContainer = undefined;
	}
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoReferencesMotherAndIndices
 */
var NeoReferencesMotherAndIndices = function() 
{
	if (!(this instanceof NeoReferencesMotherAndIndices)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.motherNeoRefsList; // this is a NeoReferencesList pointer.
	this.neoRefsIndices = []; // All objects(references) of this class.
	this.modelReferencedGroupsList; // (for new format. No used yet).
	this.blocksList;

	this.fileLoadState = 0; // init as "READY".
	this.dataArraybuffer;
	this.succesfullyGpuDataBinded;

	this.exterior_ocCullOctree; // octree that contains the visible indices.
	this.interior_ocCullOctree; // octree that contains the visible indices.
	
	this.currentVisibleIndices = [];
	this.currentVisibleMRG; // MRG = ModelReferencedGroup (for new format).
	this.xhr;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param matrix 변수
 */
NeoReferencesMotherAndIndices.prototype.multiplyKeyTransformMatrix = function(idxKey, matrix) 
{
	var refIndicesCount = this.neoRefsIndices.length;
	for (var i=0; i<refIndicesCount; i++)
	{
		this.motherNeoRefsList[this.neoRefsIndices[i]].multiplyKeyTransformMatrix(idxKey, matrix);
	}
};

NeoReferencesMotherAndIndices.prototype.updateCurrentVisibleIndices = function(eye_x, eye_y, eye_z, applyOcclusionCulling) 
{
	if (applyOcclusionCulling === undefined)
	{ applyOcclusionCulling = true; }

	// check if is interior.
	var isExterior = false;
	if (this.interior_ocCullOctree !== undefined)
	{
		var thisHasOcCullData = false;
		if (this.interior_ocCullOctree._subBoxesArray && this.interior_ocCullOctree._subBoxesArray.length > 0)
		{ thisHasOcCullData = true; }
	
		if (thisHasOcCullData && applyOcclusionCulling)
		{
			//if (this.currentVisibleMRG === undefined)
			//{ this.currentVisibleMRG = new ModelReferencedGroupsList(); }
			
			var intersectedSubBox = this.interior_ocCullOctree.getIntersectedSubBoxByPoint3D(eye_x, eye_y, eye_z);
			if (intersectedSubBox !== undefined && intersectedSubBox._indicesArray.length > 0) 
			{
				this.currentVisibleIndices = intersectedSubBox._indicesArray;
				//if (result_modelReferencedGroup)
				//{
				//	result_modelReferencedGroup = this.modelReferencedGroupsList;
				//}
				isExterior = false;
			}
			else 
			{
				isExterior = true;
			}
		}
		else
		{
			// In this case there are no occlusionCulling data.
			this.currentVisibleIndices = this.neoRefsIndices;
			this.currentVisibleMRG = this.modelReferencedGroupsList;
		}
	}
	
	if (isExterior)
	{
		if (this.exterior_ocCullOctree !== undefined)
		{
			var thisHasOcCullData = false;
			if (this.exterior_ocCullOctree._subBoxesArray && this.exterior_ocCullOctree._subBoxesArray.length > 0)
			{ thisHasOcCullData = true; }
		
			if (thisHasOcCullData && applyOcclusionCulling)
			{
				if (this.currentVisibleMRG === undefined)
				{ this.currentVisibleMRG = new ModelReferencedGroupsList(); }
				
				this.currentVisibleIndices = this.exterior_ocCullOctree.getIndicesVisiblesForEye(eye_x, eye_y, eye_z, this.currentVisibleIndices, this.currentVisibleMRG);
			}
			else 
			{
				// In this case there are no occlusionCulling data.
				this.currentVisibleIndices = this.neoRefsIndices;
				this.currentVisibleMRG = this.modelReferencedGroupsList;
			}
		}
	}
};

/**
 * Returns the neoReference
 * @param matrix 변수
 */
NeoReferencesMotherAndIndices.prototype.getNeoReference = function(idx) 
{
	return this.motherNeoRefsList[this.neoRefsIndices[idx]];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
NeoReferencesMotherAndIndices.prototype.deleteObjects = function(gl, vboMemManager) 
{
	if (this.xhr !== undefined)
	{
		this.xhr.abort();
		this.xhr = undefined;
	}
	
	this.motherNeoRefsList = undefined; // this is a NeoReferencesList pointer.
	this.neoRefsIndices = undefined;
	
	if (this.blocksList !== undefined && this.blocksList.xhr !== undefined && this.fileLoadState !== CODE.fileLoadState.READY)
	{
		this.blocksList.xhr.abort();
		this.blocksList.xhr = undefined;
	}
	this.blocksList = undefined;

	this.fileLoadState = undefined;
	this.dataArraybuffer = undefined;

	this.exterior_ocCullOctree = undefined;
	this.interior_ocCullOctree = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
  * @returns {Boolean} returns if the neoReferencesMotherAndIndices is ready to render.
 */
NeoReferencesMotherAndIndices.prototype.isReadyToRender = function() 
{
	if (this.neoRefsIndices === undefined || this.neoRefsIndices.length === 0) 
	{ return false; }

	if (this.blocksList === undefined)
	{ return false; }

	if (this.blocksList.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED) 
	{ return false; }

	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
NeoReferencesMotherAndIndices.prototype.setRenderedFalseToAllReferences = function() 
{
	var refIndicesCount = this.neoRefsIndices.length;
	for (var i=0; i<refIndicesCount; i++)
	{
		this.motherNeoRefsList[this.neoRefsIndices[i]].bRendered = false;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
NeoReferencesMotherAndIndices.prototype.createModelReferencedGroups = function() 
{
	// Group all the references that has the same model.
	if (this.neoRefsIndices === undefined)
	{ return; }
	
	if (this.modelReferencedGroupsList === undefined)
	{ this.modelReferencedGroupsList = new ModelReferencedGroupsList(); }

	this.modelReferencedGroupsList.createModelReferencedGroups(this.neoRefsIndices, this.motherNeoRefsList);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param arrayBuffer 변수
 * @param neoBuilding 변수
 * @param readWriter 변수
 */
NeoReferencesMotherAndIndices.prototype.parseArrayBufferReferencesVersioned = function(gl, arrayBuffer, readWriter, neoBuilding, tMatrix4, magoManager) 
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;

	var startBuff;
	var endBuff;
	var bytes_readed = 0;
	var testIdentityMatsCount = 0;
	var stadistic_refMat_Identities_count = 0;
	var stadistic_refMat_Translates_count = 0;
	var stadistic_refMat_Transforms_count = 0;
	var vboMemManager = magoManager.vboMemoryManager;
	var classifiedTCoordByteSize = 0, classifiedColByteSize = 0;
	var colByteSize, tCoordByteSize;
	this.succesfullyGpuDataBinded = true;
	var translationX, translationY, translationZ;
	
	// read the version.
	var versionLength = 5;
	var version = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+versionLength)));
	bytes_readed += versionLength;

	var neoRefsCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	for (var i = 0; i < neoRefsCount; i++) 
	{
		var neoRef = new NeoReference();

		// 1) Id.
		var ref_ID =  readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		neoRef._id = ref_ID;

		this.motherNeoRefsList = neoBuilding.motherNeoReferencesArray;
		if (this.motherNeoRefsList[neoRef._id] !== undefined)
		{
			// pass this neoReference because exist in the motherNeoReferencesArray.
			neoRef = this.motherNeoRefsList[neoRef._id];
			if (this.neoRefsIndices === undefined)
			{ this.neoRefsIndices = []; }
			
			this.neoRefsIndices.push(neoRef._id);

			var objectIdLength = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed +=1;
			var objectId = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+objectIdLength)));
			
			//neoRef.objectId = objectId;
			bytes_readed += objectIdLength;

			// 2) Block's Idx.
			var blockIdx =   readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			// 3) Transform Matrix4.
			// in versioned mode read the matrixType first.
			var matrixType = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (matrixType === 0)
			{ 
				// do nothing.
			}
			else if (matrixType === 1)
			{
				// read the translation vector.
				bytes_readed += 4 * 3;
			}
			else if (matrixType === 2)
			{
				// read the transformation matrix.
				bytes_readed += 4 * 16;
			}

			// Float mode.**
			var has_1_color = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (has_1_color) 
			{
				// "type" : one of following
				// 5120 : signed byte, 5121 : unsigned byte, 5122 : signed short, 5123 : unsigned short, 5126 : float
				var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
				var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

				var daya_bytes;
				if (data_type === 5121) { daya_bytes = 1; }

				var r = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var g = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var b = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var alfa = 255;

				if (dim === 4) 
				{
					alfa = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				}
			}
			
			var has_colors = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			var has_texCoords = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			
			if (has_colors || has_texCoords)
			{
				var vboDatasCount = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				for (var j=0; j<vboDatasCount; j++)
				{
					if (has_colors)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * dim;
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						bytes_readed += daya_bytes * verticesFloatValuesCount; // updating data.
					}
					
					if (has_texCoords)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						
						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * 2; // 2 = dimension of texCoord.
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						bytes_readed += daya_bytes * verticesFloatValuesCount;
					}
				}
			}
			
			// 4) short texcoords. OLD. Change this for Materials.
			var materialIdAux = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			
			// do the stadistic recount.
			if (neoRef.refMatrixType === 0){ stadistic_refMat_Identities_count +=1; }
			if (neoRef.refMatrixType === 1){ stadistic_refMat_Translates_count +=1; }
			if (neoRef.refMatrixType === 2){ stadistic_refMat_Transforms_count +=1; }
		}
		else
		{
			
			if (this.neoRefsIndices === undefined)
			{ this.neoRefsIndices = []; }
			
			this.neoRefsIndices.push(neoRef._id);

			var objectIdLength = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed +=1;
			var objectId = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+objectIdLength)));
			if (objectId === "noObjectId" || objectId.length === 0)
			{ objectId = neoRef._id.toString(); }
		
			neoRef.objectId = objectId;
			bytes_readed += objectIdLength;
			
			neoBuilding.putReferenceObject(neoRef, neoRef._id);

			// 2) Block's Idx.
			var blockIdx =   readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._block_idx = blockIdx;

			// 3) Transform Matrix4.
			neoRef.refMatrixType = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (neoRef.refMatrixType === 0)
			{ 
				// do nothing.
				stadistic_refMat_Identities_count +=1;
			}
			else if (neoRef.refMatrixType === 1)
			{
				// read the translation vector.
				translationX = readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				translationY = readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				translationZ = readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef.refTranslationVec = new Float32Array([translationX, translationY, translationZ]);
				
				stadistic_refMat_Translates_count +=1;
			}
			else if (neoRef.refMatrixType === 2)
			{
				// read the transformation matrix.
				neoRef._originalMatrix4._floatArrays[0] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[1] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[2] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[3] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

				neoRef._originalMatrix4._floatArrays[4] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[5] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[6] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[7] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

				neoRef._originalMatrix4._floatArrays[8] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[9] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[10] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[11] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

				neoRef._originalMatrix4._floatArrays[12] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[13] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[14] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[15] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				stadistic_refMat_Transforms_count +=1;
			}

			// Float mode.**
			var has_1_color = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (has_1_color) 
			{
				// "type" : one of following
				// 5120 : signed byte, 5121 : unsigned byte, 5122 : signed short, 5123 : unsigned short, 5126 : float
				var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
				var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

				var daya_bytes;
				if (data_type === 5121) { daya_bytes = 1; }

				var r = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var g = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var b = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var alfa = 255;

				if (dim === 4) 
				{
					alfa = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				}

				neoRef.color4 = new Color();
				neoRef.color4.set(r, g, b, alfa);
			}
			
			var has_colors = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			var has_texCoords = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			
			if (has_colors || has_texCoords)
			{
				var vboDatasCount = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				if (vboDatasCount > 0)
				{
					if (neoRef.vBOVertexIdxCacheKeysContainer === undefined)
					{ neoRef.vBOVertexIdxCacheKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
				}
				
				for (var j=0; j<vboDatasCount; j++)
				{
					var vboViCacheKey = neoRef.vBOVertexIdxCacheKeysContainer.newVBOVertexIdxCacheKey();
					
					if (has_colors)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * dim;
						//colByteSize = daya_bytes * verticesFloatValuesCount; // error...
						colByteSize = verticesFloatValuesCount;
						classifiedColByteSize = vboMemManager.getClassifiedBufferSize(colByteSize);
						
						neoRef.vertexCount = vertexCount; // no necessary.
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						//vboViCacheKey.colVboDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff)); // original.
						// TODO: Float32Array or UintArray depending of dataType.
						var colVboDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff));
						vboViCacheKey.setDataArrayColor(colVboDataArray, vboMemManager);

						bytes_readed += daya_bytes * verticesFloatValuesCount; // updating data.
						
						// send data to gpu.
						if (!vboViCacheKey.isReadyColors(gl, magoManager.vboMemoryManager))
						{
							this.succesfullyGpuDataBinded = false;
						}
					}
					
					if (has_texCoords)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						
						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * 2; // 2 = dimension of texCoord.

						neoRef.vertexCount = vertexCount; // no necessary.
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 

						var texCoordDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff));
						vboViCacheKey.setDataArrayTexCoord(texCoordDataArray, vboMemManager);
		
						bytes_readed += daya_bytes * verticesFloatValuesCount;
						
						// send data to gpu.
						/*
						if (!vboViCacheKey.isReadyTexCoords(gl, magoManager.vboMemoryManager))
						{
							this.succesfullyGpuDataBinded = false;
						}
						*/
					}
				}
			}

			// 4) read the reference material id.
			neoRef.materialId = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			if (neoRef.materialId === -1)
			{ neoRef.hasTexture = false; }
			else 
			{ 
				neoRef.hasTexture = true; 
			}

			if (tMatrix4)
			{
				// multiply the building transformation matrix with the reference matrix, then we save aditional multiplications inside the shader.
				neoRef.multiplyTransformMatrix(tMatrix4);
			}
		}

	}
	
	// finally read the triangles count.
	var trianglesCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	
	//this.createModelReferencedGroups(); // test for stadistics.
	

	// Now occlusion cullings.
	// Occlusion culling octree data.**
	if (this.exterior_ocCullOctree === undefined)
	{ this.exterior_ocCullOctree = new OcclusionCullingOctreeCell(); }

	var infiniteOcCullBox = this.exterior_ocCullOctree;
	//bytes_readed = this.readOcclusionCullingOctreeCell(arrayBuffer, bytes_readed, infiniteOcCullBox); // old.
	bytes_readed = this.exterior_ocCullOctree.parseArrayBuffer(arrayBuffer, bytes_readed, readWriter);
	infiniteOcCullBox.expandBox(1000); // Only for the infinite box.
	infiniteOcCullBox.setSizesSubBoxes();
	infiniteOcCullBox.createModelReferencedGroups(this.motherNeoRefsList);

	if (this.interior_ocCullOctree === undefined)
	{ this.interior_ocCullOctree = new OcclusionCullingOctreeCell(); }

	var ocCullBox = this.interior_ocCullOctree;
	//bytes_readed = this.readOcclusionCullingOctreeCell(arrayBuffer, bytes_readed, ocCullBox); // old.
	bytes_readed = this.interior_ocCullOctree.parseArrayBuffer(arrayBuffer, bytes_readed, readWriter);
	ocCullBox.setSizesSubBoxes();
	ocCullBox.createModelReferencedGroups(this.motherNeoRefsList);

	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	return this.succesfullyGpuDataBinded;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param arrayBuffer 변수
 * @param neoBuilding 변수
 * @param readWriter 변수
 */
NeoReferencesMotherAndIndices.prototype.parseArrayBufferReferences = function(gl, arrayBuffer, readWriter, neoBuilding, tMatrix4, magoManager) 
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;

	var startBuff;
	var endBuff;
	var bytes_readed = 0;
	var neoRefsCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	var testIdentityMatsCount = 0;
	var stadistic_refMat_Identities_count = 0;
	var stadistic_refMat_Translates_count = 0;
	var stadistic_refMat_Transforms_count = 0;
	var vboMemManager = magoManager.vboMemoryManager;
	var classifiedTCoordByteSize = 0, classifiedColByteSize = 0;
	var colByteSize, tCoordByteSize;
	this.succesfullyGpuDataBinded = true;

	for (var i = 0; i < neoRefsCount; i++) 
	{
		var neoRef = new NeoReference();

		// 1) Id.
		var ref_ID =  readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		neoRef._id = ref_ID;
		
		
		this.motherNeoRefsList = neoBuilding.motherNeoReferencesArray;
		if (this.motherNeoRefsList[neoRef._id] !== undefined)
		{
			// pass this neoReference because exist in the motherNeoReferencesArray.
			neoRef = this.motherNeoRefsList[neoRef._id];
			if (this.neoRefsIndices === undefined)
			{ this.neoRefsIndices = []; }
			
			this.neoRefsIndices.push(neoRef._id);

			var objectIdLength = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed +=1;
			var objectId = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+objectIdLength)));
			bytes_readed += objectIdLength;

			// 2) Block's Idx.
			var blockIdx =   readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._block_idx = blockIdx;

			// 3) Transform Matrix4.
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			// Float mode.**
			// New modifications for xxxx 20161013.**
			var has_1_color = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (has_1_color) 
			{
				// "type" : one of following
				// 5120 : signed byte, 5121 : unsigned byte, 5122 : signed short, 5123 : unsigned short, 5126 : float
				var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
				var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

				var daya_bytes;
				if (data_type === 5121) { daya_bytes = 1; }

				var r = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var g = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var b = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var alfa = 255;

				if (dim === 4) 
				{
					alfa = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				}
			}
			
			var has_colors = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			var has_texCoords = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			
			if (has_colors || has_texCoords)
			{
				var vboDatasCount = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				for (var j=0; j<vboDatasCount; j++)
				{
					if (has_colors)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * dim;
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						bytes_readed += daya_bytes * verticesFloatValuesCount; // updating data.
					}
					
					if (has_texCoords)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						
						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * 2; // 2 = dimension of texCoord.
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						bytes_readed += daya_bytes * verticesFloatValuesCount;
					}
				}
			}
			
			// 4) short texcoords. OLD. Change this for Materials.
			var textures_count = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4; // this is only indicative that there are a texcoords.
			if (textures_count > 0) 
			{

				// Now, read the texture_type and texture_file_name.
				var texture_type_nameLegth = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				for (var j=0; j<texture_type_nameLegth; j++) 
				{
					bytes_readed += 1; // for example "diffuse".
				}

				var texture_fileName_Legth = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				for (var j=0; j<texture_fileName_Legth; j++) 
				{
					bytes_readed += 1;
				}
			} 
			
			// do the stadistic recount.
			if (neoRef.refMatrixType === 0){ stadistic_refMat_Identities_count +=1; }
			if (neoRef.refMatrixType === 1){ stadistic_refMat_Translates_count +=1; }
			if (neoRef.refMatrixType === 2){ stadistic_refMat_Transforms_count +=1; }
		}
		else
		{
			if (this.neoRefsIndices === undefined)
			{ this.neoRefsIndices = []; }
			
			this.neoRefsIndices.push(neoRef._id);

			var objectIdLength = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed +=1;
			var objectId = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+objectIdLength)));
			if (objectId === "noObjectId" || objectId === "")
			{ objectId = neoRef._id; }
		
			neoRef.objectId = objectId;
			bytes_readed += objectIdLength;
			
			neoBuilding.putReferenceObject(neoRef, neoRef._id);

			// 2) Block's Idx.
			var blockIdx =   readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._block_idx = blockIdx;

			// 3) Transform Matrix4.
			neoRef._originalMatrix4._floatArrays[0] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[1] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[2] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[3] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			neoRef._originalMatrix4._floatArrays[4] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[5] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[6] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[7] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			neoRef._originalMatrix4._floatArrays[8] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[9] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[10] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[11] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			neoRef._originalMatrix4._floatArrays[12] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[13] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[14] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[15] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			
			// Compute the references matrix type.
			neoRef.refMatrixType = neoRef._originalMatrix4.computeMatrixType();
			if (neoRef.refMatrixType === 0){ stadistic_refMat_Identities_count +=1; }
			if (neoRef.refMatrixType === 1)
			{
				neoRef.refTranslationVec = new Float32Array([neoRef._originalMatrix4._floatArrays[12], neoRef._originalMatrix4._floatArrays[13], neoRef._originalMatrix4._floatArrays[14]]);
				stadistic_refMat_Translates_count +=1;
			}
			if (neoRef.refMatrixType === 2){ stadistic_refMat_Transforms_count +=1; }

			// Float mode.**
			// New modifications for xxxx 20161013.**
			var has_1_color = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (has_1_color) 
			{
				// "type" : one of following
				// 5120 : signed byte, 5121 : unsigned byte, 5122 : signed short, 5123 : unsigned short, 5126 : float
				var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
				var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

				var daya_bytes;
				if (data_type === 5121) { daya_bytes = 1; }

				var r = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var g = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var b = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var alfa = 255;

				if (dim === 4) 
				{
					alfa = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				}

				neoRef.color4 = new Color();
				neoRef.color4.set(r, g, b, alfa);
			}
			
			var has_colors = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			var has_texCoords = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			
			if (has_colors || has_texCoords)
			{
				var vboDatasCount = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				if (vboDatasCount > 0)
				{
					if (neoRef.vBOVertexIdxCacheKeysContainer === undefined)
					{ neoRef.vBOVertexIdxCacheKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
				}
				
				for (var j=0; j<vboDatasCount; j++)
				{
					var vboViCacheKey = neoRef.vBOVertexIdxCacheKeysContainer.newVBOVertexIdxCacheKey();
					
					if (has_colors)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * dim;
						colByteSize = daya_bytes * verticesFloatValuesCount;
						classifiedColByteSize = vboMemManager.getClassifiedBufferSize(colByteSize);
						
						neoRef.vertexCount = vertexCount; // no necessary.
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						//vboViCacheKey.colVboDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff)); // original.
						// TODO: Float32Array or UintArray depending of dataType.
						vboViCacheKey.colVboDataArray = new Float32Array(classifiedColByteSize);
						vboViCacheKey.colVboDataArray.set(new Float32Array(arrayBuffer.slice(startBuff, endBuff)));
						vboViCacheKey.colArrayByteSize = classifiedColByteSize;
						bytes_readed += daya_bytes * verticesFloatValuesCount; // updating data.
						
						// send data to gpu.
						if (!vboViCacheKey.isReadyColors(gl, magoManager.vboMemoryManager))
						{
							this.succesfullyGpuDataBinded = false;
						}
					}
					
					if (has_texCoords)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						
						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * 2; // 2 = dimension of texCoord.
						// example: posByteSize = 4 * verticesFloatValuesCount;
						tCoordByteSize = daya_bytes * verticesFloatValuesCount;
						classifiedTCoordByteSize = vboMemManager.getClassifiedBufferSize(tCoordByteSize);
						
						neoRef.vertexCount = vertexCount; // no necessary.
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						//vboViCacheKey.tcoordVboDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff)); // original.
						vboViCacheKey.tcoordVboDataArray = new Float32Array(classifiedTCoordByteSize);
						vboViCacheKey.tcoordVboDataArray.set(new Float32Array(arrayBuffer.slice(startBuff, endBuff)));
						vboViCacheKey.tcoordArrayByteSize = classifiedTCoordByteSize;
						bytes_readed += daya_bytes * verticesFloatValuesCount;
						
					}
				}
			}

			// 4) short texcoords. OLD. Change this for Materials.
			var textures_count = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4; // this is only indicative that there are a texcoords.
			if (textures_count > 0) 
			{
				var textureTypeName = "";
				var textureImageFileName = "";

				// Now, read the texture_type and texture_file_name.
				var texture_type_nameLegth = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				for (var j=0; j<texture_type_nameLegth; j++) 
				{
					textureTypeName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1; // for example "diffuse".
				}

				var texture_fileName_Legth = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				// utf8.
				var charArray = new Uint8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ texture_fileName_Legth)); bytes_readed += texture_fileName_Legth;
				var decoder = new TextDecoder('utf-8');
				textureImageFileName = decoder.decode(charArray);
					
				//for (var j=0; j<texture_fileName_Legth; j++) 
				//{
				//	textureImageFileName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1;
				//}
				
				if (texture_fileName_Legth > 0)
				{
					neoRef.texture = new Texture();
					neoRef.hasTexture = true;
					neoRef.texture.textureTypeName = textureTypeName;
					neoRef.texture.textureImageFileName = textureImageFileName;
				}

				/*
				// 1pixel texture, wait for texture to load.**
				if(neoRef.texture.texId === undefined)
					neoRef.texture.texId = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, neoRef.texture.texId);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([90, 80, 85, 255])); // red
				gl.bindTexture(gl.TEXTURE_2D, null);
				*/
			}
			else 
			{
				neoRef.hasTexture = false;
			}

			if (tMatrix4)
			{
				neoRef.multiplyTransformMatrix(tMatrix4);
			}
		}

	}
	
	//this.createModelReferencedGroups(); // test for new format.
	

	// Now occlusion cullings.
	// Occlusion culling octree data.**
	if (this.exterior_ocCullOctree === undefined)
	{ this.exterior_ocCullOctree = new OcclusionCullingOctreeCell(); }

	var infiniteOcCullBox = this.exterior_ocCullOctree;
	//bytes_readed = this.readOcclusionCullingOctreeCell(arrayBuffer, bytes_readed, infiniteOcCullBox); // old.
	bytes_readed = this.exterior_ocCullOctree.parseArrayBuffer(arrayBuffer, bytes_readed, readWriter);
	infiniteOcCullBox.expandBox(1000); // Only for the infinite box.
	infiniteOcCullBox.setSizesSubBoxes();
	infiniteOcCullBox.createModelReferencedGroups(this.motherNeoRefsList);

	if (this.interior_ocCullOctree === undefined)
	{ this.interior_ocCullOctree = new OcclusionCullingOctreeCell(); }

	var ocCullBox = this.interior_ocCullOctree;
	//bytes_readed = this.readOcclusionCullingOctreeCell(arrayBuffer, bytes_readed, ocCullBox); // old.
	bytes_readed = this.interior_ocCullOctree.parseArrayBuffer(arrayBuffer, bytes_readed, readWriter);
	ocCullBox.setSizesSubBoxes();
	ocCullBox.createModelReferencedGroups(this.motherNeoRefsList);

	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	return this.succesfullyGpuDataBinded;
};

/**
 * Renders the content.
 */
NeoReferencesMotherAndIndices.prototype.render = function(magoManager, neoBuilding, renderType, renderTexture, shader, maxSizeToRender, refMatrixIdxKey) 
{
	var allRendered = true;
	
	if (!this.isReadyToRender())
	{ return false; }
	
	if (renderType === 2)
	{
		renderTexture = false; // reassign value for this var.
	}
	
	var gl = magoManager.sceneState.gl;
	
	if (renderType === 2)
	{
		shader.disableVertexAttribArray(shader.texCoord2_loc);
		shader.disableVertexAttribArray(shader.normal3_loc);
	}
	if (renderType === 0)
	{
		shader.disableVertexAttribArray(shader.texCoord2_loc);
		shader.disableVertexAttribArray(shader.normal3_loc);
		shader.disableVertexAttribArray(shader.color4_loc);
	}
	
	if (renderTexture) 
	{
		gl.activeTexture(gl.TEXTURE2); // ...
		if (renderType === 1) 
		{ 
			gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
		} 
	}

	var texturesManager = magoManager.texturesManager;
	var textureAux1x1 = texturesManager.getTextureAux1x1();
	gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
	shader.last_tex_id = textureAux1x1;

	// New version. Use occlussion indices.
	//var visibleIndices_count = this.neoRefsIndices.length; // no occludeCulling mode.
	var visibleIndices_count = this.currentVisibleIndices.length;
	var noRenderedsCount = 0;

	for (var k=0; k<visibleIndices_count; k++) 
	{
		//var neoReference = this.motherNeoRefsList[this.neoRefsIndices[k]]; // no occludeCulling mode.
		var neoReference = this.motherNeoRefsList[this.currentVisibleIndices[k]];
		
		if (neoReference === undefined)
		{ continue; }
		
		// Check renderingFase.
		if (neoReference.renderingFase === magoManager.renderingFase)
		{ continue; }
		
		// Render the referenceObject.
		if (!neoReference.render(magoManager, neoBuilding, renderType, renderTexture, shader, refMatrixIdxKey, maxSizeToRender))
		{
			noRenderedsCount ++;
		}

		// Swap renderingFase.
		neoReference.swapRenderingFase();
		
		
		if (renderType === 1)
		{
			if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.OBJECT && magoManager.objectSelected === neoReference)
			{
				magoManager.renderer.disableStencilBuffer(gl);
				gl.disable(gl.POLYGON_OFFSET_FILL);
			}
		}
	}
	
	if ((visibleIndices_count - noRenderedsCount)/visibleIndices_count < 0.4)
	{ allRendered = false; }
	
	return allRendered;
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoSimpleBuilding
 */
var NeoSimpleBuilding = function() 
{
	if (!(this instanceof NeoSimpleBuilding)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.accesorsArray = [];
	this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer();
	this.texturesArray = [];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns accesor
 */
NeoSimpleBuilding.prototype.newAccesor = function() 
{
	var accesor = new Accessor();
	this.accesorsArray.push(accesor);
	return accesor;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns texture
 */
NeoSimpleBuilding.prototype.newTexture = function() 
{
	var texture = new NeoTexture();
	this.texturesArray.push(texture);
	return texture;
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoTexture
 */
var NeoTexture = function() 
{
	if (!(this instanceof NeoTexture)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.lod;
	this.textureId; // texture id in gl.
	this.texImage; // image. delete this once upload to gl.
	this.loadStarted = false;
	this.loadFinished = false;
};
'use strict';

/**
 * This is the geometry container. Is the minimum independent project.
 * @class Node
 */
var Node = function() 
{
	if (!(this instanceof Node)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * Parent (owner) of this node object. If undefined, this node is the root node.
	 * @type {Node}
	 * @default undefined
	 */
	this.parent;
	
	/**
	 * Children array. This array contains Node objects.
	 * @type {Array}
	 * @default Default length = 0.
	 */
	this.children = []; 
	
	/**
	 * An object that contains all referent data, geometry data, location data, etc.
	 * @type {Object}
	 * @default undefined.
	 */
	this.data; 
};

/**
 * Returns true if this node is a "reference" type node. "Reference" type nodes uses StaticModels geometry.
 * @returns {Boolean} true if this node is a "reference" type node.
 */
Node.prototype.isReferenceNode = function() 
{
	var isReference = false;
	if (this.data !== undefined)
	{
		var attributes = this.data.attributes;
		if (attributes !== undefined)
		{
			if (attributes.isReference !== undefined)
			{ isReference = attributes.isReference; }
		}
	}
	
	return isReference;
};

/**
 * Deletes all datas and all datas of children.
 */
Node.prototype.deleteObjects = function(gl, vboMemoryManager) 
{
	this.parent = undefined;
	var data = this.data;
	if (data !== undefined)
	{
		// Check if this is a reference node.
		var isReference = this.isReferenceNode();
		
		// No delete neoBuilding if this node is a reference node.
		if (isReference)
		{ return; }

		if (data.neoBuilding)
		{
			data.neoBuilding.deleteObjects(gl, vboMemoryManager);
			data.neoBuilding = undefined;
		}
		
		if (data.geographicCoord)
		{
			data.geographicCoord.deleteObjects();
			data.geographicCoord = undefined;
		}
		
		if (data.rotationsDegree)
		{
			data.rotationsDegree.deleteObjects();
			data.rotationsDegree = undefined;
		}
		
		if (data.bbox)
		{
			data.bbox.deleteObjects();
			data.bbox = undefined;
		}
		
		// Delete geoLocationDataManager, etc. TODO.
		
		this.data = undefined;
	}
	
	if (this.children)
	{
		var childrenCount = this.children.length;
		for (var i=0; i<childrenCount; i++)
		{
			this.children[i].deleteObjects(gl, vboMemoryManager);
			this.children[i] = undefined;
		}
		this.children = undefined;
	}
};

/**
 * Calculates the geographicLocationData of the node.
 * @param {MagoManager} magoManager Main class object of Mago3D.
 * @returns {GeoLocationData} geoLoc The calculated geoLocationData of this node.
 */
Node.prototype.calculateGeoLocData = function(magoManager) 
{
	// This function creates the geoLocationData of "node".
	// Called from magomanager.tilesMultiFrustumCullingFinished(...), flyToBuilding(...)
	var nodeRoot = this.getRoot();

	if (nodeRoot.data.geoLocDataManager === undefined)
	{ nodeRoot.data.geoLocDataManager = new GeoLocationDataManager(); }
	var geoLocDataManager = nodeRoot.data.geoLocDataManager;
	var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
		
	if (geoLoc === undefined || geoLoc.pivotPoint === undefined)
	{ 
		geoLoc = geoLocDataManager.newGeoLocationData("deploymentLoc"); 
		var geographicCoord;
		var rotationsDegree;
		
		if (this.data.geographicCoord === undefined)
		{
			var buildingSeed = this.data.buildingSeed;
			geographicCoord = buildingSeed.geographicCoord;
			rotationsDegree = buildingSeed.rotationsDegree;
		}
		else 
		{
			geographicCoord = this.data.geographicCoord;
			rotationsDegree = this.data.rotationsDegree;
		}
		
		var longitude = geographicCoord.longitude;
		var latitude = geographicCoord.latitude;
		var altitude = geographicCoord.altitude;
		var heading = rotationsDegree.z;
		var pitch = rotationsDegree.x;
		var roll = rotationsDegree.y;
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, heading, pitch, roll, geoLoc, magoManager);
		this.pointSC = this.data.bbox.getCenterPoint(this.pointSC);

		// check if use "centerOfBoundingBoxAsOrigin".
		if (this.data.mapping_type !== undefined && this.data.mapping_type.toLowerCase() === "boundingboxcenter")
		{
			var rootNode = this.getRoot();
			if (rootNode)
			{
				// now, calculate the root center of bbox.
				var buildingSeed = this.data.buildingSeed;
				var buildingSeedBBox = buildingSeed.bBox;
				this.pointSC = buildingSeedBBox.getCenterPoint(this.pointSC);
				ManagerUtils.translatePivotPointGeoLocationData(geoLoc, this.pointSC );
			}
		}
	}
	
	return geoLoc;
};

Node.prototype.checkChangesHistoryMovements = function() 
{
	var moveHistoryMap = this.data.moveHistoryMap;
	if (moveHistoryMap === undefined)
	{ return; }
	
	var neoBuilding = this.data.neoBuilding;
	///for (var changeHistory of moveHistoryMap.values()) 
	
	for (var key in moveHistoryMap)
	{
		if (Object.prototype.hasOwnProperty.call(moveHistoryMap, key)) 
		{
			var changeHistory = moveHistoryMap[key];
			var objectIndexOrder = changeHistory.getObjectIndexOrder();
			var refObject = neoBuilding.getReferenceObject(objectIndexOrder);
			if (refObject === undefined)
			{ continue; }
			
			if (refObject.moveVector === undefined)
			{ refObject.moveVector = new Point3D(); }
			
			if (refObject.moveVectorRelToBuilding === undefined)
			{ refObject.moveVectorRelToBuilding = new Point3D(); }
			
			var moveVector = changeHistory.getReferenceObjectAditionalMovement();
			var moveVectorRelToBuilding = changeHistory.getReferenceObjectAditionalMovementRelToBuilding();
			refObject.moveVectorRelToBuilding.set(moveVectorRelToBuilding.x, moveVectorRelToBuilding.y, moveVectorRelToBuilding.z);
			refObject.moveVector.set(moveVector.x, moveVector.y, moveVector.z);
			
			// now check if the building was rotated.
			var rootNode = this.getRoot();
			if (rootNode === undefined)
			{ continue; }
			
			var geoLocdataManager = rootNode.getNodeGeoLocDataManager();
			var geoLoc = geoLocdataManager.getCurrentGeoLocationData();
			// if was rotated then recalculate the move vector.
			refObject.moveVector = geoLoc.tMatrix.rotatePoint3D(refObject.moveVectorRelToBuilding, refObject.moveVector); 
			
			// if was no rotated, then set the moveVector of the changeHistory.
			//refObject.moveVectorRelToBuilding.set(moveVectorRelToBuilding.x, moveVectorRelToBuilding.y, moveVectorRelToBuilding.z);	
		}
	}
};

/**
 * Checks if there are some objects that was changed the color.
 */
Node.prototype.checkChangesHistoryColors = function() 
{
	var data = this.data;
	
	if (data === undefined)
	{ return; }
	
	var colorChangedHistoryMap = data.colorChangedHistoryMap;
	
	if (colorChangedHistoryMap === undefined)
	{ return; }
	
	var node = this;
	
	for (var key in colorChangedHistoryMap)
	{
		if (Object.prototype.hasOwnProperty.call(colorChangedHistoryMap, key)) 
		{
			var changeHistory = colorChangedHistoryMap[key];
			if (changeHistory.objectId === null || changeHistory.objectId === undefined || changeHistory.objectId === "" )
			{
				if (changeHistory.property === null || changeHistory.property === undefined || changeHistory.property === "" )
				{
					// change color for all node.
					data.isColorChanged = true;
					if (data.aditionalColor === undefined)
					{ data.aditionalColor = new Color(); }
					
					data.aditionalColor.setRGB(changeHistory.rgbColor[0], changeHistory.rgbColor[1], changeHistory.rgbColor[2]);
				}
				else 
				{
					// there are properties.
					var nodesArray = [];
					node.extractNodes(nodesArray);
					var nodesCount = nodesArray.length;
					var aNode;
					for (var i=0; i<nodesCount; i++)
					{
						aNode = nodesArray[i];
						var propertyKey = changeHistory.propertyKey;
						var propertyValue = changeHistory.propertyValue;
						// 1rst, check if this has the same "key" and same "value".
						if (aNode.data.attributes[propertyKey] !== undefined && aNode.data.attributes[propertyKey].toString() === propertyValue)
						{
							data.isColorChanged = true;
							if (data.aditionalColor === undefined)
							{ data.aditionalColor = new Color(); }
							
							data.aditionalColor.setRGB(changeHistory.rgbColor[0], changeHistory.rgbColor[1], changeHistory.rgbColor[2]);
						}
					}
				}
			}
			else 
			{
				// change color for an object.
				var neoBuilding = node.data.neoBuilding;
				
				if (neoBuilding === undefined)
				{ return; }
				
				var objectId = changeHistory.objectId;
				var objectsArray = neoBuilding.getReferenceObjectsArrayByObjectId(objectId);
				if (objectsArray)
				{
					var objectsCount = objectsArray.length;
					for (var j=0; j<objectsCount; j++)
					{
						var object = objectsArray[j];
						if (object.aditionalColor === undefined)
						{ object.aditionalColor = new Color(); }
						
						object.aditionalColor.setRGB(changeHistory.rgbColor[0], changeHistory.rgbColor[1], changeHistory.rgbColor[2]);
					}
				}
			}	
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.renderContent = function(magoManager, shader, renderType, refMatrixIdxKey) 
{
	// This function renders the neoBuilding if exist in "data".
	// renderType = 0 -> depth render.
	// renderType = 1 -> normal render.
	// renderType = 2 -> colorSelection render.
	//--------------------------------------------
	var data = this.data;
	if (data === undefined)
	{ return; }
	
	var neoBuilding = this.data.neoBuilding;
	if (neoBuilding === undefined)
	{ return; }

	// Check if we are under selected data structure.***
	var selectionManager = magoManager.selectionManager;
	if (magoManager.nodeSelected === this)
	{ selectionManager.parentSelected = true; }
	else 
	{ selectionManager.parentSelected = false; }
	

	// Update visibleOctreesControler of the neoBuilding & the relativeCurrentCamera.
	// Note: currentVisibleOctreesControler & myCameraRelative are calculated on MagoManager.getRenderablesDetailedNeoBuildingAsimetricVersion(...).
	neoBuilding.currentVisibleOctreesControler = data.currentVisibleOctreesControler;
	neoBuilding.myCameraRelative = data.myCameraRelative;
	neoBuilding.isColorChanged = data.isColorChanged;
	neoBuilding.aditionalColor = data.aditionalColor;
	
	this.checkChangesHistoryColors();
	this.checkChangesHistoryMovements();

	// Check projectType.*
	var metaData = neoBuilding.metaData;
	var projectsType = metaData.projectDataType;
	//--------------------------------------------
	
	var rootNode = this.getRoot();
	var geoLocDataManager = rootNode.data.geoLocDataManager;

	// 1rst, determine the shader.
	var gl = magoManager.sceneState.gl;
	
	// check attributes of the project.
	var project = magoManager.hierarchyManager.getNodesMap(data.projectId);
	if (project.attributes !== undefined && project.attributes.specularLighting !== undefined && shader.bApplySpecularLighting_loc !== undefined)
	{
		var applySpecLighting = project.attributes.specularLighting;
		if (applySpecLighting)
		{ gl.uniform1i(shader.bApplySpecularLighting_loc, true); }
		else
		{ gl.uniform1i(shader.bApplySpecularLighting_loc, false); }
	}
	// end check attributes of the project.----------------------------------------
	
	// set the currentObjectsRendering.
	magoManager.renderer.currentObjectsRendering.curNode = this;
	
	var flipYTexCoord = false;
	if (data.attributes.flipYTexCoords !== undefined)
	{ flipYTexCoord = data.attributes.flipYTexCoords; }

	gl.uniform1i(shader.textureFlipYAxis_loc, flipYTexCoord);
	
	// Check the geoLocationDatasCount & check if is a ghost-trail-render (trail as ghost).
	var currRenderingFase = magoManager.renderingFase;
	if (this.isReferenceNode())
	{ magoManager.renderingFase = -10; } // set a strange value to skip avoiding rendering fase of references objects.
	
	// Check if is trail-render.*
	var isTrailRender = this.data.isTrailRender;
	if (isTrailRender !== undefined && isTrailRender === true)
	{
		magoManager.isTrailRender = true;
		gl.depthRange(0.1, 1); // reduce depthRange to minimize blending flickling.
		var geoLocDatasCount = geoLocDataManager.getGeoLocationDatasCount();
		//for(var i=geoLocDatasCount - 1; i>0; i--)
		for (var i=1; i<geoLocDatasCount; i++ )
		{
			var buildingGeoLocation = geoLocDataManager.getGeoLocationData(i);
			buildingGeoLocation.bindGeoLocationUniforms(gl, shader);
						
			var externalAlpha = (geoLocDatasCount - i)/(geoLocDatasCount*7);
			gl.uniform1f(shader.externalAlpha_loc, externalAlpha);

			// If this node is a referenceNode type, then, must render all references avoiding the renderingFase.
			neoBuilding.currentLod = data.currentLod; // update currentLod.
			neoBuilding.render(magoManager, shader, renderType, refMatrixIdxKey, flipYTexCoord, data.currentLod);

		}
		gl.depthRange(0, 1);
		magoManager.isTrailRender = false;
	}
	//--------------------------------------------------------------------------------------------------------------------
	var geoLocDataIdx;
	if (geoLocDataManager.getGeoLocationDatasCount() > 1)
	{ geoLocDataIdx = 1; }
	else
	{ geoLocDataIdx = 0; }
	var buildingGeoLocation = geoLocDataManager.getGeoLocationData(geoLocDataIdx);
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader);

	// magoManager.tempSettings.renderWithTopology === 0 -> render only Building.
	// magoManager.tempSettings.renderWithTopology === 1 -> render only Topology.
	// magoManager.tempSettings.renderWithTopology === 2 -> render both.

	// If this node is a referenceNode type, then, must render all references avoiding the renderingFase.
	gl.uniform1f(shader.externalAlpha_loc, 1.0);
	neoBuilding.currentLod = data.currentLod; // update currentLod.
	neoBuilding.render(magoManager, shader, renderType, refMatrixIdxKey, flipYTexCoord, data.currentLod);
	
	magoManager.renderingFase = currRenderingFase; // Return to current renderingFase.
	
	// Finally, if there are no animationData, then delete the trailEfect.
	if (this.data.animationData !== undefined && this.data.animationData.finished === true)
	{
		if (geoLocDataManager.getGeoLocationDatasCount() > 1)
		{ geoLocDataManager.popGeoLocationData(); }
		else
		{ 
			this.data.animationData = undefined;
		}
	}
	
	// Test.
	/*
	if (neoBuilding.network)
	{
		if(magoManager.tempSettings.renderWithTopology === 0 || magoManager.tempSettings.renderWithTopology === 2)
		{
			neoBuilding.render(magoManager, shader, renderType, refMatrixIdxKey, flipYTexCoord);
		}
	}
	else{
		neoBuilding.render(magoManager, shader, renderType, refMatrixIdxKey, flipYTexCoord);
	}
	
	if (neoBuilding.network)
	{
		// Note: topology data is loaded (if exist) when loads the metaData in "prepareNeoBuildingsAsimetricVersion" in magoManager.
		if(magoManager.tempSettings.renderWithTopology === 1 || magoManager.tempSettings.renderWithTopology === 2)
		{
			// render the topology.
			if (renderType !== 0)
			{
				gl.uniform1i(shader.bApplySsao_loc, false); // no apply ssao.
				gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
				var network = neoBuilding.network;
				if (network)
				{
					network.render(magoManager, shader, renderType);
				}
				gl.uniform1i(shader.bApplySsao_loc, true); // apply ssao default.
			}
		}
	}
	*/
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.addChildren = function(children) 
{
	children.setParent(this);
	this.children.push(children);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.setParent = function(parent) 
{
	this.parent = parent;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.getRoot = function() 
{
	if (this.parent === undefined)
	{ return this; }
	else
	{
		return this.parent.getRoot();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.getClosestParentWithData = function(dataName) 
{
	if (this.data && this.data[dataName])
	{
		return this;
	}
	else 
	{
		if (this.parent)
		{ return this.parent.getClosestParentWithData(dataName); }
		else { return undefined; }
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.extractNodesByDataName = function(nodesArray, dataname) 
{
	// this function extracts nodes that has a data named dataname, including children.
	if (this.data[dataname])
	{
		nodesArray.push(this);
	}
	
	var childrenCount = this.children.length;
	for (var i=0; i<childrenCount; i++)
	{
		this.children[i].extractNodesByDataName(nodesArray, dataname);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.extractNodes = function(nodesArray) 
{
	// this function extracts nodes that has a data named dataname, including children.
	nodesArray.push(this);
	
	var childrenCount = this.children.length;
	for (var i=0; i<childrenCount; i++)
	{
		this.children[i].extractNodes(nodesArray);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
Node.prototype.getBBox = function() 
{
	var bbox;
	var data = this.data;
	if (data.bbox === undefined)
	{
		// 1rst, check if exist neoBuilding's metaData.
		var neoBuilding = data.neoBuilding;
		if (neoBuilding !== undefined && neoBuilding.metaData !== undefined)
		{
			var metaData = neoBuilding.metaData;
			data.bbox = new BoundingBox(); // Only create a node's bbox when exist neoBuilding's metaData.
			data.bbox.copyFrom(metaData.bbox);
		}
		else if (data.buildingSeed !== undefined)
		{
			var buildingSeed = data.buildingSeed;
			bbox = buildingSeed.bbox;
		}
	}
	else 
	{
		bbox = data.bbox;
	}
	
	return data.bbox;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
Node.prototype.getBBoxCenterPositionWorldCoord = function(geoLoc) 
{
	var bboxAbsoluteCenterPos;
	if (this.bboxAbsoluteCenterPos === undefined)
	{
		bboxAbsoluteCenterPos = this.calculateBBoxCenterPositionWorldCoord(geoLoc);
	}
	else 
	{
		bboxAbsoluteCenterPos = this.bboxAbsoluteCenterPos;
	}
	
	return bboxAbsoluteCenterPos;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
Node.prototype.calculateBBoxCenterPositionWorldCoord = function(geoLoc) 
{
	var bboxCenterPoint;
	var bboxAbsoluteCenterPosAux;
	if (this.data.bbox !== undefined)
	{
		// this.data.bbox is the most important bbox.
		bboxCenterPoint = this.data.bbox.getCenterPoint(bboxCenterPoint); // local bbox.
	}
	else if (this.data.neoBuilding !== undefined)
	{
		bboxCenterPoint = this.data.neoBuilding.bbox.getCenterPoint(bboxCenterPoint); // local bbox.
	}
	else 
	{
		bboxCenterPoint = new Point3D();
	}

	bboxAbsoluteCenterPosAux = geoLoc.tMatrix.transformPoint3D(bboxCenterPoint, bboxAbsoluteCenterPosAux);
	
	// Now, must applicate the aditional translation vector. Aditional translation is made when we translate the pivot point.
	if (geoLoc.pivotPointTraslation)
	{
		var traslationVector;
		traslationVector = geoLoc.tMatrix.rotatePoint3D(geoLoc.pivotPointTraslation, traslationVector );
		bboxAbsoluteCenterPosAux.add(traslationVector.x, traslationVector.y, traslationVector.z);
	}
	
	return bboxAbsoluteCenterPosAux;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
Node.prototype.getDistToCamera = function(cameraPosition, boundingSphere_Aux) 
{
	var data = this.data;
	var neoBuilding = data.neoBuilding;
	
	var nodeRoot = this.getRoot();
	var geoLocDataManager = nodeRoot.data.geoLocDataManager;
	var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
	
	// To calculate realBuildingPosition, we need this.data.bbox.
	// If this.data.bbox no exist, then calculate a provisional value.
	if (this.bboxAbsoluteCenterPos === undefined) 
	{
		if (this.data.bbox !== undefined)
		{
			// this.data.bbox is the most important bbox.
			var bboxCenterPoint = this.data.bbox.getCenterPoint(bboxCenterPoint); // local bbox.
			this.bboxAbsoluteCenterPos = geoLoc.tMatrix.transformPoint3D(bboxCenterPoint, this.bboxAbsoluteCenterPos);
		}
	}
	
	var realBuildingPos = this.getBBoxCenterPositionWorldCoord(geoLoc);
	var radiusAprox;
	var bbox = this.getBBox();
	radiusAprox = bbox.getRadiusAprox(); 
	
	boundingSphere_Aux.setCenterPoint(realBuildingPos.x, realBuildingPos.y, realBuildingPos.z);
	boundingSphere_Aux.setRadius(radiusAprox);
		
	var metaData = neoBuilding.metaData;
	var projectsType = metaData.projectDataType;
	if (projectsType && (projectsType === 4 || projectsType === 5))
	{
		// This is pointsCloud projectType.
		// Calculate the distance to camera with lowestOctrees.
		var octree = neoBuilding.octree;
		if (octree === undefined)
		{ return undefined; }
		
		var relativeCamPos;
		relativeCamPos = geoLoc.getTransformedRelativePosition(cameraPosition, relativeCamPos);
		//relativeCam = neoBuilding.getTransformedRelativeEyePositionToBuilding(cameraPosition.x, cameraPosition.y, cameraPosition.z, relativeCam);
		var octreesMaxSize = 120;
		data.distToCam = octree.getMinDistToCameraInTree(relativeCamPos, boundingSphere_Aux, octreesMaxSize);
		boundingSphere_Aux.setCenterPoint(realBuildingPos.x, realBuildingPos.y, realBuildingPos.z);
		boundingSphere_Aux.setRadius(neoBuilding.bbox.getRadiusAprox());
	}
	else 
	{
		// This is mesh projectType.
		data.distToCam = cameraPosition.distToSphere(boundingSphere_Aux);
	}

	return data.distToCam;
};

/**
 */
Node.prototype.getNodeGeoLocDataManager = function() 
{
	var closestRootNode = this.getClosestParentWithData("geoLocDataManager");
	
	if (closestRootNode === undefined)
	{ return undefined; }

	if (closestRootNode.data === undefined)
	{ return undefined; }
	
	var rootNodeGeoLocDataManager = closestRootNode.data.geoLocDataManager;
	return rootNodeGeoLocDataManager;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.finishedAnimation = function(magoManager) 
{
	var finished = false;
	var animData = this.data.animationData;
	
	if (animData === undefined)
	{ return true; }

	if (animData.startLongitude === undefined || animData.startLatitude === undefined || animData.startAltitude === undefined)
	{ return true; }
	
	// calculate the currentLocation and currentRotation.
	var currTime = magoManager.getCurrentTime();
	if (animData.lastTime === undefined)
	{ animData.lastTime = animData.birthTime; }
	
	var totalDeltaTime = (currTime - animData.birthTime)/1000.0; // in seconds.

	var nextLongitude;
	var nextLatitude;
	var nextAltitude;
	
	// calculate velocity.
	var velocityLon = (animData.targetLongitude - animData.startLongitude)/(animData.durationInSeconds);
	var velocityLat = (animData.targetLatitude - animData.startLatitude)/(animData.durationInSeconds);
	var velocityAlt = (animData.targetAltitude - animData.startAltitude)/(animData.durationInSeconds);

	var geoLocDatamanager = this.getNodeGeoLocDataManager();
	if (geoLocDatamanager === undefined)
	{
		return true;
	}
	var geoLocationData = geoLocDatamanager.getCurrentGeoLocationData();
	if (geoLocationData === undefined)
	{
		return true;
	}
	var geographicCoord = geoLocationData.geographicCoord;

	if (totalDeltaTime > animData.durationInSeconds)
	{
		nextLongitude = animData.targetLongitude;
		nextLatitude = animData.targetLatitude;
		nextAltitude = animData.targetAltitude;
		
		// finish the process.
		finished = true;
		this.data.animationData.finished = true;
	}
	else
	{
		// calculate by durationInSeconds.
		var targetLongitude = animData.targetLongitude;
		var targetLatitude = animData.targetLatitude;
		var targetAltitude = animData.targetAltitude;
		
		nextLongitude = animData.startLongitude + velocityLon * totalDeltaTime;
		nextLatitude = animData.startLatitude + velocityLat * totalDeltaTime;
		nextAltitude = animData.startAltitude + velocityAlt * totalDeltaTime;
		
		// finally update "lastTime".
		animData.lastTime = currTime;
		finished = false;
	}

	this.changeLocationAndRotation(nextLatitude, nextLongitude, nextAltitude, geoLocationData.heading, geoLocationData.pitch, geoLocationData.roll, magoManager);
	
	return finished;
};

/**
 * 어떤 일을 하고 있습니까?
 */
 
Node.prototype.changeLocationAndRotationAnimated = function(latitude, longitude, elevation, heading, pitch, roll, magoManager, animationOption) 
{
	// Provisionally set a geoLocationData target.
	if (this.data.animationData === undefined)
	{ this.data.animationData = new AnimationData(); }
	
	var animData = this.data.animationData;
	animData.finished = false;
	animData.birthTime = magoManager.getCurrentTime();
	
	var geoLocDataManager = this.getNodeGeoLocDataManager();
	if (geoLocDataManager === undefined)
	{ return; }
	var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
	if (geoLocData === undefined)
	{ return; }
	var geoCoords = geoLocData.getGeographicCoords();
	if (geoCoords === undefined)
	{ return; } 
	
	if (!geoCoords.longitude || !geoCoords.latitude || !geoCoords.altitude)
	{
		return;
	}
	if (geoCoords.longitude === undefined || geoCoords.latitude === undefined || geoCoords.altitude === undefined)
	{
		return;
	}
	// start location.***
	animData.startLongitude = geoCoords.longitude;
	animData.startLatitude = geoCoords.latitude;
	animData.startAltitude = geoCoords.altitude;
	
	// target location.
	animData.targetLongitude = longitude;
	animData.targetLatitude = latitude;
	animData.targetAltitude = elevation;
	
	// calculate rotation (heading & pitch).
	var currLongitude = geoCoords.longitude;
	var currLatitude = geoCoords.latitude;
	var currAltitude = geoCoords.altitude;

	// target rotation.
	animData.targetHeading = heading;
	animData.targetPitch = pitch;
	animData.targetRoll = roll;

	geoLocData.heading = animData.targetHeading;
	geoLocData.pitch = animData.targetPitch;
	geoLocData.roll = animData.targetRoll;

	//Duration For compatibility with lower versions, lower version parameter is just duratiuon(number).
	var isAnimOption = typeof animationOption === 'object' && isNaN(animationOption);
	var durationInSeconds = 3.0;
	if (isAnimOption)
	{
		if (animationOption.duration)
		{
			durationInSeconds = animationOption.duration;
		}
		if (animationOption.autoChangeRotation)
		{
			var nextPos = Globe.geographicToCartesianWgs84(animData.targetLongitude, animData.targetLatitude, animData.targetAltitude, undefined);
			var nextPoint3d = new Point3D(nextPos[0], nextPos[1], nextPos[2]);
			var relativeNextPos;
			relativeNextPos = geoLocData.getTransformedRelativePositionNoApplyHeadingPitchRoll(nextPoint3d, relativeNextPos);
			
			// calculate heading (initially yAxis to north).
			var nextHeading = Math.atan(-relativeNextPos.x/relativeNextPos.y)*180.0/Math.PI;
			var nextPosModule2d = Math.sqrt(relativeNextPos.x*relativeNextPos.x + relativeNextPos.y*relativeNextPos.y);
			var nextPitch = Math.atan(relativeNextPos.z/nextPosModule2d)*180.0/Math.PI;
			
			geoLocData.heading = nextHeading;
			geoLocData.pitch = nextPitch;
			geoLocData.roll = animData.targetRoll;
		}
	}
	else
	{
		durationInSeconds = animationOption;
	}

	//if (durationInSeconds === undefined)
	//{ durationInSeconds = 3.0; }
	animData.durationInSeconds = durationInSeconds;
	// linear velocity in m/s.
	//animData.linearVelocityInMetersSecond = 40.0;
				
	// angular velocity deg/s.
	//animData.headingAngDegSecondVelocity = 10.0;
	//animData.pitchAngDegSecondVelocity = 0.0;
	//animData.rollAngDegSecondVelocity = 0.0;
	// end setting geoLocDataTarget.--------------------------------------------------
	
	
};


/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.changeLocationAndRotation = function(latitude, longitude, elevation, heading, pitch, roll, magoManager) 
{
	
	var nodeRoot;
	//nodeRoot = this.getRoot(); // original.
	nodeRoot = this.getClosestParentWithData("geoLocDataManager");
	// 126.60625627706231
	
	if (nodeRoot === undefined)
	{ return; }
	
	// now, extract all buildings of the nodeRoot.
	var nodesArray = [];
	nodeRoot.extractNodesByDataName(nodesArray, "neoBuilding");
	
	nodeRoot.data.geographicCoord.longitude = longitude; 
	nodeRoot.data.geographicCoord.latitude = latitude; 
	nodeRoot.data.geographicCoord.altitude = elevation;
	
	var aNode;
	var buildingSelected;
	var nodesCount = nodesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		aNode = nodesArray[i];
		var geoLocDatamanager = aNode.getNodeGeoLocDataManager();
		if (geoLocDatamanager === undefined)
		{ continue; }
		var geoLocationData;
		if (this.data.animationData !== undefined)
		{
			geoLocationData = geoLocDatamanager.newGeoLocationData();
		}
		else 
		{
			geoLocationData = geoLocDatamanager.getCurrentGeoLocationData(); // original.
		}
		if (geoLocationData === undefined)
		{ continue; }
	
		geoLocationData = ManagerUtils.calculateGeoLocationData(longitude, latitude, elevation, heading, pitch, roll, geoLocationData, magoManager);
		if (geoLocationData === undefined)
		{ continue; }
	
		if (geoLocationData.geographicCoord === undefined)
		{ continue; } 
	
		// Change the geoCoords of the buildingSeed.
		var buildingSeed = aNode.data.buildingSeed;
		buildingSeed.geographicCoordOfBBox.longitude = longitude;
		buildingSeed.geographicCoordOfBBox.latitude = latitude;

		
		// now, must change the keyMatrix of the references of the octrees of all buildings of this node.
		var neoBuilding = aNode.data.neoBuilding;
		if (neoBuilding.octree)
		{
			neoBuilding.octree.multiplyKeyTransformMatrix(0, geoLocationData.rotMatrix);
		}
		neoBuilding.calculateBBoxCenterPositionWorldCoord(geoLocationData);
		nodeRoot.bboxAbsoluteCenterPos = undefined; // provisional.
		nodeRoot.calculateBBoxCenterPositionWorldCoord(geoLocationData); // provisional.
		
		aNode.bboxAbsoluteCenterPos = undefined; // provisional.
		aNode.calculateBBoxCenterPositionWorldCoord(geoLocationData); // provisional.
		
		// Now, calculate the geoCoords of the bbox.
		if (nodeRoot.data.bbox.geographicCoord === undefined)
		{ nodeRoot.data.bbox.geographicCoord = new GeographicCoord(); }
		
		nodeRoot.data.bbox.geographicCoord.setLonLatAlt(longitude, latitude, elevation); // provisional. Must calculate the ... TODO:
		
		// aNode was moved, so, check if is out of the smartTileOwner.
		// If aNode is out of the smartTileOwner, then, erase the node from the smartTileOwner, and then put the node in the corresponent smartTile.
		var smartTileOwner = aNode.data.smartTileOwner;
		if (!smartTileOwner.intersectsNode(aNode))
		{
			smartTileOwner.eraseNode(aNode);
					
			// Now, put the node in the corresponent smartTile.
			var targetDepth = smartTileOwner.targetDepth;
			magoManager.smartTileManager.putNode(targetDepth, aNode, magoManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
/*
Node.prototype.test__octreeModelRefAndIndices_changed = function() 
{
	var data = this.data;
	
	if(data === undefined)
		return false;
	
	var neoBuilding = data.neoBuilding;
	if(neoBuilding === undefined)
		return false;
	
	var octree = neoBuilding.octree;
	if(octree === undefined)
		return true;
	
	var modelRefMotherAndIndices = octree.neoReferencesMotherAndIndices;
	if(modelRefMotherAndIndices === undefined)
		return true;
	
	if(modelRefMotherAndIndices.neoRefsIndices.length === 0 || modelRefMotherAndIndices.motherNeoRefsList.length === 0)
		return true;
	
	return false;
};
*/
















'use strict';

/**
 * Octree class object. The octree contains detailed geometry data (meshes, points cloud, etc.).
 * @class Octree
 * @param {Octree} octreeOwner If octreeOwner is undefined, then this octree is the mother octree.
 */
var Octree = function(octreeOwner) 
{
	if (!(this instanceof Octree)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * The center position in local coordinates of the octree.
	 * @type {Point3D}
	 * @default (0,0,0)
	 */
	this.centerPos = new Point3D();
	
	/**
	 * The half width of the octree in x-axis.
	 * @type {Number}
	 * @default 0.0
	 */
	this.half_dx = 0.0; 
	
	/**
	 * The half width of the octree in y-axis.
	 * @type {Number}
	 * @default 0.0
	 */
	this.half_dy = 0.0; 
	
	/**
	 * The half width of the octree in z-axis.
	 * @type {Number}
	 * @default 0.0
	 */
	this.half_dz = 0.0; 

	/**
	 * The octree's owner. If octree_owner is undefined, then this octree is the mother octree.
	 * @type {Octree}
	 * @default undefined
	 */
	this.octree_owner;
	if (octreeOwner) 
	{
		this.octree_owner = octreeOwner;
		this.octree_level = octreeOwner.octree_level + 1;
	}
	
	/**
	 * The octree's depth level. Mother octree's depth level is zero.
	 * @type {Number}
	 * @default 0
	 */
	this.octree_level = 0;
	
	// Octree number name.**
	// Bottom           Top              Y
	// +-----+-----+   +-----+-----+     ^
	// |  4  |  3  |   |  8  |  7  |     |
	// +-----+-----+   +-----+-----+     |
	// |  1  |  2  |   |  5  |  6  |     |------> X
	// +-----+-----+   +-----+-----+
	
	/**
	 * The octree's identifier. Accumulative number, starting from mother octree.
	 * @type {Number}
	 * @default 0
	 */
	this.octree_number_name = 0;
	
	/**
	 * The octree's neoBuildingOwner identifier.
	 * @type {String}
	 * @default undefined
	 */
	this.neoBuildingOwnerId;
	
	/**
	 * The octree's neoBuildingOwner.
	 * @type {NeoBuilding}
	 * @default undefined
	 */
	this.neoBuildingOwner;
	
	/**
	 * The octree's global unique identifier. It is compost by neoBuildingOwnerId + octree_number_name.
	 * @type {String}
	 * @default undefined
	 */
	this.octreeKey; 
	
	/**
	 * The octree's current LOD. Assigned by distance to camera when frustumCulling.
	 * @type {Number}
	 * @default undefined
	 */
	this.lod; 
	
	/**
	 * The octree's current distance to camera.
	 * @type {Number}
	 * @default undefined
	 */
	this.distToCamera;
	
	/**
	 * The octree's meshes count. Readed when parsing.
	 * @type {Number}
	 * @default 0
	 */
	this.triPolyhedronsCount = 0; 
	
	/**
	 * The octree's current fileLoadState.
	 * @type {Number}
	 * @default 0
	 */
	this.fileLoadState = CODE.fileLoadState.READY;

	/**
	 * The octree's children array. Array length must be 8.
	 * @type {Array}
	 * @default 0
	 */
	this.subOctrees_array = [];
	
	/**
	 * The octree's meshes. The meshes of the octree are referenced by an indice.
	 * @type {NeoReferencesMotherAndIndices}
	 * @default undefined
	 */
	this.neoReferencesMotherAndIndices; 
	
	/**
	 * Pre-extracted leaf octrees, to speedUp.
	 * @type {Array}
	 * @default undefined
	 */
	this.lowestOctrees_array; // pre extract lowestOctrees for speedUp, if this is motherOctree.

	/**
	 * Can be a mesh or poitsCloudPartition. Generally used to contain LOD2 meshes.
	 * @type {Lego}
	 * @default undefined
	 */
	this.lego; 
	
	/**
	 * PointsCloudPartitions count.
	 * @type {Number}
	 * @default undefined
	 */
	this.pCloudPartitionsCount; // pointsCloud-pyramid-tree mode.
	
	/**
	 * PointsCloudPartitions.
	 * @type {Array}
	 * @default undefined
	 */
	this.pCloudPartitionsArray;
	
	// v002.
	//this.blocksListsPartitionsCount;
	//this.blocksListsPartitionsParsedCount;
};

/**
 * Creates a child octree.
 * @returns {Octree} subOctree Returns the created child octree.
 */
Octree.prototype.new_subOctree = function() 
{
	var subOctree = new Octree(this);
	subOctree.octree_level = this.octree_level + 1;
	this.subOctrees_array.push(subOctree);
	return subOctree;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.deleteObjectsModelReferences = function(gl, vboMemManager) 
{
	if (this.neoReferencesMotherAndIndices)
	{ this.neoReferencesMotherAndIndices.deleteObjects(gl, vboMemManager); }

	this.neoReferencesMotherAndIndices = undefined;

	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteObjectsModelReferences(gl, vboMemManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.deleteObjectsLego = function(gl, vboMemManager) 
{
	if (this.lego !== undefined) 
	{
		// deletes the geometry and the texture.
		this.lego.deleteObjects(gl, vboMemManager);
		this.lego = undefined;
	}
	
	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteObjectsLego(gl, vboMemManager);
		}
	}
	
};

/**
 * Deletes all objects of the octree.
 * @param gl : current gl.
 * @param vboMemManager : gpu memory manager
 */
Octree.prototype.deleteObjects = function(gl, vboMemManager) 
{
	if (this.lego !== undefined) 
	{
		this.lego.deleteObjects(gl, vboMemManager);
		this.lego = undefined;
	}
	
	this.legoDataArrayBuffer = undefined;
	if (this.centerPos)
	{ this.centerPos.deleteObjects(); }
	this.centerPos = undefined;
	this.half_dx = undefined; // half width.
	this.half_dy = undefined; // half length.
	this.half_dz = undefined; // half height.

	this.octree_owner = undefined;
	this.octree_level = undefined;
	this.octree_number_name = undefined;
	this.distToCamera = undefined;
	this.triPolyhedronsCount = undefined; // no calculated. Readed when parsing.
	this.fileLoadState = undefined; // 0 = no started to load. 1 = started loading. 2 = finished loading. 3 = parse started. 4 = parse finished.

	this.neoBuildingOwner = undefined;

	if (this.neoReferencesMotherAndIndices)
	{ this.neoReferencesMotherAndIndices.deleteObjects(gl, vboMemManager); }

	this.neoReferencesMotherAndIndices = undefined;
	
	// before deleteting child:
	this.deletePCloudObjects(gl, vboMemManager);

	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteObjects(gl, vboMemManager);
			this.subOctrees_array[i] = undefined;
		}
		this.subOctrees_array = undefined;
	}
	
	
};

/**
 * Deletes pointsCloud objects of the octree.
 * @param gl : current gl.
 * @param vboMemManager : gpu memory manager
 */
Octree.prototype.deletePCloudObjects = function(gl, vboMemManager) 
{
	//this.pCloudPartitionsCount; // pointsCloud-pyramid-tree mode.
	//this.pCloudPartitionsArray;
	
	if (this.pCloudPartitionsArray !== undefined)
	{ 
	
		var pCloudPartitionsCount = this.pCloudPartitionsArray.length;
		for (var i=0; i<pCloudPartitionsCount; i++)
		{
			var pCloudPartition = this.pCloudPartitionsArray[i];
			// Note: provisionally "pCloudPartition" is a lego class object.
			pCloudPartition.deleteObjects(gl, vboMemManager);
		}
		
		this.pCloudPartitionsArray = undefined;
	}
	
	// Now, delete child.
	if (this.subOctrees_array !== undefined)
	{
		var childsCount = this.subOctrees_array.length;
		for (var i=0; i<childsCount; i++)
		{
			var subOctree = this.subOctrees_array[i];
			subOctree.deletePCloudObjects(gl, vboMemManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.deleteLod0GlObjects = function(gl, vboMemManager) 
{
	if (this.neoReferencesMotherAndIndices)
	{ this.neoReferencesMotherAndIndices.deleteObjects(gl, vboMemManager); }

	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteLod0GlObjects(gl, vboMemManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.deleteLod2GlObjects = function(gl, vboMemManager) 
{
	if (this.lego !== undefined) 
	{
		this.lego.deleteObjects(gl, vboMemManager);
		this.lego = undefined;
	}
	
	if (this.neoReferencesMotherAndIndices)
	{ this.neoReferencesMotherAndIndices.deleteObjects(gl, vboMemManager); }

	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteLod2GlObjects(gl, vboMemManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.makeTree = function(treeDepth) 
{
	if (this.octree_level < treeDepth) 
	{
		for (var i=0; i<8; i++) 
		{
			var subOctree = this.new_subOctree();
			subOctree.octree_number_name = this.octree_number_name * 10 + (i+1);
			subOctree.neoBuildingOwnerId = this.neoBuildingOwnerId;
			subOctree.octreeKey = this.neoBuildingOwnerId + "_" + subOctree.octree_number_name;
		}

		this.setSizesSubBoxes();

		for (var i=0; i<8; i++) 
		{
			this.subOctrees_array[i].makeTree(treeDepth);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.prepareData = function(magoManager) 
{
	// Function no used. Under construction.
	// This function prepares data in function of the current lod.
	if (this.lod < 2)
	{
		// Must prepare modelRefList data.
		this.prepareModelReferencesListData(magoManager);
	}
	else if (this.lod >= 2)
	{
		// Must prepare skin data.
		this.prepareSkinData(magoManager);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.prepareSkinData = function(magoManager) 
{
	if (this.octree_number_name === undefined)
	{ return; }
	
	if (this.lego === undefined) 
	{
		this.lego = new Lego();
		this.lego.birthTime = magoManager.currTime;
		this.lego.fileLoadState = CODE.fileLoadState.READY;
		this.lego.legoKey = this.octreeKey + "_lego";
	}

	var neoBuilding = this.neoBuildingOwner;
	if (neoBuilding === undefined)
	{ return; }
	
	var gl = magoManager.sceneState.gl;
	var geometryDataPath = magoManager.readerWriter.geometryDataPath;
	var projectFolderName = neoBuilding.projectFolderName;
	var buildingFolderName = neoBuilding.buildingFileName;
	
	var headerVersion = neoBuilding.getHeaderVersion();

	if (this.lego.fileLoadState === CODE.fileLoadState.READY)
	{
		// must load the legoStructure of the lowestOctree.
		var subOctreeNumberName = this.octree_number_name.toString();
		var bricks_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/Bricks";
		var filePathInServer = bricks_folderPath + "/" + subOctreeNumberName + "_Brick";

		// finally check if there are legoSimpleBuildingTexture.
		if (headerVersion[0] === "v")
		{
			if (this.lego.vbo_vicks_container.vboCacheKeysArray[0] && this.lego.vbo_vicks_container.vboCacheKeysArray[0].meshTexcoordsCacheKey)
			{
				// this is the old version.
				if (neoBuilding.simpleBuilding3x3Texture === undefined)
				{
					neoBuilding.simpleBuilding3x3Texture = new Texture();
					var buildingFolderName = neoBuilding.buildingFileName;
					var texFilePath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/SimpleBuildingTexture3x3.png";
				}
				
				// Direct loading.
				if (neoBuilding.simpleBuilding3x3Texture !== undefined && neoBuilding.simpleBuilding3x3Texture.fileLoadState === CODE.fileLoadState.READY)
				{ 
					magoManager.readerWriter.readLegoSimpleBuildingTexture(gl, texFilePath, neoBuilding.simpleBuilding3x3Texture, magoManager); 
				}
				
				magoManager.readerWriter.getOctreeLegoArraybuffer(filePathInServer, this, magoManager);
				
			}
			else 
			{
				// there are no texture in this project.
				magoManager.readerWriter.getOctreeLegoArraybuffer(filePathInServer, this, magoManager);
				
			}
		}
		else 
		{
			// This is the version 001.
			if (neoBuilding.simpleBuilding3x3Texture === undefined)
			{
				neoBuilding.simpleBuilding3x3Texture = new Texture();
			}

			var imageFilaName = neoBuilding.getImageFileNameForLOD(2);
			var texFilePath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/" + imageFilaName;

			// Direct loading.
			if (neoBuilding.simpleBuilding3x3Texture !== undefined && neoBuilding.simpleBuilding3x3Texture.fileLoadState === CODE.fileLoadState.READY)
			{ 
				magoManager.readerWriter.readLegoSimpleBuildingTexture(gl, texFilePath, neoBuilding.simpleBuilding3x3Texture, magoManager); 
			}
			
			magoManager.readerWriter.getOctreeLegoArraybuffer(filePathInServer, this, magoManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.prepareModelReferencesListData = function(magoManager) 
{
	var neoBuilding = this.neoBuildingOwner;
		
	// 1rst check possibles errors.
	if (neoBuilding === undefined)
	{ return; }
	
	if (this.triPolyhedronsCount === 0) 
	{ return; }
	
	if (this.octree_number_name === undefined)
	{ return; }

	// Check the version.
	var version = neoBuilding.getHeaderVersion();
	if (version === "0.0.2")
	{
		this.prepareModelReferencesListData_v002(magoManager);
		return;
	}

	var geometryDataPath = magoManager.readerWriter.geometryDataPath;
	var buildingFolderName = neoBuilding.buildingFileName;
	var projectFolderName = neoBuilding.projectFolderName;
	
	if (this.neoReferencesMotherAndIndices === undefined)
	{
		this.neoReferencesMotherAndIndices = new NeoReferencesMotherAndIndices();
		this.neoReferencesMotherAndIndices.motherNeoRefsList = neoBuilding.motherNeoReferencesArray;
	}
	
	if (this.neoReferencesMotherAndIndices.fileLoadState === CODE.fileLoadState.READY)
	{
		if (this.neoReferencesMotherAndIndices.blocksList === undefined)
		{ this.neoReferencesMotherAndIndices.blocksList = new BlocksList("0.0.1"); }

		var subOctreeNumberName = this.octree_number_name.toString();
		var references_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/References";
		var intRef_filePath = references_folderPath + "/" + subOctreeNumberName + "_Ref";
		magoManager.readerWriter.getNeoReferencesArraybuffer(intRef_filePath, this, magoManager);
	}
	
	
	// 4 = parsed.
	// now, check if the blocksList is loaded & parsed.
	var blocksList = this.neoReferencesMotherAndIndices.blocksList;
	if (blocksList === undefined)
	{ return; }
	if (blocksList.fileLoadState === CODE.fileLoadState.READY) 
	{
		// must read blocksList.
		var subOctreeNumberName = this.octree_number_name.toString();
		var blocks_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/Models";
		var filePathInServer = blocks_folderPath + "/" + subOctreeNumberName + "_Model";
		magoManager.readerWriter.getNeoBlocksArraybuffer(filePathInServer, this, magoManager);
	}

};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.prepareModelReferencesListData_v002 = function(magoManager) 
{
	var neoBuilding = this.neoBuildingOwner;
		
	// 1rst check possibles errors.
	if (neoBuilding === undefined)
	{ return; }
	
	if (this.triPolyhedronsCount === 0) 
	{ return; }
	
	if (this.octree_number_name === undefined)
	{ return; }

	var geometryDataPath = magoManager.readerWriter.geometryDataPath;
	var buildingFolderName = neoBuilding.buildingFileName;
	var projectFolderName = neoBuilding.projectFolderName;
	
	if (this.neoReferencesMotherAndIndices === undefined)
	{
		this.neoReferencesMotherAndIndices = new NeoReferencesMotherAndIndices();
		this.neoReferencesMotherAndIndices.motherNeoRefsList = neoBuilding.motherNeoReferencesArray;
	}
	
	if (this.neoReferencesMotherAndIndices.fileLoadState === CODE.fileLoadState.READY)
	{
		if (this.neoReferencesMotherAndIndices.blocksList === undefined)
		{ 
			var blocksList = new BlocksList("0.0.2"); 
			this.neoReferencesMotherAndIndices.blocksList = blocksList; 
			
			// Set blocksList partitionData.
			blocksList.blocksArrayPartitionsCount = this.blocksListsPartitionsCount;

			var subOctreeNumberName = this.octree_number_name.toString();
			var blocks_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/Models";
			var masterPathName = blocks_folderPath + "/" + subOctreeNumberName + "_Model_";
			blocksList.blocksArrayPartitionsMasterPathName = masterPathName;
		}

		var subOctreeNumberName = this.octree_number_name.toString();
		var references_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/References";
		var intRef_filePath = references_folderPath + "/" + subOctreeNumberName + "_Ref";
		magoManager.readerWriter.getNeoReferencesArraybuffer(intRef_filePath, this, magoManager);
	}
	
	// BlocksList: must distinguish v001 to v002.
	// In v002, the blocksList is conformed by partitions.
	var blocksList = this.neoReferencesMotherAndIndices.blocksList;
	if (blocksList === undefined)
	{ return; }

	// if (blocksList.fileLoadState === CODE.fileLoadState.READY) 
	
	// Load blocksListsPartition.

	//if(this.blocksListsPartitionsParsedCount === undefined)
	//	this.blocksListsPartitionsParsedCount = 0;

	
	blocksList.prepareData(magoManager, this);
	
	/*
	var partitionIdx = this.blocksListsPartitionsParsedCount;
	if (partitionIdx < this.blocksListsPartitionsCount)
	{
		var subOctreeNumberName = this.octree_number_name.toString();
		var blocks_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/Models";
		var filePathInServer = blocks_folderPath + "/" + subOctreeNumberName + "_Model_" + partitionIdx.toString();
		magoManager.readerWriter.getNeoBlocksArraybuffer_partition(filePathInServer, this, magoManager);
	}
	*/
};

/**
 * 어떤 일을 하고 있습니까?
 * @param intNumber 변수
 * @returns numDigits
 */
Octree.prototype.renderSkin = function(magoManager, neoBuilding, renderType, renderTexture, shader) 
{
	var gl = magoManager.sceneState.gl;
	if (this.lego === undefined) 
	{
		this.lego = new Lego();
		this.lego.fileLoadState = CODE.fileLoadState.READY;
		this.lego.legoKey = this.octreeKey + "_lego";
		return false;
	}
	
	if (this.lego.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
	{ return false; }

	// if the building is highlighted, the use highlight oneColor4.
	renderTexture = true;
	gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
	if (renderType === 1)
	{
		// Solve the color or texture of the skin.
		if (neoBuilding.isHighLighted)
		{
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			gl.uniform4fv(shader.oneColor4_loc, this.highLightColor4); //.
			renderTexture = false;
		}
		else if (neoBuilding.isColorChanged)
		{
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			gl.uniform4fv(shader.oneColor4_loc, [neoBuilding.aditionalColor.r, neoBuilding.aditionalColor.g, neoBuilding.aditionalColor.b, neoBuilding.aditionalColor.a]); //.
			renderTexture = false;
		}

		//----------------------------------------------------------------------------------
		
		if (neoBuilding.simpleBuilding3x3Texture !== undefined && neoBuilding.simpleBuilding3x3Texture.texId && renderTexture)
		{
			// Provisionally flip tex coords here.
			gl.uniform1i(shader.textureFlipYAxis_loc, false);//.ppp
			gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
			if (shader.last_tex_id !== neoBuilding.simpleBuilding3x3Texture.texId)
			{
				//gl.activeTexture(gl.TEXTURE2); 
				gl.bindTexture(gl.TEXTURE_2D, neoBuilding.simpleBuilding3x3Texture.texId);
				shader.last_tex_id = neoBuilding.simpleBuilding3x3Texture.texId;
			}
		}
		else 
		{
			// Todo: If this building lod2 has no texture, then render with colors.
			//gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			//shader.disableVertexAttribArray(shader.texCoord2_loc);
			//renderTexture = false;
			//-------------------------------------------------------------------------
			
			// If texture is no ready then return.
			return false;
		}
	}
	else if (renderType === 2)
	{
		// Color selction mode.
		var colorAux;
		colorAux = magoManager.selectionColor.getAvailableColor(colorAux);
		var idxKey = magoManager.selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
		var currentObjectsRendering = magoManager.renderer.currentObjectsRendering;
		var currentNode = currentObjectsRendering.curNode;
		magoManager.selectionManager.setCandidates(idxKey, undefined, this, neoBuilding, currentNode);
		
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
	}
	
	return this.lego.render(magoManager, renderType, renderTexture, shader);
};



/**
 * 어떤 일을 하고 있습니까?
 * @param intNumber 변수
 * @returns numDigits
 */
Octree.prototype.renderContent = function(magoManager, neoBuilding, renderType, renderTexture, shader, minSizeToRender, refMatrixIdxKey, flipYTexCoord) 
{
	// the content of the octree is "neoReferencesMotherAndIndices" & the netSurfaceMesh called "lego".
	// This function renders the "neoReferencesMotherAndIndices" or the lego.
	var rendered = false;
	var gl = magoManager.sceneState.gl;

	if (this.lod < 2)
	{
		// 1rst check if the "neoReferencesMotherAndIndices" is ready to be rendered.
		if (this.neoReferencesMotherAndIndices === undefined)
		{ return; }
		gl.uniform1i(shader.textureFlipYAxis_loc, flipYTexCoord);//.ppp
		rendered = this.neoReferencesMotherAndIndices.render(magoManager, neoBuilding, renderType, renderTexture, shader, minSizeToRender, refMatrixIdxKey);
		if (!rendered)
		{
			// render the skinLego.
			rendered = this.renderSkin(magoManager, neoBuilding, renderType, renderTexture, shader);
		}
	}
	else if (this.lod === 2)
	{
		// Render the skinLego.
		rendered = this.renderSkin(magoManager, neoBuilding, renderType, renderTexture, shader);
	}
	
	return rendered;
};

/**
 * Returns the pointsCloud-PartitionsData count to consider for the "lod".
 * @param {Number} lod Level of Detail.
 * @param {Number} realPartitionsCount The real pointsCloud-PartitionsData count.
 * @param {MagoManager} magoManager The main class manager.
 * @returns {Number} pCloudPartitionsCount The pointsCloud-PartitionsData count to consider for the "lod".
 */
Octree.prototype.getPartitionsCountsForLod = function(lod, realPartitionsCount, magoManager) 
{
	var pCloudPartitionsCount =1;
	if (lod === 0)
	{ 
		var pCloudSettings = magoManager.magoPolicy.getPointsCloudSettings();
		pCloudPartitionsCount = realPartitionsCount; 
		if (pCloudPartitionsCount > pCloudSettings.maxPartitionsLod0)
		{ pCloudPartitionsCount = pCloudSettings.maxPartitionsLod0; }
	}
	else if (lod === 1)
	{ 
		var pCloudSettings = magoManager.magoPolicy.getPointsCloudSettings();
		pCloudPartitionsCount = Math.ceil(realPartitionsCount/4); 
		if (pCloudPartitionsCount > pCloudSettings.maxPartitionsLod1)
		{ pCloudPartitionsCount = pCloudSettings.maxPartitionsLod1; }
	}
	else if (lod > 1)
	{ pCloudPartitionsCount = 1; }

	return pCloudPartitionsCount;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param {MagoManager} magoManager Main mago3d manager.
 * @returns {Boolean} Returns if requested the points cloud data.
 */
Octree.prototype.preparePCloudData = function(magoManager) 
{
	if (this.pCloudPartitionsCount === undefined && this.pCloudPartitionsCount === 0)
	{ return false; }

	var neoBuilding = this.neoBuildingOwner;
	if (neoBuilding === undefined)
	{ return false; }

	if (magoManager.processQueue.existOctreeToDeletePCloud(this))
	{ return false; }
	
	if (this.pCloudPartitionsArray === undefined)
	{ this.pCloudPartitionsArray = []; }
	
	var pCloudPartitionsCount = this.getPartitionsCountsForLod(this.lod, this.pCloudPartitionsCount, magoManager);
	
	for (var i=0; i<pCloudPartitionsCount; i++)
	{
		var pCloudPartition = this.pCloudPartitionsArray[i];
		if ( i < this.pCloudPartitionsArray.length)
		{
			// Note: "pCloudPartition" is a Lego class object provisionally.
			if (pCloudPartition !== undefined && pCloudPartition.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
			{
				// Parse data.
				if (magoManager.parseQueue.pCloudPartitionsParsed < 4)
				{
					var gl = magoManager.sceneState.gl;
					pCloudPartition.parsePointsCloudData(pCloudPartition.dataArrayBuffer, gl, magoManager);
					magoManager.parseQueue.pCloudPartitionsParsed++;
				}
			}
		}
		else
		{
			if (pCloudPartition === undefined )//&& pCloudPartition.fileLoadState === CODE.fileLoadState.READY)
			{
				// Create the pCloudPartition.
				var readWriter = magoManager.readerWriter;
				var pCloudPartitions_requested = 0;
				if (this.octree_level === 0)
				{
					pCloudPartitions_requested = readWriter.pCloudPartitionsMother_requested;
				}
				else 
				{
					pCloudPartitions_requested = readWriter.pCloudPartitions_requested;
				}
				if (pCloudPartitions_requested < 3 && magoManager.vboMemoryManager.currentMemoryUsage < magoManager.vboMemoryManager.buffersKeyWorld.bytesLimit/1.5)
				{
					//var pCloudPartition = this.pCloudPartitionsArray[i];
					var pCloudPartitionLego = new Lego();
					this.pCloudPartitionsArray.push(pCloudPartitionLego);
					pCloudPartitionLego.legoKey = this.octreeKey + "_" + i.toString();
						
					var projectFolderName = neoBuilding.projectFolderName;
					var buildingFolderName = neoBuilding.buildingFileName;
					var geometryDataPath = magoManager.readerWriter.geometryDataPath;
					var subOctreeNumberName = this.octree_number_name.toString();
					var references_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/References";
					var filePath = references_folderPath + "/" + subOctreeNumberName + "_Ref_" + i.toString(); // in this case the fileName is fixed.
						
					readWriter.getOctreePCloudPartitionArraybuffer(filePath, this, pCloudPartitionLego, magoManager);
					return true;
				}
			}
			
		}
	}
	
	return false;
	
};


/**
 * 어떤 일을 하고 있습니까?
 * @param intNumber 변수
 * @returns numDigits
 */
Octree.prototype.test__renderPCloud = function(magoManager, neoBuilding, renderType, shader, relativeCam, bPrepareData) 
{
	// Test function to render octreePyramid-pointsCloud.
	// 1rst, check the number of partitions of data.
	var partitionsCount = this.pCloudPartitionsCount;
	
	if (partitionsCount === undefined || partitionsCount === 0)
	{ return; }
	
	// Determine the distance from camera.
	var magoPolicy = magoManager.magoPolicy;
	var camera = magoManager.sceneState.camera;
	var cullingVolume = relativeCam.bigFrustum;
	
	// To calculate distToCamera use the relativeCamera.
	var cameraPosition = relativeCam.position;
	var distCenterToCamera = this.centerPos.distToPoint(cameraPosition);
	var distToCamera = distCenterToCamera - this.getRadiusAprox();
	this.distToCamera = distToCamera; // distCenterToCamera.
	
	// Put this octree into magoManager.visibleObjControlerPCloudOctrees, to load after. 
	if (renderType === 0) // Note: It can be "renderType === 0" or "renderType === 1". The important is do this only once a frame.
	{
		var vocPCloudOctrees = magoManager.visibleObjControlerPCloudOctrees;
		vocPCloudOctrees.putObjectToArraySortedByDist(vocPCloudOctrees.currentVisibles0, this);
	}
	
	// Provisionally, determine the LOD level by "distToCam".
	this.lod = magoPolicy.getLod(distToCamera);
	
	// Provisionally compare "this.lod" with "this.octreeLevel".
	var gl = magoManager.sceneState.gl;
	var ssao_idx = 1;
	
	var frustumCull = this.intersectionFrustum(cullingVolume, magoManager.boundingSphere_Aux);
	if (frustumCull !== Constant.INTERSECTION_OUTSIDE ) 
	{
		// Erase from deleting queue.
		magoManager.processQueue.eraseOctreeToDeletePCloud(this);
		
		var ssao_idx = 1;
		if (this.pCloudPartitionsArray === undefined)
		{ return; }
		
		var pCloudPartitionsCount = this.getPartitionsCountsForLod(this.lod, this.pCloudPartitionsCount, magoManager);

		for (var i=0; i<pCloudPartitionsCount; i++)
		{
			var pCloudPartition = this.pCloudPartitionsArray[i];
			if (pCloudPartition !== undefined && pCloudPartition.fileLoadState === CODE.fileLoadState.PARSE_FINISHED)
			{
				// render.
				var posCompressed = pCloudPartition.bPositionsCompressed;
				gl.uniform1i(shader.bPositionCompressed_loc, posCompressed);
				var bbox = pCloudPartition.bbox;
				gl.uniform3fv(shader.bboxSize_loc, [bbox.getXLength(), bbox.getYLength(), bbox.getZLength()]); //.
				gl.uniform3fv(shader.minPosition_loc, [bbox.minX, bbox.minY, bbox.minZ]); //.
				
				magoManager.renderer.renderPCloud(gl, pCloudPartition, magoManager, shader, renderType, distToCamera, this.lod);
			}
		}
		
		for (var i=0, subOctreesArrayLength = this.subOctrees_array.length; i<subOctreesArrayLength; i++ ) 
		{
			var subOctree = this.subOctrees_array[i];
			subOctree.test__renderPCloud(magoManager, neoBuilding, renderType, shader, relativeCam, bPrepareData);
		}
		
		magoManager.processQueue.eraseOctreeToDeletePCloud(this);
		
	}
	else
	{
		// Delete unnecessary objects if ditToCam is big.
		if (distToCamera > 50.0)
		{
			// Put octree to delete pCloud, but before, delete from the parseQueue.
			if (this.pCloudPartitionsArray !== undefined)
			{
				var pCloudPartitionsCount = this.pCloudPartitionsArray.length;
				for (var i=0; i<pCloudPartitionsCount; i++)
				{
					var pCloudPartition = this.pCloudPartitionsArray[i];
					magoManager.parseQueue.eraseOctreePCloudPartitionToParse(pCloudPartition);
				}
			}
			
			// Put octree to delete pCloud.
			magoManager.processQueue.putOctreeToDeletePCloud(this);
		}
	}
};



/**
 * 어떤 일을 하고 있습니까?
 * @param intNumber 변수
 * @returns numDigits
 */
Octree.prototype.getNumberOfDigits = function(intNumber) 
{
	if (intNumber > 0) 
	{
		var numDigits = Math.floor(Math.log10(intNumber)+1);
		return numDigits;
	}
	else 
	{
		return 1;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.getMotherOctree = function() 
{
	if (this.octree_owner === undefined) { return this; }

	return this.octree_owner.getMotherOctree();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param octreeNumberName 변수
 * @param numDigits 변수
 * @returns subOctrees_array[idx-1].getOctree(rest_octreeNumberName, numDigits-1)
 */
Octree.prototype.getOctree = function(octreeNumberName, numDigits) 
{
	if (numDigits === 1) 
	{
		if (octreeNumberName === 0) { return this.getMotherOctree(); }
		else { return this.subOctrees_array[octreeNumberName-1]; }
	}

	// determine the next level octree.
	var exp = numDigits-1;
	var denominator = Math.pow(10, exp);
	var idx = Math.floor(octreeNumberName /denominator) % 10;
	var rest_octreeNumberName = octreeNumberName - idx * denominator;
	return this.subOctrees_array[idx-1].getOctree(rest_octreeNumberName, numDigits-1);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param octreeNumberName 변수
 * @returns motherOctree.subOctrees_array[idx-1].getOctree(rest_octreeNumberName, numDigits-1)
 */
Octree.prototype.getOctreeByNumberName = function(octreeNumberName) 
{
	var motherOctree = this.getMotherOctree();
	var numDigits = this.getNumberOfDigits(octreeNumberName);
	if (numDigits === 1) 
	{
		if (octreeNumberName === 0) { return motherOctree; }
		else { return motherOctree.subOctrees_array[octreeNumberName-1]; }
	}

	if (motherOctree.subOctrees_array.length === 0) { return undefined; }

	// determine the next level octree.
	var exp = numDigits-1;
	var denominator = Math.pow(10, exp);
	var idx = Math.floor(octreeNumberName /denominator) % 10;
	var rest_octreeNumberName = octreeNumberName - idx * denominator;
	return motherOctree.subOctrees_array[idx-1].getOctree(rest_octreeNumberName, numDigits-1);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.setSizesSubBoxes = function() 
{
	// Octree number name.**
	// Bottom                      Top
	// |---------|---------|     |---------|---------|
	// |         |         |     |         |         |       Y
	// |    3    |    2    |     |    7    |    6    |       ^
	// |         |         |     |         |         |       |
	// |---------+---------|     |---------+---------|       |
	// |         |         |     |         |         |       |
	// |    0    |    1    |     |    4    |    5    |       |
	// |         |         |     |         |         |       |-----------> X
	// |---------|---------|     |---------|---------|

	if (this.subOctrees_array.length > 0) 
	{
		var half_x = this.centerPos.x;
		var half_y = this.centerPos.y;
		var half_z = this.centerPos.z;

		var min_x = this.centerPos.x - this.half_dx;
		var min_y = this.centerPos.y - this.half_dy;
		var min_z = this.centerPos.z - this.half_dz;

		var max_x = this.centerPos.x + this.half_dx;
		var max_y = this.centerPos.y + this.half_dy;
		var max_z = this.centerPos.z + this.half_dz;

		this.subOctrees_array[0].setBoxSize(min_x, half_x, min_y, half_y, min_z, half_z);
		this.subOctrees_array[1].setBoxSize(half_x, max_x, min_y, half_y, min_z, half_z);
		this.subOctrees_array[2].setBoxSize(half_x, max_x, half_y, max_y, min_z, half_z);
		this.subOctrees_array[3].setBoxSize(min_x, half_x, half_y, max_y, min_z, half_z);

		this.subOctrees_array[4].setBoxSize(min_x, half_x, min_y, half_y, half_z, max_z);
		this.subOctrees_array[5].setBoxSize(half_x, max_x, min_y, half_y, half_z, max_z);
		this.subOctrees_array[6].setBoxSize(half_x, max_x, half_y, max_y, half_z, max_z);
		this.subOctrees_array[7].setBoxSize(min_x, half_x, half_y, max_y, half_z, max_z);

		for (var i=0; i<8; i++) 
		{
			this.subOctrees_array[i].setSizesSubBoxes();
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param Min_x 변수
 * @param Max_x 변수
 * @param Min_y 변수
 * @param Max_y 변수
 * @param Min_z 변수
 * @param Max_z 변수
 */
Octree.prototype.setBoxSize = function(Min_X, Max_X, Min_Y, Max_Y, Min_Z, Max_Z) 
{
	this.centerPos.x = (Max_X + Min_X)/2.0;
	this.centerPos.y = (Max_Y + Min_Y)/2.0;
	this.centerPos.z = (Max_Z + Min_Z)/2.0;

	this.half_dx = (Max_X - Min_X)/2.0; // half width.
	this.half_dy = (Max_Y - Min_Y)/2.0; // half length.
	this.half_dz = (Max_Z - Min_Z)/2.0; // half height.
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns centerPos
 */
Octree.prototype.getCenterPos = function() 
{
	return this.centerPos;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns Math.abs(this.half_dx*1.2);
 */
Octree.prototype.getRadiusAprox = function() 
{
	return this.half_dx*1.7;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param cullingVolume 변수
 * @param result_NeoRefListsArray 변수
 * @param boundingSphere_scratch 변수
 * @param eye_x 변수
 * @param eye_y 변수
 * @param eye_z 변수
 */
Octree.prototype.getFrustumVisibleLowestOctreesByLOD = function(cullingVolume, visibleObjControlerOctrees, globalVisibleObjControlerOctrees,
	boundingSphere_scratch, cameraPosition, squaredDistLod0, squaredDistLod1, squaredDistLod2) 
{
	var visibleOctreesArray = [];
	var find = false;

	//this.getAllSubOctrees(visibleOctreesArray); // Test.
	visibleOctreesArray = this.getFrustumVisibleOctreesNeoBuildingAsimetricVersion(cullingVolume, visibleOctreesArray, boundingSphere_scratch); // Original.

	// Now, we must sort the subOctrees near->far from eye.
	var visibleOctrees_count = visibleOctreesArray.length;
	for (var i=0; i<visibleOctrees_count; i++) 
	{
		visibleOctreesArray[i].setDistToCamera(cameraPosition);
	}

	for (var i=0; i<visibleOctrees_count; i++) 
	{
		if (visibleOctreesArray[i].distToCamera < squaredDistLod0) 
		{
			if (visibleOctreesArray[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles0, visibleOctreesArray[i]); }
				visibleObjControlerOctrees.currentVisibles0.push(visibleOctreesArray[i]);
				visibleOctreesArray[i].lod = 0;
				find = true;
			}
		}
		else if (visibleOctreesArray[i].distToCamera < squaredDistLod1) 
		{
			if (visibleOctreesArray[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles1, visibleOctreesArray[i]); }
				visibleObjControlerOctrees.currentVisibles1.push(visibleOctreesArray[i]);
				visibleOctreesArray[i].lod = 1;
				find = true;
			}
		}
		else if (visibleOctreesArray[i].distToCamera < squaredDistLod2) 
		{
			if (visibleOctreesArray[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles2, visibleOctreesArray[i]); }
				visibleObjControlerOctrees.currentVisibles2.push(visibleOctreesArray[i]);
				visibleOctreesArray[i].lod = 2;
				find = true;
			}
		}
		else 
		{
			if (visibleOctreesArray[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ globalVisibleObjControlerOctrees.currentVisibles3.push(visibleOctreesArray[i]); }
				visibleObjControlerOctrees.currentVisibles3.push(visibleOctreesArray[i]);
				visibleOctreesArray[i].lod = 3; // must be 3!!!
				find = true;
			}
		}
	}

	visibleOctreesArray = undefined;
	return find;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersects
 */
Octree.prototype.intersectsWithPoint3D = function(x, y, z) 
{
	//this.centerPos = new Point3D();
	//this.half_dx = 0.0; // half width.
	//this.half_dy = 0.0; // half length.
	//this.half_dz = 0.0; // half height.
	var minX = this.centerPos.x - this.half_dx;
	var minY = this.centerPos.y - this.half_dz;
	var minZ = this.centerPos.z - this.half_dz;
	var maxX = this.centerPos.x + this.half_dx;
	var maxY = this.centerPos.y + this.half_dz;
	var maxZ = this.centerPos.z + this.half_dz;
	
	var intersects = false;
	if (x> minX && x<maxX) 
	{
		if (y> minY && y<maxY) 
		{
			if (z> minZ && z<maxZ) 
			{
				intersects = true;
			}
		}
	}
	
	return intersects;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersectedSubBox
 */
Octree.prototype.getIntersectedSubBoxByPoint3D = function(x, y, z) 
{
	if (this.octree_owner === undefined) 
	{
		// This is the mother_cell.
		if (!this.intersectsWithPoint3D(x, y, z)) 
		{
			return false;
		}
	}
	
	var intersectedSubBox = undefined;
	var subBoxes_count = this.subOctrees_array.length;
	if (subBoxes_count > 0) 
	{
		var center_x = this.centerPos.x;
		var center_y = this.centerPos.y;
		var center_z = this.centerPos.z;
		
		var intersectedSubBox_aux = undefined;
		var intersectedSubBox_idx;
		if (x<center_x) 
		{
			// Here are the boxes number 0, 3, 4, 7.
			if (y<center_y) 
			{
				// Here are 0, 4.
				if (z<center_z) { intersectedSubBox_idx = 0; }
				else { intersectedSubBox_idx = 4; }
			}
			else 
			{
				// Here are 3, 7.
				if (z<center_z) { intersectedSubBox_idx = 3; }
				else { intersectedSubBox_idx = 7; }
			}
		}
		else 
		{
			// Here are the boxes number 1, 2, 5, 6.
			if (y<center_y) 
			{
				// Here are 1, 5.
				if (z<center_z) { intersectedSubBox_idx = 1; }
				else { intersectedSubBox_idx = 5; }
			}
			else 
			{
				// Here are 2, 6.
				if (z<center_z) { intersectedSubBox_idx = 2; }
				else { intersectedSubBox_idx = 6; }
			}
		}
		
		intersectedSubBox_aux = this.subOctrees_array[intersectedSubBox_idx];
		intersectedSubBox = intersectedSubBox_aux.getIntersectedSubBoxByPoint3D(x, y, z);
		
	}
	else 
	{
		intersectedSubBox = this;
	}
	
	return intersectedSubBox;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.getMinDistToCamera = function(cameraPosition)
{
	// Old function. dont use this function.
	// Old function. dont use this function.
	// Old function. dont use this function.
	// this function returns the minDistToCamera of the lowestOctrees.
	var minDistToCam = 1000000.0;
	
	if (this.lowestOctrees_array === undefined)
	{
		this.lowestOctrees_array = [];
		this.extractLowestOctreesIfHasTriPolyhedrons(this.lowestOctrees_array);
	}
	
	var distToCamera;
	var lowestOctree;
	var lowestOctreesCount = this.lowestOctrees_array.length;
	for (var i=0; i<lowestOctreesCount; i++)
	{
		lowestOctree = this.lowestOctrees_array[i];
		distToCamera = lowestOctree.centerPos.distToPoint(cameraPosition) - this.getRadiusAprox();
		if (distToCamera < minDistToCam)
		{ minDistToCam = distToCamera; }
	}
	
	return minDistToCam;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param cullingVolume 변수
 * @param result_NeoRefListsArray 변수
 * @param boundingSphere_scratch 변수
 * @param eye_x 변수
 * @param eye_y 변수
 * @param eye_z 변수
 */
Octree.prototype.extractLowestOctreesByLOD = function(visibleObjControlerOctrees, globalVisibleObjControlerOctrees,
	boundingSphere_scratch, cameraPosition, squaredDistLod0, squaredDistLod1, squaredDistLod2 ) 
{
	var distAux = 0.0;
	var find = false;
	
	var eye_x = cameraPosition.x;
	var eye_y = cameraPosition.y;
	var eye_z = cameraPosition.z;
	if (this.lowestOctrees_array === undefined)
	{
		this.lowestOctrees_array = [];
		this.extractLowestOctreesIfHasTriPolyhedrons(this.lowestOctrees_array);
	}
	
	// Now, we must sort the subOctrees near->far from eye.
	var visibleOctrees_count = this.lowestOctrees_array.length;
	for (var i=0; i<visibleOctrees_count; i++) 
	{
		this.lowestOctrees_array[i].setDistToCamera(cameraPosition);
	}

	for (var i=0; i<visibleOctrees_count; i++) 
	{
		if (this.lowestOctrees_array[i].distToCamera < squaredDistLod0) 
		{
			if (this.lowestOctrees_array[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles0, this.lowestOctrees_array[i]); }
				visibleObjControlerOctrees.currentVisibles0.push(this.lowestOctrees_array[i]);
				this.lowestOctrees_array[i].lod = 0;
				find = true;
			}
		}
		else if (this.lowestOctrees_array[i].distToCamera < squaredDistLod1) 
		{
			if (this.lowestOctrees_array[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles1, this.lowestOctrees_array[i]); }
				visibleObjControlerOctrees.currentVisibles1.push(this.lowestOctrees_array[i]);
				this.lowestOctrees_array[i].lod = 1;
				find = true;
			}
		}
		else if (this.lowestOctrees_array[i].distToCamera < squaredDistLod2) 
		{
			if (this.lowestOctrees_array[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles2, this.lowestOctrees_array[i]); }
				visibleObjControlerOctrees.currentVisibles2.push(this.lowestOctrees_array[i]);
				this.lowestOctrees_array[i].lod = 2;
				find = true;
			}
		}
		else 
		{
			if (this.lowestOctrees_array[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ globalVisibleObjControlerOctrees.currentVisibles3.push(this.lowestOctrees_array[i]); }
				visibleObjControlerOctrees.currentVisibles3.push(this.lowestOctrees_array[i]);
				this.lowestOctrees_array[i].lod = 3;
				find = true;
			}
		}
	}

	return find;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param cesium_cullingVolume 변수
 * @param result_octreesArray 변수
 * @param boundingSphere_scratch 변수
 */
Octree.prototype.intersectionFrustum = function(cullingVolume, boundingSphere_scratch) 
{
	if (boundingSphere_scratch === undefined) 
	{ boundingSphere_scratch = new Sphere(); } 

	boundingSphere_scratch.centerPoint.x = this.centerPos.x;
	boundingSphere_scratch.centerPoint.y = this.centerPos.y;
	boundingSphere_scratch.centerPoint.z = this.centerPos.z;
	boundingSphere_scratch.r = this.getRadiusAprox();

	return cullingVolume.intersectionSphere(boundingSphere_scratch);
};


/**
 * 어떤 일을 하고 있습니까?
 * @param cesium_cullingVolume 변수
 * @param result_octreesArray 변수
 * @param boundingSphere_scratch 변수
 */
Octree.prototype.getFrustumVisibleOctreesNeoBuildingAsimetricVersion = function(cullingVolume, result_octreesArray, boundingSphere_scratch) 
{
	// cullingVolume: Frustum class.
	if (this.subOctrees_array === undefined) { return; }

	if (this.subOctrees_array.length === 0 && this.triPolyhedronsCount === 0)
	{ return; }

	if (result_octreesArray === undefined) { result_octreesArray = []; }

	var frustumCull = this.intersectionFrustum(cullingVolume, boundingSphere_scratch);
	if (frustumCull === Constant.INTERSECTION_INSIDE ) 
	{
		this.getAllSubOctreesIfHasRefLists(result_octreesArray);
	}
	else if (frustumCull === Constant.INTERSECTION_INTERSECT  ) 
	{
		if (this.subOctrees_array.length === 0) 
		{
			result_octreesArray.push(this);
		}
		else 
		{
			for (var i=0, subOctreesArrayLength = this.subOctrees_array.length; i<subOctreesArrayLength; i++ ) 
			{
				this.subOctrees_array[i].getFrustumVisibleOctreesNeoBuildingAsimetricVersion(cullingVolume, result_octreesArray, boundingSphere_scratch);
			}
		}
	}
	
	return result_octreesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param cesium_cullingVolume 변수
 * @param result_octreesArray 변수
 * @param boundingSphere_scratch 변수
 */
Octree.prototype.getBBoxIntersectedOctreesNeoBuildingAsimetricVersion = function(bbox, result_octreesArray, bbox_scratch) 
{
	if (this.subOctrees_array === undefined) { return; }

	if (this.subOctrees_array.length === 0 && this.triPolyhedronsCount === 0)
	{ return; }

	if (result_octreesArray === undefined) { result_octreesArray = []; }
	
	if (bbox_scratch === undefined) 
	{ bbox_scratch = new BoundingBox(); } 
	

	bbox_scratch.minX = this.centerPos.x - this.half_dx;
	bbox_scratch.maxX = this.centerPos.x + this.half_dx;
	bbox_scratch.minY = this.centerPos.y - this.half_dy;
	bbox_scratch.maxY = this.centerPos.y + this.half_dy;
	bbox_scratch.minZ = this.centerPos.z - this.half_dz;
	bbox_scratch.maxZ = this.centerPos.z + this.half_dz;

	var intersects = bbox.intersectsWithBBox(bbox_scratch);
	if (intersects)
	{
		this.getAllSubOctreesIfHasRefLists(result_octreesArray);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param eye_x 변수
 * @param eye_y 변수
 * @param eye_z 변수
 */
Octree.prototype.setDistToCamera = function(cameraPosition) 
{
	// distance to camera as a sphere.
	var distToCamera = this.centerPos.distToPoint(cameraPosition) - this.getRadiusAprox();
	this.distToCamera = distToCamera;
	return distToCamera;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param octreesArray 변수
 * @param octree 변수
 * @returns result_idx
 */
Octree.prototype.getIndexToInsertBySquaredDistToEye = function(octreesArray, octree, startIdx, endIdx) 
{
	// this do a dicotomic search of idx in a ordered table.
	// 1rst, check the range.
	if (startIdx === undefined)
	{ startIdx = 0; }
	
	if (endIdx === undefined)
	{ endIdx = octreesArray.length-1; }
	
	var range = endIdx - startIdx;
	
	if (range <= 0)
	{ return 0; }
	
	if (range < 6)
	{
		// in this case do a lineal search.
		var finished = false;
		var i = startIdx;
		var idx;
		var octreesCount = octreesArray.length;
		while (!finished && i<=endIdx)
		{
			if (octree.distToCamera < octreesArray[i].distToCamera)
			{
				idx = i;
				finished = true;
			}
			i++;
		}
		
		if (finished)
		{
			return idx;
		}
		else 
		{
			return endIdx+1;
		}
	}
	else 
	{
		// in this case do the dicotomic search.
		var middleIdx = startIdx + Math.floor(range/2);
		var newStartIdx;
		var newEndIdx;
		if (octreesArray[middleIdx].distToCamera > octree.distToCamera)
		{
			newStartIdx = startIdx;
			newEndIdx = middleIdx;
		}
		else 
		{
			newStartIdx = middleIdx;
			newEndIdx = endIdx;
		}
		return this.getIndexToInsertBySquaredDistToEye(octreesArray, octree, newStartIdx, newEndIdx);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 * @param octree 변수
 */
Octree.prototype.putOctreeInEyeDistanceSortedArray = function(result_octreesArray, octree) 
{
	// sorting is from minDist to maxDist.
	if (result_octreesArray.length > 0)
	{
		var startIdx = 0;
		var endIdx = result_octreesArray.length - 1;
		var insert_idx= this.getIndexToInsertBySquaredDistToEye(result_octreesArray, octree, startIdx, endIdx);

		result_octreesArray.splice(insert_idx, 0, octree);
	}
	else 
	{
		result_octreesArray.push(octree);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.getAllSubOctreesIfHasRefLists = function(result_octreesArray) 
{
	if (this.subOctrees_array === undefined) { return; }

	if (result_octreesArray === undefined) { result_octreesArray = []; }

	if (this.subOctrees_array.length > 0) 
	{
		for (var i=0, subOctreesArrayLength = this.subOctrees_array.length; i<subOctreesArrayLength; i++) 
		{
			this.subOctrees_array[i].getAllSubOctreesIfHasRefLists(result_octreesArray);
		}
	}
	else 
	{
		if (this.triPolyhedronsCount > 0) { result_octreesArray.push(this); } // there are only 1.
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.getAllSubOctrees = function(result_octreesArray) 
{
	if (result_octreesArray === undefined) { result_octreesArray = []; }

	if (this.subOctrees_array.length > 0) 
	{
		for (var i=0, subOctreesArrayLength = this.subOctrees_array.length; i<subOctreesArrayLength; i++) 
		{
			this.subOctrees_array[i].getAllSubOctrees(result_octreesArray);
		}
	}
	else 
	{
		result_octreesArray.push(this); // there are only 1.
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.extractLowestOctreesIfHasTriPolyhedrons = function(lowestOctreesArray) 
{
	if (this.subOctrees_array === undefined)
	{ return; }
	
	var subOctreesCount = this.subOctrees_array.length;

	if (subOctreesCount === 0 && this.triPolyhedronsCount > 0) 
	{
		lowestOctreesArray.push(this);
	}
	else 
	{
		for (var i=0; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].extractLowestOctreesIfHasTriPolyhedrons(lowestOctreesArray);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.multiplyKeyTransformMatrix = function(idxKey, matrix) 
{
	var subOctreesCount = this.subOctrees_array.length;

	if (subOctreesCount === 0 && this.triPolyhedronsCount > 0) 
	{
		if (this.neoReferencesMotherAndIndices)
		{ this.neoReferencesMotherAndIndices.multiplyKeyTransformMatrix(idxKey, matrix); }
	}
	else 
	{
		for (var i=0; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].multiplyKeyTransformMatrix(idxKey, matrix);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.parseAsimetricVersion = function(arrayBuffer, readerWriter, bytesReaded, neoBuildingOwner) 
{
	// Check the metaData version.
	var version = neoBuildingOwner.getHeaderVersion();
	
	
	var octreeLevel = readerWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

	if (octreeLevel === 0) 
	{
		// this is the mother octree, so read the mother octree's size.
		var minX = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxX = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var minY = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxY = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var minZ = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxZ = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

		this.setBoxSize(minX, maxX, minY, maxY, minZ, maxZ );
		this.octree_number_name = 0;
	}

	var subOctreesCount = readerWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded += 1; // this must be 0 or 8.
	this.triPolyhedronsCount = readerWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
	if (this.triPolyhedronsCount > 0)
	{ this.neoBuildingOwner = neoBuildingOwner; }

	if (version === "0.0.2")
	{
		// Read ModelLists partitions count.
		this.blocksListsPartitionsCount = readerWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
	}

	// 1rst, create the 8 subOctrees.
	for (var i=0; i<subOctreesCount; i++) 
	{
		var subOctree = this.new_subOctree();
		subOctree.octree_number_name = this.octree_number_name * 10 + (i+1);
		subOctree.neoBuildingOwnerId = this.neoBuildingOwnerId;
		subOctree.octreeKey = this.neoBuildingOwnerId + "_" + subOctree.octree_number_name;
	}

	// now, set size of subOctrees.
	this.setSizesSubBoxes();

	for (var i=0; i<subOctreesCount; i++) 
	{
		var subOctree = this.subOctrees_array[i];
		bytesReaded = subOctree.parseAsimetricVersion(arrayBuffer, readerWriter, bytesReaded, neoBuildingOwner);
	}

	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.parsePyramidVersion = function(arrayBuffer, readerWriter, bytesReaded, neoBuildingOwner) 
{
	var octreeLevel = readerWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

	if (octreeLevel === 0) 
	{
		// this is the mother octree, so read the mother octree's size.
		var minX = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxX = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var minY = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxY = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var minZ = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxZ = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

		this.setBoxSize(minX, maxX, minY, maxY, minZ, maxZ );
		this.octree_number_name = 0;
	}

	var subOctreesCount = readerWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded += 1; // this must be 0 or 8.
	this.triPolyhedronsCount = readerWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
	if (this.triPolyhedronsCount > 0)
	{ this.neoBuildingOwner = neoBuildingOwner; }

	// Now, read verticesArray partitions count.
	this.pCloudPartitionsCount = readerWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

	// 1rst, create the 8 subOctrees.
	for (var i=0; i<subOctreesCount; i++) 
	{
		var subOctree = this.new_subOctree();
		subOctree.octree_number_name = this.octree_number_name * 10 + (i+1);
		subOctree.neoBuildingOwnerId = this.neoBuildingOwnerId;
		subOctree.octreeKey = this.neoBuildingOwnerId + "_" + subOctree.octree_number_name;
	}

	// now, set size of subOctrees.
	this.setSizesSubBoxes();

	for (var i=0; i<subOctreesCount; i++) 
	{
		var subOctree = this.subOctrees_array[i];
		bytesReaded = subOctree.parsePyramidVersion(arrayBuffer, readerWriter, bytesReaded, neoBuildingOwner);
	}

	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.getDistToCamera = function(cameraPosition, boundingSphere_Aux) 
{
	boundingSphere_Aux.setCenterPoint(this.centerPos.x, this.centerPos.y, this.centerPos.z);
	boundingSphere_Aux.setRadius(this.getRadiusAprox());
	return cameraPosition.distToSphere(boundingSphere_Aux);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.getMinDistToCameraInTree = function(cameraPosition, boundingSphere_Aux, octreesMaxSize) 
{
	// If this octree size > octreesMaxSize -> down in tree.
	var octreeSize = this.getRadiusAprox();
	var subOctreesCount = this.subOctrees_array.length;
	var dist;
	if (octreeSize > octreesMaxSize && subOctreesCount > 0)
	{
		// Calculate the nearest subOctree to camera.
		var currDist;
		var distCandidate;
		var subOctreeCandidate;
		for (var i=0; i<subOctreesCount; i++)
		{
			// Check if subOctree has content.
			var hasContent = false;
			var subOctree = this.subOctrees_array[i];
			if (subOctree.pCloudPartitionsCount && subOctree.pCloudPartitionsCount > 0)
			{ hasContent = true; }
			if (subOctree.triPolyhedronsCount && subOctree.triPolyhedronsCount > 0)
			{ hasContent = true; }
			
			if (!hasContent)
			{ continue; }
			
			//currDist = subOctree.getDistToCamera(cameraPosition, boundingSphere_Aux); // original.
			currDist = subOctree.centerPos.squareDistToPoint(cameraPosition); // test.
			if (distCandidate === undefined) 
			{
				distCandidate = currDist;
				subOctreeCandidate = subOctree;
			}
			else 
			{
				if (currDist < distCandidate)
				{
					distCandidate = currDist;
					subOctreeCandidate = subOctree;
				}
			}
		}
		
		if (subOctreeCandidate)
		{
			return subOctreeCandidate.getMinDistToCameraInTree(cameraPosition, boundingSphere_Aux, octreesMaxSize);
		}
	}
	else 
	{
		//dist = this.getDistToCamera(cameraPosition, boundingSphere_Aux); // original.
		dist = this.centerPos.distToPoint(cameraPosition); // test.
	}
	
	return dist;
};































'use strict';

/**
 * ParseQueue
 * 
 * @alias ParseQueue
 * @class ParseQueue
 */
var ParseQueue = function() 
{
	if (!(this instanceof ParseQueue)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.octreesLod0ReferencesToParseMap = {};
	this.octreesLod0ModelsToParseMap = {};
	this.octreesLod2LegosToParseMap = {};
	this.octreesPCloudToParseMap = {};
	this.octreesPCloudPartitionToParseMap = {}; 
	this.skinLegosToParseMap = {};
	this.tinTerrainsToParseMap = {};
	
	this.maxNumParses = 1; // default 1.***
	
	// Test for pCloudPartitions.***
	this.pCloudPartitionsParsed = 0;
};


ParseQueue.prototype.putTinTerrainToParse = function(tinTerrain, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.tinTerrainsToParseMap[tinTerrain.getPathName()] = tinTerrain;
};

ParseQueue.prototype.eraseTinTerrainToParse = function(tinTerrain)
{
	if (tinTerrain === undefined)
	{ return; }
	
	var key = tinTerrain.getPathName();
	if (this.tinTerrainsToParseMap.hasOwnProperty(key)) 
	{
		delete this.tinTerrainsToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.parseArraySkins = function(gl, nodesArray, magoManager)
{
	if (Object.keys(this.skinLegosToParseMap).length > 0)
	{
		var node;
		var skinLego;
		var neoBuilding;
		var skinsParsedCount = 0;
		var maxParsesCount = this.maxNumParses;
		var lod3buildingsCount = nodesArray.length;
		for (var i=0; i<lod3buildingsCount; i++)
		{
			node = nodesArray[i];
			neoBuilding = node.data.neoBuilding;
			
			if (neoBuilding === undefined || neoBuilding.lodMeshesMap === undefined)
			{ continue; }
		
		    // check the current lod of the building.***
			var currentBuildingLod = neoBuilding.currentLod;
			var lodIdx = currentBuildingLod;
			
			if (lodIdx < 0)
			{ continue; }// old.***
		
			var lodString = undefined;
			if (currentBuildingLod === 0)
			{ lodString = "lod0"; }
			else if (currentBuildingLod === 1)
			{ lodString = "lod1"; }
			else if (currentBuildingLod === 2)
			{ lodString = "lod2"; }
			else if (currentBuildingLod === 3)
			{ lodString = "lod3"; }
			else if (currentBuildingLod === 4)
			{ lodString = "lod4"; }
			else if (currentBuildingLod === 5)
			{ lodString = "lod5"; }

			if (lodString === undefined)
			{ continue; }
			
			///skinLego = neoBuilding.lodMeshesMap.get(lodString);
			skinLego = neoBuilding.lodMeshesMap[lodString];
			
			if (skinLego === undefined)
			{ continue; }
			
			if (this.eraseSkinLegosToParse(skinLego))
			{
				skinLego.parseArrayBuffer(gl, skinLego.dataArrayBuffer, magoManager);
				skinLego.dataArrayBuffer = undefined;
				
				skinsParsedCount++;
			}
			if (skinsParsedCount > maxParsesCount)
			{ break; }
		}
		/*
		if (skinsParsedCount === 0)
		{
			for (var key in this.skinLegosToParseMap)
			{
				var node = this.skinLegosToParseMap[key];
			
				if (node.data === undefined)
				{ continue; }
				
				neoBuilding = node.data.neoBuilding;
			
				if (neoBuilding === undefined)
				{ continue; }
			
				// check the current lod of the building.***
				var currentBuildingLod = neoBuilding.currentLod;
				var lodIdx = currentBuildingLod - 3;
				
				if (lodIdx < 0)
				{ continue; }
				
				skinLego = neoBuilding.lodMeshesArray[lodIdx];
				if (skinLego === undefined)
				{ continue; }
				if(this.eraseSkinLegosToParse(skinLego))
				{
					skinLego.parseArrayBuffer(gl, skinLego.dataArrayBuffer, magoManager);
					skinLego.dataArrayBuffer = undefined;
					
					skinsParsedCount++;
				}
				if (skinsParsedCount > maxParsesCount)
				{ break; }	
				
			}
		}
		*/
		
	}
};

ParseQueue.prototype.parseArrayOctreesPCloud = function(gl, octreesArray, magoManager)
{
	// Test function.***
	if (Object.keys(this.octreesPCloudToParseMap).length > 0)
	{
		var maxParsesCount = this.maxNumParses;
		var octreesParsedCount = 0;
		var lowestOctree;
		
		var octreesLod0Count = octreesArray.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = octreesArray[i];
			if (this.eraseOctreePCloudToParse(lowestOctree))
			{
				if (lowestOctree.lego === undefined)
				{ continue; }
				
				lowestOctree.lego.parsePointsCloudData(gl, lowestOctree.lego.dataArrayBuffer, magoManager);
				lowestOctree.lego.dataArrayBuffer = undefined;
				
				octreesParsedCount++;
			}
			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		
		if (octreesParsedCount === 0)
		{
			for (var key in this.octreesPCloudToParseMap)
			{
				if (Object.prototype.hasOwnProperty.call(this.octreesPCloudToParseMap, key))
				{
					lowestOctree = this.octreesPCloudToParseMap[key];
					if (this.eraseOctreePCloudToParse(lowestOctree))
					{
						if (lowestOctree.lego === undefined)
						{ continue; }
						
						lowestOctree.lego.parsePointsCloudData(lowestOctree.lego.dataArrayBuffer, gl, magoManager);
						lowestOctree.lego.dataArrayBuffer = undefined;
						
						octreesParsedCount++;
					}
					if (octreesParsedCount > maxParsesCount)
					{ break; }	
				}
				
			}
		}
		
		if (octreesParsedCount > 0)
		{
			if (this.selectionFbo)
			{ this.selectionFbo.dirty = true; }
		}
	}
};

ParseQueue.prototype.parseArrayOctreesPCloudPartition = function(gl, octreesArray, magoManager)
{
	// Test function.***
	if (Object.keys(this.octreesPCloudPartitionToParseMap).length > 0)
	{
		var maxParsesCount = this.maxNumParses;
		var octreesParsedCount = 0;
		var lowestOctree;
		
		var octreesLod0Count = octreesArray.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = octreesArray[i];
			
			// Check if has pCloudPartitions.***
			if (lowestOctree.pCloudPartitionsArray === undefined)
			{ continue; }
			
			var pCloudPartitionsCount = lowestOctree.pCloudPartitionsArray.length;
			for (var j=0; j<pCloudPartitionsCount; j++)
			{
				var pCloudPartition = lowestOctree.pCloudPartitionsArray[j];
				if (this.eraseOctreePCloudPartitionToParse(pCloudPartition))
				{
					pCloudPartition.parsePointsCloudData(gl, pCloudPartition.dataArrayBuffer, magoManager);
					octreesParsedCount++;
				}
			}
			
			//if (this.eraseOctreePCloudPartitionToParse(lowestOctree))
			//{
			//if (lowestOctree.lego === undefined)
			//{ continue; }
				
			//lowestOctree.lego.parsePointsCloudData(gl, lowestOctree.lego.dataArrayBuffer, magoManager);
			//lowestOctree.lego.dataArrayBuffer = undefined;
				
			//octreesParsedCount++;
			//}
			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		
		if (octreesParsedCount === 0)
		{
			for (var key in this.octreesPCloudPartitionToParseMap)
			{
				if (Object.prototype.hasOwnProperty.call(this.octreesPCloudPartitionToParseMap, key))
				{
					lowestOctree = this.octreesPCloudPartitionToParseMap[key];
					if (this.eraseOctreePCloudPartitionToParse(lowestOctree))
					{
						//if (lowestOctree.lego === undefined)
						//{ continue; }
						
						pCloudPartition.parsePointsCloudData(gl, pCloudPartition.dataArrayBuffer, magoManager);
						octreesParsedCount++;
						
						//octreesParsedCount++;
					}
					if (octreesParsedCount > maxParsesCount)
					{ break; }	
				}
			}
		}
		
		if (octreesParsedCount > 0)
		{
			if (this.selectionFbo)
			{ this.selectionFbo.dirty = true; }
		}
	}
};

ParseQueue.prototype.parseArrayOctreesLod2Legos = function(gl, octreesArray, magoManager)
{
	if (Object.keys(this.octreesLod2LegosToParseMap).length > 0)
	{
		var maxParsesCount = this.maxNumParses;
		var octreesParsedCount = 0;
		var lowestOctree;
	
		var octreesLod0Count = octreesArray.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = octreesArray[i];
			if (this.eraseOctreeLod2LegosToParse(lowestOctree))
			{
				if (lowestOctree.lego === undefined)
				{ continue; }
				
				lowestOctree.lego.parseArrayBuffer(gl, lowestOctree.lego.dataArrayBuffer, magoManager);
				lowestOctree.lego.dataArrayBuffer = undefined;
				
				octreesParsedCount++;
			}
			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		/*
		if (octreesParsedCount === 0)
		{
			for (var key in this.octreesLod2LegosToParseMap)
			{
				var lowestOctree = this.octreesLod2LegosToParseMap[key];
				if(this.eraseOctreeLod2LegosToParse(lowestOctree))
				{
					if (lowestOctree.lego === undefined)
					{ continue; }
					
					lowestOctree.lego.parseArrayBuffer(gl, lowestOctree.lego.dataArrayBuffer, magoManager);
					lowestOctree.lego.dataArrayBuffer = undefined;
					
					octreesParsedCount++;
				}
				if (octreesParsedCount > maxParsesCount)
				{ break; }	

			}
		}
		*/
		if (octreesParsedCount > 0)
		{
			if (magoManager.selectionFbo)
			{ magoManager.selectionFbo.dirty = true; }
		}
	}
};

ParseQueue.prototype.parseArrayOctreesLod0Models = function(gl, octreesArray, magoManager)
{
	if (Object.keys(this.octreesLod0ModelsToParseMap).length > 0)
	{
		var maxParsesCount = this.maxNumParses;
		var octreesParsedCount = 0;
		// 1rst parse the currently closest lowestOctrees to camera.
		var neoBuilding;
		var headerVersion;
		var lowestOctree;
		
		var octreesLod0Count = octreesArray.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = octreesArray[i];
			
			// Temp code.******************************************
			neoBuilding = lowestOctree.neoBuildingOwner;
			headerVersion = neoBuilding.getHeaderVersion();
			// End temp code.---------------------------------------
			
			if (this.eraseOctreeLod0ModelsToParse(lowestOctree))
			{
				if (lowestOctree.neoReferencesMotherAndIndices === undefined)
				{ continue; }
				
				var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList;
				if (blocksList === undefined)
				{ continue; }
				
				neoBuilding = lowestOctree.neoBuildingOwner;
				headerVersion = neoBuilding.getHeaderVersion();
				
				if (headerVersion[0] === "v")
				{
					if (blocksList.dataArraybuffer === undefined)
					{ continue; }
				
					if (blocksList.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
					{ continue; }
				
					// parse the beta version.***
					blocksList.parseBlocksList(blocksList.dataArraybuffer, magoManager.readerWriter, neoBuilding.motherBlocksArray, magoManager);
				}
				else if (headerVersion === "0.0.1")
				{
					if (blocksList.dataArraybuffer === undefined)
					{ continue; }
				
					if (blocksList.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
					{ continue; }
				
					// parse versioned.***
					blocksList.parseBlocksListVersioned_v001(blocksList.dataArraybuffer, magoManager.readerWriter, neoBuilding.motherBlocksArray, magoManager);
				}
				else if (headerVersion === "0.0.2")
				{
					// parse partitioned.***
					blocksList.parseBlocksListVersioned_v002(magoManager.readerWriter, neoBuilding.motherBlocksArray, magoManager);
				}
				blocksList.dataArraybuffer = undefined;
				octreesParsedCount++;
			}

			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		/*
		if (octreesParsedCount === 0)
		{
			for (var key in this.octreesLod0ModelsToParseMap)
			{
				var lowestOctree = this.octreesLod0ModelsToParseMap[key];
				if(this.eraseOctreeLod0ModelsToParse(lowestOctree))
				{
					if (lowestOctree.neoReferencesMotherAndIndices === undefined)
					{ continue; }
					
					var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList;
					if (blocksList === undefined)
					{ continue; }
					
					if (blocksList.dataArraybuffer === undefined)
					{ continue; }
				
					if (blocksList.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
					{ continue; }
					
					neoBuilding = lowestOctree.neoBuildingOwner;
					headerVersion = neoBuilding.getHeaderVersion();
				
					if (headerVersion[0] === "v")
					{
						// parse the beta version.
						blocksList.parseBlocksList(blocksList.dataArraybuffer, magoManager.readerWriter, neoBuilding.motherBlocksArray, magoManager);
					}
					else 
					{
						// parse versioned.
						blocksList.parseBlocksListVersioned(blocksList.dataArraybuffer, magoManager.readerWriter, neoBuilding.motherBlocksArray, magoManager);
					}
					blocksList.dataArraybuffer = undefined;
					octreesParsedCount++;
					if (octreesParsedCount > maxParsesCount)
					{ break; }	
				}
				
			}
		}
		*/
		
		
		if (octreesParsedCount > 0)
		{
			if (magoManager.selectionFbo)
			{ magoManager.selectionFbo.dirty = true; }
		}
	}
};

ParseQueue.prototype.parseArrayOctreesLod0References = function(gl, octreesArray, magoManager)
{
	if (Object.keys(this.octreesLod0ReferencesToParseMap).length > 0)
	{
		var maxParsesCount = this.maxNumParses;
		var octreesParsedCount = 0;
		var lowestOctree;
		
		// 1rst parse the currently closest lowestOctrees to camera.
		var octreesLod0Count = octreesArray.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = octreesArray[i];
			if (this.parseOctreesLod0References(gl, lowestOctree, magoManager))
			{
				octreesParsedCount++;
			}

			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		/*
		if (octreesParsedCount === 0)
		{
			for (var key in this.octreesLod0ReferencesToParseMap)
			{
				var lowestOctree = this.octreesLod0ReferencesToParseMap[key];
				if(this.parseOctreesLod0References(gl, lowestOctree, magoManager))
				{
					octreesParsedCount++;
					if (octreesParsedCount > maxParsesCount)
					{ break; }
				}
			}
		}
		*/

		if (octreesParsedCount > 0)
		{
			if (magoManager.selectionFbo)
			{ magoManager.selectionFbo.dirty = true; }
		}
	}
};

ParseQueue.prototype.parseOctreesLod0References = function(gl, lowestOctree, magoManager)
{
	var parsed = false;
	if (this.eraseOctreeLod0ReferencesToParse(lowestOctree))
	{
		if (lowestOctree.neoReferencesMotherAndIndices === undefined)
		{ return false; }
		
		if (lowestOctree.neoReferencesMotherAndIndices.dataArraybuffer === undefined)
		{ return false; }
	
		if (lowestOctree.neoReferencesMotherAndIndices.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
		{ return false; }
		
		var neoBuilding = lowestOctree.neoBuildingOwner;
				
		var node = neoBuilding.nodeOwner;
		var rootNode;
		if (node)
		{ rootNode = node.getRoot(); }
		else
		{ rootNode = undefined; }
		
		if (rootNode === undefined)
		{ return false; }
		
		if (rootNode.data === undefined)
		{ return false; }
		
		var geoLocDataManager = rootNode.data.geoLocDataManager;
		
		if (geoLocDataManager === undefined)
		{ return false; }
	
		if (this.matrix4SC === undefined)
		{ this.matrix4SC = new Matrix4(); }
		
		var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		var headerVersion = neoBuilding.getHeaderVersion();
		this.matrix4SC.setByFloat32Array(buildingGeoLocation.rotMatrix._floatArrays);
		if (headerVersion[0] === "v")
		{
			// parse beta version.
			lowestOctree.neoReferencesMotherAndIndices.parseArrayBufferReferences(gl, lowestOctree.neoReferencesMotherAndIndices.dataArraybuffer, 
				magoManager.readerWriter, neoBuilding, this.matrix4SC, magoManager);
		}
		else 
		{
			// parse vesioned.
			lowestOctree.neoReferencesMotherAndIndices.parseArrayBufferReferencesVersioned(gl, lowestOctree.neoReferencesMotherAndIndices.dataArraybuffer, 
				magoManager.readerWriter, neoBuilding, this.matrix4SC, magoManager);
		}
		lowestOctree.neoReferencesMotherAndIndices.multiplyKeyTransformMatrix(0, buildingGeoLocation.rotMatrix);
		lowestOctree.neoReferencesMotherAndIndices.dataArraybuffer = undefined;
		parsed = true;
	}
	
	return parsed;
};


ParseQueue.prototype.putOctreeLod0ReferencesToParse = function(octree, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.octreesLod0ReferencesToParseMap[octree.octreeKey] = octree;
};

ParseQueue.prototype.eraseOctreeLod0ReferencesToParse = function(octree)
{
	var key = octree.octreeKey;
	if (this.octreesLod0ReferencesToParseMap.hasOwnProperty(key))
	{
		delete this.octreesLod0ReferencesToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.putOctreeLod0ModelsToParse = function(octree, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.octreesLod0ModelsToParseMap[octree.octreeKey] = octree;
};

ParseQueue.prototype.eraseOctreeLod0ModelsToParse = function(octree)
{
	var key = octree.octreeKey;
	if (this.octreesLod0ModelsToParseMap.hasOwnProperty(key))
	{
		delete this.octreesLod0ModelsToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.putOctreeLod2LegosToParse = function(octree, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.octreesLod2LegosToParseMap[octree.octreeKey] = octree;
};

ParseQueue.prototype.eraseOctreeLod2LegosToParse = function(octree)
{
	var key = octree.octreeKey;
	if (this.octreesLod2LegosToParseMap.hasOwnProperty(key))
	{
		delete this.octreesLod2LegosToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.putOctreePCloudToParse = function(octree, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.octreesPCloudToParseMap[octree.octreeKey] = octree;
};

ParseQueue.prototype.eraseOctreePCloudToParse = function(octree)
{
	if (octree === undefined)
	{ return false; }
	
	var key = octree.octreeKey;
	if (this.octreesPCloudToParseMap.hasOwnProperty(key)) 
	{
		delete this.octreesPCloudToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.putOctreePCloudPartitionToParse = function(pCloudPartitionLego, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.octreesPCloudPartitionToParseMap[pCloudPartitionLego.legoKey] = pCloudPartitionLego;
};

ParseQueue.prototype.eraseOctreePCloudPartitionToParse = function(pCloudPartitionLego)
{
	if (pCloudPartitionLego === undefined)
	{ return false; }
	
	var key = pCloudPartitionLego.legoKey;
	if (this.octreesPCloudPartitionToParseMap.hasOwnProperty(key)) 
	{
		delete this.octreesPCloudPartitionToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.putSkinLegosToParse = function(skinLego, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.skinLegosToParseMap[skinLego.legoKey] = skinLego;
};

ParseQueue.prototype.eraseSkinLegosToParse = function(skinLego)
{
	var key = skinLego.legoKey;
	if (this.skinLegosToParseMap.hasOwnProperty(key))
	{
		delete this.skinLegosToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.clearAll = function()
{
	this.octreesLod0ReferencesToParseMap = {};
	this.octreesLod0ModelsToParseMap = {};
	this.octreesLod2LegosToParseMap = {};
};

ParseQueue.prototype.eraseAny = function(octree)
{
	this.eraseOctreeLod0ReferencesToParse(octree);
	this.eraseOctreeLod0ModelsToParse(octree);
	this.eraseOctreeLod2LegosToParse(octree);
};

ParseQueue.prototype.initCounters = function()
{
	this.pCloudPartitionsParsed = 0;
};




















'use strict';

/**
 * ProcessQueue
 * 
 * @alias ProcessQueue
 * @class ProcessQueue
 */
var ProcessQueue = function() 
{
	if (!(this instanceof ProcessQueue)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.nodesToDeleteMap = {};
	this.nodesToDeleteModelReferencesMap = {};
	this.nodesToDeleteLessThanLod3Map = {};
	this.nodesToDeleteLessThanLod4Map = {};
	this.nodesToDeleteLessThanLod5Map = {};
	this.nodesToDeleteLodMeshMap = {}; // no used.
	this.tinTerrainsToDeleteMap = {};
	
	// Test.
	this.octreeToDeletePCloudsMap = {};
};

ProcessQueue.prototype.putOctreeToDeletePCloud = function(octree, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (octree === undefined)
	{ return; }
	
	var key = octree.octreeKey;
	this.octreeToDeletePCloudsMap[key] = octree;
};

ProcessQueue.prototype.existOctreeToDeletePCloud = function(octree)
{
	if (octree === undefined)
	{ return false; }
	
	var key = octree.octreeKey;
	if (this.octreeToDeletePCloudsMap.hasOwnProperty(key)) 
	{
		return true;
	}
	return false;
};

ProcessQueue.prototype.eraseOctreeToDeletePCloud = function(octree)
{
	// this erases the octree from the "octreeToDeletePCloudsMap".
	if (octree === undefined)
	{ return false; }
	
	var key = octree.octreeKey;
	if (this.octreeToDeletePCloudsMap.hasOwnProperty(key)) 
	{
		delete this.octreeToDeletePCloudsMap[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putNodeToDeleteLodMesh = function(node, aValue)
{
	if (node.isReferenceNode())
	{ return; }
	
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteLodMeshMap[key] = node;
	
	//this.nodesToDeleteLodMeshMap.set(node, aValue);
};

ProcessQueue.prototype.eraseNodeToDeleteLodMesh = function(node)
{
	// this erases the node from the "nodesToDeleteLessThanLod3Map".
	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteLodMeshMap.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteLodMeshMap[key];
		return true;
	}
	return false;
	//return this.nodesToDeleteLodMeshMap.delete(node);
};

ProcessQueue.prototype.putTinTerrainToDelete = function(tinTerrain, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (tinTerrain === undefined)
	{ return; }
	
	var key = tinTerrain.pathName;
	this.tinTerrainsToDeleteMap[key] = tinTerrain;
};

ProcessQueue.prototype.eraseTinTerrainToDelete = function(tinTerrain)
{
	// this erases the tinTerrain from the "tinTerrainsToDeleteMap".
	if (tinTerrain === undefined)
	{ return false; }
	
	var key = tinTerrain.pathName;
	if (this.tinTerrainsToDeleteMap.hasOwnProperty(key)) 
	{
		delete this.tinTerrainsToDeleteMap[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putNodeToDeleteLessThanLod3 = function(node, aValue)
{
	if (node.isReferenceNode())
	{ return; }
	
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteLessThanLod3Map[key] = node;
};

ProcessQueue.prototype.eraseNodeToDeleteLessThanLod3 = function(node)
{
	// this erases the node from the "nodesToDeleteLessThanLod3Map".
	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteLessThanLod3Map.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteLessThanLod3Map[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putNodeToDeleteLessThanLod4 = function(node, aValue)
{
	if (node.isReferenceNode())
	{ return; }
	
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteLessThanLod4Map[key] = node;
};

ProcessQueue.prototype.eraseNodeToDeleteLessThanLod4 = function(node)
{
	// this erases the node from the "nodesToDeleteLessThanLod4Map".
	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteLessThanLod4Map.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteLessThanLod4Map[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putNodeToDeleteLessThanLod5 = function(node, aValue)
{
	if (node.isReferenceNode())
	{ return; }
	
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteLessThanLod5Map[key] = node;
};

ProcessQueue.prototype.eraseNodeToDeleteLessThanLod5 = function(node)
{
	// this erases the node from the "nodesToDeleteLessThanLod5Map".
	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteLessThanLod5Map.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteLessThanLod5Map[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putNodeToDeleteModelReferences = function(node, aValue)
{
	// In this case check if the node is reference node type.
	if (node.isReferenceNode())
	{ return; }
	
	// this puts the node to the "nodesToDeleteModelReferencesMap".
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteModelReferencesMap[key] = node;
	//this.nodesToDeleteModelReferencesMap.set(node, aValue);
};

ProcessQueue.prototype.eraseNodeToDeleteModelReferences = function(node)
{
	// this erases the node from the "nodesToDeleteModelReferencesMap".
	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteModelReferencesMap.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteModelReferencesMap[key];
		return true;
	}
	return false;
	//return this.nodesToDeleteModelReferencesMap.delete(node);
};

ProcessQueue.prototype.putNodeToDelete = function(node, aValue)
{
	if (node.isReferenceNode())
	{ return; }
	
	// this puts the node to the "nodesToDeleteMap".
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteMap[key] = node;
};

ProcessQueue.prototype.putNodesArrayToDelete = function(nodesToDeleteArray, aValue)
{
	if (nodesToDeleteArray === undefined)
	{ return; }
	
	// this puts the nodesToDeleteArray to the "nodesToDeleteArray".
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	var nodesToDeleteCount = nodesToDeleteArray.length;
	for (var i=0; i<nodesToDeleteCount; i++)
	{
		this.putNodeToDelete(nodesToDeleteArray[i], aValue);
	}
};

ProcessQueue.prototype.eraseNodeToDelete = function(node)
{
	// this erases the node from the "nodesToDeleteMap".
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteMap.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteMap[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.eraseNodesArrayToDelete = function(nodesToEraseArray)
{
	// this erases the node from the "nodesToDeleteMap".
	var key;
	var nodesCount = nodesToEraseArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		key = nodesToEraseArray[i].data.neoBuilding.buildingId;
		delete this.nodesToDeleteMap[key];
	}
};

ProcessQueue.prototype.clearAll = function()
{
	this.nodesToDeleteMap = {};
	this.nodesToDeleteModelReferencesMap = {};
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustumVolume 변수
 * @param neoVisibleBuildingsArray 변수
 * @param cameraPosition 변수
 * @returns neoVisibleBuildingsArray
 */
ProcessQueue.prototype.deleteNeoBuilding = function(gl, neoBuilding, magoManager) 
{
	// check if the neoBuilding id the selected building.
	var vboMemoryManager = magoManager.vboMemoryManager;
	if (neoBuilding === magoManager.buildingSelected)
	{
		magoManager.buildingSelected = undefined;
		magoManager.octreeSelected = undefined;
		magoManager.objectSelected = undefined;
	}
	
	neoBuilding.deleteObjects(gl, vboMemoryManager);
	
};

ProcessQueue.prototype.manageDeleteQueue = function(magoManager)
{
	var gl = magoManager.sceneState.gl;
	var maxDeleteNodesCount = 8;
	var nodesToDeleteCount = Object.keys(this.nodesToDeleteMap).length;
	if (nodesToDeleteCount < maxDeleteNodesCount)
	{ maxDeleteNodesCount = nodesToDeleteCount; }
	
	var neoBuilding;
	var node;
	var rootNode;
	
	// incompatibility gulp.
	//for (var key of this.buildingsToDeleteMap.keys())
	//{
	//	this.deleteNeoBuilding(gl, key);
	//	this.buildingsToDeleteMap.delete(key);
	//	deletedCount += 1;
	//	if (deletedCount > maxDeleteBuildingsCount)
	//	{ break; }
	//}
	

	for (var key in this.nodesToDeleteMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.nodesToDeleteMap, key))
		{
			//node = nodesToDeleteArray[i];
			node = this.nodesToDeleteMap[key];
			
			if (node === undefined)
			{ continue; }

			neoBuilding = node.data.neoBuilding;
			this.eraseNodeToDelete(node);
			
			if (neoBuilding === undefined)
			{ continue; }
		
			var deleteMetaData = true;
			if (key === 1)
			{ deleteMetaData = false; }
			this.deleteNeoBuilding(gl, neoBuilding, magoManager);
		}
	}
	
	// now delete modelReferences of lod2Octrees.
	var modelRefsDeletedCount = 0;
	for (var key in this.nodesToDeleteModelReferencesMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.nodesToDeleteModelReferencesMap, key))
		{
			//node = nodesToDeleteModelReferencesArray[i];
			node = this.nodesToDeleteModelReferencesMap[key];
			
			if (node.data === undefined)
			{ continue; }
		
			neoBuilding = node.data.neoBuilding;
			this.eraseNodeToDeleteModelReferences(neoBuilding);
			if (neoBuilding === undefined)
			{ continue; }

			if (neoBuilding.octree)
			{
				neoBuilding.octree.deleteObjectsModelReferences(gl, magoManager.vboMemoryManager);
				neoBuilding.octree.deletePCloudObjects(gl, magoManager.vboMemoryManager);
			}
			if (neoBuilding.motherBlocksArray.length > 0 || neoBuilding.motherNeoReferencesArray.length > 0)
			{
				modelRefsDeletedCount ++;
			}
			neoBuilding.deleteObjectsModelReferences(gl, magoManager.vboMemoryManager);
			
			if (modelRefsDeletedCount > 10)
			{ break; }
		}
	}
	
	
	var deletedCount = 0;
	for (var key in this.nodesToDeleteLessThanLod3Map)
	{
		if (Object.prototype.hasOwnProperty.call(this.nodesToDeleteLessThanLod3Map, key))
		{
			node = this.nodesToDeleteLessThanLod3Map[key];
			//node = nodesToDeleteLod2Lod4Lod5Array[i];
			if (node.data === undefined)
			{ continue; }
		
			if (this.eraseNodeToDeleteLessThanLod3(node))
			{
				neoBuilding = node.data.neoBuilding;
				if (neoBuilding === undefined)
				{ continue; }
				
				if (neoBuilding.octree)
				{
					neoBuilding.octree.deleteObjectsModelReferences(gl, magoManager.vboMemoryManager);
					neoBuilding.octree.deletePCloudObjects(gl, magoManager.vboMemoryManager);
				}
				if (neoBuilding.motherBlocksArray.length > 0 || neoBuilding.motherNeoReferencesArray.length > 0)
				{
					modelRefsDeletedCount ++;
				}
					
				neoBuilding.deleteObjectsModelReferences(gl, magoManager.vboMemoryManager);
				neoBuilding.deleteObjectsLod2(gl, magoManager.vboMemoryManager);
				deletedCount++;
				
				if (deletedCount > 10)
				{ break; }
			}
		}
	}
	
	deletedCount = 0;
	for (var key in this.nodesToDeleteLessThanLod4Map)
	{
		if (Object.prototype.hasOwnProperty.call(this.nodesToDeleteLessThanLod4Map, key))
		{
			node = this.nodesToDeleteLessThanLod4Map[key];
			if (node.data === undefined)
			{ continue; }
		
			if (this.eraseNodeToDeleteLessThanLod4(node))
			{
				neoBuilding = node.data.neoBuilding;
				if (neoBuilding === undefined)
				{ continue; }
			
				neoBuilding.deleteObjectsModelReferences(gl, magoManager.vboMemoryManager);
				neoBuilding.deleteObjectsLod2(gl, magoManager.vboMemoryManager);
				neoBuilding.deleteObjectsLodMesh(gl, magoManager.vboMemoryManager, "lod3");
				deletedCount++;
				
				if (deletedCount > 10)
				{ break; }
			}
		}
	}
	
	deletedCount = 0;
	for (var key in this.nodesToDeleteLessThanLod5Map)
	{
		if (Object.prototype.hasOwnProperty.call(this.nodesToDeleteLessThanLod5Map, key))
		{
			node = this.nodesToDeleteLessThanLod5Map[key];
			if (node.data === undefined)
			{ continue; }
		
			if (this.eraseNodeToDeleteLessThanLod5(node))
			{
				neoBuilding = node.data.neoBuilding;
				if (neoBuilding === undefined)
				{ continue; }
			
				neoBuilding.deleteObjectsModelReferences(gl, magoManager.vboMemoryManager);
				neoBuilding.deleteObjectsLod2(gl, magoManager.vboMemoryManager);
				neoBuilding.deleteObjectsLodMesh(gl, magoManager.vboMemoryManager, "lod3");
				neoBuilding.deleteObjectsLodMesh(gl, magoManager.vboMemoryManager, "lod4");
				deletedCount++;
				
				if (deletedCount > 10)
				{ break; }
			}
		}
	}
	
	
	// now, delete lod0, lod1, lod2.
	// now, delete tinTerrains.
	var deletedCount = 0;
	for (var key in this.tinTerrainsToDeleteMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.tinTerrainsToDeleteMap, key))
		{
			var tinTerrain = this.tinTerrainsToDeleteMap[key];
			if (tinTerrain === undefined)
			{ continue; }
			
			if (this.eraseTinTerrainToDelete(tinTerrain))
			{
				tinTerrain.deleteObjects(magoManager);
				tinTerrain = undefined;
				deletedCount++;
			}
			
			if (deletedCount > 10)
			{ break; }
		}
	}
	
	// PointsCloud.
	var deletedCount = 0;
	for (var key in this.octreeToDeletePCloudsMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.octreeToDeletePCloudsMap, key))
		{
			var octree = this.octreeToDeletePCloudsMap[key];
			if (octree === undefined)
			{ continue; }
			
			if (this.eraseOctreeToDeletePCloud(octree))
			{
				octree.deletePCloudObjects(gl, magoManager.vboMemoryManager);
				octree = undefined;
				deletedCount++;
			}
			
			if (deletedCount > 10000)
			{ break; }
		}
	}
};
'use strict';

/**
 * @class ProjectTree
 */
var ProjectTree = function() 
{
	if (!(this instanceof ProjectTree)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.root;
	
	this.nodesArray = [];
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class ReaderWriter
 */
var ReaderWriter = function() 
{
	if (!(this instanceof ReaderWriter)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	//this.geometryDataPath = "/F4D_GeometryData";
	var serverPolicy = MagoConfig.getPolicy();
	if (serverPolicy !== undefined)
	{ this.geometryDataPath = serverPolicy.geo_data_path; }
	
	this.geometrySubDataPath;

	this.j_counter;
	this.k_counter;
	this.referencesList_requested = 0;
	this.blocksList_requested = 0;
	this.blocksListPartitioned_requested = 0;
	this.octreesSkinLegos_requested = 0;
	this.skinLegos_requested = 0;
	this.pCloudPartitionsMother_requested = 0;
	this.pCloudPartitions_requested = 0;

	this.gl;
	this.incre_latAng = 0.001;
	this.incre_longAng = 0.001;
	this.GAIA3D__offset_latitude = -0.001;
	this.GAIA3D__offset_longitude = -0.001;
	this.GAIA3D__counter = 0;

	// Var for reading files.
	this.uint32;
	this.uint16;
	this.int16;
	this.float32;
	this.float16;
	this.int8;
	this.int8_value;
	this.max_color_value = 126;

	this.startBuff;
	this.endBuff;

	this.filesReadings_count = 0;

	// SCRATCH.*** 
	this.temp_var_to_waste;
	this.countSC;
	this.xSC;
	this.ySC;
	this.zSC;
	this.point3dSC = new Point3D();
	this.bboxSC = new BoundingBox();
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 */
ReaderWriter.prototype.getCurrentDataPath = function() 
{
	var currentDataPath;
	
	if (this.geometrySubDataPath !== undefined && this.geometrySubDataPath !== "")
	{
		currentDataPath = this.geometryDataPath + "/" + this.geometrySubDataPath;
	}
	else
		
	{
		currentDataPath = this.geometryDataPath;
	}
	
	return currentDataPath;
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns uint32[0]
 */
ReaderWriter.prototype.readUInt32 = function(buffer, start, end) 
{
	var uint32 = new Uint32Array(buffer.slice(start, end));
	return uint32[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns int32[0]
 */
ReaderWriter.prototype.readInt32 = function(buffer, start, end) 
{
	var int32 = new Int32Array(buffer.slice(start, end));
	return int32[0];
};

/**
 * 버퍼에서 데이터를 읽어서 16비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns uint16[0]
 */
ReaderWriter.prototype.readUInt16 = function(buffer, start, end) 
{
	var uint16 = new Uint16Array(buffer.slice(start, end));
	return uint16[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns int16[0]
 */
ReaderWriter.prototype.readInt16 = function(buffer, start, end) 
{
	var int16 = new Int16Array(buffer.slice(start, end));
	return int16[0];
};

/**
 * 버퍼에서 데이터를 읽어서 64비트 float값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns float64[0]
 */
ReaderWriter.prototype.readFloat64 = function(buffer, start, end) 
{
	var float64 = new Float64Array(buffer.slice(start, end));
	return float64[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 float값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns float32[0]
 */
ReaderWriter.prototype.readFloat32 = function(buffer, start, end) 
{
	var float32 = new Float32Array(buffer.slice(start, end));
	return float32[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns float16[0]
 */
ReaderWriter.prototype.readFloat16 = function(buffer, start, end) 
{
	var float16 = new Float32Array(buffer.slice(start, end));
	return float16[0];
};

/**
 * 버퍼에서 데이터를 읽어서 8비트 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns int8[0]
 */
ReaderWriter.prototype.readInt8 = function(buffer, start, end) 
{
	var int8 = new Int8Array(buffer.slice(start, end));
	return int8[0];
};

/**
 * 버퍼에서 데이터를 읽어서 8비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns uint8[0]
 */
ReaderWriter.prototype.readUInt8 = function(buffer, start, end) 
{
	var uint8 = new Uint8Array(buffer.slice(start, end));
	return uint8[0];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param buffer 변수
 * @param start 변수
 * @param end 변수
 * @returns int8_value
 */
ReaderWriter.prototype.readInt8ByteColor = function(buffer, start, end) 
{
	var int8 = new Int8Array(buffer.slice(start, end));
	var int8_value = int8[0];

	if (int8_value > max_color_value) { int8_value = max_color_value; }

	if (int8_value < 0) { int8_value += 256; }

	return int8_value;
};

function loadWithXhr(fileName, xhr, timeOut) 
{
	// 1) 사용될 jQuery Deferred 객체를 생성한다.
	var deferred = $.Deferred();
	
	if (xhr === undefined)
	{ xhr = new XMLHttpRequest(); }
	
	xhr.open("GET", fileName, true);
	xhr.responseType = "arraybuffer";
	if (timeOut !== undefined)
	{ xhr.timeout = timeOut; } // time in milliseconds
	  
	// 이벤트 핸들러를 등록한다.
	xhr.onload = function() 
	{
		if (xhr.status < 200 || xhr.status >= 300) 
		{
			deferred.reject(xhr.status);
			return;
		}
		else 
		{
			// 3.1) DEFERRED를 해결한다. (모든 done()...을 동작시킬 것이다.)
			deferred.resolve(xhr.response);
		} 
	};
	
	xhr.ontimeout = function (e) 
	{
		// XMLHttpRequest timed out.***
		deferred.reject(-1);
	};
	
	xhr.onerror = function(e) 
	{
		console.log("Invalid XMLHttpRequest response type.");
		deferred.reject(xhr.status);
	};

	// 작업을 수행한다.
	xhr.send(null);
	
	// 참고: jQuery.ajax를 사용할 수 있었고 해야할 수 있었다.
	// 참고: jQuery.ajax는 Promise를 반환하지만 다른 Deferred/Promise를 사용하여 애플리케이션에 의미있는 구문으로 감싸는 것은 언제나 좋은 생각이다.
	// ---- /AJAX 호출 ---- //
	  
	// 2) 이 deferred의 promise를 반환한다.
	return deferred.promise();
};

ReaderWriter.prototype.getNeoBlocksArraybuffer = function(fileName, lowestOctree, magoManager) 
{
	magoManager.fileRequestControler.modelRefFilesRequestedCount += 1;
	var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList;
	blocksList.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	var xhr;
	//xhr = new XMLHttpRequest();
	blocksList.xhr = xhr; // possibility to cancel.***
	
	this.blocksList_requested++;
	
	loadWithXhr(fileName, xhr).done(function(response) 
	{	
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			blocksList.dataArraybuffer = arrayBuffer;
			blocksList.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			arrayBuffer = null;
			
			
			magoManager.parseQueue.putOctreeLod0ModelsToParse(lowestOctree);
		}
		else 
		{
			blocksList.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("Invalid XMLHttpRequest status = " + status);
		if (status === 0) { blocksList.fileLoadState = 500; }
		else if (status === -1) { blocksList.fileLoadState = CODE.fileLoadState.READY; }
		else { blocksList.fileLoadState = status; }
	}).always(function() 
	{
		magoManager.readerWriter.blocksList_requested--;
		magoManager.fileRequestControler.modelRefFilesRequestedCount -= 1;
		if (magoManager.fileRequestControler.modelRefFilesRequestedCount < 0) { magoManager.fileRequestControler.modelRefFilesRequestedCount = 0; }
	});
};

ReaderWriter.prototype.getNeoBlocksArraybuffer_partition = function(fileName, lowestOctree, blocksArrayPartition, magoManager) 
{
	magoManager.fileRequestControler.modelRefFilesRequestedCount += 1;
	blocksArrayPartition.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	var xhr;
	
	this.blocksListPartitioned_requested++;
	
	loadWithXhr(fileName, xhr).done(function(response) 
	{	
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			blocksArrayPartition.dataArraybuffer = arrayBuffer;
			blocksArrayPartition.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			arrayBuffer = null;
			
			
			magoManager.parseQueue.putOctreeLod0ModelsToParse(lowestOctree);
		}
		else 
		{
			blocksArrayPartition.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("Invalid XMLHttpRequest status = " + status);
		if (status === 0) { blocksArrayPartition.fileLoadState = 500; }
		else if (status === -1) { blocksArrayPartition.fileLoadState = CODE.fileLoadState.READY; }
		else { blocksArrayPartition.fileLoadState = status; }
	}).always(function() 
	{
		magoManager.readerWriter.blocksListPartitioned_requested--;
		//magoManager.fileRequestControler.modelRefFilesRequestedCount -= 1;
		if (magoManager.fileRequestControler.blocksListPartitioned_requested < 0) { magoManager.fileRequestControler.blocksListPartitioned_requested = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getNeoReferencesArraybuffer = function(fileName, lowestOctree, magoManager) 
{
	if (lowestOctree.neoReferencesMotherAndIndices === undefined)
	{ return; }
	
	magoManager.fileRequestControler.modelRefFilesRequestedCount += 1;
	lowestOctree.neoReferencesMotherAndIndices.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	var xhr;
	//xhr = new XMLHttpRequest();
	lowestOctree.neoReferencesMotherAndIndices.xhr = xhr;
	
	this.referencesList_requested++;
	loadWithXhr(fileName, xhr).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			var neoRefsList = lowestOctree.neoReferencesMotherAndIndices;
			if (neoRefsList)
			{
				neoRefsList.dataArraybuffer = arrayBuffer;
				neoRefsList.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				magoManager.parseQueue.putOctreeLod0ReferencesToParse(lowestOctree);
			}
			arrayBuffer = null;
			
		}
		else 
		{
			lowestOctree.neoReferencesMotherAndIndices.fileLoadState = CODE.fileLoadState.LOAD_FAILED;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) 
		{ lowestOctree.neoReferencesMotherAndIndices.fileLoadState = CODE.fileLoadState.LOAD_FAILED; }
		else if (status === -1) 
		{ lowestOctree.neoReferencesMotherAndIndices.fileLoadState = CODE.fileLoadState.READY; }
		else 
		{ lowestOctree.neoReferencesMotherAndIndices.fileLoadState = status; }
	}).always(function() 
	{
		magoManager.readerWriter.referencesList_requested--;
		magoManager.fileRequestControler.modelRefFilesRequestedCount -= 1;
		if (magoManager.fileRequestControler.modelRefFilesRequestedCount < 0) { magoManager.fileRequestControler.modelRefFilesRequestedCount = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getOctreeLegoArraybuffer = function(fileName, lowestOctree, magoManager) 
{
	if (lowestOctree.lego === undefined)
	{ return; }
	this.octreesSkinLegos_requested ++;
	magoManager.fileRequestControler.filesRequestedCount += 1;
	lowestOctree.lego.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	var xhr = new XMLHttpRequest();
	lowestOctree.lego.xhr = xhr;
	
	loadWithXhr(fileName, xhr).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (lowestOctree.lego)
			{
				lowestOctree.lego.dataArrayBuffer = arrayBuffer;
				lowestOctree.lego.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				magoManager.parseQueue.putOctreeLod2LegosToParse(lowestOctree);
			}
			else 
			{
				lowestOctree = undefined;
			}
			arrayBuffer = null;
		}
		else 
		{
			lowestOctree.lego.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { lowestOctree.lego.fileLoadState = 500; }
		else { lowestOctree.lego.fileLoadState = status; }
	}).always(function() 
	{
		magoManager.readerWriter.octreesSkinLegos_requested --;
		magoManager.fileRequestControler.filesRequestedCount -= 1;
		if (magoManager.fileRequestControler.filesRequestedCount < 0) { magoManager.fileRequestControler.filesRequestedCount = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getOctreePCloudArraybuffer = function(fileName, lowestOctree, magoManager) 
{
	if (lowestOctree.lego === undefined)
	{ return; }
	
	magoManager.fileRequestControler.filesRequestedCount += 1;
	lowestOctree.lego.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (lowestOctree.lego)
			{
				lowestOctree.lego.dataArrayBuffer = arrayBuffer;
				lowestOctree.lego.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				magoManager.parseQueue.putOctreePCloudToParse(lowestOctree);
			}
			else 
			{
				lowestOctree = undefined;
			}
			arrayBuffer = null;
		}
		else 
		{
			lowestOctree.lego.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { lowestOctree.lego.fileLoadState = 500; }
		else { lowestOctree.lego.fileLoadState = status; }
	}).always(function() 
	{
		magoManager.fileRequestControler.filesRequestedCount -= 1;
		if (magoManager.fileRequestControler.filesRequestedCount < 0) { magoManager.fileRequestControler.filesRequestedCount = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getOctreePCloudPartitionArraybuffer = function(fileName, lowestOctree, pCloudPartitionLego, magoManager) 
{
	pCloudPartitionLego.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	var octreeDepth = lowestOctree.octree_level;
	if (octreeDepth === 0)
	{ magoManager.readerWriter.pCloudPartitionsMother_requested++; }
	else
	{ magoManager.readerWriter.pCloudPartitions_requested ++; }
	
	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (lowestOctree && pCloudPartitionLego)
			{
				pCloudPartitionLego.dataArrayBuffer = arrayBuffer;
				pCloudPartitionLego.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				//magoManager.parseQueue.putOctreePCloudPartitionToParse(pCloudPartitionLego); // NO. Old. Now parse directly.***
			}
			arrayBuffer = null;
		}
		else 
		{
			pCloudPartitionLego.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { pCloudPartitionLego.fileLoadState = 500; }
		else { pCloudPartitionLego.fileLoadState = status; }
	}).always(function() 
	{
		if (octreeDepth === 0)
		{
			magoManager.readerWriter.pCloudPartitionsMother_requested --;
			if (magoManager.readerWriter.pCloudPartitionsMother_requested < 0)
			{ magoManager.readerWriter.pCloudPartitionsMother_requested = 0; }
		}
		else
		{
			
			magoManager.readerWriter.pCloudPartitions_requested--;
			if (magoManager.readerWriter.pCloudPartitions_requested < 0)
			{ magoManager.readerWriter.pCloudPartitions_requested = 0; }
		}
	
		//magoManager.readerWriter.pCloudPartitions_requested--;
		//if (magoManager.readerWriter.pCloudPartitions_requested < 0)
		//{ magoManager.readerWriter.pCloudPartitions_requested = 0; }
	});
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getLegoArraybuffer = function(fileName, legoMesh, magoManager) 
{
	this.skinLegos_requested++;
	//magoManager.fileRequestControler.filesRequestedCount += 1;
	magoManager.fileRequestControler.lowLodDataRequestedCount += 1;
	legoMesh.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	var xhr;
	//xhr = new XMLHttpRequest();
	legoMesh.xhr = xhr;
	
	loadWithXhr(fileName, xhr).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (legoMesh)
			{
				legoMesh.dataArrayBuffer = arrayBuffer;
				legoMesh.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				magoManager.parseQueue.putSkinLegosToParse(legoMesh);
			}
			arrayBuffer = null;
		}
		else 
		{
			legoMesh.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { legoMesh.fileLoadState = 500; }
		//else { legoMesh.fileLoadState = status; }
		else 
		{ 
			legoMesh.fileLoadState = -1; 
		}
	}).always(function() 
	{
		magoManager.readerWriter.skinLegos_requested--;
		//magoManager.fileRequestControler.filesRequestedCount -= 1;
		magoManager.fileRequestControler.lowLodDataRequestedCount -= 1;
		//if (magoManager.fileRequestControler.filesRequestedCount < 0) { magoManager.fileRequestControler.filesRequestedCount = 0; }
		if (magoManager.fileRequestControler.lowLodDataRequestedCount < 0) { magoManager.fileRequestControler.lowLodDataRequestedCount = 0; }
	});
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param gl gl context
 * @param fileName 파일명
 * @param readerWriter 파일 처리를 담당
 * @param neoBuildingsList object index 파일을 파싱한 정보를 저장할 배열
 */
ReaderWriter.prototype.getObjectIndexFileForSmartTile = function(fileName, magoManager, buildingSeedList, projectId) 
{
	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			buildingSeedList.dataArrayBuffer = arrayBuffer;
			buildingSeedList.parseBuildingSeedArrayBuffer();
			
			magoManager.makeSmartTile(buildingSeedList, projectId);
			arrayBuffer = null;
			//MagoConfig.setObjectIndex("append", );
		}
		else 
		{
			// blocksList.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		//		if(status === 0) blocksList.fileLoadState = 500;
		//		else blocksList.fileLoadState = status;
	}).always(function() 
	{
		//		magoManager.fileRequestControler.filesRequestedCount -= 1;
		//		if(magoManager.fileRequestControler.filesRequestedCount < 0) magoManager.fileRequestControler.filesRequestedCount = 0;
	});
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param gl gl context
 * @param fileName 파일명
 * @param readerWriter 파일 처리를 담당
 * @param neoBuildingsList object index 파일을 파싱한 정보를 저장할 배열
 */
ReaderWriter.prototype.getObjectIndexFile = function(fileName, readerWriter, neoBuildingsList, magoManager) 
{
	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			readerWriter.parseObjectIndexFile(arrayBuffer, neoBuildingsList);
			arrayBuffer = null;
			magoManager.createDeploymentGeoLocationsForHeavyIndustries();
		}
		else 
		{
			//			blocksList.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		//		if(status === 0) blocksList.fileLoadState = 500;
		//		else blocksList.fileLoadState = status;
	}).always(function() 
	{
		//		magoManager.fileRequestControler.filesRequestedCount -= 1;
		//		if(magoManager.fileRequestControler.filesRequestedCount < 0) magoManager.fileRequestControler.filesRequestedCount = 0;
	});
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param arrayBuffer object index file binary data
 * @param neoBuildingsList object index 파일을 파싱한 정보를 저장할 배열
 */
ReaderWriter.prototype.parseObjectIndexFile = function(arrayBuffer, neoBuildingsList) 
{
	var bytesReaded = 0;
	var buildingNameLength;
	var longitude;
	var latitude;
	var altitude;

	var buildingsCount = this.readInt32(arrayBuffer, bytesReaded, bytesReaded+4);
	bytesReaded += 4;
	for (var i =0; i<buildingsCount; i++) 
	{
		// read the building location data.***
		var neoBuilding = neoBuildingsList.newNeoBuilding();
		if (neoBuilding.metaData === undefined) 
		{
			neoBuilding.metaData = new MetaData();
		}

		if (neoBuilding.metaData.geographicCoord === undefined)
		{ neoBuilding.metaData.geographicCoord = new GeographicCoord(); }

		if (neoBuilding.metaData.bbox === undefined) 
		{
			neoBuilding.metaData.bbox = new BoundingBox();
		}

		buildingNameLength = this.readInt32(arrayBuffer, bytesReaded, bytesReaded+4);
		bytesReaded += 4;
		var buildingName = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ buildingNameLength)));
		bytesReaded += buildingNameLength;

		longitude = this.readFloat64(arrayBuffer, bytesReaded, bytesReaded+8); bytesReaded += 8;
		latitude = this.readFloat64(arrayBuffer, bytesReaded, bytesReaded+8); bytesReaded += 8;
		altitude = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

		neoBuilding.bbox = new BoundingBox();
		neoBuilding.bbox.minX = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.minY = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.minZ = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.maxX = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.maxY = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.maxZ = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

		// create a building and set the location.***
		neoBuilding.buildingId = buildingName.substr(4, buildingNameLength-4);
		neoBuilding.buildingType = "basicBuilding";
		neoBuilding.buildingFileName = buildingName;
		neoBuilding.metaData.geographicCoord.setLonLatAlt(longitude, latitude, altitude);
	}

	neoBuildingsList.neoBuildingsArray.reverse();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 변수
 * @param neoBuilding 변수
 * @param readerWriter 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.getNeoHeaderAsimetricVersion = function(gl, fileName, neoBuilding, readerWriter, magoManager) 
{
	function Utf8ArrayToStr(array) 
	{
		var out, i, len, c;
		var char2, char3;

		out = "";
		len = array.length;
		i = 0;
		while (i < len) 
		{
			c = array[i++];
			switch (c >> 4)
			{ 
			case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
				// 0xxxxxxx
				out += String.fromCharCode(c);
				break;
			case 12: case 13:
				// 110x xxxx   10xx xxxx
				char2 = array[i++];
				out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
				break;
			case 14:
				// 1110 xxxx  10xx xxxx  10xx xxxx
				char2 = array[i++];
				char3 = array[i++];
				out += String.fromCharCode(((c & 0x0F) << 12) |
                       ((char2 & 0x3F) << 6) |
                       ((char3 & 0x3F) << 0));
				break;
			}
		}

		return out;
	};

	//BR_Project._f4d_header_readed = true;
	magoManager.fileRequestControler.headerFilesRequestedCount += 1;
	neoBuilding.metaData.fileLoadState = CODE.fileLoadState.LOADING_STARTED;

	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (neoBuilding.metaData === undefined) 
			{
				neoBuilding.metaData = new MetaData();
			}
			
			var metaData = neoBuilding.metaData;
			var bytesReaded = metaData.parseFileHeaderAsimetricVersion(arrayBuffer, readerWriter);
			
			// Now, make the neoBuilding's octree.***
			if (neoBuilding.octree === undefined) { neoBuilding.octree = new Octree(undefined); }
			neoBuilding.octree.neoBuildingOwnerId = neoBuilding.buildingId;
			neoBuilding.octree.octreeKey = neoBuilding.buildingId + "_" + neoBuilding.octree.octree_number_name;
			
			// now, parse octreeAsimetric or octreePyramid (check metadata.projectDataType).***
			if (metaData.projectDataType === 5)
			{ bytesReaded = neoBuilding.octree.parsePyramidVersion(arrayBuffer, readerWriter, bytesReaded, neoBuilding); }
			else
			{ bytesReaded = neoBuilding.octree.parseAsimetricVersion(arrayBuffer, readerWriter, bytesReaded, neoBuilding); }

			metaData.oct_min_x = neoBuilding.octree.centerPos.x - neoBuilding.octree.half_dx;
			metaData.oct_max_x = neoBuilding.octree.centerPos.x + neoBuilding.octree.half_dx;
			metaData.oct_min_y = neoBuilding.octree.centerPos.y - neoBuilding.octree.half_dy;
			metaData.oct_max_y = neoBuilding.octree.centerPos.y + neoBuilding.octree.half_dy;
			metaData.oct_min_z = neoBuilding.octree.centerPos.z - neoBuilding.octree.half_dz;
			metaData.oct_max_z = neoBuilding.octree.centerPos.z + neoBuilding.octree.half_dz;
			
			// now parse materialsList of the neoBuilding.
			//var ver0 = neoBuilding.metaData.version[0];
			//var ver1 = neoBuilding.metaData.version[2];
			//var ver2 = neoBuilding.metaData.version[4];
			
			if (metaData.version === "0.0.1" || metaData.version === "0.0.2")
			{
				// read materials list.
				var materialsCount = readerWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
				for (var i=0; i<materialsCount; i++)
				{
					var textureTypeName = "";
					var textureImageFileName = "";

					// Now, read the texture_type and texture_file_name.***
					var texture_type_nameLegth = readerWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
					for (var j=0; j<texture_type_nameLegth; j++) 
					{
						textureTypeName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1))[0]);bytesReaded += 1; // for example "diffuse".***
					}

					var texture_fileName_Legth = readerWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
					var charArray = new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ texture_fileName_Legth)); bytesReaded += texture_fileName_Legth;
					var decoder = new TextDecoder('utf-8');
					textureImageFileName = decoder.decode(charArray);
					
					if (texture_fileName_Legth > 0)
					{
						var texture = new Texture();
						texture.textureTypeName = textureTypeName;
						texture.textureImageFileName = textureImageFileName;
						
						if (neoBuilding.texturesLoaded === undefined)
						{ neoBuilding.texturesLoaded = []; }
						
						neoBuilding.texturesLoaded.push(texture);
					}
				}
				
				// read geometry type data.***
				var lod;
				var nameLength;
				var lodBuildingDatasCount = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
				if (lodBuildingDatasCount !== undefined)
				{
					neoBuilding.lodBuildingDatasMap = {};
					
					for (var i =0; i<lodBuildingDatasCount; i++)
					{
						var lodBuildingData = new LodBuildingData();
						lodBuildingData.lod = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
						lodBuildingData.isModelRef = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
						
						if (lodBuildingData.lod === 2)
						{
							// read the lod2_textureFileName.***
							nameLength = (new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
							lodBuildingData.textureFileName = "";
							for (var j=0; j<nameLength; j++) 
							{
								lodBuildingData.textureFileName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1))[0]);bytesReaded += 1; 
							}
						}
						
						if (!lodBuildingData.isModelRef)
						{
							nameLength = (new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
							lodBuildingData.geometryFileName = "";
							for (var j=0; j<nameLength; j++) 
							{
								lodBuildingData.geometryFileName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1))[0]);bytesReaded += 1; 
							}
							
							nameLength = (new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
							lodBuildingData.textureFileName = "";
							for (var j=0; j<nameLength; j++) 
							{
								lodBuildingData.textureFileName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1))[0]);bytesReaded += 1; 
							}
						}
						neoBuilding.lodBuildingDatasMap[lodBuildingData.lod] = lodBuildingData;
					}

				}
			}

			metaData.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;

			//BR_Project._f4d_header_readed_finished = true;
			arrayBuffer = undefined;
		}
		else 
		{
			neoBuilding.metaData.fileLoadState = 500;
			arrayBuffer = undefined;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { neoBuilding.metaData.fileLoadState = 500; }
		else { neoBuilding.metaData.fileLoadState = status; }
	}).always(function() 
	{
		magoManager.fileRequestControler.headerFilesRequestedCount -= 1;
		if (magoManager.fileRequestControler.headerFilesRequestedCount < 0) { magoManager.fileRequestControler.headerFilesRequestedCount = 0; }
	});
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param f4dTex 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.readTexture = function(gl, filePath_inServer, f4dTex, magoManager) 
{
	f4dTex.loadStarted = true;
	//f4dTex.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	f4dTex.texImage = new Image();
	f4dTex.texImage.onload = function() 
	{
		f4dTex.loadFinished = true;
		//f4dTex.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;

		if (magoManager.backGround_fileReadings_count > 0 ) { magoManager.backGround_fileReadings_count -=1; }
	};

	f4dTex.texImage.onerror = function() 
	{
		// doesn't exist or error loading
		f4dTex.loadStarted = false;
		if (magoManager.backGround_fileReadings_count > 0 ) { magoManager.backGround_fileReadings_count -=1; }
		return;
	};

	f4dTex.texImage.src = filePath_inServer;
};

ReaderWriter.prototype.decodeTGA = function(arrayBuffer) 
{
	// code from toji.***
	var content = new Uint8Array(arrayBuffer),
		contentOffset = 18 + content[0],
		imagetype = content[2], // 2 = rgb, only supported format for now
		width = content[12] + (content[13] << 8),
		height = content[14] + (content[15] << 8),
		bpp = content[16], // should be 8,16,24,32
		
		bytesPerPixel = bpp / 8,
		bytesPerRow = width * 4,
		data, i, j, x, y;

	if (!width || !height) 
	{
		console.error("Invalid dimensions");
		return null;
	}

	if (imagetype !== 2) 
	{
		console.error("Unsupported TGA format:", imagetype);
		return null;
	}

	data = new Uint8Array(width * height * 4);
	i = contentOffset;

	// Oy, with the flipping of the rows...
	for (y = height-1; y >= 0; --y) 
	{
		for (x = 0; x < width; ++x, i += bytesPerPixel) 
		{
			j = (x * 4) + (y * bytesPerRow);
			data[j] = content[i+2];
			data[j+1] = content[i+1];
			data[j+2] = content[i+0];
			data[j+3] = (bpp === 32 ? content[i+3] : 255);
		}
	}

	return {
		width  : width,
		height : height,
		data   : data
	};
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param texture 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.readNeoReferenceTexture = function(gl, filePath_inServer, texture, neoBuilding, magoManager) 
{
	// Must know the fileExtension.***
	var extension = filePath_inServer.split('.').pop();
	
	if (extension === "tga" || extension === "TGA" || extension === "Tga")
	{
		texture.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
		loadWithXhr(filePath_inServer).done(function(response) 
		{
			var arrayBuffer = response;
			if (arrayBuffer) 
			{
				// decode tga.***
				// Test with tga decoder from https://github.com/schmittl/tgajs
				var tga = new TGA();
				tga.load(arrayBuffer);
				// End decoding.---------------------------------------------------
				
				//var tga = magoManager.readerWriter.decodeTGA(arrayBuffer); // old code.
				//if(tga) {
				//    gl.bindTexture(gl.TEXTURE_2D, texture.texId);
				//     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, tga.width, tga.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, tga.data);
				//    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				//	gl.generateMipmap(gl.TEXTURE_2D);
				//	texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED; // file load finished.***
				//}
				
				// example values of tga.header
				// alphaBits 0
				// bytePerPixel 3
				// colorMapDepth 0
				// colorMapIndex 0
				// colorMapLength 0
				// colorMapType 0
				// flags 32
				// hasColorMap false
				// hasEncoding false
				// height 2048
				// idLength 0
				// imageType 2
				// isGreyColor false
				// offsetX 0
				// offsetY 0
				// origin 2
				// pixelDepth 24
				// width 2048
				
				if (tga) 
				{
					var rgbType;
					if (tga.header.bytePerPixel === 3)
					{
						rgbType = gl.RGB;
						
						// test change rgb to bgr.***
						/*
						var imageDataLength = tga.imageData.length;
						var pixelsCount = imageDataLength/3;
						var r, g, b;
						for(var i=0; i<pixelsCount; i++)
						{
							r = tga.imageData[i*3];
							g = tga.imageData[i*3+1];
							b = tga.imageData[i*3+2];
							
							tga.imageData[i*3] = b;
							tga.imageData[i*3+1] = g;
							tga.imageData[i*3+2] = r;
						}
						*/
					}
					else if (tga.header.bytePerPixel === 4)
					{
						rgbType = gl.RGBA;
						
						// test change rgb to bgr.***
						
						var imageDataLength = tga.imageData.length;
						var pixelsCount = imageDataLength/4;
						var r, g, b, a;
						for (var i=0; i<pixelsCount; i++)
						{
							r = tga.imageData[i*4];
							g = tga.imageData[i*4+1];
							b = tga.imageData[i*4+2];
							a = tga.imageData[i*4+3];
							
							tga.imageData[i*4] = b;
							tga.imageData[i*4+1] = g;
							tga.imageData[i*4+2] = r;
							tga.imageData[i*4+3] = a;
						}
						
					}
					
					
					if (tga.imageData !== undefined && tga.imageData.length > 0 && texture.texId !== undefined)
					{
						gl.bindTexture(gl.TEXTURE_2D, texture.texId);
						gl.texImage2D(gl.TEXTURE_2D, 0, rgbType, tga.header.width, tga.header.height, 0, rgbType, gl.UNSIGNED_BYTE, tga.imageData);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
						gl.generateMipmap(gl.TEXTURE_2D);
						texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED; // file load finished.***
						gl.bindTexture(gl.TEXTURE_2D, null);
					}
				}
			}
		}).fail(function(status) 
		{
			if (neoBuilding)
			{
				console.log("xhr status = " + status);
				if (status === 0) { neoBuilding.metaData.fileLoadState = 500; }
				else { neoBuilding.metaData.fileLoadState = status; }
			}
		}).always(function() 
		{
			magoManager.backGround_fileReadings_count -= 1;
			if (magoManager.backGround_fileReadings_count < 0) { magoManager.backGround_fileReadings_count = 0; }
		});
	}
	else 
	{
		var neoRefImage = new Image();
		texture.fileLoadState = CODE.fileLoadState.LOADING_STARTED; // file load started.***
		
		//magoManager.backGround_fileReadings_count ++;
		neoRefImage.onload = function() 
		{
			// is possible that during loading image the building was deleted. Then return.
			if (texture.texId === undefined)
			{
				return;
			}
			
			// if "texture.texId" exist then bind it.
			handleTextureLoaded(gl, neoRefImage, texture.texId);
			texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED; // file load finished.***

			if (magoManager.backGround_fileReadings_count > 0 ) 
			{ magoManager.backGround_fileReadings_count -=1; }
		};

		neoRefImage.onerror = function() 
		{
			// doesn't exist or error loading
			return;
		};
		neoRefImage.src = filePath_inServer;
	}	
};

ReaderWriter.loadBinaryData = function(fileName, dataContainer, weatherLayer) 
{
	dataContainer.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	loadWithXhr(fileName).done(function(response) 
	{	
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			dataContainer.dataArraybuffer = arrayBuffer;
			dataContainer.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			arrayBuffer = null;
			
			weatherLayer.parseData(dataContainer);
		}
		else 
		{
			dataContainer.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("Invalid XMLHttpRequest status = " + status);
		if (status === 0) { dataContainer.fileLoadState = 500; }
		else { dataContainer.fileLoadState = status; }
	}).always(function() 
	{
		
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param texture 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 */
ReaderWriter.loadImage = function(gl, filePath_inServer, texture) 
{
	// Must know the fileExtension.***
	//var extension = filePath_inServer.split('.').pop();
	
	var image = new Image();
	texture.fileLoadState = CODE.fileLoadState.LOADING_STARTED; // file load started.***
	
	image.onload = function() 
	{
		// is possible that during loading image the building was deleted. Then return.
		if (texture.texId === undefined)
		{
			return;
		}
		
		function createTexture(_gl, filter, data, width, height) 
		{
			var textureAux = _gl.createTexture();
			_gl.bindTexture(_gl.TEXTURE_2D, textureAux);
			_gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			_gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
			_gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
			_gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, filter);
			_gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, filter);
			if (data instanceof Uint8Array) 
			{
				_gl.texImage2D(_gl.TEXTURE_2D, 0, _gl.RGBA, width, height, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, data);
			}
			else 
			{
				_gl.texImage2D(_gl.TEXTURE_2D, 0, _gl.RGBA, _gl.RGBA, _gl.UNSIGNED_BYTE, data);
			}
			_gl.bindTexture(_gl.TEXTURE_2D, null);
			//gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
			return textureAux;
		}

		texture.texId = createTexture(gl, gl.LINEAR, image);
		texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED; // file load finished.***
	};

	image.onerror = function() 
	{
		// doesn't exist or error loading
		return;
	};
	image.src = filePath_inServer;
		
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param texture 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.readLegoSimpleBuildingTexture = function(gl, filePath_inServer, texture, magoManager) 
{
	var neoRefImage = new Image();
	texture.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	magoManager.fileRequestControler.lowLodImagesRequestedCount += 1;

	neoRefImage.onload = function() 
	{
		if (texture.texId === undefined) 
		{ texture.texId = gl.createTexture(); }

		handleTextureLoaded(gl, neoRefImage, texture.texId);
		texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
		
		magoManager.fileRequestControler.lowLodImagesRequestedCount -= 1;

		if (magoManager.backGround_fileReadings_count > 0 ) { magoManager.backGround_fileReadings_count -=1; }
		if (magoManager.fileRequestControler.lowLodImagesRequestedCount < 0) { magoManager.fileRequestControler.lowLodImagesRequestedCount = 0; }
	};

	neoRefImage.onerror = function() 
	{
		if (texture.texId === undefined) 
		{
			texture.texId = gl.createTexture();
			// Test wait for texture to load.********************************************
			gl.bindTexture(gl.TEXTURE_2D, texture.texId);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([200, 200, 200, 255])); // clear grey
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
		
		texture.fileLoadState = CODE.fileLoadState.READY;
		
		magoManager.fileRequestControler.lowLodImagesRequestedCount -= 1;
		if (magoManager.fileRequestControler.lowLodImagesRequestedCount < 0) { magoManager.fileRequestControler.lowLodImagesRequestedCount = 0; }
	};

	neoRefImage.src = filePath_inServer;
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 변수
 * @param terranTile 변수
 * @param readerWriter 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.getTileArrayBuffer = function(gl, fileName, terranTile, readerWriter, magoManager) 
{
	// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data
	terranTile.fileReading_started = true;
	//	magoManager.fileRequestControler.backGround_fileReadings_count += 1;
	//	blocksList.fileLoadState = CODE.fileLoadState.LOADING_STARTED;

	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			//var BR_Project = new BRBuildingProject(); // Test.***
			//readerWriter.readF4D_Header(gl, arrayBuffer, BR_Project ); // Test.***
			terranTile.fileArrayBuffer = arrayBuffer;
			terranTile.fileReading_finished = true;

			if (magoManager.backGround_fileReadings_count > 0 ) { magoManager.backGround_fileReadings_count -=1; }
			//			blocksList.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			arrayBuffer = null;
		}
		else 
		{
			//			blocksList.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		//		if(status === 0) blocksList.fileLoadState = 500;
		//		else blocksList.fileLoadState = status;
	}).always(function() 
	{
		//		magoManager.fileRequestControler.filesRequestedCount -= 1;
		//		if(magoManager.fileRequestControler.filesRequestedCount < 0) magoManager.fileRequestControler.filesRequestedCount = 0;
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param filePath_inServer 변수
 * @param pCloud 변수
 * @param readerWriter 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.loadTINTerrain = function(fileName, tinTerrain, magoManager) 
{
	//magoManager.fileRequestControler.modelRefFilesRequestedCount += 1;
	tinTerrain.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			tinTerrain.dataArrayBuffer = arrayBuffer;
			tinTerrain.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			//magoManager.parseQueue.putTinTerrainToParse(lowestOctree); // todo.***
			arrayBuffer = undefined;
		}
		else 
		{
			tinTerrain.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		tinTerrain.fileLoadState = CODE.fileLoadState.LOAD_FAILED;
		//console.log("xhr status = " + status);
		//if (status === 0) { lowestOctree.neoReferencesMotherAndIndices.fileLoadState = 500; }
		//else { lowestOctree.neoReferencesMotherAndIndices.fileLoadState = status; }
	}).always(function() 
	{
		//magoManager.fileRequestControler.modelRefFilesRequestedCount -= 1;
		//if (magoManager.fileRequestControler.modelRefFilesRequestedCount < 0) { magoManager.fileRequestControler.modelRefFilesRequestedCount = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param imageArrayBuffer 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.imageFromArrayBuffer = function(gl, imageArrayBuffer, texture, magoManager, flip_y_texCoords) 
{
	// example: allowedFileTypes = ["image/png", "image/jpeg", "image/gif"];
	var blob = new Blob( [ imageArrayBuffer ], { type: "image/png" } );
	var urlCreator = window.URL || window.webkitURL;
	var imagenUrl = urlCreator.createObjectURL(blob);
	var imageFromArray = new Image();

	imageFromArray.onload = function () 
	{
		if (flip_y_texCoords === undefined)
		{ flip_y_texCoords = false; }
		
		if (texture.texId === undefined)
		{ texture.texId = gl.createTexture(); }
		handleTextureLoaded(gl, imageFromArray, texture.texId, flip_y_texCoords);
		texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
		imageArrayBuffer = null;
	};

	imageFromArray.onerror = function() 
	{
		return;
	};

	imageFromArray.src = imagenUrl;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param texture 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.loadWMSImage = function(gl, filePath_inServer, texture, magoManager, flip_y_texCoords) 
{
	texture.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	var readWriter = this;
	loadWithXhr(filePath_inServer).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (flip_y_texCoords === undefined)
			{ flip_y_texCoords = false; }
		
			readWriter.imageFromArrayBuffer(gl, arrayBuffer, texture, magoManager, flip_y_texCoords);
			texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
		}
	}).fail(function(status) 
	{
		console.log(status);
		
	}).always(function() 
	{
		magoManager.backGround_fileReadings_count -= 1;
		if (magoManager.backGround_fileReadings_count < 0) { magoManager.backGround_fileReadings_count = 0; }
	});
		
};


ReaderWriter.prototype.handleTextureLoaded = function(gl, image, texture) 
{
	// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL
	//var gl = viewer.scene.context._gl;
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // if need vertical mirror of the image.***
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); // Original.***
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	gl.generateMipmap(gl.TEXTURE_2D);
	gl.bindTexture(gl.TEXTURE_2D, null);
};


'use strict';

/**
 * @class TinTerrain
 */
var TinTerrain = function(owner) 
{
	if (!(this instanceof TinTerrain)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.owner; // undefined if depth = 0.
	this.depth; 
	if (owner)
	{
		this.owner = owner;
		this.depth = owner.depth + 1;
	}
	else 
	{
		this.depth = 0;
	}
	
	this.childArray; // child array.
	this.childMap; // example: this.childMap["LU"] = tinTerrainChild.
	
	// Data.
	this.X; // tile index X.
	this.Y; // tile index Y.
	
	// CencerPosition.
	this.centerX; // Float64Array.
	this.centerY; // Float64Array.
	this.centerZ; // Float64Array.
	
	// positions(x, y, z), normals, texCoords, colors & indices array.
	this.cartesiansArray;
	this.normalsArray;
	this.texCoordsArray;
	this.colorsArray;
	this.indices;
	
	// Tile extent.
	this.geographicExtent;
	this.sphereExtent;
	
	// Tile geometry data.
	this.fileLoadState = 0;
	this.dataArrayBuffer;
	this.vboKeyContainer; // class: VBOVertexIdxCacheKeysContainer.
	this.terrainPositionHIGH;
	this.terrainPositionLOW;
	
	this.indexName; // example: "LU".
	this.pathName; // example: "14//4567//516".
	this.texture;
	this.visible;
	
	// Test vars. Delete after test.
	this.imageryGeoExtent;
};

TinTerrain.prototype.deleteObjects = function(magoManager)
{
	var gl = magoManager.sceneState.gl;
	
	// delete all tree under this tinTerrain. no delete tiles if depth < 2.
	if (this.childMap !== undefined)
	{
		// subTile 0 (Left-Up).
		var subTile_LU = this.childMap.LU;
		if (subTile_LU !== undefined)
		{
			subTile_LU.deleteObjects(magoManager);
			delete this.childMap.LU;
		}
		
		// subTile 1 (Left-Down).
		var subTile_LD = this.childMap.LD;
		if (subTile_LD !== undefined)
		{
			subTile_LD.deleteObjects(magoManager);
			delete this.childMap.LD;
		}
		
		// subTile 2 (Right-Up).
		var subTile_RU = this.childMap.RU;
		if (subTile_RU !== undefined)
		{
			subTile_RU.deleteObjects(magoManager);
			delete this.childMap.RU;
		}
		
		// subTile 3 (Right-Down).
		var subTile_RD = this.childMap.RD;
		if (subTile_RD !== undefined)
		{
			subTile_RD.deleteObjects(magoManager);
			delete this.childMap.RD;
		}
		
		this.childMap = undefined;
	}
	
	// no delete tiles if depth < 2.
	if (this.depth < 2)
	{ return; }
		
	// now delete objects of this tinTerrain.
	this.owner = undefined;
	this.depth = undefined; 
	this.childArray = undefined;
	this.childMap = undefined; 
	
	// Data.
	this.X = undefined; // index X.
	this.Y = undefined; // index Y.
	
	// Tile extent.
	if (this.geographicExtent !== undefined)
	{
		this.geographicExtent.deleteObjects();
		this.geographicExtent = undefined;
	}
	
	if (this.sphereExtent !== undefined)
	{
		this.sphereExtent.deleteObjects();
		this.sphereExtent = undefined;
	}
	
	// Tile geometry data.
	this.fileLoadState = 0;
	this.dataArrayBuffer = undefined;
	
	if (this.vboKeyContainer !== undefined)
	{
		this.vboKeyContainer.deleteGlObjects(gl, magoManager.vboMemoryManager);
		this.vboKeyContainer = undefined; // class: VBOVertexIdxCacheKeysContainer.
		
	}
	this.terrainPositionHIGH = undefined;
	this.terrainPositionLOW = undefined;
	
	this.indexName = undefined;
	this.pathName = undefined; // example: "14//4567//516".
	
	if (this.texture !== undefined)
	{
		this.texture.deleteObjects(gl);
		this.texture = undefined;
	}
	this.visible = undefined;
};

TinTerrain.prototype.getPathName = function()
{
	// this returns a string as: L//X//Y.
	// example: "14//4567//516".
	return this.depth.toString() + "\\" + this.X.toString() + "\\" + this.Y.toString();
};

TinTerrain.prototype.setGeographicExtent = function(minLon, minLat, minAlt, maxLon, maxLat, maxAlt)
{
	if (this.geographicExtent === undefined)
	{ this.geographicExtent = new GeographicExtent(); }
	
	var geoExtent = this.geographicExtent;
	
	if (geoExtent.minGeographicCoord === undefined)
	{ geoExtent.minGeographicCoord = new GeographicCoord(); }
	
	if (geoExtent.maxGeographicCoord === undefined)
	{ geoExtent.maxGeographicCoord = new GeographicCoord(); }
	
	geoExtent.minGeographicCoord.setLonLatAlt(minLon, minLat, minAlt);
	geoExtent.maxGeographicCoord.setLonLatAlt(maxLon, maxLat, maxAlt);
};

TinTerrain.prototype.isPrepared = function()
{
	// a tinTerrain is prepared if this is parsed and vbo maked and texture binded.
	
	// Provisional solution.*
	// Provisional solution.*
	// Provisional solution.*
	if (this.fileLoadState === CODE.fileLoadState.LOAD_FAILED)
	{ return true; }
	// End provisional solution.------------------------------
	// End provisional solution.------------------------------
	// End provisional solution.------------------------------
	
	if (this.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
	{ return false; }
	
	if (this.texture === undefined || this.texture.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
	{ return false; }
	
	if (this.vboKeyContainer === undefined || 
		this.vboKeyContainer.vboCacheKeysArray === undefined || 
		this.vboKeyContainer.vboCacheKeysArray.length === 0)
	{ return false; }
	
	return true;
};

TinTerrain.prototype.prepareTexture = function(magoManager, tinTerrainManager)
{
	var gl = magoManager.sceneState.gl;
	this.texture = new Texture();
	
	// Provisionally test.
	//var imagesDataPath = "\\images\\ko";
	//var textureFilePath = imagesDataPath +  "\\funny_" + this.depth + ".jpg";
	//magoManager.readerWriter.readLegoSimpleBuildingTexture(gl, textureFilePath, this.texture, magoManager);
	// End test.----------------------------------------------------------------------------------------------------
			
	var geoServURL = tinTerrainManager.geoServURL;
	var L = this.depth.toString();
	var X = this.X.toString();
	var Y = this.Y.toString();
	
	X = (Math.floor(this.X/2)).toString();
	//L = (this.depth+1).toString();
	

	var tilePath = L + "&TileRow=" + Y + "&TileCol=" + X;
	//var textureFilePath = geoServURL + "?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&Layer=mago3d:SejongBGM&Format=image/png&TileMatrixSet=EPSG:4326&TileMatrix=EPSG:4326:" + tilePath;
	//https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'

	var textureFilePath = "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/" + L + "/" + Y + "/" + X + ".png";

	magoManager.readerWriter.loadWMSImage(gl, textureFilePath, this.texture, magoManager, false);
	
	// For elevation3D data.
	//http://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer/tile/0/0/0
};

TinTerrain.prototype.prepareTinTerrainPlain = function(magoManager, tinTerrainManager)
{
	// This is a test function.!!!
	// This function 1- loads file & 2- parses file & 3- makes vbo.
	// 1rst, check if the parent is prepared. If parent is not prepared, then prepare the parent.
	
	if (this.owner === undefined || this.owner.isPrepared())
	{
		// 1rst, try to erase from procesQueue_deleting if exist.
		magoManager.processQueue.eraseTinTerrainToDelete(this);
		
		// Prepare this tinTerrain.
		this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED; // Test code.!!!
		if (this.fileLoadState === CODE.fileLoadState.READY)
		{
			//var pathName = this.getPathName();
			//var fileName = "CesiumTerrain/" + pathName + ".terrain";
			//magoManager.readerWriter.loadTINTerrain(fileName, this, magoManager);
			
		}
		else if (this.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
		{
			// put the terrain into parseQueue.
			//magoManager.parseQueue.putTinTerrainToParse(this, 0);
		}
		else if (this.fileLoadState === CODE.fileLoadState.PARSE_FINISHED && this.vboKeyContainer === undefined)
		{
			//this.decodeData();
			//this.makeVbo(magoManager.vboMemoryManager);
			this.calculateCenterPosition();
			this.makeMeshVirtually(20, 20, undefined, undefined);
			this.makeVbo(magoManager.vboMemoryManager);
		}
		else if (this.texture === undefined)
		{
			this.prepareTexture(magoManager, tinTerrainManager);
		}

		return;
	}
	else
	{
		// Prepare ownerTinTerrain.
		this.owner.prepareTinTerrainPlain(magoManager, tinTerrainManager);
		return;
	}
};

TinTerrain.prototype.prepareTinTerrain = function(magoManager, tinTerrainManager)
{
	// This function 1- loads file & 2- parses file & 3- makes vbo.
	// 1rst, check if the parent is prepared. If parent is not prepared, then prepare the parent.
	
	if (this.owner === undefined || this.owner.isPrepared())
	{
		// 1rst, try to erase from procesQueue_deleting if exist.
		magoManager.processQueue.eraseTinTerrainToDelete(this);
		
		// Prepare this tinTerrain.
		if (this.fileLoadState === CODE.fileLoadState.READY)
		{
			var pathName = this.getPathName();
			var fileName = "CesiumTerrain/" + pathName + ".terrain";
			magoManager.readerWriter.loadTINTerrain(fileName, this, magoManager);
			
		}
		else if (this.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
		{
			// put the terrain into parseQueue.
			magoManager.parseQueue.putTinTerrainToParse(this, 0);
		}
		else if (this.fileLoadState === CODE.fileLoadState.PARSE_FINISHED && this.vboKeyContainer === undefined)
		{
			this.decodeData();
			this.makeVbo(magoManager.vboMemoryManager);
		}
		else if (this.texture === undefined)
		{
			this.prepareTexture(magoManager, tinTerrainManager);
		}

		return;
	}
	else
	{
		// Prepare ownerTinTerrain.
		this.owner.prepareTinTerrain(magoManager, tinTerrainManager);
		return;
	}
};

TinTerrain.prototype.hasChildren = function()
{
	if (this.childMap !== undefined && this.childMap.length > 0)
	{ return true; }
	
	return false;
};

TinTerrain.prototype.deleteTinTerrain = function(magoManager)
{
	// The quadTree must be deleted lowest-quads first.
	// Check if this has child. If this has child, then, 1rst delete child.
	if (this.hasChildren())
	{
		// Delete children 1rst.
		for (var key in this.childMap)
		{
			if (Object.prototype.hasOwnProperty.call(this.childMap, key))
			{
				var child = this.childMap[key];
				child.deleteTinTerrain(magoManager);
			}
		}
		
		return false;
	}
	else
	{
		// 1rst, delete from parse-queue if exist.
		magoManager.parseQueue.eraseTinTerrainToParse(this);
		// put this tinTerrain into deleteQueue.
		magoManager.processQueue.putTinTerrainToDelete(this, 0);
		
		// now, must erase from myOwner-childrenMap.
		delete this.owner.childMap[this.indexName];
		
		if (this.owner.childMap.length === 0)
		{ this.owner.childMap = undefined; }
		
		return true;
	}
};

TinTerrain.prototype.render = function(currentShader, magoManager, bDepth)
{
	if (this.owner === undefined || this.owner.isPrepared())
	{
		if (this.isPrepared())
		{
			if (this.fileLoadState === CODE.fileLoadState.LOAD_FAILED) // provisional solution.
			{ return; }
			
			// render this tinTerrain.
			var gl = magoManager.sceneState.gl;
			var renderWireframe = false;
			
			gl.bindTexture(gl.TEXTURE_2D, this.texture.texId);
			
			gl.uniform3fv(currentShader.buildingPosHIGH_loc, this.terrainPositionHIGH);
			gl.uniform3fv(currentShader.buildingPosLOW_loc, this.terrainPositionLOW);
			
			var vboKey = this.vboKeyContainer.vboCacheKeysArray[0];
			
			// Positions.
			if (!vboKey.bindDataPosition(currentShader, magoManager.vboMemoryManager))
			{ return false; }
		
			// TexCoords.
			if (!bDepth)
			{
				if (!vboKey.bindDataTexCoord(currentShader, magoManager.vboMemoryManager))
				{ return false; }
			}
			
			// Normals.
			// todo:
			
			// Colors.
			// todo:
			
			// Indices.
			if (!vboKey.bindDataIndice(currentShader, magoManager.vboMemoryManager))
			{ return false; }
			
			var indicesCount = vboKey.indicesCount;
			
			if (renderWireframe)
			{
				var trianglesCount = indicesCount;
				for (var i=0; i<trianglesCount; i++)
				{
					gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i*3); // Fill.
				}
			}
			else
			{
				gl.drawElements(gl.TRIANGLES, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.
			}

		}
		else 
		{
			// render the owner tinTerrain.
			if (this.owner !== undefined)
			{ this.owner.render(currentShader, magoManager, bDepth); }
		}
	}
	else 
	{
		// render the owner tinTerrain.
		this.owner.render(currentShader, magoManager, bDepth);
	}
};

TinTerrain.prototype.getFrustumIntersectedTinTerrainsQuadTree = function(frustum, maxDepth, camPos, magoManager, visibleTilesArray, noVisibleTilesArray)
{
	if (this.geographicExtent === undefined || this.geographicExtent.minGeographicCoord === undefined || this.geographicExtent.maxGeographicCoord === undefined)
	{ return; }
	
	var currMinGeographicCoords = this.geographicExtent.minGeographicCoord;
	var currMaxGeographicCoords = this.geographicExtent.maxGeographicCoord;
		
	if (this.sphereExtent === undefined)
	{
		this.sphereExtent = SmartTile.computeSphereExtent(magoManager, currMinGeographicCoords, currMaxGeographicCoords, this.sphereExtent);
	}
	
	var sphereExtentAux = this.sphereExtent;
	var intersectionType = frustum.intersectionSphere(sphereExtentAux);
	
	if (intersectionType === Constant.INTERSECTION_OUTSIDE)
	{ 
		this.visible = false;
		noVisibleTilesArray.push(this); // collect no visible tiles to delete it.
		return; 
	}
	//else if (intersectionType === Constant.INTERSECTION_INSIDE)
	//{
	//	// finish the process.
	//	this.visible = true;
	//	visibleTilesArray.push(this);
	//	return;
	//}
	else if (intersectionType === Constant.INTERSECTION_INTERSECT || intersectionType === Constant.INTERSECTION_INSIDE)
	{
		// check distance to camera.
		var distToCam = camPos.distToSphere(sphereExtentAux);
		if (distToCam > 5000)// && this.depth > 1)
		{
			// finish the process.
			this.visible = true;
			visibleTilesArray.push(this);
			return;
		}
		
		var currDepth = this.depth;
		if (currDepth < maxDepth)
		{
			// must descend.
			var curX = this.X;
			var curY = this.Y;
			var minLon = currMinGeographicCoords.longitude;
			var minLat = currMinGeographicCoords.latitude;
			var minAlt = currMinGeographicCoords.altitude;
			var maxLon = currMaxGeographicCoords.longitude;
			var maxLat = currMaxGeographicCoords.latitude;
			var maxAlt = currMaxGeographicCoords.altitude;
			var midLon = (minLon + maxLon)/ 2;
			var midLat = (minLat + maxLat)/ 2;
		
			// create children if no exist.
			// +--------------+--------------+
			// | subTile 0(LU)| subTile 2(RU)|
			// | X = curX*2   | X = curX*2+1 |
			// | Y = curY*2   | Y = curY*2   |
			// |              |              |
			// +--------------+--------------+
			// | subTile 1(LD)| subTile 3(RD)|
			// | X = curX*2   | X = curX*2+1 |
			// | Y = curY*2+1 | Y = curY*2+1 |
			// |              |              |
			// +--------------+--------------+
			
			// Test imagery textures extent.**
			var imageryMercatorMinX = this.imageryGeoExtent.minGeographicCoord.longitude;
			var imageryMercatorMinY = this.imageryGeoExtent.minGeographicCoord.latitude;
			var imageryMercatorMaxX = this.imageryGeoExtent.maxGeographicCoord.longitude;
			var imageryMercatorMaxY = this.imageryGeoExtent.maxGeographicCoord.latitude;
			var imageryMercatorMidX = (imageryMercatorMinX + imageryMercatorMaxX)/2;
			var imageryMercatorMidY = (imageryMercatorMinY + imageryMercatorMaxY)/2;
			// End test.-------------------------------------------------------------------
				
			if (this.childMap === undefined)
			{ this.childMap = {}; }
			
			// subTile 0 (Left-Up).
			var subTile_LU = this.childMap.LU;
			if (subTile_LU === undefined)
			{
				// if no exist -> create it.
				subTile_LU = new TinTerrain(this);
				subTile_LU.X = curX*2;
				subTile_LU.Y = curY*2;
				subTile_LU.setGeographicExtent(minLon, midLat, minAlt,  midLon, maxLat, maxAlt); 
				subTile_LU.indexName = "LU";
				this.childMap.LU = subTile_LU;
				
				// Test imagery textures extent.**
				if (subTile_LU.imageryGeoExtent === undefined)
				{ subTile_LU.imageryGeoExtent = new GeographicExtent(); }
				subTile_LU.imageryGeoExtent.setExtent(imageryMercatorMinX, imageryMercatorMidY, 0.0, imageryMercatorMidX, imageryMercatorMaxY, 0.0);
				// End test.-------------------------------------------------------------------
			}
			
			// subTile 1 (Left-Down).
			var subTile_LD = this.childMap.LD;
			if (subTile_LD === undefined)
			{
				// if no exist -> create it.
				subTile_LD = new TinTerrain(this);
				subTile_LD.X = curX*2;
				subTile_LD.Y = curY*2+1;
				subTile_LD.setGeographicExtent(minLon, minLat, minAlt,  midLon, midLat, maxAlt); 
				subTile_LD.indexName = "LD";
				this.childMap.LD = subTile_LD;
				
				// Test imagery textures extent.**
				if (subTile_LD.imageryGeoExtent === undefined)
				{ subTile_LD.imageryGeoExtent = new GeographicExtent(); }
				subTile_LD.imageryGeoExtent.setExtent(imageryMercatorMinX, imageryMercatorMinY, 0.0, imageryMercatorMidX, imageryMercatorMidY, 0.0);
				// End test.-------------------------------------------------------------------
			}
			
			// subTile 2 (Right-Up).
			var subTile_RU = this.childMap.RU;
			if (subTile_RU === undefined)
			{
				subTile_RU = new TinTerrain(this);
				subTile_RU.X = curX*2+1;
				subTile_RU.Y = curY*2;
				subTile_RU.setGeographicExtent(midLon, midLat, minAlt,  maxLon, maxLat, maxAlt); 
				subTile_RU.indexName = "RU";
				this.childMap.RU = subTile_RU;
				
				// Test imagery textures extent.**
				if (subTile_RU.imageryGeoExtent === undefined)
				{ subTile_RU.imageryGeoExtent = new GeographicExtent(); }
				subTile_RU.imageryGeoExtent.setExtent(imageryMercatorMidX, imageryMercatorMidY, 0.0, imageryMercatorMaxX, imageryMercatorMaxY, 0.0);
				// End test.-------------------------------------------------------------------
			}
			
			// subTile 3 (Right-Down).
			var subTile_RD = this.childMap.RD;
			if (subTile_RD === undefined)
			{
				subTile_RD = new TinTerrain(this);
				subTile_RD.X = curX*2+1;
				subTile_RD.Y = curY*2+1;
				subTile_RD.setGeographicExtent(midLon, minLat, minAlt,  maxLon, midLat, maxAlt);
				subTile_RD.indexName = "RD";
				this.childMap.RD = subTile_RD;
				
				// Test imagery textures extent.**
				if (subTile_RD.imageryGeoExtent === undefined)
				{ subTile_RD.imageryGeoExtent = new GeographicExtent(); }
				subTile_RD.imageryGeoExtent.setExtent(imageryMercatorMidX, imageryMercatorMinY, 0.0, imageryMercatorMaxX, imageryMercatorMidY, 0.0);
				// End test.-------------------------------------------------------------------
			}
			
			// now, do frustumCulling for each childTiles.
			subTile_LU.getFrustumIntersectedTinTerrainsQuadTree(frustum, maxDepth, camPos, magoManager, visibleTilesArray, noVisibleTilesArray);
			subTile_LD.getFrustumIntersectedTinTerrainsQuadTree(frustum, maxDepth, camPos, magoManager, visibleTilesArray, noVisibleTilesArray);
			subTile_RU.getFrustumIntersectedTinTerrainsQuadTree(frustum, maxDepth, camPos, magoManager, visibleTilesArray, noVisibleTilesArray);
			subTile_RD.getFrustumIntersectedTinTerrainsQuadTree(frustum, maxDepth, camPos, magoManager, visibleTilesArray, noVisibleTilesArray);
		}
		else 
		{
			// finish the process.
			this.visible = true;
			visibleTilesArray.push(this);
			return;
		}
	}
};

TinTerrain.prototype.calculateCenterPosition = function()
{
	// Note: The centerPosition is Float64Array type.
	// The centerPosition of tiles are calculate with "altitude" = 0;.
	var altitude = 0.0;
	var resultGeographicCoord;
	resultGeographicCoord = this.geographicExtent.getMidPoint(resultGeographicCoord);
	
	var centerLon = resultGeographicCoord.longitude;
	var centerLat = resultGeographicCoord.latitude;
	
	var resultCartesian;
	resultCartesian = Globe.geographicToCartesianWgs84(centerLon, centerLat, altitude, resultCartesian);
	
	// Float64Array.
	this.centerX = new Float64Array([resultCartesian[0]]);
	this.centerY = new Float64Array([resultCartesian[1]]);
	this.centerZ = new Float64Array([resultCartesian[2]]);
};

/**
     * Calculate the translation and scale for a particular {@link TileImagery} attached to a
     * particular terrain tile.
     *
     * @private
     *
     * @param {Tile} tile The terrain tile.
     * @param {TileImagery} tileImagery The imagery tile mapping.
     * @returns {Cartesian4} The translation and scale where X and Y are the translation and Z and W
     *          are the scale.
     */
	 /*
ImageryLayer.prototype._calculateTextureTranslationAndScale = function(tile, tileImagery) {
	var imageryRectangle = tileImagery.readyImagery.rectangle;
	var terrainRectangle = tile.rectangle;

	if (tileImagery.useWebMercatorT) {
		var tilingScheme = tileImagery.readyImagery.imageryLayer.imageryProvider.tilingScheme;
		imageryRectangle = tilingScheme.rectangleToNativeRectangle(imageryRectangle, imageryBoundsScratch);
		terrainRectangle = tilingScheme.rectangleToNativeRectangle(terrainRectangle, terrainRectangleScratch);
	}

	var terrainWidth = terrainRectangle.width;
	var terrainHeight = terrainRectangle.height;

	var scaleX = terrainWidth / imageryRectangle.width;
	var scaleY = terrainHeight / imageryRectangle.height;
	return new Cartesian4(
			scaleX * (terrainRectangle.west - imageryRectangle.west) / terrainWidth,
			scaleY * (terrainRectangle.south - imageryRectangle.south) / terrainHeight,
			scaleX,
			scaleY);
};
*/

TinTerrain.prototype.calculateTextureCoordinateTranslationAndScale = function()
{
	// In construction function.
	// Tile Images from World Imagery has different extent to the tiles obtained by CRS84 rules.
	// To match image texture on to the tile, must calculate texture's coordinates translation & scale.
	// The calculation must to do onto mercator projection.
	
	// Calculate terrain mercator extension.
	var terrainMercatorMinPoint2d, terrainMercatorMaxPoint2d;
	terrainMercatorMinPoint2d = this.geographicExtent.minGeographicCoord.getMercatorProjection(terrainMercatorMinPoint2d);
	terrainMercatorMaxPoint2d = this.geographicExtent.maxGeographicCoord.getMercatorProjection(terrainMercatorMaxPoint2d);
	
	// Calculate imagery mercator extension.
	var imageryMercatorMinPoint2d, imageryMercatorMaxPoint2d;
	// Imagery coords are just mercator.
	imageryMercatorMinPoint2d = new Point2D(this.imageryGeoExtent.minGeographicCoord.longitude, this.imageryGeoExtent.minGeographicCoord.latitude);
	imageryMercatorMaxPoint2d = new Point2D(this.imageryGeoExtent.maxGeographicCoord.longitude, this.imageryGeoExtent.maxGeographicCoord.latitude);
	
	var terrainWidth = terrainMercatorMaxPoint2d.x - terrainMercatorMinPoint2d.x;
	var terrainHeight = terrainMercatorMaxPoint2d.y - terrainMercatorMinPoint2d.y;
	var imageryWidth = imageryMercatorMaxPoint2d.x - imageryMercatorMinPoint2d.x;
	var imageryHeight = imageryMercatorMaxPoint2d.y - imageryMercatorMinPoint2d.y;
	
	var scaleX = terrainWidth / imageryWidth;
	var scaleY = terrainHeight / imageryHeight;
	var translateX = scaleX *(terrainMercatorMinPoint2d.x - imageryMercatorMinPoint2d.x)/ terrainWidth;
	var translateY = scaleY *(terrainMercatorMinPoint2d.y - imageryMercatorMinPoint2d.y)/ terrainHeight;
	
	this.textureTranslateAndScale = new Point4D(translateX, translateY, scaleX, scaleY);
};

TinTerrain.prototype.makeMeshVirtually = function(lonSegments, latSegments, altitude, altitudesSlice)
{
	// This function makes an ellipsoidal mesh for tiles that has no elevation data.
	// note: "altitude" & "altitudesSlice" are optionals.
	var degToRadFactor = Math.PI/180.0;
	var minLon = this.geographicExtent.minGeographicCoord.longitude * degToRadFactor;
	var minLat = this.geographicExtent.minGeographicCoord.latitude * degToRadFactor;
	var maxLon = this.geographicExtent.maxGeographicCoord.longitude * degToRadFactor;
	var maxLat = this.geographicExtent.maxGeographicCoord.latitude * degToRadFactor;
	var lonRange = maxLon - minLon;
	var latRange = maxLat - minLat;
	
	var lonIncreDeg = lonRange/lonSegments;
	var latIncreDeg = latRange/latSegments;
	
	// use a vertexMatrix to make the regular net.
	var vertexMatrix;
	
	// calculate total verticesCount.
	var vertexCount = (lonSegments + 1)*(latSegments + 1);
	var lonArray = new Float32Array(vertexCount);
	var latArray = new Float32Array(vertexCount);
	var altArray = new Float32Array(vertexCount);
	this.texCoordsArray = new Float32Array(vertexCount*2);
	
	var currLon = minLon; // init startLon.
	var currLat = minLat; // init startLat.
	var idx = 0;
	var s, t;
	
	// check if exist altitude.
	var alt = 0;
	if (altitude)
	{ alt = altitude; }

	// Note: If exist "altitudesSlice", then use it.
	
	// Test.**
	// _calculateTextureTranslationAndScale
	var minMercator, maxMercator;
	minMercator = Globe.geographicRadianToMercatorProjection(minLon, minLat, minMercator);
	maxMercator = Globe.geographicRadianToMercatorProjection(maxLon, maxLat, maxMercator);
	this.calculateTextureCoordinateTranslationAndScale();
	// End test.-------------------------------------------------------------------------------
	
	for (var currLatSeg = 0; currLatSeg<latSegments+1; currLatSeg++)
	{
		currLon = minLon;
		for (var currLonSeg = 0; currLonSeg<lonSegments+1; currLonSeg++)
		{
			lonArray[idx] = currLon;
			latArray[idx] = currLat;
			// Now set the altitude.
			if (altitudesSlice)
			{
				altArray[idx] = altitudesSlice.getValue(currLonSeg, currLatSeg);
			}
			else
			{ altArray[idx] = alt; }

			// make texcoords.
			s = (currLon - minLon)/lonRange;
			t = (currLat - minLat)/latRange;
			
			this.texCoordsArray[idx*2] = s;
			this.texCoordsArray[idx*2+1] = t;
			
			// actualize current values.
			currLon += lonIncreDeg;
			idx++;
		}
		currLat += latIncreDeg;
	}
	
	this.cartesiansArray = Globe.geographicRadianArrayToFloat32ArrayWgs84(lonArray, latArray, altArray, this.cartesiansArray);
	
	// finally make indicesArray.
	var numCols = lonSegments + 1;
	var numRows = latSegments + 1;
	this.indices = this.getIndicesTrianglesRegularNet(numCols, numRows, undefined);
};

TinTerrain.prototype.getIndicesTrianglesRegularNet = function(numCols, numRows, resultIndicesArray)
{
	// given a regular net this function returns triangles indices of the net.
	var verticesCount = numCols * numRows;
	var trianglesCount = (numCols-1) * (numRows-1) * 2;
	if (resultIndicesArray === undefined)
	{ resultIndicesArray = new Uint16Array(trianglesCount * 3); }
	
	var idx_1, idx_2, idx_3;
	var idxCounter = 0;
	
	for (var row = 0; row<numRows-1; row++)
	{
		for (var col=0; col<numCols-1; col++)
		{
			// there are 2 triangles: triA, triB.
			idx_1 = VertexMatrix.getIndexOfArray(numCols, numRows, col, row);
			idx_2 = VertexMatrix.getIndexOfArray(numCols, numRows, col+1, row);
			idx_3 = VertexMatrix.getIndexOfArray(numCols, numRows, col, row+1);
			resultIndicesArray[idxCounter] = idx_1; idxCounter++;
			resultIndicesArray[idxCounter] = idx_2; idxCounter++;
			resultIndicesArray[idxCounter] = idx_3; idxCounter++;
			
			idx_1 = VertexMatrix.getIndexOfArray(numCols, numRows, col+1, row);
			idx_2 = VertexMatrix.getIndexOfArray(numCols, numRows, col+1, row+1);
			idx_3 = VertexMatrix.getIndexOfArray(numCols, numRows, col, row+1);
			resultIndicesArray[idxCounter] = idx_1; idxCounter++;
			resultIndicesArray[idxCounter] = idx_2; idxCounter++;
			resultIndicesArray[idxCounter] = idx_3; idxCounter++;
		}
	}
	
	return resultIndicesArray;
};

TinTerrain.prototype.zigZagDecode = function(value)
{
	return (value >> 1) ^ (-(value & 1));
};

TinTerrain.prototype.makeVbo = function(vboMemManager)
{
	if (this.cartesiansArray === undefined)
	{ return; }
	
	// rest the CenterPosition to the this.cartesiansArray.
	var coordsCount = this.cartesiansArray.length/3;
	for (var i=0; i<coordsCount; i++)
	{
		this.cartesiansArray[i*3] -= this.centerX;
		this.cartesiansArray[i*3+1] -= this.centerY;
		this.cartesiansArray[i*3+2] -= this.centerZ;
	}
	
	if (this.terrainPositionHIGH === undefined)
	{ this.terrainPositionHIGH = new Float32Array(3); }

	if (this.terrainPositionLOW === undefined)
	{ this.terrainPositionLOW = new Float32Array(3); }
	ManagerUtils.calculateSplited3fv([this.centerX[0], this.centerY[0], this.centerZ[0]], this.terrainPositionHIGH, this.terrainPositionLOW);
	
	if (this.vboKeyContainer === undefined)
	{ this.vboKeyContainer = new VBOVertexIdxCacheKeysContainer(); }
	
	var vboKey = this.vboKeyContainer.newVBOVertexIdxCacheKey();
	
	// Positions.
	vboKey.setDataArrayPos(this.cartesiansArray, vboMemManager);
	
	// TexCoords.
	if (this.texCoordsArray)
	{
		// Test modify texCoords here.
		var minLat = this.geographicExtent.minGeographicCoord.latitude;
		var maxLat = this.geographicExtent.maxGeographicCoord.latitude;
		var latRange = maxLat - minLat;
		
		var minTan = Math.tan(minLat * Math.PI/180.0);
		var maxTan = Math.tan(maxLat * Math.PI/180.0);
		var tanRange = maxTan - minTan;
		
		var texCoordsCount = this.texCoordsArray.length/2;
		for (var i=0; i<texCoordsCount; i++)
		{
			// scale.
			this.texCoordsArray[i*2] *= this.textureTranslateAndScale.z;
			this.texCoordsArray[i*2+1] *= this.textureTranslateAndScale.w;
			
			// translate.
			this.texCoordsArray[i*2] += this.textureTranslateAndScale.x;
			this.texCoordsArray[i*2+1] += this.textureTranslateAndScale.y;
			
			// Latitude correction.
			/*
			var tCoordY = this.texCoordsArray[i*2+1];
			var curLat = minLat + tCoordY * latRange;
			var tan = Math.tan(curLat * Math.PI/180.0);
			var correctedTexCoordY = (minTan - tan)/tanRange;
			
			this.texCoordsArray[i*2+1] = correctedTexCoordY;
			*/
		}
		vboKey.setDataArrayTexCoord(this.texCoordsArray, vboMemManager);
	}
		
	// Indices.
	vboKey.setDataArrayIdx(this.indices, vboMemManager);
		
	/*
	// Todo:
	if (normal)
	{ vboKey.norVboDataArray = Int8Array.from(norArray); }
	
	if (color)
	{ vboKey.colVboDataArray = Uint8Array.from(colArray); }
	this.cartesiansArray;
	this.normalsArray;
	this.texCoordsArray;
	this.colorsArray;
	this.indices;
	*/
	
	
};

TinTerrain.prototype.decodeData = function()
{
	if (this.geographicExtent === undefined)
	{ return; }
	
	if (this.vertexArray === undefined)
	{ this.vertexArray = []; }
	
	var degToRadFactor = Math.PI/180.0;
	// latitude & longitude in RADIANS.
	var minLon = this.geographicExtent.minGeographicCoord.longitude * degToRadFactor;
	var minLat = this.geographicExtent.minGeographicCoord.latitude * degToRadFactor;
	var maxLon = this.geographicExtent.maxGeographicCoord.longitude * degToRadFactor;
	var maxLat = this.geographicExtent.maxGeographicCoord.latitude * degToRadFactor;
	var lonRange = maxLon - minLon;
	var latRange = maxLat - minLat;
	
	var minHeight = this.minHeight[0];
	var maxHeight = this.maxHeight[0];
	var heightRange = maxHeight - minHeight;
	
	var vertexCount = this.vertexCount[0];
	this.texCoordsArray = new Float32Array(vertexCount*2);
	var lonArray = new Float32Array(vertexCount);
	var latArray = new Float32Array(vertexCount);
	var altArray = new Float32Array(vertexCount);
	var shortMax = 32767; // 65536
	var lonRangeDivShortMax = lonRange/shortMax;
	var latRangeDivShortMax = latRange/shortMax;
	var heightRangeDivShortMax = heightRange/shortMax;
	var uValues = this.uValues;
	var vValues = this.vValues;
	var hValues = this.hValues;
	for (var i=0; i<vertexCount; i++)
	{
		lonArray[i] = minLon + uValues[i]*lonRangeDivShortMax;
		latArray[i] = minLat + vValues[i]*latRangeDivShortMax;
		altArray[i] = minHeight + hValues[i]*heightRangeDivShortMax;
		
		// make texcoords.
		this.texCoordsArray[i*2] = uValues[i]/shortMax;
		this.texCoordsArray[i*2+1] = vValues[i]/shortMax;
	}
	
	this.cartesiansArray = Globe.geographicRadianArrayToFloat32ArrayWgs84(lonArray, latArray, altArray, this.cartesiansArray);
	
	// free memory.
	this.uValues = undefined;
	this.vValues = undefined;
	this.hValues = undefined;
	
	lonArray = undefined;
	latArray = undefined;
	altArray = undefined;
	
};

TinTerrain.prototype.parseData = function(dataArrayBuffer)
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;
	var bytes_readed = 0;
	
	// 1. header.
	this.centerX = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.centerY = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.centerZ = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	
	this.minHeight = new Float32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+4)); bytes_readed+=4;
	this.maxHeight = new Float32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+4)); bytes_readed+=4;
	
	this.boundingSphereCenterX = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.boundingSphereCenterY = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.boundingSphereCenterZ = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.boundingSphereRadius = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	
	this.horizonOcclusionPointX = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.horizonOcclusionPointY = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.horizonOcclusionPointZ = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	
	// 2. vertex data.
	this.vertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+4)); bytes_readed+=4;
	var vertexCount = this.vertexCount[0];
	this.uValues = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * vertexCount)); bytes_readed += 2 * vertexCount;
	this.vValues = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * vertexCount)); bytes_readed += 2 * vertexCount;
	this.hValues = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * vertexCount)); bytes_readed += 2 * vertexCount;
	
	// decode data.
	var u = 0;
	var v = 0;
	var height = 0;
	for (var i=0; i<vertexCount; i++)
	{
		u += this.zigZagDecode(this.uValues[i]);
		v += this.zigZagDecode(this.vValues[i]);
		height += this.zigZagDecode(this.hValues[i]);
		
		this.uValues[i] = u;
		this.vValues[i] = v;
		this.hValues[i] = height;
	}
	
	// 3. indices.
	this.trianglesCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
	var trianglesCount = this.trianglesCount;
	if (vertexCount > 65536 )
	{
		this.indices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * trianglesCount * 3)); bytes_readed += 4 * trianglesCount * 3;
	}
	else 
	{
		this.indices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * trianglesCount * 3)); bytes_readed += 2 * trianglesCount * 3;
	}
	
	// decode indices.
	var code;
	var highest = 0;
	var indicesCount = this.indices.length;
	for (var i=0; i<indicesCount; i++)
	{
		code = this.indices[i];
		this.indices[i] = highest - code;
		if (code === 0) 
		{
			++highest;
		}
	}
	
	// 4. edges indices.
	if (vertexCount > 65536 )
	{
		this.westVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.westIndices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * this.westVertexCount)); bytes_readed += 4 * this.westVertexCount;
		
		this.southVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.southIndices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * this.southVertexCount)); bytes_readed += 4 * this.southVertexCount;
		
		this.eastVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.eastIndices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * this.eastVertexCount)); bytes_readed += 4 * this.eastVertexCount;
		
		this.northVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.northIndices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * this.northVertexCount)); bytes_readed += 4 * this.northVertexCount;
	}
	else
	{
		this.westVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.westIndices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * this.westVertexCount)); bytes_readed += 2 * this.westVertexCount;
		
		this.southVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.southIndices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * this.southVertexCount)); bytes_readed += 2 * this.southVertexCount;
		
		this.eastVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.eastIndices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * this.eastVertexCount)); bytes_readed += 2 * this.eastVertexCount;
		
		this.northVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.northIndices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * this.northVertexCount)); bytes_readed += 2 * this.northVertexCount;
	}
	
	// 5. extension header.
	this.extensionId = new Uint8Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 1)); bytes_readed += 1;
	this.extensionLength = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
	
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	
	if (this.extensionId.length === 0)
	{
		dataArrayBuffer = undefined;
		return;
	}
	
	dataArrayBuffer = undefined;
};























































'use strict';

/**
 * @class TinTerrainManager
 */
var TinTerrainManager = function() 
{
	if (!(this instanceof TinTerrainManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.maxDepth = 17;
	this.currentVisibles_terrName_geoCoords_map = {}; // current visible terrains map[terrainPathName, geographicCoords].
	this.currentTerrainsMap = {}; // current terrains (that was created) map[terrainPathName, tinTerrain].
	
	this.visibleTilesArray = [];
	this.noVisibleTilesArray = [];
	
	// TinTerrainQuadTrees.
	this.tinTerrainsQuadTreeAsia; // Main object.
	this.tinTerrainsQuadTreeAmerica; // Main object.
	
	this.geoServURL = "http://192.168.10.57:9090/geoserver/gwc/service/wmts";
	
	// Elevation model or plain ellipsoid.
	// terrainType = 0 -> terrainPlainModel.
	// terrainType = 1 -> terrainElevationModel.
	this.terrainType = 0; 
	
	this.init();
};

TinTerrainManager.prototype.init = function()
{
	this.tinTerrainsQuadTreeAsia = new TinTerrain(undefined); // Main object.
	this.tinTerrainsQuadTreeAmerica = new TinTerrain(undefined); // Main object.
	//1.4844222297453322
	//var latDeg = 1.4844222297453322 *180/Math.PI;
	// Asia side.
	var minLon = 0;
	var minLat = -90;
	var minAlt = 0;
	var maxLon = 180;
	var maxLat = 90;
	var maxAlt = 0;
	this.tinTerrainsQuadTreeAsia.setGeographicExtent(minLon, minLat, minAlt, maxLon, maxLat, maxAlt);
	this.tinTerrainsQuadTreeAsia.X = 1;
	this.tinTerrainsQuadTreeAsia.Y = 0;
	
	// America side.
	minLon = -180;
	minLat = -90;
	minAlt = 0;
	maxLon = 0;
	maxLat = 90;
	maxAlt = 0;
	this.tinTerrainsQuadTreeAmerica.setGeographicExtent(minLon, minLat, minAlt, maxLon, maxLat, maxAlt);
	this.tinTerrainsQuadTreeAmerica.X = 0;
	this.tinTerrainsQuadTreeAmerica.Y = 0;
	
	// do imagery test.
	// set imagery initial geoExtent (in mercator coords).
	/*
	// https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer
	Initial Extent:
	XMin: -2.7680880158351306E7
	YMin: -195164.8424795773 // error.
	XMax: 2.7680880158351306E7
	YMax: 1.9971868880408563E7
	Spatial Reference: 102100 

	Full Extent:
	XMin: -2.003750722959434E7
	YMin: -1.997186888040859E7
	XMax: 2.003750722959434E7
	YMax: 1.9971868880408563E7
	Spatial Reference: 102100 
	
	//https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/0
	Level 0 Extent:
	XMin: -2.0028669624423463E7
	YMin: -7679113.797548824
	XMax: 2.001627433615794E7
	YMax: 1.7924177384518914E7
	Spatial Reference: 102100  (3857) 

	*/
	
	
	// Full extent.
	var initImageryMercatorMinX = -2.003750722959434E7;
	var initImageryMercatorMinY = -1.997186888040859E7;
	var initImageryMercatorMaxX = 2.003750722959434E7;
	var initImageryMercatorMaxY = 1.9971868880408563E7;
	
	//north: 1.4844222297453322
	var eqRadius = Globe.equatorialRadius();
	var north = eqRadius*1.48352986419518;
	var north2 = eqRadius*Math.PI/2;
	
	// Initial extent.
	//var initImageryMercatorMinX = -2.7680880158351306E7;
	//var initImageryMercatorMinY = -195164.8424795773;
	//var initImageryMercatorMaxX = 2.7680880158351306E7;
	//var initImageryMercatorMaxY = 1.9971868880408563E7;
	
	// Level 0 extent.
	//var initImageryMercatorMinX = -2.0028669624423463E7;
	//var initImageryMercatorMinY = -7679113.797548824;
	//var initImageryMercatorMaxX = 2.001627433615794E7;
	//var initImageryMercatorMaxY = 1.7924177384518914E7;
	
	// my extent.
	
	var initImageryMercatorMinX = -2.003750722959434E7;
	var initImageryMercatorMinY = -north2;
	var initImageryMercatorMaxX = 2.003750722959434E7;
	var initImageryMercatorMaxY = north2;
	
	
	this.tinTerrainsQuadTreeAsia.imageryGeoExtent = new GeographicExtent();
	this.tinTerrainsQuadTreeAsia.imageryGeoExtent.setExtent(initImageryMercatorMinX, initImageryMercatorMinY, 0.0, initImageryMercatorMaxX, initImageryMercatorMaxY, 0.0);
	
	this.tinTerrainsQuadTreeAmerica.imageryGeoExtent = new GeographicExtent();
	this.tinTerrainsQuadTreeAmerica.imageryGeoExtent.setExtent(initImageryMercatorMinX, initImageryMercatorMinY, 0.0, initImageryMercatorMaxX, initImageryMercatorMaxY, 0.0);
};

TinTerrainManager.prototype.doFrustumCulling = function(frustum, camPos, magoManager, maxDepth)
{
	if (maxDepth === undefined)
	{ maxDepth = this.maxDepth; }
	
	this.visibleTilesArray.length = 0;
	this.noVisibleTilesArray.length = 0;
	this.tinTerrainsQuadTreeAsia.getFrustumIntersectedTinTerrainsQuadTree(frustum, maxDepth, camPos, magoManager, this.visibleTilesArray, this.noVisibleTilesArray);
	this.tinTerrainsQuadTreeAmerica.getFrustumIntersectedTinTerrainsQuadTree(frustum, maxDepth, camPos, magoManager, this.visibleTilesArray, this.noVisibleTilesArray);
};

/**
 * Prepare tinTerrains.
 */
TinTerrainManager.prototype.prepareVisibleTinTerrains = function(magoManager) 
{
	var tinTerrain;
	
	// For the visible tinTerrains prepare its.
	// Preparing rule: First prepare the tinTerrain-owner if the owner is no prepared yet.
	var visiblesTilesCount = this.visibleTilesArray.length;
	if (this.terrainType === 0) // PlainTerrain.
	{
		for (var i=0; i<visiblesTilesCount; i++)
		{
			tinTerrain = this.visibleTilesArray[i];
			tinTerrain.prepareTinTerrainPlain(magoManager, this);
		}
	}
	else if (this.terrainType === 1)// ElevationTerrain.
	{
		for (var i=0; i<visiblesTilesCount; i++)
		{
			tinTerrain = this.visibleTilesArray[i];
			tinTerrain.prepareTinTerrain(magoManager, this);
		}
	}
	
	// 2nd, for all terrains that exist, if there are not in the visiblesMap, then delete its.
	// Deleting rule: If a tinTerrain has children, then delete first the children.
	var deletedCount = 0;
	var noVisiblesTilesCount = this.noVisibleTilesArray.length;
	for (var i=0; i<visiblesTilesCount; i++)
	{
		tinTerrain = this.noVisibleTilesArray[i];
		if (tinTerrain !== undefined)
		{
			if (tinTerrain.depth > 2)
			{
				tinTerrain.deleteTinTerrain(magoManager);
				deletedCount++;
			}
		}
		
		if (deletedCount > 5)
		{ break; }
	}
	
};

TinTerrainManager.prototype.render = function(magoManager, bDepth) 
{
	
	var gl = magoManager.sceneState.gl;
	var currentShader = magoManager.postFxShadersManager.getShader("tinTerrain");
	var shaderProgram = currentShader.program;
	
	gl.useProgram(shaderProgram);
	gl.enableVertexAttribArray(currentShader.position3_loc);
	if (bDepth)
	{ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
	else
	{ gl.enableVertexAttribArray(currentShader.texCoord2_loc); }
	//gl.disableVertexAttribArray(currentShader.normal3_loc);
	//gl.disableVertexAttribArray(currentShader.color4_loc);
	
	currentShader.bindUniformGenerals();

	var tex = magoManager.pin.texturesArray[4]; // provisional.
	gl.activeTexture(gl.TEXTURE2); 
	gl.bindTexture(gl.TEXTURE_2D, tex.texId);
	
	gl.uniform1i(currentShader.bIsMakingDepth_loc, bDepth); //.
	gl.uniform1i(currentShader.hasTexture_loc, true); //.
	gl.uniform4fv(currentShader.oneColor4_loc, [0.5, 0.5, 0.5, 1.0]);
	
	var flipTexCoordY = true;
	if (magoManager.configInformation.geo_view_library === Constant.CESIUM)
	{ flipTexCoordY = false; }
	gl.uniform1i(currentShader.textureFlipYAxis_loc, flipTexCoordY); // false for cesium, true for magoWorld.
	
	//gl.enable(gl.POLYGON_OFFSET_FILL);
	//gl.polygonOffset(1, 3);
	
	var renderWireframe = false;
	var tinTerrain;
	var visiblesTilesCount = this.visibleTilesArray.length;
	for (var i=0; i<visiblesTilesCount; i++)
	{
		//currentVisiblesTerrainsMap
		tinTerrain = this.visibleTilesArray[i];
		
		if (tinTerrain === undefined)
		{ continue; }
	
		tinTerrain.render(currentShader, magoManager, bDepth);
	}

	currentShader.disableVertexAttribArray(currentShader.texCoord2_loc); 
	currentShader.disableVertexAttribArray(currentShader.position3_loc); 
	currentShader.disableVertexAttribArray(currentShader.normal3_loc); 
	currentShader.disableVertexAttribArray(currentShader.color4_loc); 
	gl.useProgram(null);
};







































'use strict';

/**
 * This represent Arc feature in 2D
 * @class Arc2D
 */
var Arc2D = function() 
{
	if (!(this instanceof Arc2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	
	this.centerPoint; // Point2D.
	this.radius;
	this.startAngleDeg; // zero startAngle is in "X" axis positive.
	this.sweepAngleDeg; // sweeping in CounterClockWise is positive.
	this.numPointsFor360Deg; // interpolation param.
	
	// Alternative vars.
	this.startPoint; // if no exist radius, then startPoint define the radius.
	this.endPoint;
	this.sweepSense; // 1=CCW, -1=CW.
};

/**
 * Set the center position of Arc2D.
 * @class Arc2D
 */
Arc2D.prototype.deleteObjects = function()
{
	if (this.centerPoint !== undefined)
	{ this.centerPoint.deleteObjects(); } // Point3D.
	this.centerPoint = undefined;
	this.radius = undefined;
	this.startAngleDeg = undefined;
	this.sweepAngleDeg = undefined;
	this.numPointsFor360Deg = undefined;
	
	if (this.startPoint !== undefined)
	{ this.startPoint.deleteObjects(); } 
	
	this.startPoint = undefined;
	
	if (this.endPoint !== undefined)
	{ this.endPoint.deleteObjects(); } 
	
	this.endPoint = undefined;
	this.sweepSense = undefined; // 1=CCW, -1=CW.
};

/**
 * Set the center position of Arc
 * @param {Number} cx the x coordi of the center
 * @param {Number} cy the y coordi of the center
 */
Arc2D.prototype.setCenterPosition = function(cx, cy)
{
	if (this.centerPoint === undefined)
	{ this.centerPoint = new Point2D(); }
	
	this.centerPoint.set(cx, cy);
};

/**
 * Set the radius value
 * @param {Number} radius
 */
Arc2D.prototype.setRadius = function(radius)
{
	this.radius = radius;
};

/**
 * Set the start angle of the arc.
 * @param startAngleDegree 
 */
Arc2D.prototype.setStartAngleDegree = function(startAngleDegree)
{
	this.startAngleDeg = startAngleDegree;
};

/**
 * Set the start point of the arc.
 * @param {Number} x
 * @param {NUmber} y
 */
Arc2D.prototype.setStartPoint = function(x, y)
{
	// If no exist startAngle, then use this to calculate startAngle.
	if (this.startPoint === undefined)
	{ this.startPoint = new Point2D(); }
	
	this.startPoint.set(x, y);
};

/**
 * Set the start angle of the arc.
 * @class Arc2D
 */
Arc2D.prototype.setEndPoint = function(x, y)
{
	// If no exist sweepAngle, then use this to calculate sweepAngle.
	if (this.endPoint === undefined)
	{ this.endPoint = new Point2D(); }
	
	this.endPoint.set(x, y);
};

/**
 * Set the sweep direction sense of the arc.
 * @param sense
 */
Arc2D.prototype.setSense = function(sense)
{
	this.sweepSense = sense; // 1=CCW, -1=CW.
};

/**
 * Set the sweep angle of the arc.
 * @param sweepAngleDegree 
 */
Arc2D.prototype.setSweepAngleDegree = function(sweepAngleDegree)
{
	this.sweepAngleDeg = sweepAngleDegree;
};

/**
 * Returns the points of the arc.
 * @param resultPointsArray the array which saves the result of the points
 * @param pointsCountFor360Deg the value used for interpolation way
 */
Arc2D.prototype.getPoints = function(resultPointsArray, pointsCountFor360Deg)
{
	if (this.centerPoint === undefined)
	{ return resultPointsArray; }
	
	if (pointsCountFor360Deg)
	{ this.numPointsFor360Deg = pointsCountFor360Deg; }

	if (this.numPointsFor360Deg === undefined)
	{ this.numPointsFor360Deg = 36; }

	// Check if exist strAng.
	var strVector, endVector;
	var strVectorModul;
	if (this.startAngleDeg === undefined)
	{
		if (this.startPoint === undefined)
		{ return resultPointsArray; }
		
		strVector = new Point2D();
		strVector.set(this.startPoint.x - this.centerPoint.x, this.startPoint.y - this.centerPoint.y);
		strVectorModul = strVector.getModul();
		
		var angRad = Math.acos(x/strVectorModul);
		if (this.startPoint.y < 0)
		{
			angRad *= -1;
		}
		
		this.startAngleDeg = angRad * 180.0/Math.PI;
	}
	
	// Check if exist radius.
	if (this.radius === undefined)
	{
		// calculate by startPoint.
		if (this.startPoint === undefined)
		{ return resultPointsArray; }
		
		if (strVectorModul === undefined)
		{
			if (strVector === undefined)
			{
				strVector = new Point2D();
				strVector.set(this.startPoint.x - this.centerPoint.x, this.startPoint.y - this.centerPoint.y);
			}
			strVectorModul = strVector.getModul();
		}
		
		this.radius = strVectorModul;
	}
	
	// check if exist sweepAng.
	if (this.sweepAngleDeg === undefined)
	{
		if (this.endPoint === undefined || this.sweepSense === undefined)
		{ return resultPointsArray; }
		
		endVector = new Point2D();
		endVector.set(this.endPoint.x - this.centerPoint.x, this.endPoint.y - this.endPoint.y);
		var endVectorModul = endPoint.getModul();
		
		var angRad = Math.acos(x/strVectorModul);
		if (this.endPoint.y < 0)
		{
			angRad *= -1;
		}
		
		this.sweepAngleDeg = angRad * 180.0/Math.PI;
		
		if (this.sweepSense < 0)
		{ this.sweepAngleDeg = 360 - this.sweepAngleDeg; }
	}
	
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	var pointsArray = [];
	
	var increAngRad = 2.0 * Math.PI / this.numPointsFor360Deg;
	var cx = this.centerPoint.x;
	var cy = this.centerPoint.y;
	var x, y;
	var startAngRad = Math.PI/180.0 * this.startAngleDeg;
	var sweepAngRad = Math.PI/180.0 * this.sweepAngleDeg;
	var point;
	
	if (sweepAngRad >=0)
	{
		for (var currAngRad = 0.0; currAngRad<sweepAngRad; currAngRad += increAngRad)
		{
			x = cx + this.radius * Math.cos(currAngRad + startAngRad);
			y = cy + this.radius * Math.sin(currAngRad + startAngRad);
			point = new Point2D(x, y);
			pointsArray.push(point);
		}
	}
	else 
	{
		for (var currAngRad = 0.0; currAngRad>sweepAngRad; currAngRad -= increAngRad)
		{
			x = cx + this.radius * Math.cos(currAngRad + startAngRad);
			y = cy + this.radius * Math.sin(currAngRad + startAngRad);
			point = new Point2D(x, y);
			pointsArray.push(point);
		}
	}
	
	// once finished, mark the 1rst point and the last point as"important point".
	var pointsCount = pointsArray.length;
	if (pointsCount > 0)
	{
		pointsArray[0].pointType = 1;
		pointsArray[pointsCount-1].pointType = 1;
	}
	
	// now merge points into "resultPointsArray".
	var errorDist = 0.0001; // 0.1mm.
	var resultExistentPointsCount = resultPointsArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		if (i===0)
		{
			if (resultExistentPointsCount > 0)
			{
				// check if the last point of "resultPointsArray" and the 1rst point of "this" is coincident.
				var lastExistentPoint = resultPointsArray[resultExistentPointsCount-1];
				point = pointsArray[i];
				if (!lastExistentPoint.isCoincidentToPoint(point, errorDist))
				{
					resultPointsArray.push(point);
				}
			}
			else
			{
				resultPointsArray.push(pointsArray[i]);
			}
		}
		else
		{
			resultPointsArray.push(pointsArray[i]);
		}
	}
	
	// Last check: finally, in case of sweepAngle = 360 degrees, or is closed pointsArray, then pop the last insertedPoint.
	resultExistentPointsCount = resultPointsArray.length;
	if (resultExistentPointsCount > 0)
	{
		// check if the last point of "resultPointsArray" and the 1rst point of "this" is coincident.
		var lastPoint = resultPointsArray[resultExistentPointsCount-1];
		var firstPoint = resultPointsArray[0];
		if (lastPoint.isCoincidentToPoint(firstPoint, errorDist))
		{
			resultPointsArray.pop();
			lastPoint.deleteObjects();
		}
	}
	
	return resultPointsArray;
};




















'use strict';

/**
 * This show x, y ,z axises of the given feature to visualize them
 * @class AxisXYZ
 * 
 * @param {number} length
 */
var AxisXYZ = function(length) 
{
	if (!(this instanceof AxisXYZ)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	if (length === undefined)
	{ this.length = 60; }
	else { this.length = length; }
	
	/**
	 * Container which holds the VBO Cache Keys
	 * @type {VBOVertexIdxCacheKeysContainer}
	 */
	this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer();
	//this.vboKey = this.vbo_vicks_container.newVBOVertexIdxCacheKey();
};

/**
 * Set the length of the axises
 * @param {Number} length the length of the axis
 */
AxisXYZ.prototype.setDimension = function(length)
{
	this.length = length;
};

/**
 * Visualize the axises at the feature
 * @param {Number} length the length of the axis to set the length of the axises
 * @returns {Mesh} mesh
 */
AxisXYZ.prototype.makeMesh = function(length)
{
	if (length !== undefined)
	{ this.length = length; }
	
	var pMesh = new ParametricMesh();
		
	pMesh.profile = new Profile2D(); 
	var profileAux = pMesh.profile; 
	
	// create a halfArrow profile.
	var outerRing = profileAux.newOuterRing();
	var arrowLength = this.length;
	var arrowWidth  = this.length*0.1;
	var polyLine = outerRing.newElement("POLYLINE");
	var point3d = polyLine.newPoint2d(0, 0); // 0
	point3d = polyLine.newPoint2d(arrowWidth*0.25, arrowLength*0.25); // 1
	point3d = polyLine.newPoint2d(arrowWidth*0.25, arrowLength*0.75); // 2
	point3d = polyLine.newPoint2d(arrowWidth*0.5, arrowLength*0.75); // 3
	point3d = polyLine.newPoint2d(0, arrowLength); // 3
	//--------------------------------------------------------------------
	
	var bIncludeBottomCap, bIncludeTopCap;
	var revolveAngDeg, revolveSegmentsCount, revolveSegment2d;
	revolveAngDeg = 360.0;
	
	// create a rotation axis by a segment.
	revolveSegment2d = new Segment2D();
	var strPoint2d = new Point2D(0, -10);
	var endPoint2d = new Point2D(0, 10);
	revolveSegment2d.setPoints(strPoint2d, endPoint2d);
	revolveSegmentsCount = 8;
	
	// rotate the profile and create the Y axis.
	pMesh.revolve(profileAux, revolveAngDeg, revolveSegmentsCount, revolveSegment2d);
	
	bIncludeBottomCap = false;
	bIncludeTopCap = false;
	var mesh = pMesh.getSurfaceIndependentMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	mesh.setColor(0.1, 1.0, 0.1, 1.0); // set the color.
	mesh.reverseSense();
	
	// copy & rotate the mesh and create the X axis.
	var tMatTest = new Matrix4();
	var mesh2 = mesh.getCopy(undefined);
	tMatTest.rotationAxisAngDeg(-90.0, 0, 0, 1);
	mesh2.transformByMatrix4(tMatTest);
	mesh2.setColor(1.0, 0.1, 0.1, 1.0); // set the color.
	
	// copy & rotate the mesh and create the Z axis.
	var mesh3 = mesh.getCopy(undefined);
	tMatTest.rotationAxisAngDeg(90.0, 1, 0, 0);
	mesh3.transformByMatrix4(tMatTest);
	mesh3.setColor(0.1, 0.1, 1.0, 1.0); // set the color.

	// Merge all meshes into a one mesh and make a unique vbo.
	mesh.mergeMesh(mesh2);
	mesh.mergeMesh(mesh3);
	return mesh;
};

/**
 * Get the container which holds the VBO Cache Keys
 * @returns {VBOVertexIdxCacheKeysContainer} vbo_vicks_container
 */
AxisXYZ.prototype.getVboKeysContainer = function()
{
	return this.vbo_vicks_container;
};

'use strict';
/**
* This class represent the bounding box of the other feature in 2D
* @class BoundingRectangle
*/
var BoundingRectangle = function(x, y) 
{
	if (!(this instanceof BoundingRectangle)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.minX = Number.MAX_VALUE;
	this.maxX = Number.MIN_VALUE;
	this.minY = Number.MAX_VALUE;
	this.maxY = Number.MIN_VALUE;
};

BoundingRectangle.prototype.setInit = function(point)
{
	if (point === undefined)
	{ return; }
	
	this.minX = point.x;
	this.minY = point.y;
	this.maxX = point.x;
	this.maxY = point.y;
};
/**
 * Initiation bounding rectangle by the other bounding rectangle
 * @param {BoundingRectangle} bRect The other bounding rectangle	
 */
BoundingRectangle.prototype.setInitByRectangle = function(bRect)
{
	if (bRect === undefined)
	{ return; }
	
	this.minX = bRect.minX;
	this.minY = bRect.minY;
	this.maxX = bRect.maxX;
	this.maxY = bRect.maxY;
};

/**
 * Change the range of this bounding rectangle if a point is added
 * @param {Point2D} point 
 */
BoundingRectangle.prototype.addPoint = function(point)
{
	if (point === undefined)
	{ return; }
	
	if (point.x < this.minX)
	{ this.minX = point.x; }
	else if (point.x > this.maxX)
	{ this.maxX = point.x; }
	
	if (point.y < this.minY)
	{ this.minY = point.y; }
	else if (point.y > this.maxY)
	{ this.maxY = point.y; }
};
/**
 * Change the range of this bounding rectangle if a rectangle is added
 * @param {BoundingRectangle} bRect
 */
BoundingRectangle.prototype.addRectangle = function(bRect)
{
	if (bRect === undefined)
	{ return; }
	
	if (bRect.minX < this.minX)
	{ this.minX = bRect.minX; }
	if (bRect.maxX > this.maxX)
	{ this.maxX = bRect.maxX; }
	
	if (bRect.minY < this.minY)
	{ this.minY = bRect.minY; }
	if (bRect.maxY > this.maxY)
	{ this.maxY = bRect.maxY; }
};
/**
 * Check whether this rectangle is intersected with the given bounding rectangle
 * @param {BoundingRectangle} bRect
 * @returns {Boolean}
 */
BoundingRectangle.prototype.intersectsWithRectangle = function(bRect)
{
	if (bRect === undefined)
	{ return false; }
	
	if (bRect.minX > this.maxX)
	{ return false; }
	else if (bRect.maxX < this.minX)
	{ return false; }
	else if (bRect.minY > this.maxY)
	{ return false; }
	else if (bRect.maxY < this.minY)
	{ return false; }
	
	return true;
};
















































'use strict';

/**
 * This is similar with the 3D version of the Bounding Rectangle but this is slighthly different.
 * 꼭지점을 가지고 한붓 그리기로 3차원 버전의 BB를 그립니다.
 * @class BoxAux
 */
var BoxAux = function() 
{
	if (!(this instanceof BoxAux)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// vertex indices of the BoxAux.
	//    3----------2        7----------6      
	//    |          |        |          |
	//    |  bottom  |        |   top    |
	//    |          |        |          |
	//    0----------1        4----------5
	
	this.triPolyhedron = new TriPolyhedron();
	this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer();
	this.vBOVertexIdxCacheKey = this.vbo_vicks_container.newVBOVertexIdxCacheKey();
};

/**
 * get the Vbo keys container of this feature
 */
BoxAux.prototype.getVboKeysContainer = function()
{
	return this.vbo_vicks_container;
};

/**
 * make Axis Aligned Bounding Box(Aux)
 * @param {Number} xLength 
 * @param {Number} yLength
 * @param {Number} zLength
 */
BoxAux.prototype.makeAABB = function(xLength, yLength, zLength)
{
	// this makes a BoxAux centered on the center of the BoxAux.
	var minX = -xLength/2.0;
	var minY = -yLength/2.0;
	var minZ = -zLength/2.0;
	
	var maxX = xLength/2.0;
	var maxY = yLength/2.0;
	var maxZ = zLength/2.0;
	
	// make 8 vertices and 6 triSurfaces.
	var vertexList = this.triPolyhedron.vertexList;
	
	// Bottom.*
	var vertex = vertexList.newVertex(); // 0.
	vertex.setPosition(minX, minY, minZ);
	
	vertex = vertexList.newVertex(); // 1.
	vertex.setPosition(maxX, minY, minZ);
	
	vertex = vertexList.newVertex(); // 2.
	vertex.setPosition(maxX, maxY, minZ);
	
	vertex = vertexList.newVertex(); // 3.
	vertex.setPosition(minX, maxY, minZ);
	
	// Top.
	vertex = vertexList.newVertex(); // 4.
	vertex.setPosition(minX, minY, maxZ);
	
	vertex = vertexList.newVertex(); // 5.
	vertex.setPosition(maxX, minY, maxZ);
	
	vertex = vertexList.newVertex(); // 6.
	vertex.setPosition(maxX, maxY, maxZ);
	
	vertex = vertexList.newVertex(); // 7.
	vertex.setPosition(minX, maxY, maxZ);
	
	
	// now, create triSurfaces and triangles.
	var triSurface;
	var triangle;
	// Bottom surface.
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(0), vertexList.getVertex(2), vertexList.getVertex(1));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(0), vertexList.getVertex(3), vertexList.getVertex(2));
	
	// Top surface.
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(4), vertexList.getVertex(5), vertexList.getVertex(6));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(4), vertexList.getVertex(6), vertexList.getVertex(7));
	
	// Front surface.
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(0), vertexList.getVertex(1), vertexList.getVertex(5));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(0), vertexList.getVertex(5), vertexList.getVertex(4));
	
	// Right surface.
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(1), vertexList.getVertex(2), vertexList.getVertex(6));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(1), vertexList.getVertex(6), vertexList.getVertex(5));
	
	// Rear surface.
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(2), vertexList.getVertex(3), vertexList.getVertex(7));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(2), vertexList.getVertex(7), vertexList.getVertex(6));
	
	// Left surface.
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(3), vertexList.getVertex(0), vertexList.getVertex(4));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(3), vertexList.getVertex(4), vertexList.getVertex(7));
	
};
'use strict';

/**
 * This represent the circle feature drawn in 2D.
 * @class Circle2D
 */
var Circle2D = function() 
{
	if (!(this instanceof Circle2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// sweeping in CounterClockWise is positive.
	// zero startAngle is in "X" axis positive.
	this.centerPoint; // Point2D.
	this.radius;
	this.numPointsFor360Deg; // interpolation param.
};

/**
 * Set the center position of Circle.
 * @param {Number} cx the x coordi of the center
 * @param {Number} cy the y coordi of the center
 */
Circle2D.prototype.setCenterPosition = function(cx, cy)
{
	if (this.centerPoint === undefined)
	{ this.centerPoint = new Point2D(); }
	
	this.centerPoint.set(cx, cy);
};

/**
 * Set the radius value
 * @param {Number} radius
 */
Circle2D.prototype.setRadius = function(radius)
{
	this.radius = radius;
};

/**
 * Returns the points of the circle.
 * @param reulstPointsArray the array which saves the result of the points
 * @param pointsCountFor360Deg the value used for interpolation way
 */
Circle2D.prototype.getPoints = function(resultPointsArray, pointsCountFor360Deg)
{
	if (pointsCountFor360Deg)
	{ this.numPointsFor360Deg = pointsCountFor360Deg; }

	if (this.numPointsFor360Deg === undefined)
	{ this.numPointsFor360Deg = 36; }
	
	// use an arc to make points.
	if (this.centerPoint === undefined || this.radius === undefined)
	{ return resultPointsArray; }
	
	var arc = new Arc2D();
	arc.setCenterPosition(this.centerPoint.x, this.centerPoint.y);
	
	arc.setRadius(this.radius);
	arc.setStartAngleDegree(0);
	arc.setSweepAngleDegree(360.0);
	arc.setSense(1);
	
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	resultPointsArray = arc.getPoints(resultPointsArray, this.numPointsFor360Deg);
	return resultPointsArray;
};
















































'use strict';

/**
 * CuttingPlane on 3D space. 
 * @class CuttingPlane
 */
var CuttingPlane = function() 
{
	if (!(this instanceof CuttingPlane)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.plane;
	this.geoLocDataManager;
	
	// geometric representation.
	this.mesh; // use to draw a rectangle.
};
/**
 * Calculate plane.
 * In the transformationMatrix there are the normal of the plane.
 */
CuttingPlane.prototype.getPlane = function()
{
	// Calculate plane.
	if (this.plane === undefined)
	{ this.plane = new Plane(); }
	
	// In the transformationMatrix there are the normal of the plane.
	var geoLoc = this.geoLocDataManager.getCurrentGeoLocationData();
	var tMatrix = geoLoc.tMatrix; 
	var pos = geoLoc.position;
	this.plane.setPointAndNormal(pos.x, pos.y, pos.z, tMatrix._floatArrays[8], tMatrix._floatArrays[9], tMatrix._floatArrays[10]);
	
	return this.plane;
};
/**
 * create mesh to draw cutting plane's rectangle
 * @param {Number} width the width of the cutting plane's rectangle
 * @param {Number} height the height of the cutting plane's rectangle
 */
CuttingPlane.prototype.makeRectangle = function(width, height)
{
	// Provisional function.
	if (this.mesh === undefined)
	{ this.mesh = new Mesh(); }
	
	var vertexList = this.mesh.getVertexList();
	var semiWidth = width/2;
	var semiHeight = height/2;
	var alt = 100;
	
	// 1- left_down vertex.
	var vertex1 = vertexList.newVertex();
	vertex1.setPosition(-semiWidth, -semiHeight, alt);
	
	// 2- right_down vertex.
	var vertex2 = vertexList.newVertex();
	vertex2.setPosition(semiWidth, -semiHeight, alt);
	
	// 3- right_up vertex.
	var vertex3 = vertexList.newVertex();
	vertex3.setPosition(semiWidth, semiHeight, alt);
	
	// 4- left_up vertex.
	var vertex4 = vertexList.newVertex();
	vertex4.setPosition(-semiWidth, semiHeight, alt);
	
	// now, make triangles.
	var surfaces = this.mesh.newSurface();
	var face = surfaces.newFace();
	
	face.addVerticesArray([vertex1, vertex2, vertex3, vertex4]);
	
	
};

/**
 * Render cutting plane
 * @param magoManager
 * @param shader
 * @param renderType
 */
CuttingPlane.prototype.render = function(magoManager, shader, renderType)
{
	var gl = magoManager.sceneState.gl;
	var glPrimitive;
	if (renderType === 2)
	{
		// colorCoding selection.
		var selectionColor = magoManager.selectionColor;
		var selFamilyName = "general";
		var selManager = magoManager.selectionManager;
		var selCandidateNodes = selManager.getSelectionCandidatesFamily(selFamilyName);
		if (selCandidateNodes === undefined)
		{
			selCandidateNodes = selManager.newCandidatesFamily(selFamilyName);
		}
		
		var selColor4 = selectionColor.getAvailableColor(undefined); // new.
		var idxKey = selectionColor.decodeColor3(selColor4.r, selColor4.g, selColor4.b);
		selManager.setCandidateCustom(idxKey, selFamilyName, this);
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, [selColor4.r/255.0, selColor4.g/255.0, selColor4.b/255.0, 1.0]);
	}
	else if (renderType === 1)
	{
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 0.0, 1.0]);
		var refMatrixType = 0; // identity matrix.
		gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
		glPrimitive = gl.LINE_LOOP;
	}
	else if (renderType === 0)
	{
		var refMatrixType = 0; // identity matrix.
		gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
	}
	
	this.mesh.render(magoManager, shader, renderType, glPrimitive);
};












































'use strict';

/**
 * This class represents ellipsoid, but this is needed to be implemented more.
 * @class Ellipsoid
 */
var Ellipsoid = function(radiusX, radiusY, radiusZ) 
{
	if (!(this instanceof Ellipsoid)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// Ellipsoid: x^2/a^2 + y^2/b^2 + z^2/c^2 = 1, (a, b, c) = (radiusX, radiusY, radiusZ).
	
	this.radiusX;
	this.radiusY;
	this.radiusZ;
	
	if (radiusX !== undefined)
	{ this.radiusX = radiusX; }
	
	if (radiusY !== undefined)
	{ this.radiusY = radiusY; }
	
	if (radiusZ !== undefined)
	{ this.radiusZ = radiusZ; }

};

'use strict';


/**
 * 어떤 일을 하고 있습니까?
 * @class Excavation
 */
var Excavation = function() 
{
	if (!(this instanceof Excavation)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.geoCoordsList; // class : GeographicCoordsList.
	this.geoLocDataManager;
	this.excavationDepthInMeters;
	
	this.vtxProfilesList;
	this.vboKeysContainer;
	this.vboKeysContainerEdges;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Excavation.prototype.getGeographicCoordsList = function() 
{
	if (this.geoCoordsList === undefined)
	{
		this.geoCoordsList = new GeographicCoordsList();
		this.geoCoordsList.owner = this;
	}
	
	return this.geoCoordsList;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Excavation.prototype.renderPoints = function(magoManager, shader, renderType) 
{
	if (this.geoCoordsList === undefined)
	{ return false; }
	
	if (this.meshPositive !== undefined)
	{
		this.renderExcavation(magoManager, shader, renderType);
	}
	
	this.geoCoordsList.renderPoints(magoManager, shader, renderType, false);
	this.geoCoordsList.renderLines(magoManager, shader, renderType, false, false);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Excavation.prototype.renderExcavation = function(magoManager, shader, renderType) 
{
	if (this.meshPositive === undefined)
	{ return; }
	
	//if(magoManager.currentFrustumIdx !== 0)
	//	return;
	
	var gl = magoManager.sceneState.gl;
	
	shader.useProgram();
	shader.resetLastBuffersBinded();

	shader.enableVertexAttribArray(shader.position3_loc);
	shader.disableVertexAttribArray(shader.color4_loc);
	shader.enableVertexAttribArray(shader.normal3_loc); 
	shader.disableVertexAttribArray(shader.texCoord2_loc); // provisionally has no texCoords.
	
	shader.bindUniformGenerals();

	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 0.1, 0.0]); //.
	
	gl.uniform1i(shader.bApplySsao_loc, false); // apply ssao.
	gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
	gl.uniform1i(shader.colorType_loc, 1); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform1i(shader.bApplySpecularLighting_loc, true); // turn on/off specular lighting.
	
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	gl.depthRange(0, 1);
	
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader); // rotMatrix, positionHIGH, positionLOW.
		
	
	// STENCIL SETTINGS.*
	gl.colorMask(false, false, false, false);
	gl.depthMask(false);
	gl.enable(gl.CULL_FACE);
	gl.enable(gl.STENCIL_TEST);
	//gl.enable(gl.POLYGON_OFFSET_FILL);
	//gl.polygonOffset(1.0, 2.0); // Original.
	//gl.polygonOffset(0.0, 0.0); 
	
	gl.clearStencil(0);
	var glPrimitive = undefined;
	
	
	//if(magoManager.currentFrustumIdx !== 5)
	{
		// First pass.*
		gl.cullFace(gl.FRONT); // 1rstPass.
		gl.stencilFunc(gl.ALWAYS, 0x0, 0xff);
		//gl.stencilOp(gl.KEEP, gl.INCR, gl.KEEP); // stencilOp(fail, zfail, zpass)
		gl.stencilOp(gl.KEEP, gl.INCR, gl.KEEP); // stencilOp(fail, zfail, zpass)
		this.meshPositive.render(magoManager, shader, renderType, glPrimitive);
	}
	
	
	//if(magoManager.currentFrustumIdx === 5)
	{
		// Second pass.*
		gl.cullFace(gl.BACK); // 2ndPass.
		gl.stencilFunc(gl.ALWAYS, 0x0, 0xff);
		//gl.stencilOp(gl.KEEP, gl.DECR, gl.KEEP); // stencilOp(fail, zfail, zpass)
		gl.stencilOp(gl.KEEP, gl.DECR, gl.KEEP); // stencilOp(fail, zfail, zpass)
		this.meshPositive.render(magoManager, shader, renderType, glPrimitive);// Original.
	}
	

	// Render the hole.
	//shader.bindUniformGenerals();
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform4fv(shader.oneColor4_loc, [222/255, 184/255, 135/255, 1.0]); //.
	
	//gl.disable(gl.POLYGON_OFFSET_FILL);
	//gl.disable(gl.CULL_FACE);
	gl.colorMask(true, true, true, true);
	//gl.depthMask(false); // original.
	gl.depthMask(true);
	gl.stencilMask(0x00);

	//gl.stencilFunc(gl.NOTEQUAL, 0, 0xff);
	gl.stencilFunc(gl.LEQUAL, 1, 0xff);
	//gl.stencilFunc(gl.LESS, 0, 0xff);
	//gl.stencilFunc(gl.EQUAL, 1, 0xff);
	gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE); // stencilOp(fail, zfail, zpass)

	//gl.disable(gl.DEPTH_TEST);

	gl.cullFace(gl.BACK);

	gl.depthFunc(gl.ALWAYS);

	//gl.disable(gl.DEPTH_TEST);
	//gl.disable(gl.STENCIL_TEST);
	
	//if (magoManager.currentFrustumIdx === 0)
	//{
	//	
	//}
	
	this.meshNegative.render(magoManager, shader, renderType, glPrimitive);

	
	//gl.disable(gl.STENCIL_TEST);
	//gl.depthFunc(gl.LEQUAL);
	//this.meshPositive.render(magoManager, shader, renderType, glPrimitive);// Original.


	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	//gl.disable(gl.BLEND);
	gl.disable(gl.STENCIL_TEST);
	gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP); // stencilOp(fail, zfail, zpass)
	gl.disable(gl.POLYGON_OFFSET_FILL);
	gl.depthRange(0, 1);// return to the normal value.
	gl.useProgram(null);
	
	gl.depthMask(true); //sets whether writing into the depth buffer is enabled or disabled. Default value: true, meaning that writing is enabled.
	gl.stencilMask(0xff);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Excavation.prototype.getGeoLocationData = function() 
{
	if (this.geoLocDataManager === undefined)
	{ this.geoLocDataManager = new GeoLocationDataManager(); }
	
	var geoLoc = this.geoLocDataManager.getCurrentGeoLocationData();
	if (geoLoc === undefined)
	{
		geoLoc = this.geoLocDataManager.newGeoLocationData("default");
	}
	
	return geoLoc;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Excavation.prototype.makeExtrudeObject = function(magoManager) 
{
	if (this.geoCoordsList === undefined)
	{ return false; }
	
	// 1rst, set position of this extrude object. Take as position the 1rst geoCoord absolute position.
	// Another possibility is calculate the average point of geoCoords.
	var geoLoc = this.getGeoLocationData();

	// Take the 1rst geographicCoord's geoLocation.
	var geoCoord = this.geoCoordsList.getGeoCoord(0);
	var geoLocDataManagerFirst = geoCoord.getGeoLocationDataManager();
	var geoLocFirst = geoLocDataManagerFirst.getCurrentGeoLocationData();
	geoLoc.copyFrom(geoLocFirst);
	
	
	// Now, make the down & up profiles.
	if (this.vtxProfilesList === undefined)
	{ this.vtxProfilesList = new VtxProfilesList(); }
	
	// Project the geoCoordList into a plane. Remember that the local coordinate is the 1rst geoCoord.
	// Calculate down & up points of the extrude object.
	var points3dArrayDown = [];
	var points3dArrayUp = [];
	
	if (this.excavationDepthInMeters === undefined)
	{ this.excavationDepthInMeters = 80.0; }
	
	var cartesianAux;
	var geoCoord;
	var geoCoordsCount = this.geoCoordsList.getGeoCoordsCount();
	for (var i=0; i<geoCoordsCount; i++)
	{
		// Current geoCoord.
		geoCoord = this.geoCoordsList.getGeoCoord(i);
		
		// Down & Up absolute points.
		var point3DDown = new Point3D();
		var point3DUp = new Point3D();
		cartesianAux = Globe.geographicToCartesianWgs84(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude - this.excavationDepthInMeters, cartesianAux);
		point3DDown.set(cartesianAux[0], cartesianAux[1], cartesianAux[2]);
		
		cartesianAux = Globe.geographicToCartesianWgs84(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude + 100.0, cartesianAux);
		point3DUp.set(cartesianAux[0], cartesianAux[1], cartesianAux[2]);
		
		// Down & Up relative points.
		var point3DDownRel = new Point3D();
		var point3DUpRel = new Point3D();
		point3DDownRel = geoLoc.getTransformedRelativePosition(point3DDown, point3DDownRel);
		point3DUpRel = geoLoc.getTransformedRelativePosition(point3DUp, point3DUpRel);
		
		point3DDownRel.pointType = 1;
		point3DUpRel.pointType = 1;
		
		points3dArrayDown[i] = point3DDownRel;
		points3dArrayUp[i] = point3DUpRel;
	}
	
	// Now, make vertexProfiles (down_vtxProfile & up_vtxProfile).
	var vertexProfileDown = this.vtxProfilesList.newVtxProfile();
	var vertexProfileUp = this.vtxProfilesList.newVtxProfile();
	
	vertexProfileDown.makeByPoints3DArray(points3dArrayDown, undefined);
	vertexProfileUp.makeByPoints3DArray(points3dArrayUp, undefined);
	
	// Now, make the mesh.
	if (this.meshPositive === undefined)
	{
		//this.meshTest = 
		var bIncludeBottomCap = true;
		var bIncludeTopCap = true;
		this.mesh = this.vtxProfilesList.getMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
		
		// positive mesh.
		this.meshPositive = this.mesh.getCopySurfaceIndependentMesh(this.meshPositive);
		this.meshPositive.calculateVerticesNormals();
	
		this.meshPositive.setColor(0.1, 0.5, 0.5, 1.0);

		this.meshPositive.getVbo(this.vboKeysContainer, magoManager.vboMemoryManager);
		this.meshPositive.getVboEdges(this.vboKeysContainerEdges, magoManager.vboMemoryManager);
		
		// negative mesh.
		this.meshNegative = this.mesh.getCopySurfaceIndependentMesh(this.meshNegative);
		this.meshNegative.reverseSense(); // here calculates vertices normals.
	
		this.meshNegative.setColor(0.1, 0.5, 0.5, 1.0);

		this.meshNegative.getVbo(this.vboKeysContainer, magoManager.vboMemoryManager);
		this.meshNegative.getVboEdges(this.vboKeysContainerEdges, magoManager.vboMemoryManager);
		
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Excavation.prototype.remakeExtrudeObject = function(magoManager) 
{
	if (this.vtxProfilesList === undefined)
	{ return false; }
	
	// 1rst, set position of this extrude object. Take as position the 1rst geoCoord absolute position.
	// Another possibility is calculate the average point of geoCoords.
	var geoLoc = this.getGeoLocationData();

	// Take the 1rst geographicCoord's geoLocation.
	var geoCoord = this.geoCoordsList.getGeoCoord(0);
	var geoLocDataManagerFirst = geoCoord.getGeoLocationDataManager();
	var geoLocFirst = geoLocDataManagerFirst.getCurrentGeoLocationData();
	geoLoc.copyFrom(geoLocFirst);
	

	// Project the geoCoordList into a plane. Remember that the local coordinate is the 1rst geoCoord.
	// Calculate down & up points of the extrude object.
	var points3dArrayDown = [];
	var points3dArrayUp = [];
	
	if (this.excavationDepthInMeters === undefined)
	{ this.excavationDepthInMeters = 80.0; }
	
	var cartesianAux;
	var geoCoord;
	var geoCoordsCount = this.geoCoordsList.getGeoCoordsCount();
	for (var i=0; i<geoCoordsCount; i++)
	{
		// Current geoCoord.
		geoCoord = this.geoCoordsList.getGeoCoord(i);
		
		// Down & Up absolute points.
		var point3DDown = new Point3D();
		var point3DUp = new Point3D();
		cartesianAux = Globe.geographicToCartesianWgs84(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude - this.excavationDepthInMeters, cartesianAux);
		point3DDown.set(cartesianAux[0], cartesianAux[1], cartesianAux[2]);
		
		cartesianAux = Globe.geographicToCartesianWgs84(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude + 100.0, cartesianAux);
		point3DUp.set(cartesianAux[0], cartesianAux[1], cartesianAux[2]);
		
		// Down & Up relative points.
		var point3DDownRel = new Point3D();
		var point3DUpRel = new Point3D();
		point3DDownRel = geoLoc.getTransformedRelativePosition(point3DDown, point3DDownRel);
		point3DUpRel = geoLoc.getTransformedRelativePosition(point3DUp, point3DUpRel);
		
		point3DDownRel.pointType = 1;
		point3DUpRel.pointType = 1;
		
		points3dArrayDown[i] = point3DDownRel;
		points3dArrayUp[i] = point3DUpRel;
	}
	
	// Now, update vertexProfiles (down_vtxProfile & up_vtxProfile).
	var vertexProfileDown = this.vtxProfilesList.getVtxProfile(0);
	var vertexProfileUp = this.vtxProfilesList.getVtxProfile(1);
	
	vertexProfileDown.updateByPoints3DArray(points3dArrayDown, undefined);
	vertexProfileUp.updateByPoints3DArray(points3dArrayUp, undefined);
	
	var vboMemManager = magoManager.vboMemoryManager;
	//this.meshPositive.deleteVbos(vboMemManager);
	//this.meshNegative.deleteVbos(vboMemManager);
	
	if (this.meshPositive !== undefined)
	{ this.meshPositive.deleteObjects(vboMemManager); }
	
	if (this.meshNegative !== undefined)
	{ this.meshNegative.deleteObjects(vboMemManager); }
	
	this.meshPositive = undefined;
	this.meshNegative = undefined;
	
	// Now, make the mesh.
	
	if (this.meshPositive === undefined)
	{
		//this.meshTest = 
		var bIncludeBottomCap = true;
		var bIncludeTopCap = true;
		this.mesh = this.vtxProfilesList.getMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
		
		// positive mesh.
		this.meshPositive = this.mesh.getCopySurfaceIndependentMesh(this.meshPositive);
		this.meshPositive.calculateVerticesNormals();
		this.meshPositive.setColor(0.1, 0.5, 0.5, 1.0);
		this.meshPositive.getVbo(this.vboKeysContainer, magoManager.vboMemoryManager);
		this.meshPositive.getVboEdges(this.vboKeysContainerEdges, magoManager.vboMemoryManager);
		
		// negative mesh.
		this.meshNegative = this.mesh.getCopySurfaceIndependentMesh(this.meshNegative);
		this.meshNegative.reverseSense(); // here calculates vertices normals.
		this.meshNegative.setColor(0.1, 0.5, 0.5, 1.0);
		this.meshNegative.getVbo(this.vboKeysContainer, magoManager.vboMemoryManager);
		this.meshNegative.getVboEdges(this.vboKeysContainerEdges, magoManager.vboMemoryManager);
		
	}
	
};









































'use strict';

/**
 * The minimum elementary object that constitutes the surface.
 * 표면, Surface의 하위 개념.
 * 실린더를 예를 들면
 * 위 아래 뚜껑은 각각 하나의 Surface이자 face.
 * 옆면은 하나의 Surface에 수십개의 face가 모여있는 구조.
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class Face
 */
var Face = function() 
{
	if (!(this instanceof Face)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * 페이스의 버텍스 리스트
	 * @type {Array.<Vertex>}
	 */
	this.vertexArray;

	/**
	 * 페이스의 임의의 버텍스의 hEdge.
	 * @type {HalfEdge}
	 */
	this.hEdge;

	/**
	 * 페이스의 플레인 노말 포인트.
	 * @type {Point3D}
	 */
	this.planeNormal;

	/**
	 * @deprecated not used
	 */
	this.surfaceOwner;
};

/**
 * delete all member.
 * Note: "Face" is NO-Owner of vertices, so, don't delete vertices. Only set as "undefined".
 * Note: "Face" is NO-Owner of hEdge, so, don't delete hEdge. Only set as "undefined".
 */
Face.prototype.deleteObjects = function()
{
	this.vertexArray = undefined;
	this.hEdge = undefined;
	
	if (this.planeNormal !== undefined)
	{
		this.planeNormal.deleteObjects();
		this.planeNormal = undefined;
	}
	
	this.surfaceOwner = undefined;
};
/**
 * get vertex array length
 * @returns {number} length of this vertexArray.
 */
Face.prototype.getVerticesCount = function()
{
	if (this.vertexArray === undefined)
	{ return 0; }

	return this.vertexArray.length;
};

/**
 * add vertex to this vertexArray
 * @param {Vertex} vertex
 */
Face.prototype.addVertex = function(vertex)
{
	if (this.vertexArray === undefined)
	{ this.vertexArray = []; }
	
	this.vertexArray.push(vertex);
};

/**
 * add vertex array to this vertexArray
 * @param {Array.<Vertex>} vertex
 */
Face.prototype.addVerticesArray = function(verticesArray)
{
	if (this.vertexArray === undefined)
	{ this.vertexArray = []; }
	
	Array.prototype.push.apply(this.vertexArray, verticesArray);
};

/**
 * get vertex
 * @param {number} idx array index.
 * @returns {Vertex|undefined}
 */
Face.prototype.getVertex = function(idx)
{
	if (this.vertexArray === undefined)
	{ return undefined; }

	return this.vertexArray[idx];
};

/**
 * reverse this vertex array.
 */
Face.prototype.reverseSense = function()
{
	this.vertexArray.reverse();
};

/**
 * set color all vertex in vertexArray.
 * @param {number} r
 * @param {number} g
 * @param {number} b
 * @param {number} a
 */
Face.prototype.setColor = function(r, g, b, a)
{
	var vertex;
	var verticesCount = this.getVerticesCount();
	for (var i=0; i<verticesCount; i++)
	{
		vertex = this.getVertex(i);
		vertex.setColorRGBA(r, g, b, a);
	}
};

/**
 * get plane normal point. if this plane normal is undefined or not a number, calculate plane normal.
 * @returns {Point3D} this plane normal point.
 */
Face.prototype.getPlaneNormal = function()
{
	if (this.planeNormal === undefined || this.planeNormal.isNAN())
	{ 
		//this.calculateVerticesNormals(); 
		this.calculatePlaneNormal();
	} 
	
	return this.planeNormal;
};

/**
 * calculate plane normal point using vertex array.
 * @static
 * @param {Array.<Vertex>} vertexArray
 * @param {Point3D} resultPlaneNormal if this is undefined, set new Point3D instance.
 * @returns {Point3D}
 */
Face.calculatePlaneNormal = function(vertexArray, resultPlaneNormal)
{
	// Note: the vertexArray must be planar.
	if (resultPlaneNormal === undefined)
	{ resultPlaneNormal = new Point3D(); }

	resultPlaneNormal.set(0, 0, 0);
	var verticesCount = vertexArray.length;
	for (var i=0; i<verticesCount; i++)
	{
		var prevIdx = VertexList.getPrevIdx(i, vertexArray);
		var startVec = VertexList.getVector(prevIdx, vertexArray, undefined);
		var endVec = VertexList.getVector(i, vertexArray, undefined);
		
		startVec.unitary();
		endVec.unitary();
		
		if (startVec.isNAN() || endVec.isNAN())
		{ continue; }
		
		var crossProd = startVec.crossProduct(endVec, undefined); // Point3D.
		crossProd.unitary(); 
		if (crossProd.isNAN())
		{ continue; }
	
		var scalarProd = startVec.scalarProduct(endVec);
		
		var cosAlfa = scalarProd; // Bcos startVec & endVec are unitaries.
		if (cosAlfa > 1.0)
		{ cosAlfa = 1.0; }
		else if (cosAlfa < -1.0)
		{ cosAlfa = -1.0; }
		var alfa = Math.acos(cosAlfa);
		
		resultPlaneNormal.add(crossProd.x*alfa, crossProd.y*alfa, crossProd.z*alfa);
	}
	resultPlaneNormal.unitary();
	
	return resultPlaneNormal;
};

/**
 * calculate plane normal and set this plane normal.
 * @returns {Point3D} this plane normal point.
 * 
 * @see Face#calculatePlaneNormal
 */
Face.prototype.calculatePlaneNormal = function()
{
	// Note: face must be planar.
	this.planeNormal = Face.calculatePlaneNormal(this.vertexArray, this.planeNormal);
	return this.planeNormal;
};

/**
 * 각 버텍스들의 normal point를 face의 plane normal로 일괄 적용.
 * @param {Boolean} bForceRecalculatePlaneNormal if true, force execute calculatePlaneNormal.
 * 
 * @see Face#calculatePlaneNormal
 */
Face.prototype.calculateVerticesNormals = function(bForceRecalculatePlaneNormal)
{
	// This function calculates normals for concave faces.
	// Provisionally calculate the plane normal and assign to the vertices.
	var verticesCount = this.vertexArray.length;

	if (bForceRecalculatePlaneNormal !== undefined && bForceRecalculatePlaneNormal)
	{ this.calculatePlaneNormal(); }
	
	if (this.planeNormal === undefined)
	{ this.calculatePlaneNormal(); }
	
	var normal;
	var verticesCount = this.getVerticesCount();
	for (var i=0; i<verticesCount; i++)
	{
		//normal = this.vertexArray[i].getNormal();
		//normal.addPoint(this.planeNormal);
		//normal.unitary();
		this.vertexArray[i].setNormal(this.planeNormal.x, this.planeNormal.y, this.planeNormal.z);
	}
};

/**
 * 시작점과 끝점이 매우 가까울 경우 (거의 같은, 0.1mm보다 가까울때.) 끝점을 삭제.
 * "Uroborus" is an archaic motif of a snake biting its own tail.
 * "Uroborus"는 뱀이 자기 꼬리 먹고 있는 모양.
 * This function checks if the 1rst vertex & the last vertex are coincident. If are coincident then remove last one.
 * 
 * @see Point3D#isCoincidentToPoint
 */
Face.prototype.solveUroborus = function()
{
	// "Uroborus" is an archaic motif of a snake biting its own tail.
	// This function checks if the 1rst vertex & the last vertex are coincident. If are coincident then remove last one.
	var verticesCount = this.getVerticesCount();
	if (verticesCount < 3)
	{ return; }
	
	var vertex_str = this.getVertex(0);
	var vertex_end = this.getVertex(verticesCount - 1);
	
	var pos_str = vertex_str.point3d;
	var pos_end = vertex_end.point3d;
	var distError = 0.0001; // 0.1mm of error.
	
	if (pos_str.isCoincidentToPoint(pos_end, distError))
	{
		// remove the last vertex.
		this.vertexArray.pop();
	}
};

/**
 * 표출하기 위해 최적의 plane 타입을 반환.
 * @static
 * @param {Point3D} normal
 * @returns {Number} 0 : plane-xy, 1 : plane-yz, 2: plane-xz
 */
Face.getBestFacePlaneToProject = function(normal)
{
	var best_plane = -1; //"unknown";

	var nx = Math.abs(normal.x);
	var ny = Math.abs(normal.y);
	var nz = Math.abs(normal.z);

	if ( nz > nx && nz >= ny )
 	{
 		best_plane = 0; //"xy";
 	}
 	else if ( nx >= ny && nx >= nz )
 	{
 		best_plane = 1; //"yz";
 	}
 	else if ( ny > nx && ny >= nz )
 	{
 		best_plane = 2; //"xz";
	}

	return best_plane;
};

/**
 * 버텍스 배열을 plane normal에 따라 polygon2d 형식으로 변환 후 반환.
 * @static
 * @param {Array.<Vertex>} vertexArray
 * @param {Point3D} normal
 * @param {Polygon2D} resultProjectedPolygon2d
 * @returns {Polygon2D}
 */
Face.getProjectedPolygon2D = function(vertexArray, normal, resultProjectedPolygon2d)
{
	// Create a temp polygon2d.
	if (resultProjectedPolygon2d === undefined)
	{ resultProjectedPolygon2d = new Polygon2D(); }
	
	if (resultProjectedPolygon2d.point2dList === undefined)
	{ resultProjectedPolygon2d.point2dList = new Point2DList(); }

	var point2dList = resultProjectedPolygon2d.point2dList;
	point2dList.pointsArray =  VertexList.getProjectedPoints2DArray(vertexArray, normal, point2dList.pointsArray);

	return resultProjectedPolygon2d;
};

/**
 * 오목 폴리곤들을 볼록 폴리곤들로 분리 후 반환.
 * concave to convex list.
 * @param {Array.<Triangle>} resultTrianglesArray
 * @returns {Array.<Triangle>}
 */
Face.prototype.getTessellatedTriangles = function(resultTrianglesArray)
{
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }

	var verticesCount = this.getVerticesCount();
	if (verticesCount <= 3)
	{
		// This is a triangle, so no need to tessellate.
		resultTrianglesArray = this.getTrianglesConvex(resultTrianglesArray);
		return resultTrianglesArray;
	}

	// 1rst, must project the face to a plane and process to tessellate in 2d.
	var normal = this.getPlaneNormal();
	
	var bestPlaneToProject = Face.getBestFacePlaneToProject(normal);
	
	// Create a temp polygon2d.
	var polygon2d = Face.getProjectedPolygon2D(this.vertexArray, normal, undefined);
	
	// Now, tessellate the polygon2D.
	// Before tessellate, we must know if there are concavePoints.
	var resultConcavePointsIdxArray;
	resultConcavePointsIdxArray = polygon2d.calculateNormal(resultConcavePointsIdxArray);
	
	var convexPolygonsArray = [];
	polygon2d.tessellate(resultConcavePointsIdxArray, convexPolygonsArray);
	
	// inside of "convexPolygonsArray" there are 1 or more convexPolygons result of tessellation of the polygon2d.

	this.calculateVerticesNormals();
	var convexPolygonsCount = convexPolygonsArray.length;
	for (var i=0; i<convexPolygonsCount; i++)
	{
		var convexPolygon = convexPolygonsArray[i];
		
		if (convexPolygon.point2dList.getPointsCount() === 0)
		{ continue; }
		
		var vertex0, vertex1, vertex2;
		var triangle;
		var point2d_0, point2d_1, point2d_2;
		var point2d_0 = convexPolygon.point2dList.getPoint(0);
		
		vertex0 = point2d_0.ownerVertex3d;
		var point2dCount = convexPolygon.point2dList.getPointsCount();
		for (var j=1; j<point2dCount-1; j++)
		{
			point2d_1 = convexPolygon.point2dList.getPoint(j);
			point2d_2 = convexPolygon.point2dList.getPoint(j+1);
			vertex1 = point2d_1.ownerVertex3d;
			vertex2 = point2d_2.ownerVertex3d;
			triangle = new Triangle(vertex0, vertex1, vertex2);
			
			resultTrianglesArray.push(triangle);
		}
	}
	this.calculateVerticesNormals();
	return resultTrianglesArray;
};

/**
 * 버텍스 배열의 첫번째 배열을 기준으로 삼각형 convex(Triangle)을 생성 후 배열에 담아 반환
 * @param {Array.<Triangle>} resultTrianglesArray undefined일 때, 배열로 초기화.
 * @returns {Array.<Triangle>|undefined} 기존 버텍스 배열이 undefined거나 비어있으면 매개변수 resultTrianglesArray 상태 그대로 반환.
 */
Face.prototype.getTrianglesConvex = function(resultTrianglesArray)
{
	// To call this method, the face MUST be convex.
	if (this.vertexArray === undefined || this.vertexArray.length === 0)
	{ return resultTrianglesArray; }
	
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }
	
	var vertex0, vertex1, vertex2;
	var triangle;
	vertex0 = this.getVertex(0);
	var verticesCount = this.getVerticesCount();
	for (var i=1; i<verticesCount-1; i++)
	{
		vertex1 = this.getVertex(i);
		vertex2 = this.getVertex(i+1);
		triangle = new Triangle(vertex0, vertex1, vertex2);
		resultTrianglesArray.push(triangle);
	}
	
	return resultTrianglesArray;
};

/**
 * Face의 hedge 중 매개변수 hedge와 twin인 것이 있는지 유무 반환.
 * @param {HalfEdge} hedge 
 * @returns {Boolean}
 * 
 * @see HalfEdge#setTwin
 */
Face.prototype.setTwinHalfEdge = function(hedge)
{
	var twined = false;
	var finished = false;
	var startHEdge = this.hEdge;
	var currHEdge = this.hEdge;
	while (!finished)
	{
		if (currHEdge.setTwin(hedge))
		{ return true; }

		currHEdge = currHEdge.next;
		if (currHEdge === startHEdge)
		{ finished = true; }
	}
	return twined;
};

/**
 * Face의 frontier hedge 배열 반환.
 * @param {Array.<HalfEdge>} resultHedgesArray 
 * @returns {Array.<HalfEdge>}
 * 
 * @see HalfEdge#getHalfEdgesLoop
 * @see HalfEdge#isFrontier
 */
Face.prototype.getFrontierHalfEdges = function(resultHedgesArray)
{
	var hedgesArray = this.getHalfEdgesLoop(undefined);
	if (hedgesArray === undefined)
	{ return resultHedgesArray; }
	
	if (resultHedgesArray === undefined)
	{ resultHedgesArray = []; }

	var hedgesCount = hedgesArray.length;
	var hedge;
	for (var i=0; i<hedgesCount; i++)
	{
		hedge = hedgesArray[i];
		if (hedge.isFrontier())
		{
			resultHedgesArray.push(hedge);
		}
	}
	return resultHedgesArray;
};

/**
 * Face의 hedge 배열 반환.
 * @param {Array.<HalfEdge>} resultHedgesArray 
 * @returns {Array.<HalfEdge>}
 * 
 * @see HalfEdge#getHalfEdgesLoop
 */
Face.prototype.getHalfEdgesLoop = function(resultHedgesArray)
{
	if (this.hEdge === undefined)
	{ return resultHedgesArray; }
	
	resultHedgesArray = HalfEdge.getHalfEdgesLoop(this.hEdge, resultHedgesArray);
	return resultHedgesArray;
};

/**
 * 현재 Face와 매개변수 Face의 각각 hedge를 이용하여 twin hedge를 찾아서 twin 유무 반환
 * @param {Face} face Required. Must contain hEdge.
 * @returns {Boolean} is twin face.
 */
Face.prototype.setTwinFace = function(face)
{
	if (face === undefined)
	{ return false; }
	
	if (this.hEdge === undefined || face.hEdge === undefined)
	{ return false; }
	
	var hedgesArray = face.getHalfEdgesLoop(undefined);
	var hedgesCount = hedgesArray.length;
	var hedge;
	var twined = false;
	for (var i=0; i<hedgesCount; i++)
	{
		hedge = hedgesArray[i];
		if (this.setTwinHalfEdge(hedge))
		{ twined = true; }
	}
	
	return twined;
};

/**
 * 버텍스 배열의 각각 버텍스의 hedge를 설정(next hedge도 설정) 후 배열에 담아서 반환. 
 * 반환배열의 첫번째 요소(HalfEdge, resultHalfEdgesArray[0])는 this.hEdge로 설정
 * @param {Array.<HalfEdge>|undefined} resultHalfEdgesArray
 * @returns {Array.<HalfEdge>}
 */
Face.prototype.createHalfEdges = function(resultHalfEdgesArray)
{
	if (this.vertexArray === undefined || this.vertexArray.length === 0)
	{ return resultHalfEdgesArray; }
	
	if (resultHalfEdgesArray === undefined)
	{ resultHalfEdgesArray = []; }
	
	var vertex;
	var hedge;
	var verticesCount = this.getVerticesCount();
	
	// 1rst, create the half edges.
	for (var i=0; i<verticesCount; i++)
	{
		vertex = this.getVertex(i);
		hedge = new HalfEdge();
		hedge.setStartVertex(vertex);
		hedge.setFace(this);
		resultHalfEdgesArray.push(hedge);
	}
	
	// now, for all half edges, set the nextHalfEdge.
	var nextHedge;
	var nextIdx;
	for (var i=0; i<verticesCount; i++)
	{
		hedge = resultHalfEdgesArray[i];
		nextIdx = VertexList.getNextIdx(i, this.vertexArray);
		nextHedge = resultHalfEdgesArray[nextIdx];
		hedge.setNext(nextHedge);
	}
	
	// set a hedge for this face.
	this.hEdge = resultHalfEdgesArray[0];
	
	return resultHalfEdgesArray;
};






















































'use strict';

/**
 * 특정 버텍스로 부터의 방향을 가진 테두리. 
 * 트윈과 넥스트를 함께 가지는 구조로 이뤄져있음.
 * 트윈은 해당 테두리의 반대 방향 테두리.
 * 넥스트는 현재 테두리의 다음 테두리. 방향은 같음.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class HalfEdge
 */
var HalfEdge = function() 
{
	if (!(this instanceof HalfEdge)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * start vertex of this edge.
	 * @type {Vertex}
	 */
	this.startVertex;

	/**
	 * next edge of this edge.
	 * @type {HalfEdge}
	 */
	this.next;

	/**
	 * opposite direction edge of this edge.
	 * @type {HalfEdge}
	 */
	this.twin;

	/**
	 * the face of include this edge.
	 * @type {Face}
	 */
	this.face;
};

/**
 * delete all member.
 * Note: "HalfEdge" is NO-Owner of the contents, so, don't delete contents. Only set as "undefined".|
 */
HalfEdge.prototype.deleteObjects = function()
{
	this.startVertex = undefined;
	this.next = undefined;
	this.twin = undefined;
	this.face = undefined;
};

/**
 * set start vertex. this vertex's outingHedge set this edge.
 * @param {Vetex}
 */
HalfEdge.prototype.setStartVertex = function(vertex)
{
	this.startVertex = vertex;
	vertex.outingHedge = this;
};

/**
 * set next hedge
 * @param {HalfEdge}
 */
HalfEdge.prototype.setNext = function(hedge)
{
	this.next = hedge;
};

/**
 * if this param hedge is twinable this hedge, set twin hedge.
 * if twinable, param hedge.twin set this hedge.
 * @param {HalfEdge}
 * 
 * @see HalfEdge#areTwinables
 */
HalfEdge.prototype.setTwin = function(hedge)
{
	var isTwinable = HalfEdge.areTwinables(hedge, this);
	if (isTwinable)
	{
		this.twin = hedge;
		hedge.twin = this;
	}
	return isTwinable;
};

/**
 * set Face.
 * @param {Face}
 */
HalfEdge.prototype.setFace = function(face)
{
	this.face = face;
};

/**
 * get end vertex.
 * @returns {Vertex|undefined} if this next is undefined, can't get end vertex. so return undefined.
 */
HalfEdge.prototype.getEndVertex = function()
{
	if (this.next === undefined)
	{ return undefined; }
	
	return this.next.startVertex;
};

/**
 * is this hedge frontier?
 * @returns {Boolean} if this twin is undefined or null, return true;
 */
HalfEdge.prototype.isFrontier = function()
{
	if (this.twin === undefined || this.twin === null)
	{ return true; }
	
	return false;
};

/**
 * get prev hedge.
 * half edge의 next를 계속 찾아서 현재 edge와 특정 테두리의 next가 일치할때 특정테두리를 반환.
 * @deprecated not use
 * @returns {HalfEdge|undefined}  if next is not define, return undefined.
 */
HalfEdge.prototype.getPrev = function()
{
	var currHedge = this;
	var prevHedge;
	var finished = false;
	while (!finished)
	{
		/**
		 * @todo check this compare is possible.
		 */
		if (currHedge.next === this)
		{ return currHedge; }
		
		if (currHedge.next === undefined)
		{ return undefined; }
		
		currHedge = currHedge.next;
	}
	
	return undefined;
};

/**
 * 매개변수로 받은 두 edge가 서로 twinable한 상황인지 체크.
 * @static
 * @param {HalfEdge} hedgeA
 * @param {HalfEdge} hedgeB
 * @returns {Boolean}  각각의 시작 vertex와 마지막 vertex가 동일한지 비교하여 둘다 동일 할 경우 true 반환.
 */
HalfEdge.areTwinables = function(hedgeA, hedgeB)
{
	// check if "hedgeA" is twinable with "hedgeB".
	if (hedgeA.startVertex === hedgeB.getEndVertex())
	{
		if (hedgeA.getEndVertex() === hedgeB.startVertex)
		{ return true; }
	}
	
	return false;
};

/**
 * 연결된 테두리들을 찾아 배열로 반환.
 * @static
 * @param {HalfEdge} hedge Required. if undefined, return original resultHedgesArray.
 * @param {Array|undefined} resultHedgesArray
 * @returns {Array.<HalfEdge>}
 */
HalfEdge.getHalfEdgesLoop = function(hedge, resultHedgesArray)
{
	if (hedge === undefined)
	{ return resultHedgesArray; }
	
	if (resultHedgesArray === undefined)
	{ resultHedgesArray = []; }
	
	resultHedgesArray.length = 0; // init the array.
	
	var startHedge = hedge;
	var currHedge = hedge;
	var finished = false;
	while (!finished)
	{
		resultHedgesArray.push(currHedge);
		currHedge = currHedge.next;
		if (currHedge === startHedge || currHedge === undefined)
		{ finished = true; }
	}
	
	return resultHedgesArray;
};

'use strict';

/**
 * HalfEdge객체의 리스트
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class HalfEdgesList
 */
var HalfEdgesList = function() 
{
	if (!(this instanceof HalfEdgesList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * @type {Array.<HalfEdge>}
	 */
	this.hEdgesArray;
};

/**
 * hEdgesArray 초기화
 */
HalfEdgesList.prototype.deleteObjects = function()
{
	if (this.hEdgesArray !== undefined)
	{
		var hedgesCount = this.hEdgesArray.length;
		for (var i=0; i<hedgesCount; i++)
		{
			this.hEdgesArray[i].deleteObjects();
			this.hEdgesArray[i] = undefined;
		}
		this.hEdgesArray = undefined;
	}
};

/**
 * 새로 HalfEdge 인스턴스를 생성하여 hEdgesArray에 추가한다.
 * @returns {HalfEdge} 새로 생성된 HalfEdge인스턴스를 반환.
 */
HalfEdgesList.prototype.newHalfEdge = function()
{
	if (this.hEdgesArray === undefined)
	{ this.hEdgesArray = []; }
	
	var hedge = new HalfEdge();
	this.hEdgesArray.push(hedge);
	return hedge;
};

/**
 * 기존 멤버 변수 hEdgesArray에 HalfEdge들을 추가.
 * @param {Array.<HalfEdge>} HalfEdge Required. HalfEdge들의 배열
 */
HalfEdgesList.prototype.addHalfEdgesArray = function(hEdgesArray)
{
	if (hEdgesArray === undefined)
	{ return; }
	
	if (this.hEdgesArray === undefined)
	{ this.hEdgesArray = []; }
	
	Array.prototype.push.apply(this.hEdgesArray, hEdgesArray);
};
'use strict';
/**
* 폴리곤을 구성하는 포인트의 인덱스데이터 객체
* Rind2D의 getPolygon 수행 시 인스턴스를 생성하여 각 포인트에 설정함.
* owner는 Ring2D instance로 설정.
*
* @exception {Error} Messages.CONSTRUCT_ERROR
* @class IndexData
*
* @see Ring2D#getPolygon
*/
var IndexData = function() 
{
	if (!(this instanceof IndexData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * 포인트를 포함하는 Ring2D 객체
	 * @type {Ring2D}
	 */
	this.owner;

	/**
	 * 포인트의 idxInList
	 * @deprecated idx 대신 idxInList로 사용되고 있음. 변경 필요
	 * @type {Number}
	 */
	this.idx;
};

/**
 * delete the value of owner and idx.
 */
IndexData.prototype.deleteObjects = function() 
{
	// Don't delete objects. Only assign as undefined.
	this.owner = undefined;
	this.idx = undefined;
};
'use strict';

/**
 * index range. consist of two vertex index. start and end.
 * 특정 geometry의 시작vertex와 끝vertex의 index를 저장
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class IndexRange
 */
var IndexRange = function() 
{
	if (!(this instanceof IndexRange)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * start index
	 * @type {Number}
	 */
	this.strIdx;

	/**
	 * last index
	 * @type {Number}
	 */
	this.endIdx;
};

/**
 * make indexRange copy from another indexRange.
 * @param {IndexRange} indexRange 
 */
IndexRange.prototype.copyFrom = function(indexRange)
{
	if (indexRange === undefined)
	{ return; }
	
	this.strIdx = indexRange.strIdx;
	this.endIdx = indexRange.endIdx;
};

/**
 * indexRange init.
 * all member set undifined;
 */
IndexRange.prototype.deleteObjects = function()
{
	this.strIdx = undefined;
	this.endIdx = undefined;
};
'use strict';
/**
 * 교차 판단값
 * 한 객체가 다른 한 객체에 완전히 안쪽에 포함된 경우: INSIDE
 * 한 객체가 다른 한 객체에 일부는 안쪽에 포함되고 일부는 바깥쪽에 포함된 경우: INTERSECT
 * 한 객체가 다른 한 객체에 완전히 바깥쪽에 있는 경우: OUTSIDE
 * A 지점에 포함된 경우: POINT_A
 * B 지점에 포함된 경우: POINT_B
 * 
 * @enum
 */
var Intersect = {
	/**
     * 한 객체가 다른 한 객체에 완전히 바깥쪽에 존재함
     * @type {Number}
     * @constant
     */
	OUTSIDE: 0,
    
	/**
     * 한 객체가 다른 한 객체의 일부분만 포함
     * @type {Number}
     * @constant
     */
	INTERSECT: 1,
    
	/**
     * 한 객체가 다른 한 객체를 완전히 포함
     * @type {Number}
     * @constant
     */
	INSIDE: 2,
    
	/**
     * A 지점에 포함
     * @type {Number}
     * @constant
     */
	POINT_A: 3,
    
	/**
     * B 지점에 포함
     * @type {Number}
     * @constant
     */
	POINT_B: 4
};
'use strict';

/**
 * This represents a line which can be shown as linear equation
 * @class Line
 * @param {Point3D} point the point which decides line
 * @param {Point3D} direction the vector of the direction which decides line
 */
var Line = function(point, direction) 
{
	if (!(this instanceof Line)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// (x,y,z) = (x0,y0,z0) + lambda * (u, v, w);
	if (point !== undefined)
	{ this.point = point; }
	else
	{ this.point = new Point3D(); }
	
	if (direction !== undefined)
	{ this.direction = direction; }
	else
	{ this.direction = new Point3D(); }
};

/**
 * Set a point and a direction of a linear equation
 * @param px 변수 the value of x coordi of the point
 * @param py 변수 the value of y coordi of the point
 * @param pz 변수 the value of z coordi of the point
 * @param dx 변수 the value of x coordi of the point which represents direction
 * @param dy 변수 the value of y coordi of the point which represents direction
 * @param dz 변수 the value of z coordi of the point which represents direction
 */
Line.prototype.setPointAndDir = function(px, py, pz, dx, dy, dz) 
{
	// Note: dx, dy, dz must be unitary.
	this.point.set(px, py, pz);
	this.direction.set(dx, dy, dz);
	this.direction.unitary();
};

/**
 * get the point which is projected as 2d plane(the plane which is represented by using x,y axis)
 * @param point the target point 
 * @param projectedPoint the projected point of the target point
 * @returns projetedPoint
 */
Line.prototype.getProjectedPoint = function(point, projectedPoint) 
{
	if (projectedPoint === undefined)
	{ projectedPoint = new Point3D(); }
	
	var plane = new Plane();
	plane.setPointAndNormal(point.x, point.y, point.z, this.direction.x, this.direction.y, this.direction.z);
	projectedPoint = plane.intersectionLine(this, projectedPoint);
	
	return projectedPoint;
};

/**
 * Check whether the given point is on this line or not
 * @param {Point3D} point the given point
 * @param {Number} error the error rate which can be handdled
 * @returns {Boolean} 
 */
Line.prototype.isCoincidentPoint = function(point, error) 
{
	if (point === undefined)
	{ return false; }
	
	var projectedPoint = this.getProjectedPoint(point);
	
	if (projectedPoint === undefined)
	{ return false; }
	
	if (error === undefined)
	{ error = 10E-8; }
	
	var squaredDist = projectedPoint.squareDistToPoint(point);
	
	if (squaredDist < error*error)
	{ return true; }
	
	return false;
};


















































'use strict';

/**
 * 선
 * @class Line2D
 */
var Line2D = function() 
{
	if (!(this instanceof Line2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// (x,y) = (x0,y0) + lambda * (u, v);
	this.point = new Point2D();
	this.direction = new Point2D();
};

/**
 * set the needed value of this line with a point and a direction value
 * @param px the value of x coordi of this line
 * @param py the value of y coordi of this line
 * @param dx the value of x direction of this line
 * @param dy the value of y direction of this line
 */
Line2D.prototype.setPointAndDir = function(px, py, dx, dy) 
{
	this.point.set(px, py);
	this.direction.set(dx, dy);
	this.direction.unitary();
};

/** 
 * Get the perpendicular direction of the line in right-handed coordinate system
 * @param {Point2D} point target point
 * @returns {Line2D} perpendicular the perpendicular direction 
 */
Line2D.prototype.getPerpendicularRight = function(point) 
{
	var perpendicular = new Line2D();
	
	if (point)
	{ perpendicular.point.set(point.x, point.y); }
	else
	{ perpendicular.point.set(this.point.x, this.point.y); }
	
	perpendicular.direction.set(this.direction.y, -this.direction.x);
	return perpendicular;
};

/**
 * Get the perpendicular direction of the line in left-handed coordinate system
 * @param {Point2D} pointt target point
 * @returns {Line2D} perpendicular the perpendicular direction 
 */
Line2D.prototype.getPerpendicularLeft = function(point) 
{
	var perpendicular = new Line2D();
	
	if (point)
	{ perpendicular.point.set(point.x, point.y); }
	else
	{ perpendicular.point.set(this.point.x, this.point.y); }
	
	perpendicular.direction.set(-this.direction.y, this.direction.x);
	return perpendicular;
};

/**
 * Return the point which is projected as perpendicular way to the line
 * @param {Point2D} point the given point
 * @param {Point2D} projectedPoint the result of the projection to the line
 * @returns {Point2D} projectedPoint
 * 
 */
Line2D.prototype.getProjectedPoint = function(point, projectedPoint) 
{
	if (point === undefined)
	{ return undefined; }
	
	if (projectedPoint === undefined)
	{ projectedPoint = new Point2D(); }
	
	var perpendicular = this.getPerpendicularLeft(point);
	projectedPoint = this.intersectionWithLine(perpendicular, projectedPoint);
	
	return projectedPoint;
};

/**
 * Check whether the given point is on this line or not
 * @param {Point2D} point the given point
 * @param {Number} error the error rate which can be handdled
 * @returns {Boolean} 
 */
Line2D.prototype.isCoincidentPoint = function(point, error) 
{
	if (point === undefined)
	{ return false; }
	
	if (error === undefined)
	{ error = 10E-8; }
	
	var projectedPoint = this.getProjectedPoint(point, projectedPoint);
	var squaredDist = point.squareDistToPoint(projectedPoint);
	
	if (squaredDist < error*error)
	{ return true; }

	return false;
};

/**
 * Check whether the given line is parallel to this line or not
 * @param {Line2D} line
 * @returns {Boolean}
 */
Line2D.prototype.isParallelToLine = function(line) 
{
	if (line === undefined)
	{ return false; }
	
	var zero = 10E-10;
	var angRad = this.direction.angleRadToVector(line.direction);
	
	// if angle is zero or 180 degree, then this is parallel to "line".
	if (angRad < zero || Math.abs(angRad - Math.PI) < zero)
	{ return true; }
	
	return false;
};

/**
 * Get the intersection point with given line
 * @param {Line2D} line
 * @param {Point2D} resultIntersectPoint
 * @returns {Point2D} resultIntersectPoint
 */
Line2D.prototype.intersectionWithLine = function(line, resultIntersectPoint) 
{
	if (line === undefined)
	{ return undefined; }
	
	// 1rst, check that this is not parallel to "line".
	if (this.isParallelToLine(line))
	{ return undefined; }
	
	// now, check if this or "line" are vertical or horizontal.
	var intersectX;
	var intersectY;
	
	var zero = 10E-10;
	if (Math.abs(this.direction.x) < zero)
	{
		// this is a vertical line.
		var slope = line.direction.y / line.direction.x;
		var b = line.point.y - slope * line.point.x;
		
		intersectX = this.point.x;
		intersectY = slope * this.point.x + b;
	}
	else if (Math.abs(this.direction.y) < zero)
	{
		// this is a horizontal line.
		// must check if the "line" is vertical.
		if (Math.abs(line.direction.x) < zero)
		{
			// "line" is vertical.
			intersectX = line.point.x;
			intersectY = this.point.y;
		}
		else 
		{
			var slope = line.direction.y / line.direction.x;
			var b = line.point.y - slope * line.point.x;
			
			intersectX = (this.point.y - b)/slope;
			intersectY = this.point.y;
		}	
	}
	else 
	{
		// this is oblique.
		if (Math.abs(line.direction.x) < zero)
		{
			// "line" is vertical.
			var mySlope = this.direction.y / this.direction.x;
			var myB = this.point.y - mySlope * this.point.x;
			intersectX = line.point.x;
			intersectY = line.point.x * mySlope + myB;
		}
		else 
		{
			var mySlope = this.direction.y / this.direction.x;
			var myB = this.point.y - mySlope * this.point.x;
			
			var slope = line.direction.y / line.direction.x;
			var b = line.point.y - slope * line.point.x;
			
			intersectX = (myB - b)/ (slope - mySlope);
			intersectY = slope * intersectX + b;
		}
	}
	
	if (resultIntersectPoint === undefined)
	{ resultIntersectPoint = new Point2D(); }
	
	resultIntersectPoint.set(intersectX, intersectY);
	return resultIntersectPoint;
};















































'use strict';


/**
 * Under implementation
 * @class MagoNativeProject
 */
var MagoNativeProject = function() 
{
	if (!(this instanceof MagoNativeProject)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// This is a "ParametricMeshes" composition.
	this.meshesArray;
	this.geoLocDataManager;
	this.vboKeysContainer; // class: VBOVertexIdxCacheKeysContainer
};

MagoNativeProject.prototype.newParametricMesh = function()
{
	if (this.meshesArray === undefined)
	{ this.meshesArray = []; }
	
	var parametricMesh = new ParametricMesh();
	this.meshesArray.push(parametricMesh);
	return parametricMesh;
};

MagoNativeProject.prototype.deleteObjects = function()
{
	if (this.meshesArray === undefined)
	{ return; }
	
	var parametricMeshesCount = this.meshesArray.length;
	for (var i=0; i<parametricMeshesCount; i++)
	{
		this.meshesArray[i].deleteObjects();
		this.meshesArray[i] = undefined;
	}
	this.meshesArray = undefined;
	
	if (this.geoLocDataManager)
	{ this.geoLocDataManager.deleteObjects(); }
	
	this.geoLocDataManager = undefined;
};

MagoNativeProject.prototype.getMeshesCount = function()
{
	if (this.meshesArray === undefined)
	{ return 0; }
	
	return this.meshesArray.length;
};

MagoNativeProject.prototype.getMesh = function(idx)
{
	if (this.meshesArray === undefined)
	{ return undefined; }
	
	return this.meshesArray[idx];
};

















































'use strict';

/**
 * Under implementation
 * Top class on Mago3D.
 * Handling mouse event and send it to MouseAction
 * @class MagoWorld
 * @param {MagoManager} magoManager
 */
var MagoWorld = function(magoManager) 
{
	if (!(this instanceof MagoWorld)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.magoManager = magoManager;
};

/**
 * 시각화 준비 함수
 */
MagoWorld.prototype.prepareVisibles = function()
{
	// 1rst, do terrain frustum culling.
	// TODO:
};

/**
 * 첫 번째 시야를 그릴 준비
 */
MagoWorld.prototype.renderScene = function()
{
	//this.renderTest();
	var gl = this.magoManager.sceneState.gl;
	gl.clearColor(0.0, 0.0, 0.0, 1.0);
	gl.enable(gl.DEPTH_TEST);
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	this.magoManager.start(undefined, true, 0, 1);
};

/**
 * 첫 번째 시야를 그릴 준비
 * @TODO : 리팩토링 필요
 */
MagoWorld.prototype.renderTest = function()
{
	var gl = this.magoManager.sceneState.gl;
	gl.clearColor(0.0, 0.0, 0.0, 1.0);
	gl.enable(gl.DEPTH_TEST);
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	this.magoManager.start(undefined, true, 0, 1);
	
};

/**
 * 카메라를 지구의 특정 위치에 위치시키는 함수
 * @param {Number} longitude 
 * @param {Number} latitude
 * @param {Number} altitude 
 */
MagoWorld.prototype.goto = function(longitude, latitude, altitude)
{
	var resultCartesian;
	resultCartesian = Globe.geographicToCartesianWgs84(longitude, latitude, altitude, resultCartesian);
	
	var camera = this.magoManager.sceneState.camera;
	var camPos = camera.position;
	var camDir = camera.direction;
	var camUp = camera.up;
	
	var matrixAux;
	matrixAux = this.magoManager.globe.transformMatrixAtCartesianPointWgs84(resultCartesian[0], resultCartesian[1], resultCartesian[2], matrixAux);
	
	camPos.set(resultCartesian[0], resultCartesian[1], resultCartesian[2]);
	
	// calculate camDir & camUp.
	camDir.set(-matrixAux[8], -matrixAux[9], -matrixAux[10]);
	camUp.set(matrixAux[4], matrixAux[5], matrixAux[6]); // tangent north direction.
	
	this.updateModelViewMatrixByCamera(camera);
};

/**
 * 마우스 꾹 누르는 동작을 핸들링
 * @param {type}event 
 */
MagoWorld.prototype.mousedown = function(event)
{
	this.magoManager.sceneState.mouseButton = event.button;
	MagoWorld.updateMouseStartClick(event.clientX, event.clientY, this.magoManager);
	this.magoManager.isCameraMoving = true;
	
};

/**
 * 마우스 클릭 위치를 최신으로 갱신
 * @param {Number} mouseX 최신 마우스 클릭 위치의 x 좌표
 * @param {Number} mouseY 최신 마우스 클릭 위치의 y 좌표
 * @param {MagoManager} magoManager
 * 
 */

MagoWorld.updateMouseClick = function(mouseX, mouseY, magoManager)
{
	var mouseAction = magoManager.sceneState.mouseAction;
	mouseAction.curX = mouseX;
	mouseAction.curY = mouseY;
};

/**
 * 마우스를 드래그하기 시작하는 시점을 저장
 * @param {Number} mouseX the x coordi of the start point 
 * @param {Number} mouseY the y coordi of the start point
 * @param {MagoManager} magoManager
 */
MagoWorld.updateMouseStartClick = function(mouseX, mouseY, magoManager)
{
	var gl = magoManager.sceneState.gl;
	var mouseAction = magoManager.sceneState.mouseAction;
	
	MagoWorld.updateMouseClick(mouseX, mouseY, magoManager);
	
	// if button = 1 (middleButton), then rotate camera.
	mouseAction.strX = mouseX;
	mouseAction.strY = mouseY;
	if (magoManager.sceneState.mouseButton === 0)
	{
		magoManager.bPicking = true;
	}
	
	// determine world position of the X,Y.
	mouseAction.strLinealDepth = ManagerUtils.calculatePixelLinearDepth(gl, mouseAction.strX, mouseAction.strY, magoManager.depthFboAux, magoManager);
	mouseAction.strCamCoordPoint = ManagerUtils.calculatePixelPositionCamCoord(gl, mouseAction.strX, mouseAction.strY, mouseAction.strCamCoordPoint, magoManager.depthFboAux, undefined, magoManager);
	mouseAction.strWorldPoint = ManagerUtils.cameraCoordPositionToWorldCoord(mouseAction.strCamCoordPoint, mouseAction.strWorldPoint, magoManager);
	
	// now, copy camera to curCamera.
	var camera = magoManager.sceneState.camera;
	var strCamera = mouseAction.strCamera;
	
	strCamera.copyPosDirUpFrom(camera);
	
	// copy modelViewMatrix.
	var modelViewMatrix = magoManager.sceneState.modelViewMatrix;
	var modelViewMatrixInv = magoManager.sceneState.modelViewMatrixInv;
	mouseAction.strModelViewMatrix._floatArrays = glMatrix.mat4.copy(mouseAction.strModelViewMatrix._floatArrays, modelViewMatrix._floatArrays);
	mouseAction.strModelViewMatrixInv._floatArrays = glMatrix.mat4.copy(mouseAction.strModelViewMatrixInv._floatArrays, modelViewMatrixInv._floatArrays);

	// save the sphere pick.
	if (magoManager.globe !== undefined)
	{
		var camRay;
		camRay = ManagerUtils.getRayWorldSpace(gl, mouseX, mouseY, camRay, magoManager); // rayWorldSpace.
		mouseAction.strWorldPoint2 = magoManager.globe.intersectionLineWgs84(camRay, mouseAction.strWorldPoint2);
	}
};

/**
 * 만약 마우스 핸들링으로 화면이 바뀌었을 경우, 다음 함수가 활성화 된다
 * @param {Camera} camera
 */
MagoWorld.prototype.updateModelViewMatrixByCamera = function(camera)
{
	var camera = this.magoManager.sceneState.camera;
	var camPos = camera.position;
	var camDir = camera.direction;
	var camUp = camera.up;
	var far = camera.frustum.far[0];
	
	var tergetX = camPos.x + camDir.x * far;
	var tergetY = camPos.y + camDir.y * far;
	var tergetZ = camPos.z + camDir.z * far;
	
	var modelViewMatrix = this.magoManager.sceneState.modelViewMatrix;																	
	modelViewMatrix._floatArrays = Matrix4.lookAt(modelViewMatrix._floatArrays, [camPos.x, camPos.y, camPos.z], 
		[tergetX, tergetY, tergetZ], 
		[camUp.x, camUp.y, camUp.z]);

};

/**
 * 마우스를 꾹 눌렀다가 땔 때의 동작을 감지
 * @param {type}event 
 * 
 */
MagoWorld.prototype.mouseup = function(event)
{
	this.magoManager.sceneState.mouseButton = -1;
	this.magoManager.bPicking = false;
	this.magoManager.isCameraMoving = false;
};

/**
 * 마우스 클릭 동작을 감지
 * @param {type}event 
 */
MagoWorld.prototype.mouseclick = function(event)
{
	if (event.button === 0)
	{
		var mouseX = event.clientX;
		var mouseY = event.clientY;
		this.magoManager.mouseActionLeftClick(mouseX, mouseY);
	}
};

/**
 * 마우스 휠 동작을 감지
 * @param {type}event 
 */
MagoWorld.prototype.mousewheel = function(event)
{
	var delta = event.wheelDelta / 10;
	
	var mouseAction = this.magoManager.sceneState.mouseAction;
	
	// move camera.
	var camera = this.magoManager.sceneState.camera;
	var camPos = camera.position;
	var camDir = camera.direction;
	var camUp = camera.up;
	
	var camHeght = camera.getCameraElevation();

	if (isNaN(camHeght))
	{ return; }

	// Lineal increment.
	//delta *= camHeght * 0.003;
	
	// Squared increment.
	delta *= (camHeght*camHeght) * 0.00001 + camHeght * 0.001;
	delta += 1;
	
	var maxDelta = 200000;
	if (delta < -maxDelta)
	{ delta = -maxDelta; }
	
	if (delta > maxDelta)
	{ delta = maxDelta; }
	
	camPos.add(camDir.x * delta,  camDir.y * delta,  camDir.z * delta);
	
	this.updateModelViewMatrixByCamera(camera);
};

/**
 * 어떻게 화면을 변화시키는지를 처리할 수 있다. 마우스 왼쪽 또는 마우스 휠로 회전 가능.
 */
MagoWorld.prototype.mousemove = function(event)
{
	var mouseAction = this.magoManager.sceneState.mouseAction;
	if (this.magoManager.sceneState.mouseButton === 0)
	{
		// left button pressed.
		var gl = this.magoManager.sceneState.gl;
		var sceneState = this.magoManager.sceneState;
		var strCamera = mouseAction.strCamera; // camera of onMouseDown.
		var camera = this.magoManager.sceneState.camera;
		
		// now, calculate the angle and the rotationAxis.
		var strWorldPoint = mouseAction.strWorldPoint;
		var strEarthRadius = strWorldPoint.getModul();
		var nowX = event.clientX;
		var nowY = event.clientY;
		if (nowX === mouseAction.strX && nowY === mouseAction.strY)
		{ return; }
		
		var nowPoint;
		var camRay, camRayCamCoord;
		
		camRayCamCoord = ManagerUtils.getRayCamSpace(nowX, nowY, camRayCamCoord, this.magoManager);
		
		// Now calculate rayWorldCoord.
		if (this.pointSC === undefined)
		{ this.pointSC = new Point3D(); }
		
		this.pointSC.set(camRayCamCoord[0], camRayCamCoord[1], camRayCamCoord[2]);

		// Now, must transform this posCamCoord to world coord, but with the "mouseAction.strModelViewMatrixInv".
		var mv_inv = mouseAction.strModelViewMatrixInv;
		this.pointSC2 = mv_inv.rotatePoint3D(this.pointSC, this.pointSC2); // rayWorldSpace.
		this.pointSC2.unitary(); // rayWorldSpace.
		camRay = new Line();
		camRay.setPointAndDir(strCamera.position.x, strCamera.position.y, strCamera.position.z,       this.pointSC2.x, this.pointSC2.y, this.pointSC2.z);// original.
		// end calculate camRayWorldCoord.---------------
		
		var nowWorldPoint;
		nowWorldPoint = this.magoManager.globe.intersectionLineWgs84(camRay, nowWorldPoint, strEarthRadius);

		if (nowWorldPoint === undefined)
		{ return; }

		var strPoint = new Point3D(strWorldPoint.x, strWorldPoint.y, strWorldPoint.z); // copy point3d.
		var nowPoint = new Point3D(nowWorldPoint[0], nowWorldPoint[1], nowWorldPoint[2]);
		
		var rotAxis;
		rotAxis = strPoint.crossProduct(nowPoint, rotAxis);
		rotAxis.unitary();
		if (rotAxis.isNAN())
		{ return; }
		
		var angRad = strPoint.angleRadToVector(nowPoint);
		if (angRad === 0 || isNaN(angRad))
		{ return; }
		
		// recalculate position and direction of the camera.
		camera.copyPosDirUpFrom(strCamera);
	
		var rotMat = new Matrix4();
		rotMat.rotationAxisAngRad(-angRad, rotAxis.x, rotAxis.y, rotAxis.z);
		camera.transformByMatrix4(rotMat);

		this.updateModelViewMatrixByCamera(camera);
	}
	else if (this.magoManager.sceneState.mouseButton === 1)
	{
		// middle button pressed.
		var strCamera = mouseAction.strCamera;
		var camera = this.magoManager.sceneState.camera;
		camera.copyPosDirUpFrom(strCamera);
		var camPos = camera.position;
		var camDir = camera.direction;
		var camUp = camera.up;
		
		// 1rst, determine the point of rotation.
		var rotPoint = mouseAction.strWorldPoint;
		
		// now determine the rotation axis.
		// the rotation axis are the camRight & normalToSurface.
		if (this.magoManager.globe === undefined)
		{ this.magoManager.globe = new Globe(); }
		
		var pivotPointNormal;
		pivotPointNormal = this.magoManager.globe.normalAtCartesianPointWgs84(rotPoint.x, rotPoint.y, rotPoint.z, pivotPointNormal);
		
		var xAxis = camera.getCameraRight();
		
		// now determine camZRot & camXRot angles.
		var nowX = event.clientX;
		var nowY = event.clientY;
		var increX = nowX - mouseAction.strX;
		var increY = nowY - mouseAction.strY;
		
		var zRotAngRad = increX * 0.003;
		var xRotAngRad = increY * 0.003;
		
		if (zRotAngRad === 0 && xRotAngRad === 0)
		{ return; }
		
		if (this.rotMatX === undefined)
		{ this.rotMatX = new Matrix4(); }
		
		if (this.rotMatZ === undefined)
		{ this.rotMatZ = new Matrix4(); }
		
		if (this.rotMat === undefined)
		{ this.rotMat = new Matrix4(); }
	
		this.rotMatX.rotationAxisAngRad(-xRotAngRad, xAxis.x, xAxis.y, xAxis.z);
		this.rotMatZ.rotationAxisAngRad(-zRotAngRad, pivotPointNormal[0], pivotPointNormal[1], pivotPointNormal[2]);
		this.rotMat = this.rotMatX.getMultipliedByMatrix(this.rotMatZ, this.rotMat);
		
		var translationVec_1 = new Point3D(-rotPoint.x, -rotPoint.y, -rotPoint.z);
		var translationVec_2 = new Point3D(rotPoint.x, rotPoint.y, rotPoint.z);
		
		camera.translate(translationVec_1);
		camera.transformByMatrix4(this.rotMat);
		camera.translate(translationVec_2);
		
		this.updateModelViewMatrixByCamera(camera);
	}
};

/**
 *
 *
 * @param {*} event
 */
MagoWorld.prototype.keydown = function(event)
{
	// TODO: keydown()
	console.log("keydown");
};





























'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Mesh
 */
var Mesh = function() 
{
	if (!(this instanceof Mesh)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.vertexList;
	this.surfacesArray;
	this.hedgesList;
	
	this.vboKeysContainer;
};

Mesh.prototype.deleteObjects = function(vboMemManager)
{
	if (this.vertexList !== undefined)
	{
		this.vertexList.deleteObjects();
	}
	
	if (this.surfacesArray !== undefined)
	{
		var surfacesCount = this.surfacesArray.length;
		for (var i=0; i<surfacesCount; i++)
		{
			this.surfacesArray[i].deleteObjects();
			this.surfacesArray[i] = undefined;
		}
		this.surfacesArray = undefined;
	}
	
	if (this.hedgesList !== undefined)
	{
		this.hedgesList.deleteGlObjects();
		this.hedgesList = undefined;
	}
	
	if (this.vboKeysContainer !== undefined)
	{
		this.vboKeysContainer.deleteGlObjects(vboMemManager.gl, vboMemManager);
		this.vboKeysContainer = undefined;
	}
};

Mesh.prototype.deleteVbos = function(vboMemManager)
{
	if (this.vboKeysContainer !== undefined)
	{
		this.vboKeysContainer.deleteGlObjects(vboMemManager.gl, vboMemManager);
		this.vboKeysContainer = undefined;
	}
};

Mesh.prototype.newSurface = function()
{
	if (this.surfacesArray === undefined)
	{ this.surfacesArray = []; }
	
	var surface = new Surface();
	this.surfacesArray.push(surface);
	return surface;
};

Mesh.prototype.getHalfEdgesList = function()
{
	if (this.hedgesList === undefined)
	{ this.hedgesList = new HalfEdgesList(); }

	return this.hedgesList;
};

Mesh.prototype.getSurface = function(idx)
{
	if (this.surfacesArray === undefined)
	{ return undefined; }
	
	return this.surfacesArray[idx];
};

Mesh.prototype.addSurface = function(surface)
{
	if (surface === undefined)
	{ return; }
	
	if (this.surfacesArray === undefined)
	{ this.surfacesArray = []; }
	
	this.surfacesArray.push(surface);
};

Mesh.prototype.mergeMesh = function(mesh)
{
	if (mesh === undefined)
	{ return; }
	
	if (this.surfacesArray === undefined)
	{ this.surfacesArray = []; }
	
	var surfacesCount = mesh.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		this.addSurface(mesh.getSurface(i));
	}
	mesh.surfacesArray = undefined;
};

Mesh.prototype.getSurfacesCount = function()
{
	if (this.surfacesArray === undefined)
	{ return 0; }
	
	return this.surfacesArray.length;
};

Mesh.prototype.getCopySurfaceIndependentMesh = function(resultMesh)
{
	// In a surfaceIndependentMesh, the surfaces are disconex.
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }
	
	var surface, surfaceCopy;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surfaceCopy = resultMesh.newSurface();
		surfaceCopy = surface.getCopyIndependentSurface(surfaceCopy);
	}
	
	return resultMesh;
};

Mesh.prototype.getTriangles = function(resultTrianglesArray)
{
	if (this.surfacesArray === undefined || this.surfacesArray.length === 0)
	{ return resultTrianglesArray; }
	
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }
	
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		resultTrianglesArray = surface.getTriangles(resultTrianglesArray);
	}
	
	return resultTrianglesArray;
};

Mesh.prototype.getTrianglesConvex = function(resultTrianglesArray)
{
	// To call this method, the faces must be CONVEX.
	if (this.surfacesArray === undefined || this.surfacesArray.length === 0)
	{ return resultTrianglesArray; }
	
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }
	
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		resultTrianglesArray = surface.getTrianglesConvex(resultTrianglesArray);
	}
	
	return resultTrianglesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
Mesh.prototype.getNoRepeatedVerticesArray = function(resultVerticesArray) 
{
	if (resultVerticesArray === undefined)
	{ resultVerticesArray = []; }
	
	// 1rst, assign vertex-IdxInList for all used vertices.
	var facesCount;
	var face;
	var surface;
	var idxAux = 0;
	var vtx;
	var verticesCount;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		facesCount = surface.getFacesCount();
		for (var j=0; j<facesCount; j++)
		{
			face = surface.getFace(j);
			verticesCount = face.getVerticesCount();
			for (var k=0; k<verticesCount; k++)
			{
				vtx = face.getVertex(k);
				vtx.setIdxInList(idxAux);
				idxAux++;
			}
		}
	}
	
	// now, make a map of unique vertices map using "idxInList" of vertices.
	var verticesMap = {};
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		facesCount = surface.getFacesCount();
		for (var j=0; j<facesCount; j++)
		{
			face = surface.getFace(j);
			verticesCount = face.getVerticesCount();
			for (var k=0; k<verticesCount; k++)
			{
				vtx = face.getVertex(k);
				verticesMap[vtx.getIdxInList().toString()] = vtx;
			}
		}
	}
	
	// finally make the unique vertices array.
	var vertex;
	for (var key in verticesMap)
	{
		if (Object.prototype.hasOwnProperty.call(verticesMap, key))
		{
			vertex = verticesMap[key];
			resultVerticesArray.push(vertex);
		}
	}
	
	return resultVerticesArray;
};

Mesh.prototype.getVertexList = function()
{
	if (this.vertexList === undefined)
	{
		this.vertexList = new VertexList();
	}
	
	return this.vertexList;
};

Mesh.prototype.transformByMatrix4 = function(tMat4)
{
	if (this.vertexList === undefined)
	{
		this.vertexList = new VertexList();
		this.vertexList.vertexArray = this.getNoRepeatedVerticesArray(this.vertexList.vertexArray);
	}
	
	this.vertexList.transformPointsByMatrix4(tMat4);
	
	// If rotate a mesh, must recalculate normals.
	var bForceRecalculatePlaneNormal = true;
	this.calculateVerticesNormals(bForceRecalculatePlaneNormal);
};

Mesh.prototype.translate = function(x, y, z)
{
	if (this.vertexList === undefined)
	{
		this.vertexList = new VertexList();
		this.vertexList.vertexArray = this.getNoRepeatedVerticesArray(this.vertexList.vertexArray);
	}
	
	this.vertexList.translateVertices(x, y, z);
};

Mesh.prototype.calculateVerticesNormals = function(bForceRecalculatePlaneNormal)
{
	// PROVISIONAL.
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surface.calculateVerticesNormals(bForceRecalculatePlaneNormal);
	}
};

Mesh.prototype.calculateTexCoordsSpherical = function()
{
	var sphericalCoords = new GeographicCoord();
	var verticesCount = this.vertexList.getVertexCount();
	for (var i=0; i<verticesCount; i++)
	{
		var vertex = this.vertexList.getVertex(i);
		var position = vertex.point3d;
		sphericalCoords = position.getSphericalCoords(sphericalCoords);
		
		var u = sphericalCoords.longitude / 360.0;
		var v;
		var lat = sphericalCoords.latitude;
		v = 0.5 * (90.0 + lat) / 90.0;
		
		if (vertex.texCoord === undefined)
		{ vertex.texCoord = new Point2D(u, v); }
	}
};

Mesh.prototype.setColor = function(r, g, b, a)
{
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surface.setColor(r, g, b, a);
	}
};

Mesh.prototype.reverseSense = function()
{
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surface.reverseSense();
	}
	
	this.calculateVerticesNormals();
};

Mesh.prototype.getFrontierHalfEdges = function(resultHedgesArray)
{
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		resultHedgesArray = surface.getFrontierHalfEdges(resultHedgesArray);
	}
	
	return resultHedgesArray;
};

Mesh.prototype.getCopy = function(resultMeshCopy)
{
	if (this.vertexList === undefined)
	{ this.vertexList = new VertexList(); }
	
	if (this.vertexList.vertexArray === undefined || this.vertexList.vertexArray.length === 0)
	{ this.vertexList.vertexArray = this.getNoRepeatedVerticesArray(this.vertexList.vertexArray); }
	
	if (resultMeshCopy === undefined)
	{ resultMeshCopy = new Mesh(); }
	
	// 1rst copy vertexList.
	if (resultMeshCopy.vertexList === undefined)
	{ resultMeshCopy.vertexList = new VertexList(); }
	
	resultMeshCopy.vertexList.copyFrom(this.vertexList);
	
	// set idxInList both vertexLists.
	this.vertexList.setIdxInList();
	resultMeshCopy.vertexList.setIdxInList();
	
	// now copy surfaces.
	var surface, facesCount, face, verticesCount;
	var vtxIdx;
	var surfaceCopy, faceCopy, vtxCopy;
	var vtx;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surfaceCopy = resultMeshCopy.newSurface();
		facesCount = surface.getFacesCount();
		for (var j=0; j<facesCount; j++)
		{
			face = surface.getFace(j);
			faceCopy = surfaceCopy.newFace();
			verticesCount = face.getVerticesCount();
			for (var k=0; k<verticesCount; k++)
			{
				vtx = face.getVertex(k);
				vtxIdx = vtx.getIdxInList();
				vtxCopy = resultMeshCopy.vertexList.getVertex(vtxIdx);
				faceCopy.addVertex(vtxCopy);
			}
		}
	}
	
	resultMeshCopy.calculateVerticesNormals();
	
	return resultMeshCopy;
};

Mesh.prototype.getTrianglesListsArrayBy2ByteSize = function(trianglesArray, resultTrianglesListsArray)
{
	if (resultTrianglesListsArray === undefined)
	{ resultTrianglesListsArray = []; }
	
	// This function returns trianglesListsArray. Each trianglesList's vertices count is lower than 65535.
	var shortSize = 65535;
	var trianglesList = new TrianglesList();
	resultTrianglesListsArray.push(trianglesList);
	var trianglesCount = trianglesArray.length;
	if (trianglesCount*3 <shortSize)
	{
		trianglesList.trianglesArray = [];
		Array.prototype.push.apply(trianglesList.trianglesArray, trianglesArray);
		return resultTrianglesListsArray;
	}
	
	// 1rst, make global vertices array.
	var globalVerticesArray = TrianglesList.getNoRepeatedVerticesArray(trianglesArray, undefined);
	var verticesCount = globalVerticesArray.length;
	
	if (verticesCount <shortSize)
	{
		trianglesList.trianglesArray = [];
		Array.prototype.push.apply(trianglesList.trianglesArray, trianglesArray);
		return resultTrianglesListsArray;
	}
	
	VertexList.setIdxInList(globalVerticesArray);
	var rejectedTrianglesArray = [];
	var trianglesCount = trianglesArray.length;
	var triangle;
	
	for (var i=0; i<trianglesCount; i++)
	{
		triangle = trianglesArray[i];
		if (triangle.vertex0.idxInList < shortSize && triangle.vertex1.idxInList< shortSize && triangle.vertex2.idxInList< shortSize)
		{
			trianglesList.addTriangle(triangle);
		}
		else 
		{
			rejectedTrianglesArray.push(triangle);
		}
	};
	
	if (rejectedTrianglesArray.length > 0)
	{
		resultTrianglesListsArray = this.getTrianglesListsArrayBy2ByteSize(rejectedTrianglesArray, resultTrianglesListsArray);
	}
	
	return resultTrianglesListsArray;
};

Mesh.prototype.render = function(magoManager, shader, renderType, glPrimitive)
{
	var vboMemManager = magoManager.vboMemoryManager;
	
	if (this.vboKeysContainer === undefined)
	{
		this.vboKeysContainer = this.getVbo(this.vboKeysContainer, vboMemManager);
		return;
	}
	
	var gl = magoManager.sceneState.gl;
	var primitive;
	
	var vboKeysCount = this.vboKeysContainer.vboCacheKeysArray.length;
	for (var i=0; i<vboKeysCount; i++)
	{
		var vboKey = this.vboKeysContainer.vboCacheKeysArray[i];
		
		// Positions.
		if (!vboKey.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }
		
		// Normals.
		if (vboKey.vboBufferNor)
		{
			if (!vboKey.bindDataNormal(shader, magoManager.vboMemoryManager))
			{ return false; }
		}
		else 
		{
			shader.disableVertexAttribArray(shader.normal3_loc);
		}
		
		// Colors.
		if (vboKey.vboBufferCol)
		{
			if (!vboKey.bindDataColor(shader, magoManager.vboMemoryManager))
			{ return false; }
		}
		else 
		{
			shader.disableVertexAttribArray(shader.color4_loc);
		}
		
		// TexCoords.
		if (vboKey.vboBufferTCoord)
		{
			if (!vboKey.bindDataTexCoord(shader, magoManager.vboMemoryManager))
			{ return false; }
		}
		else 
		{
			shader.disableVertexAttribArray(shader.texCoord2_loc);
		}
		
		// Indices.
		if (!vboKey.bindDataIndice(shader, magoManager.vboMemoryManager))
		{ return false; }
		
		if (glPrimitive)
		{ primitive = glPrimitive; }
		else
		{ primitive = gl.TRIANGLES; }
		
		gl.drawElements(primitive, vboKey.indicesCount, gl.UNSIGNED_SHORT, 0);
	}
};

Mesh.prototype.getVbo = function(resultVboContainer, vboMemManager)
{
	if (resultVboContainer === undefined)
	{ resultVboContainer = new VBOVertexIdxCacheKeysContainer(); }

	// make global triangles array.
	var trianglesArray = this.getTriangles(undefined);
	var trianglesCount = trianglesArray.length;
	
	// If vertices count > shortSize(65535), then must split the mesh.
	var trianglesListsArray = this.getTrianglesListsArrayBy2ByteSize(trianglesArray, undefined);
	var trianglesList;
	var verticesArray;
	var trianglesListsCount = trianglesListsArray.length;
	for (var i=0; i<trianglesListsCount; i++)
	{
		trianglesList = trianglesListsArray[i];
		verticesArray = trianglesList.getNoRepeatedVerticesArray(undefined);
		var vbo = resultVboContainer.newVBOVertexIdxCacheKey();
		VertexList.setIdxInList(verticesArray);
		VertexList.getVboDataArrays(verticesArray, vbo, vboMemManager);
		trianglesList.assignVerticesIdx();
		TrianglesList.getVboFaceDataArray(trianglesList.trianglesArray, vbo, vboMemManager);
		
	}

	return resultVboContainer;
};

Mesh.prototype.getVboTrianglesConvex = function(resultVboContainer, vboMemManager)
{
	if (resultVboContainer === undefined)
	{ resultVboContainer = new VBOVertexIdxCacheKeysContainer(); }

	// make global triangles array.
	var trianglesArray = this.getTrianglesConvex(undefined); // for convex faces (faster).
	var trianglesCount = trianglesArray.length;
	
	// If vertices count > shortSize(65535), then must split the mesh.
	var trianglesListsArray = this.getTrianglesListsArrayBy2ByteSize(trianglesArray, undefined);
	var trianglesList;
	var verticesArray;
	var trianglesListsCount = trianglesListsArray.length;
	for (var i=0; i<trianglesListsCount; i++)
	{
		trianglesList = trianglesListsArray[i];
		verticesArray = trianglesList.getNoRepeatedVerticesArray(undefined);
		var vbo = resultVboContainer.newVBOVertexIdxCacheKey();
		VertexList.setIdxInList(verticesArray);
		VertexList.getVboDataArrays(verticesArray, vbo, vboMemManager);
		trianglesList.assignVerticesIdx();
		TrianglesList.getVboFaceDataArray(trianglesList.trianglesArray, vbo, vboMemManager);
		
	}

	return resultVboContainer;
};

Mesh.prototype.getVboEdges = function(resultVboContainer, vboMemManager)
{
	if (resultVboContainer === undefined)
	{ return; }
	
	// provisionally make edges by this.
	var frontierHedgesArray = this.getFrontierHalfEdges(undefined);
	var hedgesCount = frontierHedgesArray.length;
	var hedge;
	var verticesCount = hedgesCount * 2;
	var vertexArray = new Float32Array(verticesCount*3);
	var indicesArray = new Uint16Array(verticesCount);
	var strVertex, endVertex;
	var index = 0;
	for (var i=0; i<hedgesCount; i++)
	{
		hedge = frontierHedgesArray[i];
		strVertex = hedge.startVertex;
		endVertex = hedge.getEndVertex();
		vertexArray[i*6] = strVertex.point3d.x;
		vertexArray[i*6+1] = strVertex.point3d.y;
		vertexArray[i*6+2] = strVertex.point3d.z;
		vertexArray[i*6+3] = endVertex.point3d.x;
		vertexArray[i*6+4] = endVertex.point3d.y;
		vertexArray[i*6+5] = endVertex.point3d.z;
		
		indicesArray[i*2] = index; index++;
		indicesArray[i*2+1] = index; index++;
	}
	
	var resultVbo = resultVboContainer.newVBOVertexIdxCacheKey();
	resultVbo.setDataArrayPos(vertexArray, vboMemManager);
	resultVbo.setDataArrayIdx(indicesArray, vboMemManager);
};





















































'use strict';


/**
 * Now under implementation
 * @class Modeler
 */
var Modeler = function() 
{
	if (!(this instanceof Modeler)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.mode = CODE.modelerMode.INACTIVE; // test for the moment.
	this.drawingState = CODE.modelerDrawingState.NO_STARTED; // test for the moment.
	this.drawingElement = CODE.modelerDrawingElement.NOTHING; // test for the moment.
	this.planeGrid; // sketch plane.
	this.polyLine2d; // current polyline2D to sketch.
	this.geoCoordsList; // class: GeographicCoordsList. geographic polyline.
	this.excavation; // class : Excavation.
	this.tunnel; // class : Tunnel.
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.getGeographicCoordsList = function() 
{
	if (this.geoCoordsList === undefined)
	{ this.geoCoordsList = new GeographicCoordsList(); }
	
	return this.geoCoordsList;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.getExcavation = function() 
{
	if (this.excavation === undefined)
	{ this.excavation = new Excavation(); }
	
	return this.excavation;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.getTunnel = function() 
{
	if (this.tunnel === undefined)
	{ this.tunnel = new Tunnel(); }
	
	return this.tunnel;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.addPointToPolyline = function(point2d) 
{
	if (this.polyLine2d === undefined)
	{ this.polyLine2d = new PolyLine2D(); }
	
	this.polyLine2d.newPoint2d(point2d.x, point2d.y);
};


/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.render = function(magoManager, shader, renderType) 
{
	// 1rst, render the planeGrid if exist.
	if (this.planeGrid !== undefined)
	{
		this.planeGrid.render(magoManager, shader);
	}
	
	if (this.polyLine2d !== undefined)
	{
		// Provisionally render the polyLine2d on the sketch plane here.
		var points2dCount = this.polyLine2d.getPointsCount();
		
	}
	
	if (this.geoCoordsList !== undefined)
	{
		// Provisionally render geographicPoints.
		this.geoCoordsList.renderPoints(magoManager, shader, renderType);
	}
	
	if (this.excavation !== undefined)
	{
		this.excavation.renderPoints(magoManager, shader, renderType);
	}
	
	if (this.tunnel !== undefined)
	{
		this.tunnel.renderPoints(magoManager, shader, renderType);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.createPlaneGrid = function(width, height, numCols, numRows) 
{
	// Test function.
	if (width === undefined)
	{ width = 500.0; }
	
	if (height === undefined)
	{ height = 500.0; }
	
	if (numCols === undefined)
	{ numCols = 50; }
	
	if (numRows === undefined)
	{ numRows = 50; }
	
	if (this.planeGrid === undefined)
	{
		this.planeGrid = new PlaneGrid(width, height, numCols, numRows);
	}
	
	
};













































'use strict';


/**
 * 어떤 일을 하고 있습니까?
 * @class ParametricMesh
 */
var ParametricMesh = function() 
{
	if (!(this instanceof ParametricMesh)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.vtxProfilesList; // class: VtxProfilesList.
	this.profile; // class: Profile. is a 2d object.
	this.vboKeyContainer; // class: VBOVertexIdxCacheKeyContainer.
	this.vboKeyContainerEdges; // class: VBOVertexIdxCacheKeyContainer.
};

/**
 * Delete the data of this.profile
 */
ParametricMesh.prototype.deleteObjects = function() 
{
	if (this.profile)
	{ this.profile.deleteObjects(); }
	
	this.profile = undefined;
};

/**
 * Get the vbo key container of this feature
 * @returns {VBOVertexIdxCacheKeysContaier}	
 */
ParametricMesh.prototype.getVboKeysContainer = function()
{
	return this.vboKeyContainer;
};

/**
 * Get mesh of this instance
 * @param {Mesh} resultMesh
 * @param {Boolean} bIncludeBottomCap Chech whether include the bottom of this revolved mesh ex) pipeline doesn't have bottom and top cap
 * @param {Boolean} bIncludeTopCap Chech whether include the top of this revolved mesh ex) pipeline doesn't have bottom and top cap
 * @returns {Mesh}
 */
ParametricMesh.prototype.getMesh = function(resultMesh, bIncludeBottomCap, bIncludeTopCap)
{
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }

	// must separate vbo groups by surfaces.
	resultMesh = this.vtxProfilesList.getMesh(resultMesh, bIncludeBottomCap, bIncludeTopCap);
	resultMesh.calculateVerticesNormals();
	
	return resultMesh;
};

/**
 * Change the unified mesh to the group of surfaces for drawing the mesh with WebGL
 * @param {Mesh} resultMesh
 * @param {Boolean} bIncludeBottomCap Chech whether include the bottom of this revolved mesh ex) pipeline doesn't have bottom and top cap
 * @param {Boolean} bIncludeTopCap Chech whether include the top of this revolved mesh ex) pipeline doesn't have bottom and top cap
 * 
 */
ParametricMesh.prototype.getSurfaceIndependentMesh = function(resultMesh, bIncludeBottomCap, bIncludeTopCap)
{
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }

	// must separate vbo groups by surfaces.
	this.mesh = this.vtxProfilesList.getMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	resultMesh = this.mesh.getCopySurfaceIndependentMesh(resultMesh);
	resultMesh.calculateVerticesNormals();
	
	return resultMesh;
};

/**
 * Extrude the profile with curved direction
 * @param profile2d the profile which will be extruede
 * @param revolveAngDeg the angle of the vector used for extruding
 * @param revolveSegmentsCount the number of the segements which constitue of the extruded feature
 * @param revolveSegment2d rotating shaft
 * 
 */
ParametricMesh.prototype.revolve = function(profile2d, revolveAngDeg, revolveSegmentsCount, revolveSegment2d) 
{
	// Note: move this function into "VtxProfilesList" class.
	if (profile2d === undefined)
	{ return undefined; }
	
	if (this.vtxProfilesList === undefined)
	{ this.vtxProfilesList = new VtxProfilesList(); }
	
	// if want caps in the extruded mesh, must calculate "ConvexFacesIndicesData" of the profile2d before creating vtxProfiles.
	this.vtxProfilesList.convexFacesIndicesData = profile2d.getConvexFacesIndicesData(undefined);
	//profile2d.checkNormals();
	// create vtxProfiles.
	// make the base-vtxProfile.
	var baseVtxProfile = this.vtxProfilesList.newVtxProfile();
	baseVtxProfile.makeByProfile2D(profile2d);
	
	var increAngDeg = revolveAngDeg/revolveSegmentsCount;
	
	// calculate the translation.
	var line2d = revolveSegment2d.getLine();
	var origin2d = new Point2D(0, 0);
	var translationVector = line2d.getProjectedPoint(origin2d);
	translationVector.inverse();
	
	var rotMat = new Matrix4();
	var quaternion = new Quaternion();
	var rotAxis2d = revolveSegment2d.getDirection();
	var rotAxis = new Point3D(rotAxis2d.x, rotAxis2d.y, 0);
	rotAxis.unitary();
	
	for (var i=0; i<revolveSegmentsCount; i++)
	{
		// calculate rotation.
		quaternion.rotationAngDeg(increAngDeg*(i+1), rotAxis.x, rotAxis.y, rotAxis.z);
		rotMat.rotationByQuaternion(quaternion);
		
		// test top profile.
		var nextVtxProfile = this.vtxProfilesList.newVtxProfile();
		nextVtxProfile.copyFrom(baseVtxProfile);
		nextVtxProfile.translate(translationVector.x, translationVector.y, 0);
		nextVtxProfile.transformPointsByMatrix4(rotMat);
		nextVtxProfile.translate(-translationVector.x, -translationVector.y, 0);
	}
};

/**
 * Make new instance which consist of the part of the extruded segment(The number of the segments is extrudeSegmentsCount) by extruding profile2D
 * @param {profile2D} profile2d the feature which will be extruded
 * @param {Number} extrusionDist the height of extruded feature
 * @param {Number} extrudeSegmentsCount the number of the segement which consist of extruded feature
 * @param {Point3D} extrusionVector the direction of extrusion
 */
ParametricMesh.prototype.extrude = function(profile2d, extrusionDist, extrudeSegmentsCount, extrusionVector) 
{
	// Note: move this function into "VtxProfilesList" class.
	if (profile2d === undefined || extrusionDist === undefined)
	{ return undefined; }
	
	if (this.vtxProfilesList === undefined)
	{ this.vtxProfilesList = new VtxProfilesList(); }
	

	// if want caps in the extruded mesh, must calculate "ConvexFacesIndicesData" of the profile2d before creating vtxProfiles.
	this.vtxProfilesList.convexFacesIndicesData = profile2d.getConvexFacesIndicesData(undefined);
	
	// create vtxProfiles.
	// make the base-vtxProfile.
	var baseVtxProfile = this.vtxProfilesList.newVtxProfile();
	baseVtxProfile.makeByProfile2D(profile2d);
	
	if (extrusionVector === undefined)
	{ extrusionVector = new Point3D(0, 0, 1); }
	
	var increDist = extrusionDist/extrudeSegmentsCount;
	for (var i=0; i<extrudeSegmentsCount; i++)
	{
		// test with a 1 segment extrusion.
		var nextVtxProfile = this.vtxProfilesList.newVtxProfile();
		nextVtxProfile.copyFrom(baseVtxProfile);
		nextVtxProfile.translate(0, 0, increDist*(i+1));
	}
};




































'use strict';

/**
 * PlaneGrid on 3D space. (Draw on the ground or plane in 3D space)
 * Now under implementation 
 * @class PlaneGrid
 */
var PlaneGrid = function(width, height, numCols, numRows) 
{
	if (!(this instanceof PlaneGrid)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	//this.plane; // plane 3d.
	this.geoLocDataManager;
	this.width;
	this.height;
	this.altitude = 0.0;
	this.numCols;
	this.numRows;
	this.vboKeysContainer;
	
	this.setSize(width, height, numCols, numRows);
};

/**
 * 어떤 일을 하고 있습니까?
 */
PlaneGrid.prototype.setSize = function(width, height, numCols, numRows) 
{
	if (width !== undefined)
	{ this.width = width; }
	
	if (height !== undefined)
	{ this.height = height; }
	
	if (numCols !== undefined)
	{ this.numCols = numCols; }
	
	if (numRows !== undefined)
	{ this.numRows = numRows; }
};

/**
 * 어떤 일을 하고 있습니까?
 */
PlaneGrid.prototype.render = function(magoManager, shader) 
{
	if (this.vboKeysContainer === undefined)
	{ return; }
	
	var gl = magoManager.sceneState.gl;
	var vboMemManager = magoManager.vboMemoryManager;
	
	// Set uniforms.
	var geoLoc = this.geoLocDataManager.getCurrentGeoLocationData();
	gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, geoLoc.rotMatrix._floatArrays);
	gl.uniform3fv(shader.buildingPosHIGH_loc, geoLoc.positionHIGH);
	gl.uniform3fv(shader.buildingPosLOW_loc, geoLoc.positionLOW);
	
	gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
	gl.uniform1i(shader.hasAditionalMov_loc, false);
	shader.disableVertexAttribArray(shader.texCoord2_loc); // Grid has no texCoords.
	
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 1.0, 1.0]);
	
	gl.uniform1i(shader.bApplySpecularLighting_loc, false); // turn off specular lighting.
	
	// disable All AttribPointer.
	shader.disableVertexAttribArrayAll(); // init.
	
	var vboKeysCount = this.vboKeysContainer.vboCacheKeysArray.length;
	for (var i=0; i<vboKeysCount; i++)
	{
		var vboKey = this.vboKeysContainer.vboCacheKeysArray[i];

		// Positions.
		if (vboKey.vboBufferPos!== undefined && !vboKey.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }

		// Normals.
		if (vboKey.vboBufferNor!== undefined)
		{
			if (!vbo_vicky.bindDataNormal(shader, magoManager.vboMemoryManager))
			{ return false; }
		}
		else 
		{
			shader.disableVertexAttribArray(shader.normal3_loc);
		}

		// Colors.
		if (vboKey.vboBufferCol!== undefined)
		{
			if (!vbo_vicky.bindDataColor(shader, magoManager.vboMemoryManager))
			{ return false; }
		}
		else 
		{
			shader.disableVertexAttribArray(shader.color4_loc);
		}
		
		// TexCoords.
		if (vboKey.vboBufferTCoord!== undefined)
		{
			if (!vbo_vicky.bindDataTexCoord(shader, magoManager.vboMemoryManager))
			{ return false; }
		}
		else 
		{
			shader.disableVertexAttribArray(shader.texCoord2_loc);
		}
		
		//gl.drawElements(primitive, vboKey.indicesCount, gl.UNSIGNED_SHORT, 0);
		gl.drawArrays(gl.LINES, 0, vboKey.vertexCount);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
PlaneGrid.prototype.makeVbo = function(vboMemManager) 
{
	// Calculate positions.
	var halfWidth = this.width/2;
	var halfHeight = this.height/2;
	var alt = this.altitude;
	
	var leftDownPoint = new Point3D(-halfWidth, -halfHeight, alt);
	var rightDownPoint = new Point3D(halfWidth, -halfHeight, alt);
	var rightUpPoint = new Point3D(halfWidth, halfHeight, alt);
	var leftUpPoint = new Point3D(-halfWidth, halfHeight, alt);
	
	var increX = this.width/(this.numCols - 1);
	var increY = this.height/(this.numRows - 1);
	
	var pointsCount = this.numCols * 2 + this.numRows * 2;
	var positionsArray = new Float32Array(pointsCount*3);
	
	// Now, calculate all lines points.
	var x1, y1, z1;
	var x2, y2, z2;
	var idx = 0;
	
	// Vertical lines. "y" are constant.
	y1 = leftDownPoint.y; // down.
	y2 = leftUpPoint.y; // up.
	for (var col = 0; col < this.numCols; col++)
	{
		x1 = leftDownPoint.x + col * increX;
		x2 = x1;
		positionsArray[idx] = x1; idx++;
		positionsArray[idx] = y1; idx++;
		positionsArray[idx] = alt; idx++;
		positionsArray[idx] = x2; idx++;
		positionsArray[idx] = y2; idx++;
		positionsArray[idx] = alt; idx++;
	}
	
	// Horizontal lines.
	x1 = leftDownPoint.x; // left.
	x2 = rightDownPoint.x; // right.
	for (var row = 0; row < this.numRows; row++)
	{
		y1 = leftDownPoint.y + row * increY;
		y2 = y1;
		positionsArray[idx] = x1; idx++;
		positionsArray[idx] = y1; idx++;
		positionsArray[idx] = alt; idx++;
		positionsArray[idx] = x2; idx++;
		positionsArray[idx] = y2; idx++;
		positionsArray[idx] = alt; idx++;
	}
	
	if (this.vboKeysContainer === undefined)
	{ this.vboKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
	
	var vbo = this.vboKeysContainer.newVBOVertexIdxCacheKey();
	vbo.setDataArrayPos(positionsArray, vboMemManager);
	
	
};


























































'use strict';
/**
* 어떤 일을 하고 있습니까?
* @class Point2D
*/
var Point2D = function(x, y) 
{
	if (!(this instanceof Point2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	if (x) { this.x = x; }
	else { this.x = 0.0; }
	if (y) { this.y = y; }
	else { this.y = 0.0; }
	
	this.ownerVertex3d; // Aux var. This will be used for this : this Point2D is the projected ownerVertex3d into 2D
	
	/**associated this property will be used to save topologic information */
	this.associated;
};

/**
 * delete the value of x and y coordi
 */
Point2D.prototype.deleteObjects = function() 
{
	this.x = undefined;
	this.y = undefined;
};

/**
 * set the value of the property 'associated'
 * @param {Point2D} associated
 */
Point2D.prototype.setAssociated = function(associated) 
{
	// aux test.
	this.associated.x = associated.x;
	this.associated.y = associated.y;
};

/**
 * get the value of the property 'associated'
 * @returns {Point2D} this.associated
 */
Point2D.prototype.getAssociated = function() 
{
	// aux test.
	return this.associated;	
};

/**
 * copy the value of other point
 * @param {Point2D} point2d
 */
Point2D.prototype.copyFrom = function(point2d) 
{
	this.x = point2d.x;
	this.y = point2d.y;
};

/**
 * change the sign of the values of point inversely
 */
Point2D.prototype.inverse = function() 
{
	this.x = -this.x;
	this.y = -this.y;
};

/**
 * set the value of x,y coordi of the point
 * @param {Number} x
 * @param {Number} y
 */
Point2D.prototype.set = function(x, y) 
{
	this.x = x;
	this.y = y;
};

/**
 * return the result of calculating (this.x*this.x + this.y*this.y) 
 * @returns this.x*this.x + this.y*this.y;
 */
Point2D.prototype.getSquaredModul = function() 
{
	return this.x*this.x + this.y*this.y;
};

/**
 * return the result of calculating Math.sqrt(this.x*this.x + this.y*this.y);
 * @returns Math.sqrt(this.x*this.x + this.y*this.y);
 */
Point2D.prototype.getModul = function() 
{
	return Math.sqrt(this.getSquaredModul());
};

/**
 * 
 * make unitary of the point
 */
Point2D.prototype.unitary = function() 
{
	var modul = this.getModul();
	this.x /= modul;
	this.y /= modul;
};

/**
 * prepare to calculate the Euclidean distance between this point and the other point.
 * @param {Number} point
 * @returns dx*dx + dy*dy
 */
Point2D.prototype.squareDistToPoint = function(point) 
{
	var dx = this.x - point.x;
	var dy = this.y - point.y;

	return dx*dx + dy*dy;
};

/**
 * calculate the Euclidean distance between this point and the other point.
 * @param {Point2D} point the target
 * @returns the calculated Euclidan distance
 */
Point2D.prototype.distToPoint = function(point) 
{
	return Math.sqrt(this.squareDistToPoint(point));
};

/**
 * Check whether this point and the other point are overlapped(coincident) or not 
 * @param {Point2D} point the point which will be checked whether the two points are coincident or not
 * @param {Number} errorDist allowed error range value of calculating distance. It can be from 0.1mm to 10E-8
 * @returns {Boolean} the flag which let us know whether they are coincident or not 
 */
Point2D.prototype.isCoincidentToPoint = function(point, errorDist) 
{
	var squareDist = this.distToPoint(point);
	var coincident = false;
	if (squareDist < errorDist*errorDist)
	{
		coincident = true;
	}

	return coincident;
};

/**
 * @param {Point2D} targetPoint this returns a vector that points to "targetPoint" from "this" 
 * @param {Point3D} resultVector the "resultVector" has the direction from "this" to "targetPoint", but is NOT normalized.
 * @returns {Point3D} resultVector
 */
Point2D.prototype.getVectorToPoint = function(targetPoint, resultVector) 
{
	if (targetPoint === undefined)
	{ return undefined; }
	
	if (resultVector === undefined)
	{ resultVector = new Point2D(); }
	
	resultVector.set(targetPoint.x - this.x, targetPoint.y - this.y);
	
	return resultVector;
};

/**
 * Calculate vector product
 * @param {Point2D} point the point which will be used at this calculate.
 * @returns {Number} calculated result
 */
Point2D.prototype.crossProduct = function(point) 
{
	return this.x * point.y - point.x * this.y;
};

/**
 * Calculate scalar production of vector
 * @param {Point2D} point the point which will be used at this calculate.
 * @returns {Number} calculated result
 */
Point2D.prototype.scalarProduct = function(point) 
{
	var scalarProd = this.x*point.x + this.y*point.y;
	return scalarProd;
};

/**
 * Calculate the radian value of the angle of the two vectors
 * @param vector the target vector
 * @returns the angle of two vector
 */
Point2D.prototype.angleRadToVector = function(vector) 
{
	if (vector === undefined)
	{ return undefined; }
	
	//
	//var scalarProd = this.scalarProduct(vector);
	var myModul = this.getModul();
	var vecModul = vector.getModul();
	
	// calcule by cos.
	//var cosAlfa = scalarProd / (myModul * vecModul); 
	//var angRad = Math.acos(cosAlfa);
	//var angDeg = alfa * 180.0/Math.PI;
	//------------------------------------------------------
	var error = 10E-10;
	if (myModul < error || vecModul < error)
	{ return undefined; }
	
	return Math.acos(this.scalarProduct(vector) / (myModul * vecModul));
};

/**
 * Calculate the degree value of the angle of the two vectors
 * @param point 변수
 * @param resultPoint 변수
 * @returns resultPoint
 */
Point2D.prototype.angleDegToVector = function(vector) 
{
	if (vector === undefined)
	{ return undefined; }
	
	var angRad = this.angleRadToVector(vector);
	
	if (angRad === undefined)
	{ return undefined; }
		
	return angRad * 180.0/Math.PI;
};

















































'use strict';
/**
* Contain the list of the features of Point2D
* @class Point2DList
*/
var Point2DList = function() 
{
	if (!(this instanceof Point2DList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.pointsArray;
};

/**
 * Clear this.pointsArray of this feature
 */
Point2DList.prototype.deleteObjects = function()
{
	if (this.pointsArray === undefined)
	{ return; }
	
	var pointsCount = this.pointsArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		this.pointsArray[i].deleteObjects();
		this.pointsArray[i] = undefined;
	}
	this.pointsArray = undefined;
};

/**
 * Add a feature of Point2D at the last of this.pointsArray
 * @param {Point2D} point2d the point that will be pushed at this.pointsArray
 */
Point2DList.prototype.addPoint = function(point2d)
{
	if (point2d === undefined)
	{ return; }
	
	if (this.pointsArray === undefined)
	{ this.pointsArray = []; }

	this.pointsArray.push(point2d);
};

/**
 * Create a new feature of Point2D
 * @param {Number} x the x coordi of the point
 * @param {Number} y the y coordi of the point
 * @returns {Point2D} return the created point
 */
Point2DList.prototype.newPoint = function(x, y)
{
	if (this.pointsArray === undefined)
	{ this.pointsArray = []; }
	
	var point = new Point2D(x, y);
	this.pointsArray.push(point);
	return point;
};

/**
 * Search and return the specific feature of Point2D with the index that has at this.pointArray
 * @param {Number} idx the index of the target point at this.pointArray
 * 
 */
Point2DList.prototype.getPoint = function(idx)
{
	return this.pointsArray[idx];
};

/**
 * Return the length of this.pointArray
 * @returns {Number}
 */
Point2DList.prototype.getPointsCount = function()
{
	if (this.pointsArray === undefined)
	{ return 0; }
	
	return this.pointsArray.length;
};

/**
 * This function is used when this feature is a point2DRing.
 * Return the previous index of the given index.
 * @param {Number} idx the target index
 * @param {Number} prevIdx
 */
Point2DList.prototype.getPrevIdx = function(idx)
{
	var pointsCount = this.pointsArray.length;
	var prevIdx;
	
	if (idx === 0)
	{ prevIdx = pointsCount - 1; }
	else
	{ prevIdx = idx - 1; }

	return prevIdx;
};

/**
 * This function is used when this feature is a point2DRing.
 * Return the next index of the given index
 * @param {Number} idx the target index
 * @param {Number} nexIndx
 */
Point2DList.prototype.getNextIdx = function(idx)
{
	var pointsCount = this.pointsArray.length;
	var nextIdx;
	
	if (idx === pointsCount - 1)
	{ nextIdx = 0; }
	else
	{ nextIdx = idx + 1; }

	return nextIdx;
};

/**
 * Get the index of the given point
 * @param {Point2D} point
 * @returns {Number} idx the index of the target point at this.pointArray
 */
Point2DList.prototype.getIdxOfPoint = function(point)
{
	var pointsCount = this.pointsArray.length;
	var i=0;
	var idx = -1;
	var found = false;
	while (!found && i<pointsCount)
	{
		if (this.pointsArray[i] === point)
		{
			found = true;
			idx = i;
		}
		i++;
	}
	
	return idx;
};

/**
 * get the segement with the index of the segment
 * @param {Number} idx the index of start point of segment
 * @param {Segment2D} resultSegment the segement which will store the result segment
 * @returns {Segment2D} resultSegment 
 * 
 */
Point2DList.prototype.getSegment = function(idx, resultSegment)
{
	var currPoint = this.getPoint(idx);
	var nextIdx = this.getNextIdx(idx);
	var nextPoint = this.getPoint(nextIdx);
	
	if (resultSegment === undefined)
	{ resultSegment = new Segment2D(currPoint, nextPoint); }
	else 
	{
		resultSegment.setPoints(currPoint, nextPoint);
	}

	return resultSegment;
};

/**
 * 
 */
Point2DList.prototype.setIdxInList = function()
{
	var pointsCount = this.pointsArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		this.pointsArray[i].idxInList = i;
	}
};

/**
 * Copy the target Point2dList from this.arrayList
 */
Point2DList.prototype.getCopy = function(resultPoint2dList) 
{
	if (resultPoint2dList === undefined)
	{ resultPoint2dList = new Point2DList(); }
	else
	{ resultPoint2dList.deleteObjects(); }
	
	var myPoint, copyPoint;
	var pointsCount = this.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		myPoint = this.getPoint(i);
		copyPoint = resultPoint2dList.newPoint(myPoint.x, myPoint.y);
	}
	
	return resultPoint2dList;
};

/**
 * Calculate the bounding box of this point2DList
 * @param {BoundingRectangle} resultBoundingRectangle the BoundingRectangle which will be calculated
 * @returns {BoundingRectanble} resultPoint
 */
Point2DList.prototype.getBoundingRectangle = function(resultBoundingRectangle) 
{
	var pointsCount = this.getPointsCount();
	if (pointsCount === 0)
	{ return resultBoundingRectangle; }
	
	if (resultBoundingRectangle === undefined)
	{ resultBoundingRectangle = new BoundingRectangle(); }
	
	var point;
	for (var i=0; i<pointsCount; i++)
	{
		if (i === 0)
		{ resultBoundingRectangle.setInit(this.getPoint(i)); }
		else
		{ resultBoundingRectangle.addPoint(this.getPoint(i)); }
	}
	
	return resultBoundingRectangle;
};

/**
 * Calculate and return the point in this.pointArray which is the nearest point of the target point
 * @param point the target point
 * @param resultPoint the nearest point from the target point
 * @returns {Point2D} resultPoint
 */
Point2DList.prototype.getNearestPointIdxToPoint = function(point) 
{
	if (point === undefined)
	{ return undefined; }
	
	var currPoint, candidatePointIdx;
	var currSquaredDist, candidateSquaredDist;
	var pointsCount = this.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		currPoint = this.getPoint(i);
		currSquaredDist = currPoint.squareDistToPoint(point);
		if (candidatePointIdx === undefined)
		{
			candidatePointIdx = i;
			candidateSquaredDist = currSquaredDist;
		}
		else 
		{
			if (currSquaredDist < candidateSquaredDist)
			{
				candidatePointIdx = i;
				candidateSquaredDist = currSquaredDist;
			}
		}
	}
	
	return candidatePointIdx;
};

/**
 * Reverse the order of this.pointArray
 */
Point2DList.prototype.reverse = function() 
{
	if (this.pointsArray !== undefined)
	{ this.pointsArray.reverse(); }
};

/**
 * Sort the points in this.pointArray as the distance from thePoint
 * @param {Point2D} thePoint the target point
 * @param resultSortedPointsIndxArray the target pointArray
 * @TODO : need to change the name of this function. So confused.
 * @result resultSortedPointsIdexArray sorted array
 */
Point2DList.prototype.getPointsIdxSortedByDistToPoint = function(thePoint, resultSortedPointsIdxArray)
{
	if (this.pointsArray === undefined)
	{ return resultSortedPointsIdxArray; }
	
	// Static function.
	// Sorting minDist to maxDist.
	if (resultSortedPointsIdxArray === undefined)
	{ resultSortedPointsIdxArray = []; }
	
	var pointsArray = this.pointsArray;
	
	var objectAux;
	var objectsAuxArray = [];
	var point;
	var squaredDist;
	var startIdx, endIdx, insertIdx;
	var pointsCount = pointsArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		point = pointsArray[i];
		if (point === thePoint)
		{ continue; }
		
		squaredDist = thePoint.squareDistToPoint(point);
		objectAux = {};
		objectAux.pointIdx = i;
		objectAux.squaredDist = squaredDist;
		startIdx = 0;
		endIdx = objectsAuxArray.length - 1;
		
		insertIdx = this.getIndexToInsertBySquaredDist(objectsAuxArray, objectAux, startIdx, endIdx);
		objectsAuxArray.splice(insertIdx, 0, objectAux);
	}
	
	resultSortedPointsIdxArray.length = 0;
	var objectsCount = objectsAuxArray.length;
	for (var i=0; i<objectsCount; i++)
	{
		resultSortedPointsIdxArray.push(objectsAuxArray[i].pointIdx);
	}
	
	return resultSortedPointsIdxArray;
};

/**
 * this do a dicotomic search of idx in a ordered table.
 * @param objectsArray 
 * @param {Point2D} object the target point
 * @param {Number} startIdx the start index of objectsArray
 * @param {Number} endIdx the end index of objectsArray
 * @returns {Number} result_idx the index of object in objectsArray
 * 
 */
Point2DList.prototype.getIndexToInsertBySquaredDist = function(objectsArray, object, startIdx, endIdx) 
{
	// 
	// 1rst, check the range.
	
	var range = endIdx - startIdx;
	
	if (objectsArray.length === 0)
	{ return 0; }
	
	if (range < 6)
	{
		// in this case do a lineal search.
		var finished = false;
		var i = startIdx;
		var idx;
		//var objectsCount = objectsArray.length;
		while (!finished && i<=endIdx)
		{
			if (object.squaredDist < objectsArray[i].squaredDist)
			{
				idx = i;
				finished = true;
			}
			i++;
		}
		
		if (finished)
		{
			return idx;
		}
		else 
		{
			return endIdx+1;
		}
	}
	else // in this case do the dicotomic search. (Binary search)
	{		
		var middleIdx = startIdx + Math.floor(range/2);
		var newStartIdx;
		var newEndIdx;
		if (objectsArray[middleIdx].squaredDist > object.squaredDist)
		{
			newStartIdx = startIdx;
			newEndIdx = middleIdx;
		}
		else 
		{
			newStartIdx = middleIdx;
			newEndIdx = endIdx;
		}
		return this.getIndexToInsertBySquaredDist(objectsArray, object, newStartIdx, newEndIdx);
	}
};
















































'use strict';

/**
 * a point feature which will be used at three degree world
 * @class Point3D 
 * @param {Number} x 
 * @param {Number} y 
 * @param {Number} z 
 */

var Point3D = function(x, y, z) 
{
	if (!(this instanceof Point3D)) 
	{
		// throw new Error(Messages.CONSTRUCT_ERROR);
		throw new Error(i18next.t('error.construct.create'));
	}

	if (x !== undefined)
	{ this.x = x; }
	else
	{ this.x = 0.0; }
	
	if (y !== undefined)
	{ this.y = y; }
	else
	{ this.y = 0.0; }
	
	if (z !== undefined)
	{ this.z = z; }
	else
	{ this.z = 0.0; }
	
	this.pointType; // 1 = important point.
};

/**
 * delete the value of x,y,z coordi
 */
Point3D.prototype.deleteObjects = function() 
{
	this.x = undefined;
	this.y = undefined;
	this.z = undefined;
};

/**
 * copy the value of other point
 * @param {Point3D} point3d
 */
Point3D.prototype.copyFrom = function(point3d) 
{
	this.x = point3d.x;
	this.y = point3d.y;
	this.z = point3d.z;
};

/**
 * Calculate [this.x*this.x + this.y*this.y + this.z*this.z] to prepare squared module 
 * @returns {Number}
 */
Point3D.prototype.getSquaredModul = function() 
{
	return this.x*this.x + this.y*this.y + this.z*this.z;
};

/**
 * Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z );
 * @returns {Number}
 */
Point3D.prototype.getModul = function() 
{
	return Math.sqrt(this.getSquaredModul());
};

/**
 * 
 * get the unitary value
 */
Point3D.prototype.unitary = function() 
{
	var modul = this.getModul();
	this.x /= modul;
	this.y /= modul;
	this.z /= modul;
};

/**
 * 
 * check whether each value of the coordi is null or not
 * @returns {Boolean}
 */
Point3D.prototype.isNAN = function() 
{
	if (isNaN(this.x) || isNaN(this.y) || isNaN(this.z) )
	{ return true; }
	else
	{ return false; }
};

/**
 * Calculate vector product
 * @param {Point3D} point the point which will be used at this calculate.
 * @param {Point3D} resultPoint the point which will save the calculated value.
 * @returns {Number} calculated result
 */
Point3D.prototype.crossProduct = function(point, resultPoint) 
{
	if (resultPoint === undefined) { resultPoint = new Point3D(); }

	resultPoint.x = this.y * point.z - point.y * this.z;
	resultPoint.y = point.x * this.z - this.x * point.z;
	resultPoint.z = this.x * point.y - point.x * this.y;

	return resultPoint;
};

/**
 * Calculate scalar production of vector
 * @param {Point3D} point the point which will be used at this calculate.
 * @returns {Number} calculated result
 */
Point3D.prototype.scalarProduct = function(point) 
{
	var scalarProd = this.x*point.x + this.y*point.y + this.z*point.z;
	return scalarProd;
};

/**
 * get the spherical coordinates
 * @param {GeographicCoord}resultGeographicCoords the target that will be canged
 * @returns {GeographicCoord} resultGeographicCoords
 */
Point3D.prototype.getSphericalCoords = function(resultGeographicCoords) 
{
	if (resultGeographicCoords === undefined)
	{ resultGeographicCoords = new GeographicCoord(); }
	
	// heading.
	var xyProjectedPoint = new Point2D(this.x, this.y);
	var longitudeVectorRef = new Point2D(1.0, 0.0);
	var headingDeg = xyProjectedPoint.angleDegToVector(longitudeVectorRef);
	
	if (this.y < 0.0)
	{
		headingDeg = 360.0 - headingDeg;
	}
	
	// azimutal.meridian angle
	var projectedModul = xyProjectedPoint.getModul();
	var azimutRad = Math.atan(this.z/projectedModul);
	var azimutDeg = azimutRad * 180.0 / Math.PI;
	
	if (this.z < 0.0)
	{
		azimutDeg *= -1.0;
	}
	
	resultGeographicCoords.longitude = headingDeg;
	resultGeographicCoords.latitude = azimutDeg;
	
	return resultGeographicCoords;
};

/**
 * Check whether those of two vectors are parallel or not
 * If parallel then check whether the direction sense is same or not 
 */
Point3D.prototype.getRelativeOrientationToVector = function(vector, radError) 
{
	var angRad = this.angleRadToVector(vector);
	if (angRad < radError)
	{ return 0; } // there are parallel & the same direction sense.
	else if (Math.abs(Math.PI - angRad) < radError)
	{ return 1; } // there are parallel & opposite direction sense.
	else
	{ return 2; } // there are NO parallels.
};

/**
 * Calculate the radian value of the angle of the two vectors
 * @param vector the target vector
 * @returns the angle of two vector
 */
Point3D.prototype.angleRadToVector = function(vector) 
{
	if (vector === undefined)
	{ return undefined; }
	
	//
	//var scalarProd = this.scalarProd(vector);
	var myModul = this.getModul();
	var vecModul = vector.getModul();
	
	// calculate by cos.
	//var cosAlfa = scalarProd / (myModul * vecModul); 
	//var angRad = Math.acos(cosAlfa);
	//var angDeg = alfa * 180.0/Math.PI;
	//------------------------------------------------------
	var error = 10E-10;
	if (myModul < error || vecModul < error)
	{ return undefined; }
	
	return Math.acos(this.scalarProduct(vector) / (myModul * vecModul));
};

/**
 * Calculate the degree value of the angle of the two vectors
 * @param point 변수
 * @param resultPoint 변수
 * @returns resultPoint
 */
Point3D.prototype.angleDegToVector = function(vector) 
{
	if (vector === undefined)
	{ return undefined; }
	
	var angRad = this.angleRadToVector(vector);
	
	if (angRad === undefined)
	{ return undefined; }
		
	return angRad * 180.0/Math.PI;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.squareDistToPoint = function(point) 
{
	var dx = this.x - point.x;
	var dy = this.y - point.y;
	var dz = this.z - point.z;

	return dx*dx + dy*dy + dz*dz;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.isCoincidentToPoint = function(point, errorDist) 
{
	var squareDist = this.distToPoint(point);
	var coincident = false;
	if (squareDist < errorDist*errorDist)
	{
		coincident = true;
	}

	return coincident;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.squareDistTo = function(x, y, z) 
{
	var dx = this.x - x;
	var dy = this.y - y;
	var dz = this.z - z;

	return dx*dx + dy*dy + dz*dz;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.distTo = function(x, y, z) 
{
	return Math.sqrt(this.squareDistTo(x, y, z));
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.distToPoint = function(point) 
{
	return Math.sqrt(this.squareDistToPoint(point));
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.distToSphere = function(sphere) 
{
	return Math.sqrt(this.squareDistToPoint(sphere.centerPoint)) - sphere.r;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.aproxDistTo = function(pointB, sqrtTable) 
{
	var difX = Math.abs(this.x - pointB.x);
	var difY = Math.abs(this.y - pointB.y);
	var difZ = Math.abs(this.z - pointB.z);
	
	// find the big value.
	var maxValue, value1, value2;
	var value1Idx, value2Idx;
	
	if (difX > difY)
	{
		if (difX > difZ)
		{
			maxValue = difX;
			value1 = difY/maxValue;
			value1Idx = Math.floor(value1*10);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difZ/middleDist;
			value2Idx = Math.floor(value2*10);
			return (middleDist * sqrtTable[value2Idx]);
		}
		else 
		{
			maxValue = difZ;
			value1 = difX/maxValue;
			value1Idx = Math.floor(value1*10);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difY/middleDist;
			value2Idx = Math.floor(value2*10);
			return (middleDist * sqrtTable[value2Idx]);
		}
	}
	else 
	{
		if (difY > difZ)
		{
			maxValue = difY;
			value1 = difX/maxValue;
			value1Idx = Math.floor(value1*10);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difZ/middleDist;
			value2Idx = Math.floor(value2*10);
			return (middleDist * sqrtTable[value2Idx]);
		}
		else 
		{
			maxValue = difZ;
			value1 = difX/maxValue;
			value1Idx = Math.floor(value1*10);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difY/middleDist;
			value2Idx = Math.floor(value2*10);
			return (middleDist * sqrtTable[value2Idx]);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.getVectorToPoint = function(targetPoint, resultVector) 
{
	// this returns a vector that points to "targetPoint" from "this".
	// the "resultVector" has the direction from "this" to "targetPoint", but is NOT normalized.
	if (targetPoint === undefined)
	{ return undefined; }
	
	if (resultVector === undefined)
	{ resultVector = new Point3D(); }
	
	resultVector.set(targetPoint.x - this.x, targetPoint.y - this.y, targetPoint.z - this.z);
	
	return resultVector;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.set = function(x, y, z) 
{
	this.x = x; this.y = y; this.z = z;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.add = function(x, y, z) 
{
	this.x += x; this.y += y; this.z += z;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.addPoint = function(point) 
{
	this.x += point.x; this.y += point.y; this.z += point.z;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.scale = function(scaleFactor) 
{
	this.x *= scaleFactor; this.y *= scaleFactor; this.z *= scaleFactor;
};


/**
 * 3차원 정보
 * @class Point3DList
 */
var Point3DList = function() 
{
	if (!(this instanceof Point3DList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.points3dArray;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Point3DList.prototype.newPoint3D = function(x, y, z) 
{
	if (this.points3dArray === undefined)
	{ this.points3dArray = []; }
	
	var point3d = new Point3D(x, y, z);
	this.points3dArray.push(point3d);
	return point3d;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Point3DList.prototype.addPoint3D = function(point3d) 
{
	if (this.points3dArray === undefined)
	{ this.points3dArray = []; }
	
	this.points3dArray.push(point3d);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Point3DList.calculateBBox = function(points3DArray, resultBBox) 
{
	if (points3DArray === undefined)
	{ return undefined; }

	var pointCount = points3DArray.length;
	if (pointCount === 0)
	{ return undefined; }
	
	if (resultBBox === undefined)
	{ resultBBox = new BoundingBox(); }
	
	resultBBox.init(points3DArray[0]); // init the box.
	for (var i=1; i<pointCount; i++)
	{
		resultBBox.addPoint(points3DArray[i]);
	}
	
	return resultBBox;
};































'use strict';
/**
* Contain the list of the features of Point3D
* @class Point3DList
*/
var Point3DList = function(points3dArray) 
{
	if (!(this instanceof Point3DList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.pointsArray;
	if (points3dArray !== undefined)
	{ this.pointsArray = points3dArray; }
	
	this.bLoop; //check whether this Point3DList represents just LineString or Ring
	
	this.geoLocDataManager;//This contains the information to change this point to Absolute CRS
	this.vboKeysContainer;//This saves the key which GPU returns to VBO
};
/**
 * Clear the properties of this feature
 */
Point3DList.prototype.deleteObjects = function(magoManager)
{
	this.deletePoints3d();
	this.deleteVboKeysContainer(magoManager);
	
	if (this.geoLocDataManager !== undefined)
	{
		this.geoLocDataManager.deleteObjects();
		this.geoLocDataManager = undefined;
	}
};

/**
 * Clear vboKeysContainer
*/
Point3DList.prototype.deleteVboKeysContainer = function(magoManager)
{
	if (this.vboKeysContainer !== undefined)
	{
		var gl = magoManager.sceneState.gl;
		this.vboKeysContainer.deleteGlObjects(gl, magoManager.vboMemoryManager);
		this.vboKeysContainer = undefined;
	}
};
/**
 * Clear this.pointsArray of this feature
 */
Point3DList.prototype.deletePoints3d = function()
{
	if (this.pointsArray === undefined)
	{ return; }
	
	var pointsCount = this.pointsArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		this.pointsArray[i].deleteObjects();
		this.pointsArray[i] = undefined;
	}
	this.pointsArray = undefined;
};
/**
 * Add a feature of Point3D at the last of this.pointsArray
 * @param {Point3D} point3d the point that will be pushed at this.pointsArray
 */
Point3DList.prototype.addPoint = function(point3d)
{
	if (point3d === undefined)
	{ return; }
	
	if (this.pointsArray === undefined)
	{ this.pointsArray = []; }

	this.pointsArray.push(point3d);
};
/**
 * Return the coordinate contained at geoLocDataManager
 * @returns geoLoc
 */
Point3DList.prototype.getGeographicLocation = function()
{
	if (this.geoLocDataManager === undefined)
	{ this.geoLocDataManager = new GeoLocationDataManager(); }
	
	var geoLoc = this.geoLocDataManager.getCurrentGeoLocationData();
	if (geoLoc === undefined)
	{
		geoLoc = this.geoLocDataManager.newGeoLocationData("default");
	}
	
	return geoLoc;
};
/**
 * Add a list of Point3D at the last of this.pointsArray
 * @param point3dArray the point that will be pushed at this.pointsArray
 */
Point3DList.prototype.addPoint3dArray = function(points3dArray)
{
	if (this.pointsArray === undefined)
	{ this.pointsArray = []; }

	this.pointsArray.push.apply(this.pointsArray, points3dArray);
};
/**
 * Create a new feature of Point3D
 * @param {Number} x the x coordi of the point
 * @param {Number} y the y coordi of the point
 * @param {Number} z the z coordi of the point
 * @returns {Point3D} return the created point
 */
Point3DList.prototype.newPoint = function(x, y, z)
{
	if (this.pointsArray === undefined)
	{ this.pointsArray = []; }
	
	var point = new Point3D(x, y, z);
	this.pointsArray.push(point);
	return point;
};
/**
 * Search and return the specific feature of Point2D with the index that has at this.pointArray
 * @param {Number} idx the index of the target point at this.pointArray
 * 
 */
Point3DList.prototype.getPoint = function(idx)
{
	return this.pointsArray[idx];
};
/**
 * Return the length of this.pointArray
 * @returns {Number}
 */
Point3DList.prototype.getPointsCount = function()
{
	if (this.pointsArray === undefined)
	{ return 0; }
	
	return this.pointsArray.length;
};

/**
 * This function is used when this feature is a point3DRing.
 * Return the previous index of the given index.
 * @param {Number} idx the target index
 * @returns {Number} prevIdx
 */
Point3DList.prototype.getPrevIdx = function(idx)
{
	// Note: This function is used when this is a point3dLoop.
	var pointsCount = this.pointsArray.length;
	var prevIdx;
	
	if (idx === 0)
	{ prevIdx = pointsCount - 1; }
	else
	{ prevIdx = idx - 1; }

	return prevIdx;
};
/**
 * This function is used when this is a point3dLoop.
 * @param {Number} idx the index of the target point at this.pointArray
  * @returns {Number} prevIdx
 */
Point3DList.prototype.getNextIdx = function(idx)
{
	
	var pointsCount = this.pointsArray.length;
	var nextIdx;
	
	if (idx === pointsCount - 1)
	{ nextIdx = 0; }
	else
	{ nextIdx = idx + 1; }

	return nextIdx;
};

/**
 * get the segement with the index of the segment
 * @param {Number} idx the index of start point of segment
 * @param {Segment3D} resultSegment the segement which will store the result segment
 * @returns {Segment3D} resultSegment 
 * 
 */
Point3DList.prototype.getSegment3D = function(idx, resultSegment3d, bLoop)
{
	// If "bLoop" = true, then this points3dList is a loop.
	// If "bLoop" = false, then this points3dList is a string.
	if (bLoop === undefined)
	{ bLoop = false; }
	
	var pointsCount = this.getPointsCount();
	
	if (!bLoop && idx === pointsCount-1)
	{ return undefined; }
	
	var currPoint = this.getPoint(idx);
	var nextIdx = this.getNextIdx(idx);
	var nextPoint = this.getPoint(nextIdx);
	
	if (resultSegment3d === undefined)
	{ resultSegment3d = new Segment3D(currPoint, nextPoint); }
	else 
	{
		resultSegment3d.setPoints(currPoint, nextPoint);
	}
	
	return resultSegment3d;
};
/**
 * This function returns a plane that has the same angle with the 2 segments of a point(idx).
 * If "bLoop" = true, then this points3dList is a loop.
 * If "bLoop" = false, then this points3dList is a string.
 * @param idx index of the point3D which will define bisection plane
 * @param resultBisectionPlane
 * @param bLoop save the information whether this point3DList is ring or not
 * @result resultBisectionPlane a plane that has the same angle with the 2 segments of a point
 */
Point3DList.prototype.getBisectionPlane = function(idx, resultBisectionPlane, bLoop)
{
	if (bLoop === undefined)
	{ bLoop = false; }
	
	var pointsCount = this.getPointsCount();
	
	if (pointsCount < 1)
	{ return resultBisectionPlane; }
	
	if (resultBisectionPlane === undefined)
	{ resultBisectionPlane = new Plane(); }
	
	var point3d = this.getPoint(idx);
	var segment3d_A, segment3d_B;
	
	if (!bLoop)
	{
		if (idx === pointsCount-1)
		{
			// The last point is an exception in string mode.
			// Take the previous segment.
			var idxPrev = idx-1;
			segment3d_A = this.getSegment3D(idxPrev, undefined, bLoop);	
			segment3d_B = this.getSegment3D(idxPrev, undefined, bLoop);	
		}
		else if (idx === 0)
		{
			segment3d_A = this.getSegment3D(idx, undefined, bLoop);	
			segment3d_B = this.getSegment3D(idx, undefined, bLoop);
		}
		else
		{
			var idxPrev = idx-1;
			segment3d_A = this.getSegment3D(idx, undefined, bLoop);	
			segment3d_B = this.getSegment3D(idxPrev, undefined, bLoop);	
		}
	}
	else 
	{
		var idxPrev = this.getPrevIdx(idx);
		segment3d_A = this.getSegment3D(idx, undefined, bLoop);
		segment3d_B = this.getSegment3D(idxPrev, undefined, bLoop);	
	}
	
	var dirA = segment3d_A.getDirection();
	var dirB = segment3d_B.getDirection();
	dirA.addPoint(dirB);
	dirA.unitary;
	
	// Now, with "point3d" & "dir" make the plane.
	resultBisectionPlane.setPointAndNormal(point3d.x, point3d.y, point3d.z, dirA.x, dirA.y, dirA.z);
	
	return resultBisectionPlane;
};


/**
 * Make the vbo of this point3DList
 * @param magoManager
 */
Point3DList.prototype.makeVbo = function(magoManager)
{
	if (this.vboKeysContainer === undefined)
	{ this.vboKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
	
	var pointsCount = this.pointsArray.length;
	var posByteSize = pointsCount * 3;
	var posVboDataArray = new Float32Array(posByteSize);
	var point3d;
	for (var i=0; i<pointsCount; i++)
	{
		point3d = this.pointsArray[i];
		posVboDataArray[i*3] = point3d.x;
		posVboDataArray[i*3+1] = point3d.y;
		posVboDataArray[i*3+2] = point3d.z;
	}
	
	var vbo = this.vboKeysContainer.newVBOVertexIdxCacheKey();
	vbo.setDataArrayPos(posVboDataArray, magoManager.vboMemoryManager);
};

/**
 * Render this point3dlist using vbo of this list. 
 * @param magoManager
 * @param shader 
 * @param renderType
 * @param bLoop 
 * @param bEnableDepth if this is turned off, then the last-drawing feature will be shown at the top
 */
Point3DList.prototype.renderLines = function(magoManager, shader, renderType, bLoop, bEnableDepth)
{
	if (this.pointsArray === undefined)
	{ return false; }
	
	var gl = magoManager.sceneState.gl;
	
	if (this.vboKeysContainer === undefined || this.vboKeysContainer.getVbosCount() === 0)
	{
		this.makeVbo(magoManager);
		return;
	}

	shader.enableVertexAttribArray(shader.position3_loc);
	
	gl.uniform1i(shader.bPositionCompressed_loc, false);
	gl.uniform1i(shader.bUse1Color_loc, true);
	gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 0.1, 1.0]); //.
	gl.uniform1f(shader.fixPointSize_loc, 5.0);
	gl.uniform1i(shader.bUseFixPointSize_loc, true);
	
	if (bEnableDepth === undefined)
	{ bEnableDepth = true; }
	
	if (bEnableDepth)
	{ gl.enable(gl.DEPTH_TEST); }
	else
	{ gl.disable(gl.DEPTH_TEST); }

	// Render the line.
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader);
	
	if (renderType === 2)
	{
		var selectionManager = magoManager.selectionManager;
		var selectionColor = magoManager.selectionColor;

		var selColor = selectionColor.getAvailableColor(undefined); 
		var idxKey = selectionColor.decodeColor3(selColor.r, selColor.g, selColor.b);

		selectionManager.setCandidateGeneral(idxKey, this);
		gl.uniform4fv(shader.oneColor4_loc, [selColor.r/255.0, selColor.g/255.0, selColor.b/255.0, 1.0]);
	}
	
	var vbo_vicky = this.vboKeysContainer.vboCacheKeysArray[0]; // there are only one.
	if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
	{ return false; }

	gl.drawArrays(gl.LINE_STRIP, 0, vbo_vicky.vertexCount);
	
	// Check if exist selectedGeoCoord.
	/*
	var currSelected = magoManager.selectionManager.getSelectedGeneral();
	if(currSelected !== undefined && currSelected.constructor.name === "GeographicCoord")
	{
		gl.uniform4fv(shader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.
		gl.uniform1f(shader.fixPointSize_loc, 10.0);
		currSelected.renderPoint(magoManager, shader, gl, renderType);
	}
	*/
	
	gl.enable(gl.DEPTH_TEST);
};

Point3DList.prototype.renderPoints = function(magoManager)
{
	
};











































'use strict';

/**
 * 4차원 정보
 * @class Point4D
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @param {Number} w
 */
var Point4D = function(x, y, z, w) 
{
	if (!(this instanceof Point4D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	if (x !== undefined)
	{ this.x = x; }
	else
	{ this.x = 0.0; }
	
	if (y !== undefined)
	{ this.y = y; }
	else
	{ this.y = 0.0; }
	
	if (z !== undefined)
	{ this.z = z; }
	else
	{ this.z = 0.0; }
	
	if (w !== undefined)
	{ this.w = w; }
	else
	{ this.w = 0.0; }
	
	this.pointType; // 1 = important point.
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Polygon2D
 */
var Polygon2D = function() 
{
	if (!(this instanceof Polygon2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// This is a 2D polygon.
	this.point2dList; // the border of this feature
	this.normal; // Polygon2D sense. (normal = 1) -> CCW. (normal = -1) -> CW.
	this.convexPolygonsArray; // tessellation result.
	this.bRect; // boundary rectangle.
};

Polygon2D.prototype.deleteObjects = function()
{
	if (this.point2dList !== undefined)
	{
		this.point2dList.deleteObjects();
		this.point2dList = undefined;
	}
	
	this.normal = undefined;
};

Polygon2D.prototype.getBoundingRectangle = function(resultBRect)
{
	if (this.point2dList === undefined)
	{ return resultBRect; }
	
	resultBRect = this.point2dList.getBoundingRectangle(resultBRect);
	return resultBRect;
};
/**
 * get the direction of the specific line segment of the edge
 * @param {Number} idx the index of the specific line segment
 * @returns direction	
 */
Polygon2D.prototype.getEdgeDirection = function(idx)
{
	// the direction is unitary vector.
	var segment = this.point2dList.getSegment(idx);
	var direction = segment.getDirection(undefined);
	return direction;
};

/**
 * get the vector of the specigic line segement of the edge
 * @param {Number} index the index of the specific line segment
 * @returns vector
 */
Polygon2D.prototype.getEdgeVector = function(idx)
{
	var segment = this.point2dList.getSegment(idx);
	var vector = segment.getVector(undefined);
	return vector;
};

/**
 * reverse the direction sense of this polygon
 */
Polygon2D.prototype.reverseSense = function()
{
	if (this.point2dList !== undefined)
	{ this.point2dList.reverse(); }
};

/**
 * copy the information of the other polygon to this polygon
 * @param {Polygon2D} resultCopyPolygon
 * @returns {Polygon2D} resultCopyPolygon
 */
Polygon2D.prototype.getCopy = function(resultCopyPolygon)
{
	if (this.point2dList === undefined)
	{ return resultCopyPolygon; }
	
	if (resultCopyPolygon === undefined)
	{ resultCopyPolygon = new Polygon2D(); }
	
	// copy the point2dList and the normal.
	if (resultCopyPolygon.point2dList === undefined)
	{ resultCopyPolygon.point2dList = new Point2DList(); }
	
	resultCopyPolygon.point2dList = this.point2dList.getCopy(resultCopyPolygon.point2dList);
	
	if (this.normal)
	{ resultCopyPolygon.normal = this.normal; }
	
	return resultCopyPolygon;
};

/**
 * Calculate the normal vector of this polygon
 * @param resultConcavePointsIdxArray save the index of the points which make concave at the border
 * @returns resultFConcavePointsIdxArray the list of the index which make concave at the border
 */
Polygon2D.prototype.calculateNormal = function(resultConcavePointsIdxArray)
{
	// must check if the verticesCount is 3. Then is a convex polygon.
	
	// A & B are vectors.
	// A*B is scalarProduct.
	// A*B = |A|*|B|*cos(alfa)
	var point;
	var crossProd;
	
	if (resultConcavePointsIdxArray === undefined)
	{ resultConcavePointsIdxArray = []; }
	
	//var candidate_1 = {}; // normal candidate 1.
	//var candidate_2 = {}; // normal candidate 2.
	
	this.normal = 0; // unknown sense.
	var pointsCount = this.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point = this.point2dList.getPoint(i);
		var prevIdx = this.point2dList.getPrevIdx(i);
		
		// get unitari directions of the vertex.
		var startVec = this.getEdgeDirection(prevIdx); // Point3D.
		var endVec = this.getEdgeDirection(i); // Point3D.
		
		// calculate the cross product.
		var crossProd = startVec.crossProduct(endVec, crossProd); // Point3D.
		var scalarProd = startVec.scalarProduct(endVec);
		
		if (crossProd < 0.0) 
		{
			crossProd = -1;
			resultConcavePointsIdxArray.push(i);
		}
		else if (crossProd > 0.0) 
		{
			crossProd = 1;
		}
		else
		{ continue; }
		// calcule by cos.
		// cosAlfa = scalarProd / (strModul * endModul); (but strVecModul = 1 & endVecModul = 1), so:
		var cosAlfa = scalarProd;
		var alfa = Math.acos(cosAlfa);
		this.normal += (crossProd * alfa);
	}
	
	if (this.normal > 0 )
	{ this.normal = 1; }
	else
	{ this.normal = -1; }
	
	return resultConcavePointsIdxArray;
};

/**
 * Make the tessellate of the triangles which originally make up single Polygon2D feature (like a patchwork with triangle)
 * To call this function, before must call "calculateNormal" that returns "concaveVerticesIndices"
 * In 2D, "normal" is -1=(cw) or 1=(ccw).
 * @param concaveVerticesIndices the index of the points which make concave
 * @param convexPolygonsArray the index of the points which make convex
 */
Polygon2D.prototype.tessellate = function(concaveVerticesIndices, convexPolygonsArray)
{

	var concaveVerticesCount = concaveVerticesIndices.length;
	
	if (concaveVerticesCount === 0)
	{
		convexPolygonsArray.push(this);
		return convexPolygonsArray;
	}
	
	// now, for any concave vertex, find the closest vertex to split the polygon.
	var find = false;
	var idx_B;
	var i=0;
	
	while (!find && i<concaveVerticesCount)
	{
		var idx = concaveVerticesIndices[i];
		var point = this.point2dList.getPoint(idx);
		var resultSortedPointsIdxArray = [];
		
		// get vertices indices sorted by distance to "point".
		this.getPointsIdxSortedByDistToPoint(point, resultSortedPointsIdxArray);
		
		var sortedVerticesCount = resultSortedPointsIdxArray.length;
		var j=0;
		while (!find && j<sortedVerticesCount)
		{
			idx_B = resultSortedPointsIdxArray[j];
			
			// skip adjacent vertices.
			if (this.point2dList.getPrevIdx(idx) === idx_B || this.point2dList.getNextIdx(idx) === idx_B)
			{
				j++;
				continue;
			}
			
			// check if is splittable by idx-idx_B.
			var segment = new Segment2D(this.point2dList.getPoint(idx), this.point2dList.getPoint(idx_B));
			if (this.intersectionWithSegment(segment))
			{
				j++;
				continue;
			}
			
			var resultSplittedPolygons = this.splitPolygon(idx, idx_B);
			
			if (resultSplittedPolygons.length < 2)
			{
				j++;
				continue;
			}
			
			// now, compare splittedPolygon's normals with myNormal.
			var polygon_A = resultSplittedPolygons[0];
			var polygon_B = resultSplittedPolygons[1];
			var concavePoints_A = polygon_A.calculateNormal();
			var concavePoints_B = polygon_B.calculateNormal();
			
			var normal_A = polygon_A.normal;
			var normal_B = polygon_B.normal;
			if (normal_A === this.normal && normal_B === this.normal)
			{
				find = true;
				// polygon_A.
				if (concavePoints_A.length > 0)
				{
					convexPolygonsArray = polygon_A.tessellate(concavePoints_A, convexPolygonsArray);
				}
				else 
				{
					if (convexPolygonsArray === undefined)
					{ convexPolygonsArray = []; }
					
					convexPolygonsArray.push(polygon_A);
				}
				
				// polygon_B.
				if (concavePoints_B.length > 0)
				{
					convexPolygonsArray = polygon_B.tessellate(concavePoints_B, convexPolygonsArray);
				}
				else 
				{
					if (convexPolygonsArray === undefined)
					{ convexPolygonsArray = []; }
					
					convexPolygonsArray.push(polygon_B);
				}
			}
			
			j++;
		}
		i++;
	}
	
	return convexPolygonsArray;
};
/**
 * Check whether the given segment cut a polygon edges or is coincident with a polygon's vertex 
 * @param segment the target segement
 * */
Polygon2D.prototype.intersectionWithSegment = function(segment)
{
	if (this.bRect !== undefined)
	{
		// if exist boundary rectangle, check bRect intersection.
		var segmentsBRect = segment.getBoundaryRectangle(segmentsBRect);
		if (!this.bRect.intersectsWithRectangle(segmentsBRect))
		{ return false; }
	}
	
	// 1rst check if the segment is coincident with any polygons vertex.
	var mySegment;
	var intersectionType;
	var error = 10E-8;
	var pointsCount = this.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		mySegment = this.point2dList.getSegment(i, mySegment);
		
		// if segment shares points, then must not cross.
		if (segment.sharesPointsWithSegment(mySegment))
		{
			continue;
		}
		
		if (segment.intersectionWithSegment(mySegment, error))
		{
			return true;
		}
	}
	
	return false;
};

/**
 * Split single polygon as 2 polygons regarding of points of idx1, idx2
 * @param idx1 the index of the first point
 * @param idx2 the index of the second point
 * @param resultSplittedPolygonsArray the list of the created polygons by splitting
 */
Polygon2D.prototype.splitPolygon = function(idx1, idx2, resultSplittedPolygonsArray)
{
	if (resultSplittedPolygonsArray === undefined)
	{ resultSplittedPolygonsArray = []; }
	
	// polygon A. idx1 -> idx2.
	var polygon_A = new Polygon2D();
	polygon_A.point2dList = new Point2DList();
	polygon_A.point2dList.pointsArray = [];
	
	// 1rst, put vertex1 & vertex2 in to the polygon_A.
	polygon_A.point2dList.pointsArray.push(this.point2dList.getPoint(idx1));
	polygon_A.point2dList.pointsArray.push(this.point2dList.getPoint(idx2));
	
	var finished = false;
	var currIdx = idx2;
	var startIdx = idx1;
	var i=0;
	var totalPointsCount = this.point2dList.getPointsCount();
	while (!finished && i<totalPointsCount)
	{
		var nextIdx = this.point2dList.getNextIdx(currIdx);
		if (nextIdx === startIdx)
		{
			finished = true;
		}
		else 
		{
			polygon_A.point2dList.pointsArray.push(this.point2dList.getPoint(nextIdx));
			currIdx = nextIdx;
		}
		i++;
	}
	
	resultSplittedPolygonsArray.push(polygon_A);
	
	// polygon B. idx2 -> idx1.
	var polygon_B = new Polygon2D();
	polygon_B.point2dList = new Point2DList();
	polygon_B.point2dList.pointsArray = [];
	
	// 1rst, put vertex2 & vertex1 in to the polygon_B.
	polygon_B.point2dList.pointsArray.push(this.point2dList.getPoint(idx2));
	polygon_B.point2dList.pointsArray.push(this.point2dList.getPoint(idx1));
	
	finished = false;
	currIdx = idx1;
	startIdx = idx2;
	i=0;
	while (!finished && i<totalPointsCount)
	{
		var nextIdx = this.point2dList.getNextIdx(currIdx);
		if (nextIdx === startIdx)
		{
			finished = true;
		}
		else 
		{
			polygon_B.point2dList.pointsArray.push(this.point2dList.getPoint(nextIdx));
			currIdx = nextIdx;
		}
		i++;
	}
	
	resultSplittedPolygonsArray.push(polygon_B);
	return resultSplittedPolygonsArray;
};

Polygon2D.prototype.getPointsIdxSortedByDistToPoint = function(thePoint, resultSortedPointsIdxArray)
{
	// Static function.
	// Sorting minDist to maxDist.
	if (resultSortedPointsIdxArray === undefined)
	{ resultSortedPointsIdxArray = []; }
	
	resultSortedPointsIdxArray = this.point2dList.getPointsIdxSortedByDistToPoint(thePoint, resultSortedPointsIdxArray);
	
	return resultSortedPointsIdxArray;
};

/**
 * Make the list of triangles at the convex polygon
 * @param resultTrianglesArray the list of triangles made from the polygon
 * @returns resultTrianglesArray
 */
Polygon2D.prototype.getTrianglesConvexPolygon = function(resultTrianglesArray)
{
	// PROVISIONAL.
	// in this case, consider the polygon is convex.
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }

	var pointsCount = this.point2dList.getPointsCount();
	if (pointsCount <3)
	{ return resultTrianglesArray; }
	
	var triangle;
	for (var i=1; i<pointsCount-1; i++)
	{
		triangle = new Triangle();
		
		var point0idx = this.point2dList.getPoint(0).idxInList;
		var point1idx = this.point2dList.getPoint(i).idxInList;
		var point2idx = this.point2dList.getPoint(i+1).idxInList;
		
		triangle.vtxIdx0 = point0idx;
		triangle.vtxIdx1 = point1idx;
		triangle.vtxIdx2 = point2idx;
		
		resultTrianglesArray.push(triangle);
	}
	
	return resultTrianglesArray;
};
/**
 * @TODO : need to refactoring both of this function. 
 * 
 */
Polygon2D.prototype.getVbo = function(resultVbo)
{
	// PROVISIONAL.
	// return positions, normals and indices.
	if (resultVbo === undefined)
	{ resultVbo = new VBOVertexIdxCacheKey(); }
	
	// 1rst, obtain pos, nor.
	var posArray = [];
	var norArray = [];
	var point;
	var normal;
	if (this.normal > 0)
	{ normal = 1; }
	else
	{ normal = -1; }
		
	var pointsCount = this.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point = this.point2dList.getPoint(i);
		
		posArray.push(point.x);
		posArray.push(point.y);
		posArray.push(0.0);
		
		norArray.push(0);
		norArray.push(0);
		norArray.push(normal*255);
	}
	
	resultVbo.posVboDataArray = Float32Array.from(posArray);
	resultVbo.norVboDataArray = Int8Array.from(norArray);
	
	// now calculate triangles indices.
	this.point2dList.setIdxInList(); // use this function instead a map.
	
	var trianglesArray = [];
	var convexPolygonsCount = this.convexPolygonsArray.length;
	for (var i=0; i<convexPolygonsCount; i++)
	{
		var convexPolygon = this.convexPolygonsArray[i];
		trianglesArray = convexPolygon.getTrianglesConvexPolygon(trianglesArray); // provisional.
	}
	TrianglesList.getVboFaceDataArray(trianglesArray, resultVbo);

	return resultVbo;
};
/**
 * @TODO : need to refactoring both of this function. 
 * 
 */
Polygon2D.getVbo = function(concavePolygon, convexPolygonsArray, resultVbo)
{
	// PROVISIONAL.
	// return positions, normals and indices.
	if (resultVbo === undefined)
	{ resultVbo = new VBOVertexIdxCacheKey(); }
	
	// 1rst, obtain pos, nor.
	var posArray = [];
	var norArray = [];
	var point;
	var normal;
	if (concavePolygon.normal > 0)
	{ normal = 1; }
	else
	{ normal = -1; }
		
	var pointsCount = concavePolygon.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point = concavePolygon.point2dList.getPoint(i);
		
		posArray.push(point.x);
		posArray.push(point.y);
		posArray.push(0.0);
		
		norArray.push(0);
		norArray.push(0);
		norArray.push(normal*255);
	}
	
	resultVbo.posVboDataArray = Float32Array.from(posArray);
	resultVbo.norVboDataArray = Int8Array.from(norArray);
	
	// now calculate triangles indices.
	concavePolygon.point2dList.setIdxInList(); // use this function instead a map.
	
	var trianglesArray = [];
	var convexPolygonsCount = convexPolygonsArray.length;
	for (var i=0; i<convexPolygonsCount; i++)
	{
		var convexPolygon = convexPolygonsArray[i];
		trianglesArray = convexPolygon.getTrianglesConvexPolygon(trianglesArray); // provisional.
	}
	TrianglesList.getVboFaceDataArray(trianglesArray, resultVbo);

	return resultVbo;
};
























'use strict';

/**
 * PolyLine represented in 2D
 * This is similar with Point2DList, but this one represents real polyline geometry feature.
 * @class PolyLine2D
 */
var PolyLine2D = function() 
{
	if (!(this instanceof PolyLine2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.point2dArray;
};

/**
 * Creates a new Point2D.
 * @param {Number} x
 * @param {Number} y
 * @returns point2d
 */
PolyLine2D.prototype.newPoint2d = function(x, y)
{
	if (this.point2dArray === undefined)
	{ this.point2dArray = []; }
	
	var point2d = new Point2D(x, y);
	this.point2dArray.push(point2d);
	return point2d;
};

/**
 * Count the number of the point2D in this list
 */
PolyLine2D.prototype.getPointsCount = function()
{
	if (this.point2dArray === undefined)
	{ return 0; }
	
	return this.point2dArray.length;
};

/**
 * Clear all the features in this.point2dArray
 */
PolyLine2D.prototype.deleteObjects = function()
{
	var pointsCount = this.point2dArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		this.point2dArray[i].deleteObjects();
		this.point2dArray[i] = undefined;
	}
	this.point2dArray = undefined;
};

/**
 * Copy the point from this.point2dArray to resultPointsArray
 * @param resultPointsArray
 * @returns resultPointsArray 
 */
PolyLine2D.prototype.getPoints = function(resultPointsArray)
{
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	var point;
	var errorDist = 10E-8;
	var resultExistentPointsCount = resultPointsArray.length;
	var pointsCount = this.point2dArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		if (i===0)
		{
			if (resultExistentPointsCount > 0)
			{
				// check if the last point of "resultPointsArray" and the 1rst point of "this" is coincident.
				var lastExistentPoint = resultPointsArray[resultExistentPointsCount-1];
				var point0 = this.point2dArray[i];
				if (!lastExistentPoint.isCoincidentToPoint(point0, errorDist))
				{
					point = new Point2D();
					point.copyFrom(this.point2dArray[i]); 
					point.pointType = 1; // mark as "important point".
					resultPointsArray.push(point);
				}
			}
			else
			{
				point = new Point2D();
				point.copyFrom(this.point2dArray[i]); 
				point.pointType = 1; // mark as "important point".
				resultPointsArray.push(point);
			}
		}
		else
		{
			point = new Point2D();
			point.copyFrom(this.point2dArray[i]); 
			point.pointType = 1; // mark as "important point".
			resultPointsArray.push(point);
		}
	}
	
	return resultPointsArray;
};












































'use strict';

/**
 * This is similar with Point23List, but this one represents real polyline geometry feature.
 * @class PolyLine3D
 */
var PolyLine3D = function() 
{
	if (!(this instanceof PolyLine3D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.point3dArray;
	this.geoLocDataManager;
	this.vboKeysContainer;
};

/**
 * Creates a new Point3D.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @returns point3d
 */
PolyLine3D.prototype.newPoint3d = function(x, y, z)
{
	if (this.point3dArray === undefined)
	{ this.point3dArray = []; }
	
	var point3d = new Point3D(x, y, z);
	this.point3dArray.push(point3d);
	return point3d;
};

/**
 * Add a list of Point3D at the last of this.pointsArray
 * @param point3dArray the point that will be pushed at this.pointsArray
 */
PolyLine3D.prototype.addPoint3dArray = function(points3dArray)
{
	if (points3dArray === undefined)
	{ return; }
	
	if (this.point3dArray === undefined)
	{ this.point3dArray = []; }

	this.point3dArray.push.apply(this.point3dArray, points3dArray);
};

/**
 * Return the coordinate contained at geoLocDataManager
 * @returns geoLoc
 */
PolyLine3D.prototype.getGeographicLocation = function()
{
	if (this.geoLocDataManager === undefined)
	{ this.geoLocDataManager = new GeoLocationDataManager(); }
	
	var geoLoc = this.geoLocDataManager.getCurrentGeoLocationData();
	if (geoLoc === undefined)
	{
		geoLoc = this.geoLocDataManager.newGeoLocationData("default");
	}
	
	return geoLoc;
};

/**
 * Make the vbo of this point3DList
 * @param magoManager
 */
PolyLine3D.prototype.makeVbo = function(magoManager)
{
	if (this.vboKeysContainer === undefined)
	{ this.vboKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
	
	var pointsCount = this.point3dArray.length;
	var posByteSize = pointsCount * 3;
	var posVboDataArray = new Float32Array(posByteSize);
	var point3d;
	for (var i=0; i<pointsCount; i++)
	{
		point3d = this.point3dArray[i];
		posVboDataArray[i*3] = point3d.x;
		posVboDataArray[i*3+1] = point3d.y;
		posVboDataArray[i*3+2] = point3d.z;
	}
	
	var vbo = this.vboKeysContainer.newVBOVertexIdxCacheKey();
	vbo.setDataArrayPos(posVboDataArray, magoManager.vboMemoryManager);
};

/**
 * Render this point3dlist using vbo of this list. 
 * @param magoManager
 * @param shader 
 * @param renderType
 * @param bLoop 
 * @param bEnableDepth if this is turned off, then the last-drawing feature will be shown at the top
 */
PolyLine3D.prototype.renderLines = function(magoManager, shader, renderType, bLoop, bEnableDepth)
{
	if (this.point3dArray === undefined)
	{ return false; }
	
	var gl = magoManager.sceneState.gl;
	
	if (this.vboKeysContainer === undefined || this.vboKeysContainer.getVbosCount() === 0)
	{ this.makeVbo(magoManager); }

	shader.enableVertexAttribArray(shader.position3_loc);
	
	gl.uniform1i(shader.bPositionCompressed_loc, false);
	gl.uniform1i(shader.bUse1Color_loc, true);
	gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 0.1, 1.0]); //.
	gl.uniform1f(shader.fixPointSize_loc, 5.0);
	gl.uniform1i(shader.bUseFixPointSize_loc, true);
	
	if (bEnableDepth === undefined)
	{ bEnableDepth = true; }
	
	if (bEnableDepth)
	{ gl.enable(gl.DEPTH_TEST); }
	else
	{ gl.disable(gl.DEPTH_TEST); }

	// Render the line.
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader);
	
	if (renderType === 2)
	{
		var selectionManager = magoManager.selectionManager;
		var selectionColor = magoManager.selectionColor;

		var selColor = selectionColor.getAvailableColor(undefined); 
		var idxKey = selectionColor.decodeColor3(selColor.r, selColor.g, selColor.b);

		selectionManager.setCandidateGeneral(idxKey, this);
		gl.uniform4fv(shader.oneColor4_loc, [selColor.r/255.0, selColor.g/255.0, selColor.b/255.0, 1.0]);
	}
	
	var vbo_vicky = this.vboKeysContainer.vboCacheKeysArray[0]; // there are only one.
	if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
	{ return false; }

	gl.drawArrays(gl.LINE_STRIP, 0, vbo_vicky.vertexCount);
	
	// Check if exist selectedGeoCoord.
	/*
	var currSelected = magoManager.selectionManager.getSelectedGeneral();
	if(currSelected !== undefined && currSelected.constructor.name === "GeographicCoord")
	{
		gl.uniform4fv(shader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.
		gl.uniform1f(shader.fixPointSize_loc, 10.0);
		currSelected.renderPoint(magoManager, shader, gl, renderType);
	}
	*/
	
	gl.enable(gl.DEPTH_TEST);
};

/**
 * @class PolyLine3D
 */
PolyLine3D.prototype.renderPoints = function(magoManager)
{
	
};




















































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Profile2D
 */
var Profile2D = function() 
{
	if (!(this instanceof Profile2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.outerRing; // one Ring2D. 
	this.innerRingsList; // class: Ring2DList. 
};

/**
 * Set new outer border of this polygon as outerRing
 * @returns {Ring2D} outerRing
 */
Profile2D.prototype.newOuterRing = function() 
{
	if (this.outerRing === undefined)
	{ this.outerRing = new Ring2D(); }
	else 
	{
		this.outerRing.deleteObjects();
	}
	
	return this.outerRing;
};

/**
 * set new inner border of this polygon as innerRing
 * @returns {Ring2D} innerRing
 */
Profile2D.prototype.newInnerRing = function() 
{
	if (this.innerRingsList === undefined)
	{ this.innerRingsList = new Ring2DList(); }
	
	var innerRing = this.innerRingsList.newRing();
	
	return innerRing;
};

/**
 * Get the list of innerRings
 * @returns {}
 */
Profile2D.prototype.getInnerRingsList = function() 
{
	if (this.innerRingsList === undefined)
	{ this.innerRingsList = new Ring2DList(); }

	return this.innerRingsList;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile2D.prototype.deleteObjects = function() 
{
	if (this.outerRing)
	{
		this.outerRing.deleteObjects();
		this.outerRing = undefined;
	}

	if (this.innerRingsList)
	{
		this.innerRingsList.deleteObjects();
		this.innerRingsList = undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */

Profile2D.prototype.hasHoles = function() 
{
	if (this.innerRingsList === undefined || this.innerRingsList.getRingsCount() === 0)
	{ return false; }
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
 
Profile2D.prototype.getVBO = function(resultVbo) 
{
	if (this.outerRing === undefined)
	{ return resultVbo; }
	
	var generalPolygon = this.getGeneralPolygon(undefined);
	generalPolygon.getVbo(resultVbo);
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
 
Profile2D.prototype.getConvexFacesIndicesData = function(resultGeneralIndicesData) 
{
	if (this.outerRing === undefined)
	{ return resultVbo; }
	
	var generalPolygon = this.getGeneralPolygon(undefined);
	
	if (resultGeneralIndicesData === undefined)
	{ resultGeneralIndicesData = []; }
	
	// 1rst, set idxInList all points.
	this.outerRing.polygon.point2dList.setIdxInList();
	
	if (this.innerRingsList !== undefined)
	{
		var innerRingsCount = this.innerRingsList.getRingsCount();
		for (var i=0; i<innerRingsCount; i++)
		{
			var innerRing = this.innerRingsList.getRing(i);
			innerRing.polygon.point2dList.setIdxInList();
		}
	}
	
	var convexDatas;
	var convexPolygon;
	var indexData;
	var currRing;
	var ringIdxInList;
	var point;
	var convexPolygonsCount = generalPolygon.convexPolygonsArray.length;
	for (var i=0; i<convexPolygonsCount; i++)
	{
		convexPolygon = generalPolygon.convexPolygonsArray[i];
		convexDatas = [];
		var pointsCount = convexPolygon.point2dList.getPointsCount();
		for (var j=0; j<pointsCount; j++)
		{
			point = convexPolygon.point2dList.getPoint(j);
			indexData = point.indexData;
			currRing = indexData.owner;
			indexData.idxInList = point.idxInList;
			if (currRing === this.outerRing)
			{
				ringIdxInList = -1; // Set idx of outerRing as -1.
			}
			else 
			{
				ringIdxInList = this.innerRingsList.getRingIndex(currRing);
			}
			indexData.ownerIdx = ringIdxInList;
			convexDatas.push(indexData);
		}
		resultGeneralIndicesData.push(convexDatas);
	}
	
	return resultGeneralIndicesData;
};


/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
 
Profile2D.prototype.getGeneralPolygon = function(generalPolygon) 
{
	// this returns a holesTessellatedPolygon, and inside it has convexPolygons.
	this.checkNormals(); // here makes outer & inner's polygons.
	
	if (!this.hasHoles())
	{
		// Simply, put all points of outerPolygon into generalPolygon(computingPolygon).
		if (generalPolygon === undefined)
		{ generalPolygon = new Polygon2D(); }
		
		if (generalPolygon.point2dList === undefined)
		{ generalPolygon.point2dList = new Point2DList(); }
		
		var outerPolygon = this.outerRing.polygon;
		var point;
		var outerPointsCount = outerPolygon.point2dList.getPointsCount();
		for (var i=0; i<outerPointsCount; i++)
		{
			point = outerPolygon.point2dList.getPoint(i);
			generalPolygon.point2dList.addPoint(outerPolygon.point2dList.getPoint(i));
		}
	}
	else 
	{
		// 1rst, check normals congruences.
		generalPolygon = this.tessellateHoles(generalPolygon);
	}
	
	generalPolygon.convexPolygonsArray = [];
	var concavePointsIndices = generalPolygon.calculateNormal(concavePointsIndices);
	generalPolygon.convexPolygonsArray = generalPolygon.tessellate(concavePointsIndices, generalPolygon.convexPolygonsArray);
	
	return generalPolygon;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile2D.prototype.eliminateHolePolygonBySplitPoints = function(outerPolygon, innerPolygon, outerPointIdx, innerPointIdx, resultPolygon) 
{
	if (resultPolygon === undefined)
	{ resultPolygon = new Polygon2D(); }
	
	if (resultPolygon.point2dList === undefined)
	{ resultPolygon.point2dList = new Point2DList(); }
	
	// 1rst, copy in newPolygon the outerPolygon.
	var outerPointsCount = outerPolygon.point2dList.getPointsCount();
	var finished = false;
	var i=0;
	var newPoint;
	var outerPoint;
	var currIdx = outerPointIdx;
	
	while (!finished && i<outerPointsCount)
	{
		outerPoint = outerPolygon.point2dList.getPoint(currIdx);
		resultPolygon.point2dList.addPoint(outerPoint);
		
		currIdx = outerPolygon.point2dList.getNextIdx(currIdx);
		if (currIdx === outerPointIdx)
		{
			finished = true;
			
			// must add the firstPoint point.
			outerPoint = outerPolygon.point2dList.getPoint(currIdx);
			resultPolygon.point2dList.addPoint(outerPoint);
		}
		
		i++;
	}
	// now add innerPolygon's points.
	var innerPointsCount = innerPolygon.point2dList.getPointsCount();
	finished = false;
	i=0;
	newPoint;
	var innerPoint;
	currIdx = innerPointIdx;
	while (!finished && i<innerPointsCount)
	{
		innerPoint = innerPolygon.point2dList.getPoint(currIdx);
		resultPolygon.point2dList.addPoint(innerPoint);
		
		currIdx = innerPolygon.point2dList.getNextIdx(currIdx);
		if (currIdx === innerPointIdx)
		{
			finished = true;
			// must add the firstPoint point.
			innerPoint = innerPolygon.point2dList.getPoint(currIdx);
			resultPolygon.point2dList.addPoint(innerPoint);
		}
		
		i++;
	}
	
	return resultPolygon;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile2D.prototype.eliminateHolePolygon = function(computingPolygon, innerRing, innerPointIdx, resultPolygon) 
{
	// 1rst, make a sorted by dist of points of outer to "innerPoint".
	var resultSortedPointsIdxArray = [];
	var innerPolygon = innerRing.polygon;
	var innerPoint = innerPolygon.point2dList.getPoint(innerPointIdx);
	resultSortedPointsIdxArray = computingPolygon.getPointsIdxSortedByDistToPoint(innerPoint, resultSortedPointsIdxArray);
	
	var outerSortedPointsCount = resultSortedPointsIdxArray.length;
	var splitSegment = new Segment2D();;
	var finished = false;
	var i=0;
	var outPointIdx;
	var outPoint;
	while (!finished && i<outerSortedPointsCount)
	{
		outPointIdx = resultSortedPointsIdxArray[i];
		outPoint = computingPolygon.point2dList.getPoint(outPointIdx);
		splitSegment.setPoints(outPoint, innerPoint);
		
		// check if splitSegment intersects the computingPolygon or any innerPolygons.
		if (computingPolygon.intersectionWithSegment(splitSegment) || innerPolygon.intersectionWithSegment(splitSegment))
		{
			i++;
			continue;
		}
		
		resultPolygon = this.eliminateHolePolygonBySplitPoints(computingPolygon, innerPolygon, outPointIdx, innerPointIdx, resultPolygon);
		finished = true;
		
		i++;
	}
	
	if (!finished)
	{ return false; }
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile2D.prototype.tessellateHoles = function(resultHolesEliminatedPolygon) 
{
	if (this.outerRing === undefined)
	{ return resultHolesEliminatedPolygon; }
	
	if (!this.hasHoles())
	{ return resultHolesEliminatedPolygon; }
	
	if (resultHolesEliminatedPolygon === undefined)
	{ resultHolesEliminatedPolygon = new Polygon2D(); }
	
	var hole;
	var holeIdx;
	var holePolygon;
	var objectAux;
	var innerPointIdx;
	var innersBRect;
	
	// prepare outerRing if necessary.
	var outerRing = this.outerRing;
	if (outerRing.polygon === undefined)
	{ outerRing.makePolygon(); }
	var outerPolygon = outerRing.polygon;
	var concavePointsIndices = outerPolygon.calculateNormal(concavePointsIndices);
	
	// make a innerRingsArray copy.
	var innerRingsArray = [];
	var innerRingsCount = this.innerRingsList.getRingsCount();
	for (var i=0; i<innerRingsCount; i++)
	{
		innerRingsArray.push(this.innerRingsList.getRing(i));
	}
	
	var resultPolygon = new Polygon2D();
	var computingPolygon = new Polygon2D();
	computingPolygon.point2dList = new Point2DList();
	
	// put all points of outerPolygon into computingPolygon.
	var indexData;
	var point;
	var outerPointsCount = outerPolygon.point2dList.getPointsCount();
	for (var i=0; i<outerPointsCount; i++)
	{
		point = outerPolygon.point2dList.getPoint(i);
		computingPolygon.point2dList.addPoint(outerPolygon.point2dList.getPoint(i));
	}
	
	var innersBRectLeftDownPoint = new Point2D();
	var objectsArray = [];
	
	// now, for each innerRing, try to merge to outerRing by splitSegment.
	var innerRingsCount = innerRingsArray.length;
	var i=0;
	var finished = false;
	while (!finished && i<innerRingsCount)
	{
		// calculate the most left-down innerRing.
		innersBRect = Ring2DList.getBoundingRectangle(innerRingsArray, innersBRect);
		innersBRectLeftDownPoint.set(innersBRect.minX, innersBRect.minY);
		
		objectsArray.length = 0; // init.
		objectsArray = Ring2DList.getSortedRingsByDistToPoint(innersBRectLeftDownPoint, innerRingsArray, objectsArray);
	
		objectAux = objectsArray[0];
		hole = objectAux.ring;
		holeIdx = objectAux.ringIdx;
		holePolygon = hole.polygon;
		innerPointIdx = objectAux.pointIdx;
		holePolygon.calculateNormal();
		
		if (this.eliminateHolePolygon(computingPolygon, hole, innerPointIdx, resultPolygon))
		{
			computingPolygon = resultPolygon;
			
			if (innerRingsArray.length === 1)
			{
				finished = true;
				break;
			}
			// erase the hole from innerRingsArray.
			innerRingsArray.splice(holeIdx, 1);
			resultPolygon = new Polygon2D();
		}
		i++;
	}
	resultHolesEliminatedPolygon = computingPolygon;
	return resultHolesEliminatedPolygon;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile2D.prototype.checkNormals = function() 
{
	if (this.outerRing === undefined)
	{ return; }
	
	// 1rst, calculate the outerNormal.
	var outerRing = this.outerRing;
	if (outerRing.polygon === undefined)
	{ outerRing.makePolygon(); }
	var outerPolygon = outerRing.polygon;
	var concavePointsIndices = outerPolygon.calculateNormal(concavePointsIndices);
	var outerNormal = outerPolygon.normal;
	
	if (this.innerRingsList === undefined)
	{ return; }
	
	// if there are inners, the innerNormals must be inverse of the outerNormal.
	var innerRing;
	var innerPolygon;
	var innerNormal;
	var innersCount = this.innerRingsList.getRingsCount();
	for (var i=0; i<innersCount; i++)
	{
		innerRing = this.innerRingsList.getRing(i);
		if (innerRing.polygon === undefined)
		{ innerRing.makePolygon(); }
		var innerPolygon = innerRing.polygon;
		innerPolygon.calculateNormal();
		var innerNormal = innerPolygon.normal;
		
		if (innerNormal === outerNormal)
		{
			// then reverse innerPolygon.
			innerPolygon.reverseSense();
			innerPolygon.normal = -innerNormal;
		}
		
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Profile2D.prototype.TEST__setFigure_1 = function() 
{
	// complicated polygon with multiple holes.
	var polyLine;
	var arc;
	var circle;
	var rect;
	var point3d;
	var star;
	
	// Outer ring.**
	var outerRing = this.newOuterRing();
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(7, 7); // 0
	point3d = polyLine.newPoint2d(0, 7); // 1
	point3d = polyLine.newPoint2d(0, 0); // 2
	point3d = polyLine.newPoint2d(7, 0); // 3
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(7, 3.5);
	arc.setRadius(3.5);
	arc.setStartAngleDegree(-90.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	// hole.
	var innerRing = this.newInnerRing();
	rect = innerRing.newElement("RECTANGLE");
	rect.setCenterPosition(3, 3);
	rect.setDimensions(2, 2);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Profile2D.prototype.TEST__setFigure_2holes = function() 
{
	// complicated polygon with multiple holes.
	var polyLine;
	var arc;
	var circle;
	var rect;
	var point3d;
	var star;
	
	// Outer ring.**
	var outerRing = this.newOuterRing();
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(7, 7); // 0
	point3d = polyLine.newPoint2d(0, 7); // 1
	point3d = polyLine.newPoint2d(0, 0); // 2
	point3d = polyLine.newPoint2d(7, 0); // 3
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(7, 3.5);
	arc.setRadius(3.5);
	arc.setStartAngleDegree(-90.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	// hole 1.
	var innerRing = this.newInnerRing();
	rect = innerRing.newElement("RECTANGLE");
	rect.setCenterPosition(3, 3);
	rect.setDimensions(2, 2);
	
	// hole 2.
	innerRing = this.newInnerRing();
	circle = innerRing.newElement("CIRCLE");
	circle.setCenterPosition(7, 3);
	circle.setRadius(1);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Profile2D.prototype.TEST__setFigureHole_2 = function() 
{
	// complicated polygon with multiple holes.
	var polyLine;
	var arc;
	var circle;
	var rect;
	var point3d;
	var star;
	
	// Outer ring.**
	var outerRing = this.newOuterRing();
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-13, 3); // 0
	point3d = polyLine.newPoint2d(-13, -11); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(-8, -11);
	arc.setRadius(5);
	arc.setStartAngleDegree(180.0);
	arc.setSweepAngleDegree(90.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-8, -16); // 0
	point3d = polyLine.newPoint2d(-5, -16); // 1
	point3d = polyLine.newPoint2d(-3, -15); // 2
	point3d = polyLine.newPoint2d(-3, -14); // 3
	point3d = polyLine.newPoint2d(-5, -12); // 4
	point3d = polyLine.newPoint2d(-3, -11); // 5
	point3d = polyLine.newPoint2d(-2, -9); // 6
	point3d = polyLine.newPoint2d(3, -9); // 7
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(9, -9);
	arc.setRadius(6);
	arc.setStartAngleDegree(180.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(15, -9); // 0
	point3d = polyLine.newPoint2d(16, -9); // 1
	point3d = polyLine.newPoint2d(16, 4); // 2
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(11, 4);
	arc.setRadius(5);
	arc.setStartAngleDegree(0.0);
	arc.setSweepAngleDegree(90.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(11, 9); // 0
	point3d = polyLine.newPoint2d(4, 9); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(4, 11);
	arc.setRadius(2);
	arc.setStartAngleDegree(-90.0);
	arc.setSweepAngleDegree(-180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(4, 13); // 0
	point3d = polyLine.newPoint2d(9, 13); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(9, 14.5);
	arc.setRadius(1.5);
	arc.setStartAngleDegree(-90.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(9, 16); // 0
	point3d = polyLine.newPoint2d(2, 16); // 1
	point3d = polyLine.newPoint2d(0, 14); // 2
	point3d = polyLine.newPoint2d(-4, 16); // 3
	point3d = polyLine.newPoint2d(-9, 16); // 4
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(-9, 14);
	arc.setRadius(2);
	arc.setStartAngleDegree(90.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-9, 12); // 0
	point3d = polyLine.newPoint2d(-6, 12); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(-6, 10.5);
	arc.setRadius(1.5);
	arc.setStartAngleDegree(90.0);
	arc.setSweepAngleDegree(-180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-6, 9); // 0
	point3d = polyLine.newPoint2d(-7, 9); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(-7, 3);
	arc.setRadius(6);
	arc.setStartAngleDegree(90.0);
	arc.setSweepAngleDegree(90.0);
	arc.numPointsFor360Deg = 24;
	
	// Holes.**
	// Hole 1.*
	var innerRing = this.newInnerRing();
	
	polyLine = innerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-9, 3); // 0
	point3d = polyLine.newPoint2d(-10, -4); // 1
	point3d = polyLine.newPoint2d(-10, -8); // 2
	point3d = polyLine.newPoint2d(-8, -11); // 3
	point3d = polyLine.newPoint2d(-3, -7); // 4
	point3d = polyLine.newPoint2d(4, -7); // 5
	
	arc = innerRing.newElement("ARC");
	arc.setCenterPosition(8, -7);
	arc.setRadius(4);
	arc.setStartAngleDegree(180.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = innerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(12, -7); // 0
	point3d = polyLine.newPoint2d(12, -4); // 1
	point3d = polyLine.newPoint2d(8, -10); // 2
	point3d = polyLine.newPoint2d(4, -5); // 3
	point3d = polyLine.newPoint2d(-8, -5); // 4
	point3d = polyLine.newPoint2d(-7, 4); // 5
	point3d = polyLine.newPoint2d(9, 4); // 6
	point3d = polyLine.newPoint2d(9, -5); // 7
	point3d = polyLine.newPoint2d(14, 2); // 8
	point3d = polyLine.newPoint2d(13, 2); // 9
	point3d = polyLine.newPoint2d(11, 0); // 10
	point3d = polyLine.newPoint2d(11, 7); // 11
	point3d = polyLine.newPoint2d(13, 8); // 12
	point3d = polyLine.newPoint2d(5, 8); // 13
	point3d = polyLine.newPoint2d(9, 6); // 14
	point3d = polyLine.newPoint2d(-6, 6); // 15
	
	arc = innerRing.newElement("ARC");
	arc.setCenterPosition(-6, 3);
	arc.setRadius(3);
	arc.setStartAngleDegree(90.0);
	arc.setSweepAngleDegree(90.0);
	arc.numPointsFor360Deg = 24;
	
	
		
	// Hole 2.*
	innerRing = this.newInnerRing();
	circle = innerRing.newElement("CIRCLE");
	circle.setCenterPosition(-10, -13);
	circle.setRadius(1);
	
	// Hole 3.*
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(-6.5, -14);
	star.setRadiusCount(5);
	star.setInteriorRadius(0.6);
	star.setExteriorRadius(2);

	// Hole 4.*
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(-9, 14);
	star.setRadiusCount(6);
	star.setInteriorRadius(0.5);
	star.setExteriorRadius(1.5);
	
	// Hole 5.*
	innerRing = this.newInnerRing();
	rect = innerRing.newElement("RECTANGLE");
	rect.setCenterPosition(-4.5, 1.5);
	rect.setDimensions(3, 3);
	
	// Hole 6.*
	innerRing = this.newInnerRing();
	circle = innerRing.newElement("CIRCLE");
	circle.setCenterPosition(-4.5, -2.5);
	circle.setRadius(2);
	
	// Hole 7.*
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(0, 0);
	star.setRadiusCount(5);
	star.setInteriorRadius(1);
	star.setExteriorRadius(2.5);
	
	// Hole 8.*
	innerRing = this.newInnerRing();
	circle = innerRing.newElement("CIRCLE");
	circle.setCenterPosition(-6, 14);
	circle.setRadius(1.5);
	
	// Hole 9.*
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(-1.5, 11);
	star.setRadiusCount(12);
	star.setInteriorRadius(0.6);
	star.setExteriorRadius(2);
	
	// Hole 10.*
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(13.5, 5);
	star.setRadiusCount(25);
	star.setInteriorRadius(0.4);
	star.setExteriorRadius(1.5);
	
	// Hole 11.*
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(9, -13);
	star.setRadiusCount(10);
	star.setInteriorRadius(0.4);
	star.setExteriorRadius(1.5);
	
	// Hole 12.*
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(5.5, 1.5);
	star.setRadiusCount(7);
	star.setInteriorRadius(0.7);
	star.setExteriorRadius(2);
	
};



















'use strict';

/**
 * the list of the features of Profile2D
 * @class Profiles2DList
 */
var Profiles2DList = function() 
{
	// Class no used.
	if (!(this instanceof Profiles2DList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.profilesArray;
	this.auxiliarAxis;
};

/**
 * create new feature of Profile2D and push it at the list
 * @returns {Profile2D} profile
 */
Profiles2DList.prototype.newProfile = function() 
{
	if (this.profilesArray === undefined)
	{ this.profilesArray = []; }
	
	var profile = new Profile2D();
	this.profilesArray.push(profile);
	return profile;
};

/**
 * Clear all the features of this list
 */
Profiles2DList.prototype.deleteObjects = function() 
{
	if (this.profilesArray)
	{
		var profilesCount = this.profilesArray.length;
		for (var i=0; i<profilesCount; i++)
		{
			this.profilesArray[i].deleteObjects();
			this.profilesArray = undefined;
		}
		this.profilesArray = undefined;
	}
};





























'use strict';
/**
 * 중심점과 가로, 세로 길이를 가진 클래스
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class Rectangle2D
 */
var Rectangle2D = function() 
{
	if (!(this instanceof Rectangle2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * center point of this rectangle
	 * @type {Point2D}
	 */
	this.centerPoint;

	/**
	 * width of rectangle
	 * @type {Number}
	 */
	this.width;

	/**
	 * height of rectangle
	 * @type {Number}
	 */
	this.height;
};

/**
 * rectangle의 중심점 설정
 * @param {number} cx
 * @param {number} cy
 */
Rectangle2D.prototype.setCenterPosition = function(cx, cy)
{
	if (this.centerPoint === undefined)
	{ this.centerPoint = new Point2D(); }
	
	this.centerPoint.set(cx, cy);
};

/**
 * rectangle의 가로,세로 길이 설정
 * @param {number} width
 * @param {number} height
 */
Rectangle2D.prototype.setDimensions = function(width, height)
{
	this.width = width;
	this.height = height;
};

/**
 * Returns the points of the Rectangle.
 * @param {Array.<Point3D>|undefined} resultPointsArray if this undefined, set new Array. []
 * @returns {Array.<Point3D>} resultPointsArray rectangle의 꼭지점 반환, 중심점으로부터 가로,세로의 절반 만큼 떨어진 4점을 반환
 */
Rectangle2D.prototype.getPoints = function(resultPointsArray)
{
	if (this.centerPoint === undefined || this.width === undefined || this.height === undefined)
	{ return resultPointsArray; }
	
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	var point;
	var halfWidth = this.width / 2;
	var halfHeight = this.height / 2;
	
	// starting in left-down corner, go in CCW.
	point = new Point2D(this.centerPoint.x - halfWidth, this.centerPoint.y - halfHeight);
	point.pointType = 1; // mark as "important point".
	resultPointsArray.push(point);
	
	point = new Point2D(this.centerPoint.x + halfWidth, this.centerPoint.y - halfHeight);
	point.pointType = 1; // mark as "important point".
	resultPointsArray.push(point);
	
	point = new Point2D(this.centerPoint.x + halfWidth, this.centerPoint.y + halfHeight);
	point.pointType = 1; // mark as "important point".
	resultPointsArray.push(point);
	
	point = new Point2D(this.centerPoint.x - halfWidth, this.centerPoint.y + halfHeight);
	point.pointType = 1; // mark as "important point".
	resultPointsArray.push(point);
	
	return resultPointsArray;
};



















































'use strict';

/**
 * 링형태의 폴리곤 객체를 생성하기 위한 클래스
 * 
 * @class
 */
var Ring2D = function() 
{
	if (!(this instanceof Ring2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * 다양한 폴리곤을 갖고 있는 배열
	 * @type {Obecjt[]}
	 */
	this.elemsArray = [];

	/**
	 * 폴리곤
	 * @type {Polygon2D}
	 */
	this.polygon = undefined;
};

/**
 * 생성된 객체가 있다면 삭제하고 초기화 한다.
 */
Ring2D.prototype.deleteObjects = function()
{
	for (var i=0, len = this.elemsArray.length; i<len; i++)
	{
		this.elemsArray[i].deleteObjects();
	}
	this.elemsArray = [];
	
	if (this.polygon !== undefined)
	{
		this.polygon.deleteObjects();
	}
	
	this.polygon = undefined;
};

/**
 * 폴리곤을 생성하고 elemsArray 에 추가한다.
 * 
 * @param {String} type 폴리곤의 형태
 * @returns {Object} 지정된 형태로 생성한 폴리곤 객체
 */
Ring2D.prototype.newElement = function(type)
{
	var result = undefined;
	
	if (type === "ARC") { result = new Arc2D(); }
	else if (type === "CIRCLE") { result = new Circle2D(); }
	else if (type === "POLYLINE") { result = new PolyLine2D(); }
	else if (type === "RECTANGLE") { result = new Rectangle2D(); }
	else if (type === "STAR") { result = new Star2D(); }
	
	this.elemsArray.push(result);
	
	return result;
};

/**
 * 폴리곤을 생성한다.
 * 
 * @returns {Polygon2D} 폴리곤
 */
Ring2D.prototype.makePolygon = function()
{
	this.polygon = this.getPolygon(this.polygon);
	return this.polygon;
};

/**
 * 폴리곤을 생성한다.
 * 
 * @param {Polygon2D} resultPolygon 결과값을 저장할 폴리곤
 * @returns {Polygon2D} 수정되거나 새로 생성된 폴리곤
 */
Ring2D.prototype.getPolygon = function(resultPolygon)
{
	if (resultPolygon === undefined)
	{
		resultPolygon = new Polygon2D();
	}
	
	if (resultPolygon.point2dList === undefined)
	{
		resultPolygon.point2dList = new Point2DList();
	}
	
	// reset polygon
	resultPolygon.point2dList.deleteObjects();
	// TODO : 폴리곤에서 포인트를 가지고 오도록 변경해야함
	resultPolygon.point2dList.pointsArray = this.getPoints(resultPolygon.point2dList.pointsArray);
	
	// set idxData for all points
	var point;
	var pointsCount = resultPolygon.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point = resultPolygon.point2dList.getPoint(i);
		point.indexData = new IndexData();
		point.indexData.owner = this;
	}
	
	return resultPolygon;
};

/**
 * 다양한 폴리곤 배열에서 포인트를 구한다.
 * 
 * @param {Point2D[]} resultPointsArray 결과값을 저장할 포인트 배열
 * @returns {Point2D[]} 포인트 배열
 */
Ring2D.prototype.getPoints = function(resultPointsArray)
{
	if (resultPointsArray === undefined)
	{
		resultPointsArray = [];
	}
	
	var elem;
	for (var i=0, len = this.elemsArray.length; i<len; i++)
	{
		elem = this.elemsArray[i];
		elem.getPoints(resultPointsArray);
	}

	// finally check if the 1rst point and the last point are coincidents.
	var totalPointsCount = resultPointsArray.length;
	if (totalPointsCount > 1)
	{
		
		var errorDist = 10E-8;
		var firstPoint = resultPointsArray[0];
		var lastPoint = resultPointsArray[totalPointsCount-1];
		
		// mark the last as pointType = 1
		lastPoint.pointType = 1; 

		if (firstPoint.isCoincidentToPoint(lastPoint, errorDist))
		{
			// delete the last point.
			lastPoint = resultPointsArray.pop();
			lastPoint.deleteObjects();
			lastPoint = undefined;
		}
	}
	
	return resultPointsArray;
};








































'use strict';
/**
 * Ring2D 의 리스트 {@link Ring2D}
 */
var Ring2DList = function() 
{
	if (!(this instanceof Ring2DList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * 폴리곤 배열
	 * @type {Ring2D[]}
	 */
	this.ringsArray = [];

	/**
	 * 인덱스 리스트
	 * @type {Number[]}
	 */
	this.idxInList;
};

/**
 * Ring2D 를 생성하고 배열에 추가한다.
 * 
 * @returns {Ring2D} 생성된 Ring2D 의 객체
 */
Ring2DList.prototype.newRing = function() 
{
	var ring = new Ring2D();
	this.ringsArray.push(ring);
	
	return ring;
};

/**
 * 주어진 Ring2D 를 배열에 추가한다.
 * 
 * @param {Ring2D} ring 추가할 Ring2D 객체
 */
Ring2DList.prototype.addRing = function(ring) 
{
	this.ringsArray.push(ring);
};

/**
 * 생성된 객체가 있다면 삭제하고 초기화 한다.
 */
Ring2DList.prototype.deleteObjects = function() 
{
	for (var i=0, len = this.ringsArray.length; i<len; i++)
	{
		this.ringsArray[i].deleteObjects();
		this.ringsArray[i] = undefined;
	}
	this.ringsArray = [];
};

/**
 * Ring2D 배열의 개수를 구한다.
 * 
 * @returns {Number} 배열의 개수
 */
Ring2DList.prototype.getRingsCount = function() 
{
	return this.ringsArray.length;
};

/**
 * 주어진 객체의 인덱스값을 찾는다.
 * 
 * @param {Ring2D} ring Ring2D 객체
 * @returns {Number} 인덱스값
 */
Ring2DList.prototype.getRingIndex = function(ring) 
{
	return this.ringsArray.indexOf(ring);
};

/**
 * 주어진 인덱스에 있는 Ring2D 객체를 가져온다.
 * 
 * @param {Number} index 가져올 Ring2D 객체의 인덱스값.
 * @returns {Ring2D} <code>index</code> 위치의 Ring2D 객체
 * 
 * @see Ring2DList#getRingsCount
 */
Ring2DList.prototype.getRing = function(index) 
{
	return this.ringsArray[index];
};

/**
 * 주어진 Ring2D 배열의 각 폴리곤을 포함하는 경계 사각형을 구한다.
 * 
 * @param {Ring2D[]} ringsArray Ring2D 배열
 * @param {BoundingRectangle} resultBRect 폴리곤들을 포함하는 경계 사각형
 * @returns {BoundingRectangle} 폴리곤들을 포함하는 경계 사각형 결과값
 */
Ring2DList.getBoundingRectangle = function(ringsArray, resultBRect) 
{
	if (resultBRect === undefined)
	{
		resultBRect = new BoundingRectangle();
	}
	
	var ring;
	var currBRect;
	for (var i=0, len = ringsArray.length; i<len; i++)
	{
		ring = ringsArray[i];
		if (ring.polygon !== undefined)
		{
			currBRect = ring.polygon.getBoundingRectangle(currBRect);
			resultBRect.addRectangle(currBRect);
		}
	}

	return resultBRect;
};

/**
 * Ring2D 배열에 대한 인덱스값을 idxInList 속성에 설정한다.
 */
Ring2DList.prototype.setIdxInList = function() 
{
	for (var i=0, len = this.ringsArray.length; i<len; i++)
	{
		this.ringsArray[i].idxInList = i;
	}
};

/**
 * TODO : 확인이 필요함
 */
Ring2DList.prototype.intersectionWithSegment = function(segment) 
{
	// returns true if any ring's polygon intersects with "segment".
	if (segment === undefined)
	{
		return false;
	}
	
	var i=0;
	var intersects = false;
	var ringsCount = this.getRingsCount();
	while (!intersects && i<ringsCount)
	{
		if (this.ringsArray[i].intersectionWithSegment(segment))
		{
			intersects = true;
		}
		i++;
	}
	
	return intersects;
};


/**
 * 주어진 Ponint2D 와 각 Ring2D 의 거리를 기준으로 Ring2D 배열을 정렬한다.
 *
 * @param {Point2D} point 거리를 구하기 위해 주어진 포인트
 * @param {Ring2D[]} ringsArray 정렬을 하기 위한 Ring2D 배열
 * @param {Object[]} resultSortedObjectsArray 거리 기준으로 정렬된 결과값
 * @returns {Object[]} 거리 기준으로 정렬된 결과값
 */
Ring2DList.getSortedRingsByDistToPoint = function(point, ringsArray, resultSortedObjectsArray) 
{
	if (point === undefined)
	{
		return resultSortedObjectsArray;
	}
	
	if (resultSortedObjectsArray === undefined)
	{
		resultSortedObjectsArray = [];
	}
	
	var objectsAuxArray = [];
	var ring;
	var ringPoint;
	var ringPointIdx;
	var squaredDist;
	var objectAux;
	var startIdx, endIdx, insertIdx;
	for (var i=0, len = ringsArray.length; i<len; i++)
	{
		ring = ringsArray[i];
		ringPointIdx = ring.polygon.point2dList.getNearestPointIdxToPoint(point);
		ringPoint = ring.polygon.point2dList.getPoint(ringPointIdx);
		squaredDist = ringPoint.squareDistToPoint(point);

		objectAux = {};
		objectAux.ring = ring;
		objectAux.ringIdx = i;
		objectAux.pointIdx = ringPointIdx;
		objectAux.squaredDist = squaredDist;
		
		startIdx = 0;
		endIdx = objectsAuxArray.length - 1;
		
		// TODO : getIndexToInsertBySquaredDist 함수를 getBinarySearchIndex 를 이용하여 구현하기
		insertIdx = Ring2DList.getIndexToInsertBySquaredDist(objectsAuxArray, objectAux, startIdx, endIdx);
		objectsAuxArray.splice(insertIdx, 0, objectAux);
	}
	
	for (var i=0, len = objectsAuxArray.length; i<len; i++)
	{
		resultSortedObjectsArray.push(objectsAuxArray[i]);
	}
	
	return resultSortedObjectsArray;
};

/**
 * 이진 탐색 방법을 통해 해당 객체가 추가될 인덱스 값을 찾는다.
 * - 탐색의 대상인 배열은 이미 정렬되어있어야 한다.
 * @param {Object[]} objectsArray 탐색하기 위한 배열
 * @param {Object} object 탐색 대상
 * @param {Number} startIdx 시작 인덱스값
 * @param {Number} endIdx 종료 인덱스값
 * @returns {Number} 탐색 결과 인덱스
 */
Ring2DList.getIndexToInsertBySquaredDist = function(objectsArray, object, startIdx, endIdx) 
{
	// this do a dicotomic search of idx in a ordered table.
	// 1rst, check the range.
	
	var range = endIdx - startIdx;
	
	if (objectsArray.length === 0)
	{
		return 0;
	}
	
	if (range < 6)
	{
		// in this case do a lineal search.
		var finished = false;
		var i = startIdx;
		var idx;
		//var objectsCount = objectsArray.length;
		while (!finished && i<=endIdx)
		{
			if (object.squaredDist < objectsArray[i].squaredDist)
			{
				idx = i;
				finished = true;
			}
			i++;
		}
		
		if (finished)
		{
			return idx;
		}
		else 
		{
			return endIdx+1;
		}
	}
	else 
	{
		// in this case do the dicotomic search.
		var middleIdx = startIdx + Math.floor(range/2);
		var newStartIdx;
		var newEndIdx;
		if (objectsArray[middleIdx].squaredDist > object.squaredDist)
		{
			newStartIdx = startIdx;
			newEndIdx = middleIdx;
		}
		else 
		{
			newStartIdx = middleIdx;
			newEndIdx = endIdx;
		}
		return this.getIndexToInsertBySquaredDist(objectsArray, object, newStartIdx, newEndIdx);
	}
};

/**
 * 이진 탐색 방법을 통해 해당 객체가 추가될 인덱스 값을 찾는다.
 * - 탐색의 대상인 배열은 이미 정렬되어있어야 한다.
 *
 * @param {Object[]} arr 탐색하기 위한 배열
 * @param {Object} x 탐색 대상
 * @param {Function} func 탐색 비교값
 * @returns {Number} 탐색 결과 인덱스
 */
Ring2DList.getBinarySearchIndex = function (arr, x, func)
{
	var start = 0;
	var end = arr.length - 1;

	func = func || function (value) { return value; };

	// Iterate while start not meets end 
	while (start <= end)
	{
		// Find the mid index 
		var mid = Math.floor((start + end) / 2);

		if (func(arr[mid]) < func(x))
		{
			start = mid + 1;
		}
		else
		{
			end = mid - 1;
		}
	}

	return start;
};

"use strict";

/**
 * 링폴리곤의 형태를 정의
 */
var RingType = {
	/**
     * 아치형태의 폴리곤 {@link Arc2D}
     * @type {Number}
     * @constant
     */
	ARC: 0,

	/**
     * 원형태의 폴리곤 {@link Circle2D}
     * @type {Number}
     * @constant
     */
	CIRCLE: 1,

	/**
     * 폴리라인형태의 폴리곤 {@link PolyLine2D}
     * @type {Number}
     * @constant
     */
	POLYLINE: 2,

	/**
     * 사각형형태의 폴리곤 {@link Rectangle2D}
     * @type {Number}
     * @constant
     */
	RECTANGLE: 3,

	/**
     * 별형태의 폴리곤 {@link Star2D}
     * @type {Number}
     * @constant
     */
	Star2D: 4,

	/**
     * @private
     */
	NUMBER_OF_RING_TYPE: 5
};
'use strict';
/**
 * 선분 생성을 위한 클래스
 *
 * @param {Point2D} strPoint2D 시작 포인트
 * @param {Point2D} endPoint2D 종료 포인트
 */
var Segment2D = function(strPoint2D, endPoint2D) 
{
	if (!(this instanceof Segment2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.startPoint2d;
	this.endPoint2d;
	
	if (strPoint2D)
	{
		this.startPoint2d = strPoint2D;
	}
	
	if (endPoint2D)
	{
		this.endPoint2d = endPoint2D;
	}
};


/**
 * 선분에 포인트를 설정한다.
 *
 * @param {Point2D} strPoint2D 시작 포인트
 * @param {Point2D} endPoint2D 종료 포인트
 */
Segment2D.prototype.setPoints = function(strPoint2D, endPoint2D)
{
	if (strPoint2D !== undefined)
	{
		this.startPoint2d = strPoint2D; 
	}
	if (endPoint2D !== undefined)
	{ 
		this.endPoint2d = endPoint2D;
	}
};

/**
 * 시작 포인트에서 종료 포인트까지의 벡터를 구한다.
 *
 * @param {Point2D} result 벡터 결과값
 * @returns {Point2D} 벡터 결과값
 */
Segment2D.prototype.getVector = function(result)
{
	if (this.startPoint2d === undefined || this.endPoint2d === undefined)
	{
		return undefined;
	}
	
	if (result === undefined)
	{
		result = new Point2D();
	}
	
	result = this.startPoint2d.getVectorToPoint(this.endPoint2d, result);
	return result;
};


/**
 * 선분의 방향값을 계산한다.
 *
 * @param {Point2D} result 선분이 나타내는 방향값
 * @returns {Point2D} 선분이 나타내는 방향값
 */
Segment2D.prototype.getDirection = function(result)
{
	if (result === undefined)
	{
		result = new Point2D();
	}
	
	result = this.getVector(result);
	result.unitary();
	
	return result;
};


/**
 * 선분의 경계 사각형을 구한다.
 *
 * @param {BoundaryRectangle} result 선분을 포함하는 경계 사각형
 * @returns {BoundaryRectangle} 선분을 포함하는 경계 사각형
 */
Segment2D.prototype.getBoundaryRectangle = function(result)
{
	if (result === undefined)
	{
		result = new BoundaryRectangle();
	}
	
	result.setInit(this.startPoint2d);
	result.addPoint(this.endPoint2d);
	
	return result;
};


/**
 * 선분을 지나는 직선을 구한다.
 *
 * @param {Line2D} result 주어진 선분을 지나는 직선
 * @returns {Line2D} 주어진 선분을 지나는 직선
 */
Segment2D.prototype.getLine = function(result)
{
	if (result === undefined)
	{
		result = new Line2D();
	}
	// unitary direction.
	var dir = this.getDirection();
	var strPoint = this.startPoint2d;
	result.setPointAndDir(strPoint.x, strPoint.y, dir.x, dir.y);
	return result;
};


/**
 * 선분의 제곱된 길이를 구한다.
 *
 * @returns {Number} 선분의 제곱된 길이
 */
Segment2D.prototype.getSquaredLength = function()
{
	return this.startPoint2d.squareDistToPoint(this.endPoint2d);
};


/**
 * 선분의 길이를 구한다.
 *
 * @returns {Number} 선분의 길이
 */
Segment2D.prototype.getLength = function()
{
	return Math.sqrt(this.getSquaredLength());
};


/**
 * 오차율에 따라 주어진 포인트와 선분의 교차를 판단한다.
 *
 * @param {Point2D} point 포인트
 * @param {Number} error 오차율
 * @returns 교차 판단 결과값
 */
Segment2D.prototype.intersectionWithPointByDistances = function(point, error)
{
	if (point === undefined)
	{
		return undefined;
	}
	
	if (error === undefined)
	{
		error = 10E-8;
	}
	
	// here no check line-point coincidance.
	// now, check if is inside of the segment or if is coincident with any vertex of segment.
	var distA = this.startPoint2d.distToPoint(point);
	var distB = this.endPoint2d.distToPoint(point);
	var distTotal = this.getLength();
	
	if (distA < error)
	{
		return Constant.INTERSECTION_POINT_A;
	}
	
	if (distB < error)
	{
		return Constant.INTERSECTION_POINT_B;
	}
	
	if (distA> distTotal || distB> distTotal)
	{
		return Constant.INTERSECTION_OUTSIDE;
	}
	
	if (Math.abs(distA + distB - distTotal) < error)
	{
		return Constant.INTERSECTION_INSIDE;
	}
};


/**
 * 오차율에 따라 주어진 포인트와 선분의 교차를 판단한다.
 *
 * @param {Point2D} point 포인트
 * @param {Number} error 오차율
 * @returns 교차 판단 결과값
 */
Segment2D.prototype.intersectionWithPoint = function(point, error)
{
	if (point === undefined)
	{
		return undefined;
	}
	
	if (error === undefined)
	{
		error = 10E-8;
	}
	
	var line = this.getLine();
	if (!line.isCoincidentPoint(point, error))
	{
		// no intersection
		return Constant.INTERSECTION_OUTSIDE;
	}
	
	return this.intersectionWithPointByDistances(point, error);
};

/**
 * 오차율에 따라 주어진 선분과 선분의 교차를 판단한다.
 *
 * @param {Segment2D} segment 선분
 * @param {Number} error 오차율
 * @returns 교차 판단 결과값
 */
Segment2D.prototype.intersectionWithSegment = function(segment, error)
{
	if (segment === undefined)
	{
		return undefined;
	}
	
	if (error === undefined)
	{
		error = 10E-8;
	}
	
	var lineA = this.getLine();
	var lineB = segment.getLine();
	var intersectionPoint = lineA.intersectionWithLine(lineB);
	
	// 두 선분이 평행한 경우
	if (intersectionPoint === undefined)
	{
		return undefined;
	}
	
	var intersectionTypeA = this.intersectionWithPointByDistances(intersectionPoint);
	var intersectionTypeB = segment.intersectionWithPointByDistances(intersectionPoint);
	
	if (intersectionTypeA === Constant.INTERSECTION_OUTSIDE)
	{
		return Constant.INTERSECTION_OUTSIDE;
	}
	if (intersectionTypeB === Constant.INTERSECTION_OUTSIDE)
	{
		return Constant.INTERSECTION_OUTSIDE;
	}
	
	return Constant.INTERSECTION_INTERSECT;
};


/**
 * 주어진 포인트가 시작 포인트 또는 종료 포인트를 갖는지 판단한다.
 * returns if this segment has "point" as startPoint or endPoint.
 *
 * @param {Point2D} point 포인트
 * @returns {Boolean} 시작/종료 포인트 존재 여부
 */
Segment2D.prototype.hasPoint = function(point)
{
	if (point === undefined)
	{
		return false;
	}
	
	if (point === this.startPoint2d || point === this.endPoint2d)
	{
		return true;
	}
	
	return false;
};


/**
 * 주어진 선분이 해당 선분과 공유 포인트를 갖는지 판단한다.
 *
 * @param {Segment2D} segment 선분
 * @returns {Boolean} 공유 포인트 존재 여부
 */
Segment2D.prototype.sharesPointsWithSegment = function(segment)
{
	if (segment === undefined)
	{
		return false;
	}
	
	if (this.hasPoint(segment.startPoint2d) || this.hasPoint(segment.endPoint2d))
	{
		return true;
	}
	
	return false;
};
'use strict';
/**
 * 선분 생성을 위한 클래스
 *
 * @param {Point3D} strPoint2D 시작 포인트
 * @param {Point3D} endPoint2D 종료 포인트
 */
var Segment3D = function(strPoint3D, endPoint3D) 
{
	if (!(this instanceof Segment3D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.startPoint3d;
	this.endPoint3d;
	
	if (strPoint3D)
	{
		this.startPoint3d = strPoint3D;
	}
	
	if (endPoint3D)
	{
		this.endPoint3d = endPoint3D;
	}
};

/**
 * 선분에 포인트를 설정한다.
 *
 * @param {Point3D} strPoint3D 시작 포인트
 * @param {Point3D} endPoint3D 종료 포인트
 */
Segment3D.prototype.setPoints = function(strPoint3D, endPoint3D)
{
	if (strPoint3D)
	{
		this.startPoint3d = strPoint3D;
	}
	
	if (endPoint3D)
	{
		this.endPoint3d = endPoint3D;
	}
};

/**
 * 시작 포인트에서 종료 포인트까지의 벡터를 구한다.
 *
 * @param {Point3D} result 벡터 결과값
 * @returns {Point3D} 벡터 결과값
 */
Segment3D.prototype.getVector = function(result)
{
	if (this.startPoint3d === undefined || this.endPoint3d === undefined)
	{
		return undefined;
	}
	
	if (result === undefined)
	{
		result = new Point3D();
	}
	
	result = this.startPoint3d.getVectorToPoint(this.endPoint3d, result);
	return result;
};

/**
 * 선분의 방향값을 계산한다.
 *
 * @param {Point3D} result 선분이 나타내는 방향값
 * @returns {Point3D} 선분이 나타내는 방향값
 */
Segment3D.prototype.getDirection = function(result)
{
	if (result === undefined)
	{
		result = new Point3D();
	}
	
	result = this.getVector(result);
	result.unitary();
	
	return result;
};

/**
 * 시작 포인트와 종료 포인트를 맞바꾼다.
 * interchange strPoint & endPoint.
 */
Segment3D.prototype.invertSense = function()
{
	var point3dAux = this.startPoint3d;
	this.startPoint3d = this.endPoint3d;
	this.endPoint3d = point3dAux;
};
'use strict';

/**
 * '별(star)'모양 폴리곤 객체
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class Star2D
 */
var Star2D = function() 
{
	if (!(this instanceof Star2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// this is a closed element.
	/**
	 * center of star
	 * @type {Point2D}
	 */
	this.centerPoint; // Point3D.

	/**
	 * interior radius
	 * @type {Number}
	 */
	this.interiorRadius;
	/**
	 * exterior radius
	 * @type {Number}
	 */
	this.exteriorRadius;

	/**
	 * 별꼭지점 갯수
	 * @type {Number}
	 */
	this.radiusCount;
};

/**
 * star의 중심점 설정
 * @param {number} cx
 * @param {number} cy
 */
Star2D.prototype.setCenterPosition = function(cx, cy)
{
	if (this.centerPoint === undefined)
	{ this.centerPoint = new Point2D(); }
	
	this.centerPoint.set(cx, cy);
};

/**
 * star의 interior radius 설정
 * @param {number} radius
 */
Star2D.prototype.setInteriorRadius = function(radius)
{
	this.interiorRadius = radius;
};

/**
 * star의 exterior radius 설정
 * @param {number} radius
 */
Star2D.prototype.setExteriorRadius = function(radius)
{
	this.exteriorRadius = radius;
};

/**
 * star의 꼭지점 갯수 설정
 * @param {number} radiusCount
 */
Star2D.prototype.setRadiusCount = function(radiusCount)
{
	this.radiusCount = radiusCount;
};

/**
 * star의 꼭지점 배열 반환
 * @param {Array.<Point2D>} resultPointsArray
 * @returns {Array.<Point2D>} 
 */
Star2D.prototype.getPoints = function(resultPointsArray)
{
	// star has an arrow to up.
	var increAngDeg = 360 / this.radiusCount;
	var increAngRad = increAngDeg * Math.PI/180;
	var halfIncreAngRad = increAngRad / 2;
	var startAngRad = 90 * Math.PI/180;
	var currAngRad = startAngRad;
	var point;
	var x, y;
	
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	for (var i=0; i<this.radiusCount; i++)
	{
		// exterior.
		x = this.centerPoint.x + this.exteriorRadius * Math.cos(currAngRad);
		y = this.centerPoint.y + this.exteriorRadius * Math.sin(currAngRad);
		point = new Point2D(x, y);
		point.pointType = 1; // mark as "important point".
		resultPointsArray.push(point);
		
		// interior.
		x = this.centerPoint.x + this.interiorRadius * Math.cos(currAngRad + halfIncreAngRad);
		y = this.centerPoint.y + this.interiorRadius * Math.sin(currAngRad + halfIncreAngRad);
		point = new Point2D(x, y);
		point.pointType = 1; // mark as "important point".
		resultPointsArray.push(point);
		
		currAngRad += increAngRad;
	}
	
	return resultPointsArray;
};


















































'use strict';

/**
 * 정적모델데이터
 * 
 * @class
 */
var StaticModel = function() 
{
	if (!(this instanceof StaticModel)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * 고유 아이디
	 * @type {String}
	 */
	this.guid = "";
	
	/**
	 * 건물 이름
	 * @type {String}
	 */
	this.buildingFolderName = "";

	/**
	 * 프로젝트 이름
	 * @type {String}
	 */
	this.projectFolderName= "";

	/**
	 * 건물 객체
	 * @type {F4D}
	 */
	this.neoBuilding = undefined;
};


/**
 * 정적모델데이터 관리자
 * 
 * @class
 */
var StaticModelsManager = function() 
{
	if (!(this instanceof StaticModelsManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.staticModelsMap = {};
};

/**
 * 고유아이디를 가진 정적모델데이터를 추가한다.
 * 
 * @param {String} guid 고유아이디
 * @param {StaticModel} staticModel 정적모델데이터
 */
StaticModelsManager.prototype.addStaticModel = function(guid, staticModel)
{
	this.staticModelsMap[guid] = staticModel;
};


/**
 * 고유아이디를 가진 정적모델데이터를 가져온다.
 *
 * @param {String} guid 고유아이디
 * @returns {StaticModel} 정적모델데이터
 */
StaticModelsManager.prototype.getStaticModel = function(guid)
{
	var staticModel = this.staticModelsMap[guid];
	if (staticModel === undefined)
	{
		throw new Error('StaticModel is not exist.');
	}
	return staticModel;
};






































'use strict';

/**
 * 서피스
 * 
 * @class
 */
var Surface = function()
{
	if (!(this instanceof Surface))
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/** 
	 * Surface 가 가진 Face 배열
	 * @type {Face[]}
	 */
	this.facesArray = [];

	/** 
	 * 전체 Face 가 가진 Vertex 배열
	 * - "Surface" is NO-Owner of vertices of "localVertexList".
	 * - so, don't delete "localVertexList". Only set as "undefined".
	 * @type {VertexList}
	 */
	this.localVertexList = undefined;

	/** 
	 * - "Surface" is NO-Owner of hedges of "localHedgesList".
	 * - so, don't delete "localHedgesList". Only set as "undefined".
	 * @type {Object[]}
	 */
	this.localHedgesList = undefined;
};

/**
 * 생성된 객체가 있다면 삭제하고 초기화 한다.
 */
Surface.prototype.deleteObjects = function()
{
	for (var i=0, len=this.facesArray.length; i<len; i++)
	{
		this.facesArray[i].deleteObjects();
		this.facesArray[i] = undefined;
	}

	this.facesArray = [];
	this.localVertexList = undefined;
	this.localHedgesList = undefined;
};


/**
 * 페이스 객체를 생성하고 배열에 추가한다.
 *
 * @returns {Face} 새로 생성된 Face 객체
 * 
 * @see Face
 */
Surface.prototype.newFace = function()
{
	var face = new Face();
	this.facesArray.push(face);
	return face;
};


/**
 * Surface 가 가지고 있는 Face 의 총 개수를 구한다.
 *
 * @returns {Number} 생성된 Face 의 총 개수
 */
Surface.prototype.getFacesCount = function()
{
	return this.facesArray.length;
};


/**
 * 주어진 인덱스값의 위치에 있는 Face 객체를 가져온다.
 *
 * @param {Number} index 검색하기 위한 인덱스값
 * @returns {Face} 해당 Face
 */
Surface.prototype.getFace = function(index)
{
	return this.facesArray[index];
};

/**
 * 전체 Face 에 대한 색상정보를 주어진 색상값으로 설정한다.
 *
 * @param {Number} r Red 색상정보
 * @param {Number} g green 색상정보
 * @param {Number} b blue 색상정보
 * @param {Number} a alpha 색상정보
 */
Surface.prototype.setColor = function(r, g, b, a)
{
	var face;
	for (var i=0, len=this.getFacesCount(); i<len; i++)
	{
		face = this.getFace(i);
		face.setColor(r, g, b, a);
	}
};

/**
 * 주어진 Face 객체들을 추가한다.
 *
 * @param {Face[]} faces 추가할 Face 배열
 */
Surface.prototype.addFacesArray = function(faces)
{
	if (faces !== undefined)
	{
		Array.prototype.push.apply(this.facesArray, faces);
	}
};


/**
 * 전체 Face 에 대한 Frontier Half Edge 를 구한다.
 *
 * @param {HalfEdge[]} result Frontier Half Edges
 * @returns {HalfEdge[]} Frontier Half Edges
 * 
 * @see HalfEdge
 */
Surface.prototype.getFrontierHalfEdges = function(result)
{
	result = result || [];

	var face;
	for (var i=0, len=this.getFacesCount(); i<len; i++)
	{
		face = this.getFace(i);
		result = face.getFrontierHalfEdges(result);
	}

	return result;
};

/**
 * 전체 Face 에 대한 Half Edge 를 구한다.
 *
 * @param {HalfEdge[]} result Half Edges
 * @returns {HalfEdge[]} Half Edges
 * 
 * @see HalfEdge
 */
Surface.prototype.getHalfEdges = function(result)
{
	result = result || [];

	var face;
	for (var i=0, len=this.getFacesCount(); i<len; i++)
	{
		face = this.getFace(i);
		result = face.getHalfEdgesLoop(result);
	}

	return result;
};

/**
 * 현재 서피스 정보의 복사본을 제공한다.
 *
 * @param {Surface} result 서피스
 * @returns {Surface}
 */
Surface.prototype.getCopyIndependentSurface = function(result)
{
	if (result === undefined)
	{
		result = new Surface();
	}

	if (result.localVertexList === undefined)
	{
		result.localVertexList = new VertexList();
	}

	var resultLocalvertexList = result.localVertexList;

	// copy the localVertexList.
	var vertex;
	var vertexCopy;
	var verticesArray = this.getNoRepeatedVerticesArray();
	var vertexCount = verticesArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex = verticesArray[i];
		vertex.setIdxInList(i);
		vertexCopy = resultLocalvertexList.newVertex();
		vertexCopy.copyFrom(vertex);
	}

	// copy the faces.
	var face;
	var faceCopy;
	var vertexIdxInList;

	var faceCount = this.getFacesCount();
	for (var i=0; i<faceCount; i++)
	{
		face = this.getFace(i);
		faceCopy = result.newFace();
		// TODO : 생성과 관련된 코드는 클래스 외부에서 하지 않도록 변경해야함
		faceCopy.vertexArray = [];

		vertexCount = face.getVerticesCount();
		for (var j=0; j<vertexCount; j++)
		{
			vertex = face.getVertex(j);
			vertexIdxInList = vertex.getIdxInList();
			faceCopy.vertexArray.push(resultLocalvertexList.getVertex(vertexIdxInList));
		}
		var halfEdgesArray = [];
		faceCopy.createHalfEdges(halfEdgesArray);
	}

	result.setTwinsFaces();

	return result;
};

/**
 * 특정 Face 와 Face 배열을 비교하여 동일한 Face 가 존재하는지를 알려준다.
 *
 * @param {Face} face 찾을 Face 대상
 * @param {Face[]} facesArray Face 배열
 * @param {Boolean} bIsRegularQuadGrid 정규쿼드격자 여부
 * @returns {Boolean} 동일한 Face 존재 여부.
 * 					 동일한 Face 가 존재하면 <code>true</code>
 * 					 동일한 Face 가 존재하지 않으면 <code>false</code>
 */
Surface.setTwinsFacesBetweenFaceAndFacesArrays = function(face, facesArray, bIsRegularQuadGrid)
{
	// if the faces pertains a regular-quad-grid,
	// then there are only ONE twin between the "face" & the "facesArray".
	if (facesArray === undefined)
	{
		return false;
	}

	var twined = false;
	for (var i=0, len=facesArray.length; i<len; i++)
	{
		if (facesArray[i].setTwinFace(face))
		{
			twined = true;
			if (bIsRegularQuadGrid)
			{
				// if faces are from a regular quad grid,
				// there are only 1 twin possible.
				return true;
			}
		}
	}

	return twined;
};


/**
 * 두개의 Face 배열 사이에 동일한 Face 가 존재하는지를 알려준다.
 *
 * @param {Face[]} facesA 비교할 Face 배열
 * @param {Face[]} facesB 비교할 Face 배열
 * @returns {Boolean} 동일한 Face 존재 여부.
 * 					 동일한 Face 가 존재하면 <code>true</code>
 * 					 동일한 Face 가 존재하지 않으면 <code>false</code>
 */
Surface.setTwinsFacesBetweenFacesArrays_regularQuadGrid = function(facesA, facesB)
{
	// Faces are rectangles in a rectangle grid.
	if (facesA === undefined || facesB === undefined)
	{
		return false;
	}

	var faceA, faceB;
	for (var i=0, len=facesA.length-1; i<len; i++)
	{
		faceA = facesA[i];
		faceB = facesB[i+1];
		if (!faceA.setTwinFace(faceB))
		{
			faceA = facesA[i+1];
			faceB = facesB[i];
			if (!faceA.setTwinFace(faceB))
			{
				faceA = facesA[i];
				faceB = facesB[i];
				if (!faceA.setTwinFace(faceB))
				{
					faceA = facesA[i+1];
					faceB = facesB[i+1];
					if (!faceA.setTwinFace(faceB))
					{
						// do nothing.
					}
				}
			}
		}
	}
};


/**
 * 전체 Face 배열 중 동일한 Face 가 존재하는지를 알려준다.
 *
 */
Surface.prototype.setTwinsFaces = function()
{
	var face, face2;
	
	var facesCount = this.facesArray.length;
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		for (var j=0; j<facesCount; j++)
		{
			if (i !== j)
			{
				face2 = this.getFace(j);
				face.setTwinFace(face2);
			}
		}
	}
};


/**
 * 전체 Face 로부터 반복되지 않는 버텍스 배열을 구한다.
 *
 * @param {Vertex[]} result 버텍스 배열 결과를 저장
 * @returns {Vertex[]} 버텍스 배열
 */
Surface.prototype.getNoRepeatedVerticesArray = function(result)
{
	result = result || [];

	// assign vertex-IdxInList for all used vertices.
	var face;
	var vtx;
	var idxAux = 0;
	var facesCount = this.getFacesCount();
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		for (var j=0, len=face.getVerticesCount(); j<len; j++)
		{
			vtx = face.getVertex(j);
			vtx.setIdxInList(idxAux);
			idxAux++;
		}
	}

	// make a map of unique vertices map using "idxInList" of vertices.
	var verticesMap = {};
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		for (var j=0, len=face.getVerticesCount(); j<len; j++)
		{
			vtx = face.getVertex(j);
			verticesMap[vtx.getIdxInList().toString()] = vtx;
		}
	}

	// finally make the unique vertices array.
	var vertex;
	for (var key in verticesMap)
	{
		if (Object.prototype.hasOwnProperty.call(verticesMap, key))
		{
			vertex = verticesMap[key];
			result.push(vertex);
		}
	}

	return result;
};

/**
 * 전체 Face 에 대해 삼각형을 생성하고 배열로 제공한다.
 * - To call this method, the faces must be convex.
 *
 * @param {Triangle[]} result  Face 배열로부터 생성한 삼각형 배열
 * @returns {Triangle[]} Face 배열로부터 생성한 삼각형 배열
 */
Surface.prototype.getTrianglesConvex = function(result)
{
	result = result || [];

	var face;
	for (var i=0, len=this.getFacesCount(); i<len; i++)
	{
		face = this.getFace(i);
		result = face.getTrianglesConvex(result);
	}

	return result;
};

/**
 * 전체 Face 에 대해 테슬레이트된 삼각형을 생성하고 배열로 제공한다.
 *
 * @param {Triangle[]} result  Face 배열로부터 생성한 삼각형 배열
 * @returns {Triangle[]} Face 배열로부터 생성한 삼각형 배열
 */
Surface.prototype.getTriangles = function(result)
{
	result = result || [];

	var face;
	for (var i=0, len=this.getFacesCount(); i<len; i++)
	{
		face = this.getFace(i);
		result = face.getTessellatedTriangles(result);
	}

	return result;
};

/**
 * 전체 Face 에 대해 버텍스 노말을 계산한다.
 * 
 * @param {Boolean} bForceRecalculatePlaneNormal Plane 노말의 계산 적용 여부
 * 					<code>true</code> Plane 노말을 사용한다.
 *					<code>false</code> Plane 노말을 사용하지 않는다.
 */
Surface.prototype.calculateVerticesNormals = function(bForceRecalculatePlaneNormal)
{
	var face;
	var facesCount = this.getFacesCount();
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		face.calculateVerticesNormals(bForceRecalculatePlaneNormal);
	}
};

/**
 *
 * 전체 Face 에 대해 각 Face 가 가진 버텍스값을 뒤바꾼다
 */
Surface.prototype.reverseSense = function()
{
	var face;
	var facesCount = this.getFacesCount();
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		face.reverseSense();
	}
};

'use strict';

/**
 * Triangle(삼각형)를 생성하기 위한 클래스
 * 
 * @class Triangle
 *  
 * @param {Vertex} vertex0
 * @param {Vertex} vertex1
 * @param {Vertex} vertex2
 */
var Triangle= function(vertex0, vertex1, vertex2) 
{
	if (!(this instanceof Triangle)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * vertex0
	 * @type {Vertex}
	 * @default vertex0.
	 */
	this.vertex0;
	/**
	 * vertex1
	 * @type {Vertex}
	 * @default vertex1.
	 */
	this.vertex1;
	/**
	 * vertex2
	 * @type {Vertex}
	 * @default vertex2.
	 */
	this.vertex2;
	/**
	 * vtxIdx0
	 * @type {number}
	 * @default undefined.
	 */
	this.vtxIdx0;
	/**
	 * vtxIdx1
	 * @type {number}
	 * @default undefined.
	 */
	this.vtxIdx1;
	/**
	 * vtxIdx2
	 * @type {number}
	 * @default undefined.
	 */
	this.vtxIdx2;
	/**
	 * plainNormal
	 * @type {Point3D}
	 * @default undefined.
	 */	
	this.normal; 
	
	if (vertex0 !== undefined)
	{ this.vertex0 = vertex0; }
	
	if (vertex1 !== undefined)
	{ this.vertex1 = vertex1; }
	
	if (vertex2 !== undefined)
	{ this.vertex2 = vertex2; }
	
	this.hEdge;
};

/**
* 생성된 객체가 있다면 삭제하고 초기화 한다.
*/
Triangle.prototype.deleteObjects = function() 
{
	// the triangle no deletes vertices.
	if (this.vertex0)
	{
		this.vertex0 = undefined;
	}
	if (this.vertex1)
	{
		this.vertex1 = undefined;
	}
	if (this.vertex2)
	{
		this.vertex2 = undefined;
	}
	if (this.normal)
	{
		this.normal.deleteObjects();
		this.normal = undefined;
	}
	
	this.vtxIdx0 = undefined;
	this.vtxIdx1 = undefined;
	this.vtxIdx2 = undefined;
};

/**
 * Triangle의 각각의 Vertex 설정
 * 
 * @param {Vertex} vertex0
 * @param {Vertex} vertex1
 * @param {Vertex} vertex2
 */
Triangle.prototype.setVertices = function(vertex0, vertex1, vertex2) 
{
	this.vertex0 = vertex0;
	this.vertex1 = vertex1;
	this.vertex2 = vertex2;
};

/**
 * Vertex의 vertexList index를 가지고 와서 Vertex index 설정
 */
Triangle.prototype.assignVerticesIdx = function() 
{
	if (this.vertex0 === undefined || this.vertex1 === undefined || this.vertex2 === undefined)
	{ return; }
	
	this.vtxIdx0 = this.vertex0.getIdxInList();
	this.vtxIdx1 = this.vertex1.getIdxInList();
	this.vtxIdx2 = this.vertex2.getIdxInList();
};

/**
 * Triangle의 Vertex index를 인덱스 배열에 추가한다.
 * 
 * @param {indicesArray[]} 인덱스 배열
 * @returns {indicesArray[]} 인덱스 배열 
 */
Triangle.prototype.getIndicesArray = function(indicesArray)
{
	if (indicesArray === undefined)
	{ indicesArray = []; }
	
	if (this.vtxIdx0 !== undefined && this.vtxIdx1 !== undefined && this.vtxIdx2 !== undefined )
	{
		indicesArray.push(this.vtxIdx0);
		indicesArray.push(this.vtxIdx1);
		indicesArray.push(this.vtxIdx2);
	}
	
	return indicesArray;
};

/**
 * invert triangle을 구한다.
 */
Triangle.prototype.invertSense = function() 
{
	var vertexAux = this.vertex1;
	this.vertex1 = this.vertex2;
	this.vertex2 = vertexAux;
	
	this.calculatePlaneNormal();
};

/**
 * PlaneNormal을 계산한다.
 */
Triangle.prototype.calculatePlaneNormal = function() 
{
	if (this.normal === undefined)
	{ this.normal = new Point3D(); }

	this.getCrossProduct(0, this.normal);
	this.normal.unitary();
};

/**
 * CrossProduct(벡터의 외적)를 계산한다.
 * 
 * @param {Number} idxVertex 
 * @param {Number} resultCrossProduct 
 * @returns {Number} resultCrossProduct
 */
Triangle.prototype.getCrossProduct = function(idxVertex, resultCrossProduct) 
{
	if (resultCrossProduct === undefined)
	{ resultCrossProduct = new Point3D(); }

	var currentPoint, prevPoint, nextPoint;

	if (idxVertex === 0)
	{
		currentPoint = this.vertex0.point3d;
		prevPoint = this.vertex2.point3d;
		nextPoint = this.vertex1.point3d;
	}
	else if (idxVertex === 1)
	{
		currentPoint = this.vertex1.point3d;
		prevPoint = this.vertex0.point3d;
		nextPoint = this.vertex2.point3d;
	}
	else if (idxVertex === 2)
	{
		currentPoint = this.vertex2.point3d;
		prevPoint = this.vertex1.point3d;
		nextPoint = this.vertex0.point3d;
	}

	var v1 = new Point3D();
	var v2 = new Point3D();

	v1.set(currentPoint.x - prevPoint.x,     currentPoint.y - prevPoint.y,     currentPoint.z - prevPoint.z);
	v2.set(nextPoint.x - currentPoint.x,     nextPoint.y - currentPoint.y,     nextPoint.z - currentPoint.z);

	v1.unitary();
	v2.unitary();

	resultCrossProduct = v1.crossProduct(v2, resultCrossProduct);

	return resultCrossProduct;
};

'use strict';

/**
 * Triangle 객체의 리스트
 * 
 * @class
 */
var TrianglesList = function() 
{
	if (!(this instanceof TrianglesList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * Triangle 객체의 배열
	 * @type {Triangle[]}
	 */
	this.trianglesArray = [];
};

/**
 * Triangle을 생성하고, 배열에 추가한다.
 * 
 * @param {Vertex} vertex0 1번 버텍스
 * @param {Vertex} vertex1 2번 버텍스
 * @param {Vertex} vertex2 3번 버텍스
 * @returns {Triangle} 생성된 Triangle 객체
 */
TrianglesList.prototype.newTriangle = function(vertex0, vertex1, vertex2) 
{
	var triangle = new Triangle(vertex0, vertex1, vertex2);
	this.trianglesArray.push(triangle);

	return triangle;
};

/**
 * 주어진 Triangle을 배열에 추가한다.
 * 
 * @param {Triangle} triangle 추가할 Triangle 객체
 */
TrianglesList.prototype.addTriangle = function(triangle) 
{
	this.trianglesArray.push(triangle);
};

/**
 * 생성된 객체가 있다면 삭제하고, 초기화한다.
 */
TrianglesList.prototype.deleteObjects = function() 
{
	var trianglesCount = this.getTrianglesCount();
	for (var i=0; i<trianglesCount; i++)
	{
		this.trianglesArray[i].deleteObjects();
		this.trianglesArray[i] = undefined;
	}
	this.trianglesArray = [];
};

/**
 * Triangle 배열의 개수를 구한다.
 * 
 * @returns {Number} 배열의 개수
 */
TrianglesList.prototype.getTrianglesCount = function() 
{
	return this.trianglesArray.length;
};

/**
 * 주어진 인덱스에 있는 Triangle 객체를 가져온다.
 * 
 * @param {Number} index 가져올 Triangle 객체의 인덱스 값
 * @returns {Triangle} 주어진 인덱스 위치의 Triangle 객체
 */
TrianglesList.prototype.getTriangle = function(index) 
{
	return this.trianglesArray[index];
};

/**
 * 버텍스 인덱스를 할당한다.
 */
TrianglesList.prototype.assignVerticesIdx = function() 
{
	TrianglesList.assignVerticesIdx(this.trianglesArray);
};

/**
 * 버텍스 인덱스를 할당한다.
 * 
 * @param {Triangle[]} triangles 삼각형 클래스 배열
 */
TrianglesList.assignVerticesIdx = function(triangles) 
{
	if (triangles === undefined)
	{ return; }
	
	var trianglesCount = triangles.length;
	var triangles = triangles;
	for (var i=0; i<trianglesCount; i++)
	{
		triangles[i].assignVerticesIdx();
	}
};

/**
 * 주어진 삼각형 클래스 배열의 버텍스 인덱스를 주어진 인텍스 배열에 설정한다.
 * 
 * @param {Triangle[]} triangles 삼각형 클래스 배열
 * @param {Uint16Array[]}  indices 버텍스 인덱스 배열
 * @returns {Uint16Array[]}  버텍스 인덱스 배열
 */
TrianglesList.getTrianglesIndicesArray = function(triangles, indices) 
{
	var trianglesCount = triangles.length;
	var indicesCount = trianglesCount * 3;
	
	if (indices === undefined)
	{ indices = new Uint16Array(indicesCount); }
	
	for (var i=0; i<trianglesCount; i++)
	{
		indices[i*3] = triangles[i].vtxIdx0;
		indices[i*3+1] = triangles[i].vtxIdx1;
		indices[i*3+2] = triangles[i].vtxIdx2;
	}
	
	return indices;
};

/**
 * 삼각형 클래스 배열의 반복되지 않는 인덱스들을 주어진 인텍스 배열에 설정한다.
 * 
 * @param {Vertex[]} vertices 버텍스 배열
 * @returns {Vertex[]} 버텍스 배열
 */
TrianglesList.prototype.getNoRepeatedVerticesArray = function(vertices) 
{
	vertices = TrianglesList.getNoRepeatedVerticesArray(this.trianglesArray, vertices);
	return vertices;
};

/**
 * 주어진 삼각형 클래스 배열의 반복되지 않는 인덱스들을 주어진 인텍스 배열에 설정한다.
 * 
 * @param {Triangle[]} triangles 
 * @param {Vertex[]} vertices 버텍스 배열
 * @returns {Vertex[]} 버텍스 배열
 */
TrianglesList.getNoRepeatedVerticesArray = function(triangles, vertices) 
{
	if (vertices === undefined)
	{ vertices = []; }
	
	// 1rst, assign vertexIdxInList for all used vertives.
	var triangle;
	var idxAux = 0;
	var vtx_0, vtx_1, vtx_2;

	var trianglesCount = triangles.length;
	for (var i=0; i<trianglesCount; i++)
	{
		triangle = triangles[i];
		vtx_0 = triangle.vertex0;
		vtx_1 = triangle.vertex1;
		vtx_2 = triangle.vertex2;
		
		vtx_0.setIdxInList(idxAux);
		idxAux++;
		vtx_1.setIdxInList(idxAux);
		idxAux++;
		vtx_2.setIdxInList(idxAux);
		idxAux++;
	}
	
	// now, make a map of unique vertices map using "idxInList" of vertices.
	var verticesMap = {};
	for (var i=0; i<trianglesCount; i++)
	{
		triangle = triangles[i];
		vtx_0 = triangle.vertex0;
		vtx_1 = triangle.vertex1;
		vtx_2 = triangle.vertex2;
		
		verticesMap[vtx_0.getIdxInList().toString()] = vtx_0;
		verticesMap[vtx_1.getIdxInList().toString()] = vtx_1;
		verticesMap[vtx_2.getIdxInList().toString()] = vtx_2;
	}
	
	// finally make the unique vertices array.
	var vertex;
	for (var key in verticesMap)
	{
		if (Object.prototype.hasOwnProperty.call(verticesMap, key))
		{
			vertex = verticesMap[key];
			vertices.push(vertex);
		}
	}
	
	return vertices;
};

/**
 * 주어진 trianglesArray을 VBO face 형태의 버텍스 배열로 설정한다.
 * 
 * @param {Triangle[]} triangles 삼각형 클래스 배열
 * @param {VBOVertexIdxCacheKey} result 
 * @param {VboMemoryManager} vboMemManager 
 * @returns {VBOVertexIdxCacheKey}
 */
TrianglesList.getVboFaceDataArray = function(triangles, result, vboMemManager) 
{
	// TODO: 함수기능을 분리해야함.
	if (result === undefined)
	{ result = new VBOVertexIdxCacheKey(); }

	if (triangles === undefined)
	{ return result; }
	
	var trianglesCount = triangles.length;
	if (trianglesCount === 0)
	{ return result; }

	var indicesArray = TrianglesList.getTrianglesIndicesArray(triangles, undefined);
	result.setDataArrayIdx(indicesArray, vboMemManager);
	
	return result;
};

'use strict';

/**
 * Triangle 리스트의 배열
 * 
 * @class
 * 
 * @see TrianglesMatrix
 * @see TrianglesList
 */
var TrianglesMatrix= function() 
{
	if (!(this instanceof TrianglesMatrix)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * Triangle 리스트의 배열
	 * @type {TrianglesList[]}
	 */
	this.trianglesListsArray = [];
};

/**
 * 생성된 객체가 있다면 삭제하고, 초기화한다.
 */
TrianglesMatrix.prototype.deleteObjects = function()
{
	var trianglesListsCount = this.trianglesListsArray.length;
	for (var i=0; i<trianglesListsCount; i++)
	{
		this.trianglesListsArray[i].deleteObjects();
		this.trianglesListsArray[i] = undefined;
	}
	this.trianglesListsArray = [];
};

/**
 * 주어진 인덱스에 있는 TrianglesList를 가져온다.
 * 
 * @param {Number} index 가져올 Triangle 리스트의 인덱스 값
 * @returns {TrianglesList} 주어진 인덱스 위치의 TrianglesList
 */
TrianglesMatrix.prototype.getTrianglesList = function(index)
{
	return this.trianglesListsArray[index];
};

/**
 * TrianglesList 배열의 개수를 구한다.
 * 
 * @returns {Number} 배열의 개수
 */
TrianglesMatrix.prototype.getTrianglesListsCount = function()
{
	return this.trianglesListsArray.length;
};

/**
 * Triangle 객체의 리스트를 추가하고, 배열에 추가한다.
 *
 * @returns {TrianglesList} Triangle 객체의 리스트
 */
TrianglesMatrix.prototype.newTrianglesList = function()
{
	var trianglesList = new TrianglesList();
	this.trianglesListsArray.push(trianglesList);

	return trianglesList;
};

/**
 * 버텍스 인덱스를 할당한다.
 */
TrianglesMatrix.prototype.assignVerticesIdx = function() 
{
	var trianglesListsCount = this.trianglesListsArray.length;
	for (var i=0; i<trianglesListsCount; i++)
	{
		this.trianglesListsArray[i].assignVerticesIdx();
	}
};

/**
 * 주어진 trianglesArray을 VBO face 형태의 버텍스 배열로 설정한다.
 * 
 * @param {} result 
 * @returns vertexArray[idx] VBO face 형태의 버텍스 배열
 */
TrianglesMatrix.prototype.getVboFaceDataArray = function(result)
{
	// TODO: 정확한 입출력 결과 타입을 알 수 없음.
	var indicesArray = [];
	var trianglesListsCount = this.trianglesListsArray.length;
	for (var i=0; i<trianglesListsCount; i++)
	{
		indicesArray = this.trianglesListsArray[i].getTrianglesIndicesArray(indicesArray);
	}
	
	result.idxVboDataArray = Int16Array.from(indicesArray);
	result.indicesCount = result.idxVboDataArray.length;
	
	return result;
};



















































'use strict';


/**
 * 어떤 일을 하고 있습니까?
 * @class Tunnel
 */
var Tunnel = function() 
{
	if (!(this instanceof Tunnel)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// This is a loft object, so need a path & a profile.
	
	this.geoCoordsListPath; // class : GeographicCoordsList.
	this.geoCoordsListProfile; // class : GeographicCoordsList.
	this.geoLocDataManager;
	
	this.vtxProfilesList;
	this.vboKeysContainer;
	this.vboKeysContainerEdges;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.getGeoLocationData = function() 
{
	if (this.geoLocDataManager === undefined)
	{ this.geoLocDataManager = new GeoLocationDataManager(); }
	
	var geoLoc = this.geoLocDataManager.getCurrentGeoLocationData();
	if (geoLoc === undefined)
	{
		geoLoc = this.geoLocDataManager.newGeoLocationData("default");
	}
	
	return geoLoc;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.getPathGeographicCoordsList = function() 
{
	if (this.geoCoordsListPath === undefined)
	{
		this.geoCoordsListPath = new GeographicCoordsList();
		this.geoCoordsListPath.owner = this;
	}
	return this.geoCoordsListPath;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.getProfileGeographicCoordsList = function() 
{
	if (this.geoCoordsListProfile === undefined)
	{
		this.geoCoordsListProfile = new GeographicCoordsList();
		this.geoCoordsListProfile.owner = this;
	}

	return this.geoCoordsListProfile;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.renderPoints = function(magoManager, shader, renderType) 
{
	if (this.geoCoordsListPath === undefined)
	{ return false; }

	//this.renderMesh(magoManager, shader, renderType);
	this.renderTunnel(magoManager, shader, renderType);

	//if(this.meshPositive !== undefined)
	//{
	//	this.renderExcavation(magoManager, shader, renderType);
	//}
	
	this.geoCoordsListPath.renderPoints(magoManager, shader, renderType, false);
	this.geoCoordsListPath.renderLines(magoManager, shader, renderType, false, false);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.renderMesh = function(magoManager, shader, renderType) 
{
	if (this.meshPositive === undefined)
	{ return; }
	
	var gl = magoManager.sceneState.gl;
	var buildingGeoLocation = this.getGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader);
	this.meshPositive.render(magoManager, shader, renderType);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.renderTunnel = function(magoManager, shader, renderType) 
{
	if (this.meshPositive === undefined)
	{ return; }
	
	//if(magoManager.currentFrustumIdx !== 0)
	//	return;
	
	var gl = magoManager.sceneState.gl;
	
	shader.useProgram();
	shader.resetLastBuffersBinded();

	shader.enableVertexAttribArray(shader.position3_loc);
	shader.disableVertexAttribArray(shader.color4_loc);
	shader.enableVertexAttribArray(shader.normal3_loc); 
	shader.disableVertexAttribArray(shader.texCoord2_loc); // provisionally has no texCoords.
	
	shader.bindUniformGenerals();

	
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 0.1, 0.0]); //.
	
	gl.uniform1i(shader.bApplySsao_loc, false); // apply ssao.
	gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
	gl.uniform1i(shader.colorType_loc, 1); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform1i(shader.bApplySpecularLighting_loc, true); // turn on/off specular lighting.
	
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	gl.depthRange(0, 1);
	
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader); // rotMatrix, positionHIGH, positionLOW.
		
	
	// STENCIL SETTINGS.*
	gl.colorMask(false, false, false, false);
	gl.depthMask(false);
	gl.enable(gl.CULL_FACE);
	gl.enable(gl.STENCIL_TEST);
	//gl.enable(gl.POLYGON_OFFSET_FILL);
	//gl.polygonOffset(1.0, 2.0); // Original.
	//gl.polygonOffset(0.0, 0.0); 
	
	gl.clearStencil(0);
	var glPrimitive = undefined;
	
	
	//if(magoManager.currentFrustumIdx !== 5)
	{
		// First pass.*
		gl.cullFace(gl.FRONT); // 1rstPass.
		gl.stencilFunc(gl.ALWAYS, 0x0, 0xff);
		//gl.stencilOp(gl.KEEP, gl.INCR, gl.KEEP); // stencilOp(fail, zfail, zpass)
		gl.stencilOp(gl.KEEP, gl.INCR, gl.KEEP); // stencilOp(fail, zfail, zpass)
		this.meshPositive.render(magoManager, shader, renderType, glPrimitive);
	}
	
	
	//if(magoManager.currentFrustumIdx === 5)
	{
		// Second pass.*
		gl.cullFace(gl.BACK); // 2ndPass.
		gl.stencilFunc(gl.ALWAYS, 0x0, 0xff);
		//gl.stencilOp(gl.KEEP, gl.DECR, gl.KEEP); // stencilOp(fail, zfail, zpass)
		gl.stencilOp(gl.KEEP, gl.DECR, gl.KEEP); // stencilOp(fail, zfail, zpass)
		this.meshPositive.render(magoManager, shader, renderType, glPrimitive);// Original.
	}
	

	// Render the hole.
	//shader.bindUniformGenerals();
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform4fv(shader.oneColor4_loc, [222/255, 184/255, 135/255, 1.0]); //.
	
	//gl.disable(gl.POLYGON_OFFSET_FILL);
	//gl.disable(gl.CULL_FACE);
	gl.colorMask(true, true, true, true);
	//gl.depthMask(false); // original.
	gl.depthMask(true);
	gl.stencilMask(0x00);

	//gl.stencilFunc(gl.NOTEQUAL, 0, 0xff);
	gl.stencilFunc(gl.LEQUAL, 1, 0xff);
	//gl.stencilFunc(gl.LESS, 0, 0xff);
	//gl.stencilFunc(gl.EQUAL, 1, 0xff);
	gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE); // stencilOp(fail, zfail, zpass)

	//gl.disable(gl.DEPTH_TEST);

	gl.cullFace(gl.BACK);

	gl.depthFunc(gl.ALWAYS);

	//gl.disable(gl.DEPTH_TEST);
	//gl.disable(gl.STENCIL_TEST);
	
	//if (magoManager.currentFrustumIdx === 0)
	//{
	//	
	//}
	
	this.meshNegative.render(magoManager, shader, renderType, glPrimitive);

	
	//gl.disable(gl.STENCIL_TEST);
	//gl.depthFunc(gl.LEQUAL);
	//this.meshPositive.render(magoManager, shader, renderType, glPrimitive);// Original.


	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	//gl.disable(gl.BLEND);
	gl.disable(gl.STENCIL_TEST);
	gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP); // stencilOp(fail, zfail, zpass)
	gl.disable(gl.POLYGON_OFFSET_FILL);
	gl.depthRange(0, 1);// return to the normal value.
	gl.useProgram(null);
	
	gl.depthMask(true); //sets whether writing into the depth buffer is enabled or disabled. Default value: true, meaning that writing is enabled.
	gl.stencilMask(0xff);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.makeMesh = function(magoManager) 
{
	if (this.geoCoordsListPath === undefined || this.geoCoordsListProfile === undefined)
	{ return false; }
	
	// 1rst, set position of this extrude object. Take as position the 1rst geoCoord absolute position.
	// Another possibility is calculate the average point of geoCoords.
	var geoLoc = this.getGeoLocationData();

	// Take the 1rst geographicCoord's geoLocation of the path.
	var geoCoord = this.geoCoordsListPath.getGeoCoord(0);
	var geoLocDataManagerFirst = geoCoord.getGeoLocationDataManager();
	var geoLocFirst = geoLocDataManagerFirst.getCurrentGeoLocationData();
	geoLoc.copyFrom(geoLocFirst);

	// Now, make the profiles ( 1 vtxProfile for each point of the path).
	if (this.vtxProfilesList === undefined)
	{ this.vtxProfilesList = new VtxProfilesList(); }
	
	// Transform pathGeoCoordsList to cartesianPath(points3DList).
	var wgs84Point3DArray = this.geoCoordsListPath.getWgs84Points3D(undefined);
	var relativePoints3dArray = geoLoc.getTransformedRelativePositionsArray(wgs84Point3DArray, undefined);
	
	var pathPoints3dList = new Point3DList(relativePoints3dArray);
	var bLoop = false; // this is a stringTypePath, no loopTypePath.
	
	// Provisionally make an circular profile in the 1rst point3d-plane.
	var bisectionPlane = pathPoints3dList.getBisectionPlane(0, undefined, bLoop);
	// Note: "bisectionPlane" is in local coordinate "geoLoc".
			
	var profile2d = new Profile2D();
	//profile2d.TEST__setFigureHole_2();
	//profile2d.TEST__setFigure_1();
	//profile2d.TEST__setFigure_2holes();
	
	var ring = profile2d.newOuterRing();
	var circle = ring.newElement("CIRCLE");
	circle.setCenterPosition(0, 0);
	circle.setRadius(15);
	var resultPoints2dArray = [];
	var pointsCountFor360Deg = 24;
	ring.getPoints(resultPoints2dArray, pointsCountFor360Deg);

	// Now, calculate the rotMatrix of the bisectionPlane, & calculate points3ds of the circle points2d.
	var rotMat4 = bisectionPlane.getRotationMatrix(undefined);
	var firstPoint3d = pathPoints3dList.getPoint(0);
	rotMat4.setTranslation(firstPoint3d.x, firstPoint3d.y, firstPoint3d.z);

	// Make the loft vtxProfilesList.
	//bLoop = true;
	
	if (this.meshPositive === undefined)
	{
		this.vtxProfilesList.makeLoft(profile2d, pathPoints3dList, bLoop);
		
		// positive mesh.
		var bIncludeBottomCap = true;
		var bIncludeTopCap = true;
		var meshAux = this.vtxProfilesList.getMesh(undefined, bIncludeBottomCap, bIncludeTopCap, bLoop);
		this.meshPositive = meshAux.getCopySurfaceIndependentMesh(this.meshPositive);
		var bForceRecalculatePlaneNormal = false;
		this.meshPositive.calculateVerticesNormals(bForceRecalculatePlaneNormal);
		this.meshPositive.setColor(0.1, 0.5, 0.5, 1.0);
		
		// negative mesh.
		this.meshNegative = meshAux.getCopySurfaceIndependentMesh(this.meshNegative);
		this.meshNegative.reverseSense(); // here calculates vertices normals.
		this.meshNegative.setColor(0.1, 0.5, 0.5, 1.0);
		this.meshNegative.getVbo(this.vboKeysContainer, magoManager.vboMemoryManager);
		this.meshNegative.getVboEdges(this.vboKeysContainerEdges, magoManager.vboMemoryManager);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.remakeMesh = function(magoManager) 
{
	if (this.vtxProfilesList === undefined)
	{ return false; }
	
	// 1rst, set position of this extrude object. Take as position the 1rst geoCoord absolute position.
	// Another possibility is calculate the average point of geoCoords.
	var geoLoc = this.getGeoLocationData();

	// Take the 1rst geographicCoord's geoLocation of the path.
	var geoCoord = this.geoCoordsListPath.getGeoCoord(0);
	var geoLocDataManagerFirst = geoCoord.getGeoLocationDataManager();
	var geoLocFirst = geoLocDataManagerFirst.getCurrentGeoLocationData();
	geoLoc.copyFrom(geoLocFirst);

	// Now, make the profiles ( 1 vtxProfile for each point of the path).
	
	// Transform pathGeoCoordsList to cartesianPath(points3DList).
	var wgs84Point3DArray = this.geoCoordsListPath.getWgs84Points3D(undefined);
	var relativePoints3dArray = geoLoc.getTransformedRelativePositionsArray(wgs84Point3DArray, undefined);
	
	var pathPoints3dList = new Point3DList(relativePoints3dArray);
	var bLoop = false; // this is a stringTypePath, no loopTypePath.
	
	// Provisionally make an circular profile in the 1rst point3d-plane.
	var bisectionPlane = pathPoints3dList.getBisectionPlane(0, undefined, bLoop);
	// Note: "bisectionPlane" is in local coordinate "geoLoc".
			
	var profile2d = new Profile2D();
	//profile2d.TEST__setFigureHole_2();
	//profile2d.TEST__setFigure_1();
	//profile2d.TEST__setFigure_2holes();
	
	var ring = profile2d.newOuterRing();
	var circle = ring.newElement("CIRCLE");
	circle.setCenterPosition(0, 0);
	circle.setRadius(15);
	var resultPoints2dArray = [];
	var pointsCountFor360Deg = 24;
	ring.getPoints(resultPoints2dArray, pointsCountFor360Deg);

	// Now, calculate the rotMatrix of the bisectionPlane, & calculate points3ds of the circle points2d.
	var rotMat4 = bisectionPlane.getRotationMatrix(undefined);
	var firstPoint3d = pathPoints3dList.getPoint(0);
	rotMat4.setTranslation(firstPoint3d.x, firstPoint3d.y, firstPoint3d.z);

	// Make the loft vtxProfilesList.
	//bLoop = true;
	this.meshPositive = undefined;
	this.meshNegative = undefined;
	
	this.vtxProfilesList.deleteObjects();
	this.vtxProfilesList = new VtxProfilesList();
	
	if (this.meshPositive === undefined)
	{
		this.vtxProfilesList.makeLoft(profile2d, pathPoints3dList, bLoop);
		
		// positive mesh.
		var bIncludeBottomCap = true;
		var bIncludeTopCap = true;
		var meshAux = this.vtxProfilesList.getMesh(undefined, bIncludeBottomCap, bIncludeTopCap, bLoop);
		this.meshPositive = meshAux.getCopySurfaceIndependentMesh(this.meshPositive);
		var bForceRecalculatePlaneNormal = false;
		this.meshPositive.calculateVerticesNormals(bForceRecalculatePlaneNormal);
		this.meshPositive.setColor(0.1, 0.5, 0.5, 1.0);
		
		// negative mesh.
		this.meshNegative = meshAux.getCopySurfaceIndependentMesh(this.meshNegative);
		this.meshNegative.reverseSense(); // here calculates vertices normals.
		this.meshNegative.setColor(0.1, 0.5, 0.5, 1.0);
		this.meshNegative.getVbo(this.vboKeysContainer, magoManager.vboMemoryManager);
		this.meshNegative.getVboEdges(this.vboKeysContainerEdges, magoManager.vboMemoryManager);
	}
};















































'use strict';

/**
 * Data structure with vertex information
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class Vertex
 * 
 * @param {Point3D} position vertex postion.
 */
var Vertex = function(position) 
{
	if (!(this instanceof Vertex)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * vertex 3d coordinate.
	 * @type {Point3D}
	 */
	this.point3d;

	/**
	 * vertex noraml.
	 * @type {Point3D}
	 */
	this.normal;

	/**
	 * 2d coordinate
	 * @type {Point2D}
	 */
	this.texCoord;

	/**
	 * vertex color
	 * @type {Color}
	 */
	this.color4; // class: Color.
	
	/**
	 * outingHedge
	 * @type {HalfEdge}
	 */
	this.outingHedge; // class: HalfEdge
	//this.outingHalfEdgesArray; // Array [class: HalfEdge]. 

	/**
	 * vertex type. 1 is important vertex.
	 * @type {Number}
	 */
	this.vertexType;

	/**
	 *  vertexList index
	 * @type {Number}
	 * 
	 * @see VertexList
	 */
	this.idxInList;
	

	if (position)
	{ this.point3d = position; }
	else
	{
		this.point3d = new Point3D();
	}
};

/**
 * vertex init.
 * all member set undifined;
 */
Vertex.prototype.deleteObjects = function() 
{
	if (this.point3d)
	{ this.point3d.deleteObjects(); }
	if (this.normal)
	{ this.normal.deleteObjects(); }
	if (this.texCoord)
	{ this.texCoord.deleteObjects(); }
	if (this.color4)
	{ this.color4.deleteObjects(); }
	
	this.point3d = undefined;
	this.normal = undefined;
	this.texCoord = undefined;
	this.color4 = undefined;
};

/**
 * get vertexList index
 * @returns {Number}
 */
Vertex.prototype.getIdxInList = function() 
{
	return this.idxInList;
};

/**
 * set vertexList index
 * @param {Number} idx index
 */
Vertex.prototype.setIdxInList = function(idx) 
{
	this.idxInList = idx;
};

/**
 * make vertex copy from another vertex. like clone.
 * @param {Vertex} vertex 
 */
Vertex.prototype.copyFrom = function(vertex) 
{
	// copy position if exist.
	if (vertex.point3d)
	{
		if (this.point3d === undefined)
		{ this.point3d = new Point3D(); }
		
		this.point3d.copyFrom(vertex.point3d);
	}
	
	// copy normal if exist.
	if (vertex.normal)
	{
		if (this.normal === undefined)
		{ this.normal = new Point3D(); }
		
		this.normal.copyFrom(vertex.normal);
	}
	
	// copy texCoord if exist.
	if (vertex.texCoord)
	{
		if (this.texCoord === undefined)
		{ this.texCoord = new Point2D(); }
		
		this.texCoord.copyFrom(vertex.texCoord);
	}
	
	// copy color4 if exist.
	if (vertex.color4)
	{
		if (this.color4 === undefined)
		{ this.color4 = new Color(); }
		
		this.color4.copyFrom(vertex.color4);
	}
	
	this.vertexType = vertex.vertexType;
};

/**
 * get this vertex point.
 * @returns {Point3D}
 */
Vertex.prototype.getPosition = function() 
{
	return this.point3d;
};

/**
 * set this vertex point. if this point3d undefined, set new Point3D instance.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Vertex.prototype.setPosition = function(x, y, z) 
{
	if (this.point3d === undefined)
	{ this.point3d = new Point3D(); }
	
	this.point3d.set(x, y, z);
};

/**
 * set this vertex texCoord. if this texCoord undefined, set new Point2D instance.
 * @param {Number} s
 * @param {Number} t
 */
Vertex.prototype.setTexCoord = function(s, t) 
{
	if (this.texCoord === undefined)
	{ this.texCoord = new Point2D(); }
	
	this.texCoord.set(s, t);
};

/**
 * set this vertex color exclude alpha. if this color4 undefined, set new Color instance.
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 */
Vertex.prototype.setColorRGB = function(r, g, b) 
{
	if (this.color4 === undefined) { this.color4 = new Color(); }
	
	this.color4.setRGB(r, g, b);
};

/**
 * set this vertex color include alpha. if this color4 undefined, set new Color instance.
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @param {Number} alpha
 */
Vertex.prototype.setColorRGBA = function(r, g, b, alpha) 
{
	if (this.color4 === undefined) { this.color4 = new Color(); }
	
	this.color4.setRGBA(r, g, b, alpha);
};

/**
 * set this vertex normal. if this normal undefined, set new Point3D instance.
 * @param {Number} nx
 * @param {Number} ny
 * @param {Number} nz
 */
Vertex.prototype.setNormal = function(nx, ny, nz) 
{
	if (this.normal === undefined) { this.normal = new Point3D(); }
	
	this.normal.set(nx, ny, nz);
};

/**
 * get this vertex normal
 * @returns {Point3D} normal
 */
Vertex.prototype.getNormal = function() 
{
	if (this.normal === undefined) { this.normal = new Point3D(); }
	
	return this.normal;
};

/**
 * vertex point translate. use add method.
 * @param {Number} dx
 * @param {Number} dy
 * @param {Number} dz
 * @see Point3D#add
 */
Vertex.prototype.translate = function(dx, dy, dz) 
{
	this.point3d.add(dx, dy, dz);
};

/**
 * get vertex outinghedges. 
 * @deprecated
 * @param {Array} resultHedgesArray
 * @returns {Array} resultHedgesArray
 */
Vertex.prototype.getOutingHEdges = function(resultHedgesArray) 
{
	if (resultHedgesArray === undefined)
	{ resultHedgesArray = []; }
	
	// todo:
	
	return resultHedgesArray;
};

/**
 * get vertex intersected with plane. 
 * @static
 * @param {Vertex} vertex Required. 
 * @param {Plane} plane. 
 * @param {Point3D} projectionDirection projectionDirection must be unitary.
 * @param {Vertex} resultVertex Optional. 
 * @returns {Vertex} resultVertex
 */
Vertex.getProjectedOntoPlane = function(vertex, plane, projectionDirection, resultVertex)
{
	if (vertex === undefined)
	{ return resultVertex; }
	
	var position = vertex.getPosition();
	var line = new Line(position, projectionDirection);

	var intersectionPoint;
	intersectionPoint = plane.intersectionLine(line, intersectionPoint);
	
	if (resultVertex === undefined)
	{ resultVertex = new Vertex(); }
	
	// 1rst, copy from the original vertex.
	resultVertex.copyFrom(vertex);
	
	// Now, change only the position.
	resultVertex.setPosition(intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);
	
	return resultVertex;
};

'use strict';

/**
 * Vertex List (Array of Vetex)
 * @see Vertex
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class VertexList
 */
var VertexList = function() 
{
	if (!(this instanceof VertexList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * vertex list.
	 * @type {Array.<Vertex>}
	 */
	this.vertexArray = [];
};

/**
 * get previus index of vertexArray
 * @static
 * @param {Number} idx index must bigger than 0, less than vertexArray length.
 * @param {Array.<Vertex>} vertexArray
 * @returns {Number} prevIdx. if idx is 0, return vertexArray.length - 1.
 */
VertexList.getPrevIdx = function(idx, vertexArray)
{
	var verticesCount = vertexArray.length;
	
	if (idx < 0 || idx > verticesCount-1)
	{ return undefined; }
	
	var prevIdx;
	
	if (idx === 0)
	{ prevIdx = verticesCount - 1; }
	else
	{ prevIdx = idx - 1; }

	return prevIdx;
};

/**
 * get next index of vertexArray
 * @static
 * @param {Number} idx index must bigger than 0, less than vertexArray length.
 * @param {Array.<Vertex>} vertexArray
 * @returns {Number} nextIdx. if idx is equal vertexArray.length - 1, return 0.
 */
VertexList.getNextIdx = function(idx, vertexArray)
{
	var verticesCount = vertexArray.length;
	
	if (idx < 0 || idx > verticesCount-1)
	{ return undefined; }
	
	var nextIdx;
	
	if (idx === verticesCount - 1)
	{ nextIdx = 0; }
	else
	{ nextIdx = idx + 1; }

	return nextIdx;
};

/**
 * get vertex segment. This segment is consist of indexed vertex and next vertex
 * @static
 * @param {Number} idx index
 * @param {Array.<Vertex>} vertexArray
 * @param {VtxSegment} resultVtxSegment if resultVtxSegment is undefined, resultVtxSegment set new VtxSegemnt instance.
 * @returns {VtxSegment} resultVtxSegment
 */
VertexList.getVtxSegment = function(idx, vertexArray, resultVtxSegment)
{
	var currVertex = vertexArray[idx];
	var nextIdx = VertexList.getNextIdx(idx, vertexArray);
	var nextVertex = vertexArray[nextIdx];
	
	if (resultVtxSegment === undefined)
	{ resultVtxSegment = new VtxSegment(currVertex, nextVertex); }
	else 
	{
		resultVtxSegment.setVertices(currVertex, nextVertex);
	}

	return resultVtxSegment;
};

/**
 * get vertex vector. This vector is consist of indexed vertex and next vertex
 * @static
 * @param {Number} idx index
 * @param {Array.<Vertex>} vertexArray
 * @param {Point3D} resultVector if resultVector is undefined, resultVector set new Point3D instance.
 * @returns {Point3D} resultVector
 */
VertexList.getVector = function(idx, vertexArray, resultVector)
{
	var currVertex = vertexArray[idx];
	var nextIdx = VertexList.getNextIdx(idx, vertexArray);
	var nextVertex = vertexArray[nextIdx];
	
	var currPoint = currVertex.point3d;
	var nextPoint = nextVertex.point3d;
	
	if (resultVector === undefined)
	{ resultVector = new Point3D(nextPoint.x - currPoint.x, nextPoint.y - currPoint.y, nextPoint.z - currPoint.z); }
	else 
	{
		resultVector.setVertices(nextPoint.x - currPoint.x, nextPoint.y - currPoint.y, nextPoint.z - currPoint.z);
	}

	return resultVector;
};

/**
 * get vertex direction. vertex vector's unitary.
 * @static
 * @param {Number} idx index
 * @param {Array.<Vertex>} vertexArray
 * @param {Point3D} resultDir point3d unitary.
 * @returns {Point3D} 
 */
VertexList.getDirection = function(idx, vertexArray, resultDir)
{
	resultDir = VertexList.getVector(idx, vertexArray, resultDir);
	resultDir.unitary();
	return resultDir;
};

/**
 * get crossproduct. This crossproduct is consist of indexed vertex and prev vertex
 * @deprecated
 * @static
 * @param {Number} idx index
 * @param {Array.<Vertex>} vertexArray
 * @param {Point3D} resultCrossProduct
 * @returns {Point3D} 
 */
VertexList.getCrossProduct = function(idx, vertexArray, resultCrossProduct)
{
	var currVector = VertexList.getVector(idx, vertexArray, undefined);
	var prevIdx = VertexList.getPrevIdx(idx, vertexArray);
	var prevVector = VertexList.getVector(prevIdx, vertexArray, undefined);
	resultCrossProduct = prevVector.crossProduct(currVector, resultCrossProduct);

	return resultCrossProduct;
};

/**
 * get vertex list. this vertex is projected onto plane. 
 * @static
 * @param {Array.<Vertex>} vertexArray if vertexArray is undefined, return resultVertexList
 * @param {Plane} plane. 
 * @param {Point3D} projectionDirection projectionDirection must be unitary.
 * @param {VertexList} resultVertexList if resultVertexList is undefined, resultVector set new VertexList instance.
 * @returns {VertexList} 
 * 
 * @see Vertex#getProjectedOntoPlane
 */
VertexList.getProjectedOntoPlane = function(vertexList, plane, projectionDirection, resultVertexList)
{
	if (vertexList === undefined)
	{ return resultVertexList; }
	
	if (resultVertexList === undefined)
	{ resultVertexList = new VertexList(); }
	
	var vertex, projectedVertex;
	var vertexCount = vertexList.getVertexCount();
	for (var i=0; i<vertexCount; i++)
	{
		vertex = vertexList.getVertex(i);
		projectedVertex = resultVertexList.newVertex();
		projectedVertex = Vertex.getProjectedOntoPlane(vertex, plane, projectionDirection, projectedVertex);
	}
	
	return resultVertexList;
};

/**
 * get projected point(2d) list.
 * @static
 * @param {Array.<Vertex>} vertexArray if vertexArray is undefined, return resultPoints2dArray
 * @param {Point3D} normal. 
 * @param {Array.<Point2D>} resultPoints2dArray array.
 * @returns {Array.<Point2D>} resultPoints2dArray
 */
VertexList.getProjectedPoints2DArray = function(vertexArray, normal, resultPoints2dArray)
{
	// This function projects the vertices on to planes xy, yz or xz.
	if (vertexArray === undefined)
	{ return resultPoints2dArray; }
	
	if (resultPoints2dArray === undefined)
	{ resultPoints2dArray = []; }
	
	var bestPlaneToProject = Face.getBestFacePlaneToProject(normal);
	
	var point2d;
	var verticesCount = vertexArray.length;
	// Project this face into the bestPlane.
	if (bestPlaneToProject === 0) // plane-xy.
	{
		// project this face into a xy plane.
		for (var i=0; i<verticesCount; i++)
		{
			var vertex = vertexArray[i];
			var point3d = vertex.point3d;
			if (normal.z > 0)
			{ point2d = new Point2D(point3d.x, point3d.y); }
			else
			{ point2d = new Point2D(point3d.x, -point3d.y); }
			point2d.ownerVertex3d = vertex; // with this we can reconvert polygon2D to face3D.
			resultPoints2dArray.push(point2d);
		}
	}
	else if (bestPlaneToProject === 1) // plane-yz.
	{
		// project this face into a yz plane.
		for (var i=0; i<verticesCount; i++)
		{
			var vertex = vertexArray[i];
			var point3d = vertex.point3d;
			if (normal.x > 0)
			{ point2d = new Point2D(point3d.y, point3d.z); }
			else
			{ point2d = new Point2D(-point3d.y, point3d.z); }
			point2d.ownerVertex3d = vertex; // with this we can reconvert polygon2D to face3D.
			resultPoints2dArray.push(point2d);
		}
	}
	else if (bestPlaneToProject === 2) // plane-xz.
	{
		// project this face into a xz plane.
		for (var i=0; i<verticesCount; i++)
		{
			var vertex = vertexArray[i];
			var point3d = vertex.point3d;
			if (normal.y > 0)
			{ point2d = new Point2D(-point3d.x, point3d.z); }
			else
			{ point2d = new Point2D(point3d.x, point3d.z); }
			point2d.ownerVertex3d = vertex; // with this we can reconvert polygon2D to face3D.
			resultPoints2dArray.push(point2d);
		}
	}
	
	return resultPoints2dArray;
};

/**
 * delete all vertex.
 */
VertexList.prototype.deleteObjects = function() 
{
	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		this.vertexArray[i].deleteObjects();
		this.vertexArray[i] = undefined;
	}
	this.vertexArray = undefined;
};

/**
 * Copy vertex list from another vertexList.
 * @param {VertexList} vertexList
 */
VertexList.prototype.copyFrom = function(vertexList) 
{
	// first reset vertexArray.
	this.deleteObjects();
	this.vertexArray = [];
	
	var vertex;
	var myVertex;
	var vertexCount = vertexList.getVertexCount();
	for (var i=0; i<vertexCount; i++)
	{
		vertex = vertexList.getVertex(i);
		myVertex = this.newVertex();
		myVertex.copyFrom(vertex);
	}
};

/**
 * Copy vertex list from point3d array
 * @param {Array.<Point3D>} point3dArray Required.
 */
VertexList.prototype.copyFromPoint3DArray = function(point3dArray) 
{
	if (point3dArray === undefined)
	{ return; }
	
	// first reset vertexArray.
	this.deleteObjects();
	this.vertexArray = [];
	
	var point3d;
	var vertex;

	var pointsCount = point3dArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		point3d = point3dArray[i];
		vertex = this.newVertex();
		vertex.point3d = new Point3D();
		vertex.point3d.set(point3d.x, point3d.y, point3d.z);
		vertex.point3d.pointType = point3d.pointType;
		vertex.vertexType = point3d.pointType;
	}
};

/**
 * Copy vertex list from point2d array and z coordinate.
 * @param {Point2DList} point2dArray.
 * @param {Number} z default is 0.
 */
VertexList.prototype.copyFromPoint2DList = function(point2dList, z) 
{
	// first reset vertexArray.
	this.deleteObjects();
	this.vertexArray = [];
	
	var point2d;
	var vertex;
	if (z === undefined)
	{ z = 0; }

	var pointsCount = point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point2d = point2dList.getPoint(i);
		vertex = this.newVertex();
		vertex.point3d = new Point3D();
		vertex.point3d.set(point2d.x, point2d.y, z);
		vertex.point3d.pointType = point2d.pointType;
		vertex.vertexType = point2d.pointType;
	}
};

/**
 * set normal
 * @param {Number} nx
 * @param {Number} ny
 * @param {Number} nz
 */
VertexList.prototype.setNormal = function(nx, ny, nz) 
{
	var vertex;
	var vertexCount = this.getVertexCount();
	for (var i=0; i<vertexCount; i++)
	{
		vertex = this.getVertex(i);
		vertex.setNormal(nx, ny, nz);
	}
};

/**
 * add vertex and return.
 * @returns {Vertex}
 */
VertexList.prototype.newVertex = function() 
{
	var vertex = new Vertex();
	this.vertexArray.push(vertex);
	return vertex;
};

/**
 * get vertex
 * @param {Number} idx
 * @returns {Vertex}
 */
VertexList.prototype.getVertex = function(idx) 
{
	return this.vertexArray[idx];
};

/**
 * get vertex list lench
 * @returns {Number}
 */
VertexList.prototype.getVertexCount = function() 
{
	return this.vertexArray.length;
};

/**
 * get previus index
 * @param {Number} idx
 * @returns {Number} prev index
 */
VertexList.prototype.getPrevIdx = function(idx)
{
	return VertexList.getPrevIdx(idx, this.vertexArray);
};

/**
 * get next index
 * @param {Number} idx
 * @returns {Number} next index
 */
VertexList.prototype.getNextIdx = function(idx)
{
	return VertexList.getNextIdx(idx, this.vertexArray);
};

/**
 * get index of vertex in list
 * @deprecated not use.
 * @param {Vertex}
 * @returns {Number} index
 */
VertexList.prototype.getIdxOfVertex = function(vertex)
{
	var verticesCount = this.vertexArray.length;
	var i=0;
	var idx = -1;
	var found = false;
	while (!found && i<verticesCount)
	{
		if (this.vertexArray[i] === vertex)
		{
			found = true;
			idx = i;
		}
		i++;
	}
	
	return idx;
};

/**
 * get vertex segment
 * @deprecated not use.
 * @param {Number} idx
 * @param {VtxSegment}
 * @returns {VtxSegment}
 */
VertexList.prototype.getVtxSegment = function(idx, resultVtxSegment)
{
	return VertexList.getVtxSegment(idx, this.vertexArray, resultVtxSegment);
};

/**
 * translate vertex
 * @param {Number} dx
 * @param {Number} dy
 * @param {Number} dz
 */
VertexList.prototype.translateVertices = function(dx, dy, dz) 
{
	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		this.vertexArray[i].translate(dx, dy, dz);
	}
};

/**
 * get bounding box of vertex list.
 * @param {BoundingBox} resultBox if this is undefined, set new BoundingBox instance.
 * @returns {BoundingBox} resultBox
 */
VertexList.prototype.getBoundingBox = function(resultBox) 
{
	if (resultBox === undefined) { resultBox = new BoundingBox(); }

	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		if (i === 0) { resultBox.init(this.vertexArray[i].point3d); }
		else { resultBox.addPoint(this.vertexArray[i].point3d); }
	}
	return resultBox;
};

/**
 * vertex point transform by matrix4
 * @param {Matrix4} transformMatrix
 * @see Matrix4#transformPoint3D
 */
VertexList.prototype.transformPointsByMatrix4 = function(transformMatrix) 
{
	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		var vertex = this.vertexArray[i];
		transformMatrix.transformPoint3D(vertex.point3d, vertex.point3d);
	}
};

/**
 * set vertex idxInList
 */
VertexList.prototype.setIdxInList = function()
{
	VertexList.setIdxInList(this.vertexArray);
	/*
	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		this.vertexArray[i].idxInList = i;
	}
	*/
};

/**
 * set vertex idxInList
 * @static
 * @param {VertexList} Required.
 */
VertexList.setIdxInList = function(vertexArray)
{
	if (vertexArray === undefined)
	{ return; }
	
	for (var i = 0, vertexCount = vertexArray.length; i < vertexCount; i++) 
	{
		vertexArray[i].idxInList = i;
	}
};

/**
 * get vbo vertex index cache key. not use.
 * @deprecated only used static method.
 * @param {VBOVertexIdxCacheKey} resultVbo.
 * @param {VBOMemoryManager} vboMemManager.
 * @returns {VBOVertexIdxCacheKey}
 * 
 * @see VertexList#getVboDataArrays
 */
VertexList.prototype.getVboDataArrays = function(resultVbo, vboMemManager) 
{
	VertexList.getVboDataArrays(this.vertexArray, resultVbo, vboMemManager) ;
	return resultVbo;
};

/**
 * get vbo vertex index cache key. for set VboBuffer data
 * @static
 * @param {VertexList} vertexArray if this length 0, return argument resultVbo.
 * @param {VBOVertexIdxCacheKey} resultVbo. if this is undefined, set new VBOVertexIdxCacheKey Instance.
 * @param {VBOMemoryManager} vboMemManager.
 * @returns {VBOVertexIdxCacheKey}
 * 
 * @see VBOManager
 */
VertexList.getVboDataArrays = function(vertexArray, resultVbo, vboMemManager) 
{
	// returns positions, and if exist, normals, colors, texCoords.
	var verticesCount = vertexArray.length;
	if (verticesCount === 0)
	{ return resultVbo; }
	
	if (resultVbo === undefined)
	{ resultVbo = new VBOVertexIdxCacheKey(); }
	
	var vertex, position, normal, color, texCoord;
	
	// 1rst, check if exist normals, colors & texCoords.
	var hasNormals = false;
	var hasColors = false;
	var hasTexCoords = false;
	
	// Take the 1rst vertex.
	vertex = vertexArray[0];
	if (vertex.point3d === undefined)
	{ return resultVbo; }
	
	if (vertex.normal !== undefined)
	{ hasNormals = true; }
	
	if (vertex.color4 !== undefined)
	{ hasColors = true; }
	
	if (vertex.texCoord !== undefined)
	{ hasTexCoords = true; }
	
	// Make dataArrays. Use vboMemManager to determine classified memorySize( if use memory pool).
	var posVboDataArray, norVboDataArray, colVboDataArray, tcoordVboDataArray;
	
	// Positions.
	var posByteSize = verticesCount * 3;
	posVboDataArray = new Float32Array(posByteSize);
	
	if (hasNormals)
	{ 
		var norByteSize = verticesCount * 3;
		norVboDataArray = new Int8Array(norByteSize);
	}
	
	if (hasColors)
	{ 
		var colByteSize = verticesCount * 4;
		colVboDataArray = new Uint8Array(colByteSize);
	}
	
	if (hasTexCoords)
	{ 
		var texCoordByteSize = verticesCount * 2;
		tcoordVboDataArray = new Float32Array(texCoordByteSize);
	}
	
	for (var i = 0; i < verticesCount; i++) 
	{
		vertex = vertexArray[i];
		if (vertex.point3d === undefined)
		{ continue; }
		
		position = vertex.point3d;

		posVboDataArray[i*3] = position.x;
		posVboDataArray[i*3+1] = position.y;
		posVboDataArray[i*3+2] = position.z;
		
		if (hasNormals)
		{
			normal = vertex.normal;
			norVboDataArray[i*3] = normal.x*127;
			norVboDataArray[i*3+1] = normal.y*127;
			norVboDataArray[i*3+2] = normal.z*127;
		}
		
		if (hasColors)
		{
			color = vertex.color4;
			colVboDataArray[i*4] = color.r*255;
			colVboDataArray[i*4+1] = color.g*255;
			colVboDataArray[i*4+2] = color.b*255;
			colVboDataArray[i*4+3] = color.a*255;
		}
		
		if (hasTexCoords)
		{
			texCoord = vertex.texCoord;
			tcoordVboDataArray[i*2] = texCoord.x;
			tcoordVboDataArray[i*2+1] = texCoord.y;
		}
	}
	
	resultVbo.setDataArrayPos(posVboDataArray, vboMemManager);
	
	if (hasNormals)
	{
		resultVbo.setDataArrayNor(norVboDataArray, vboMemManager);
	}
	
	if (hasColors)
	{
		resultVbo.setDataArrayCol(colVboDataArray, vboMemManager);
	}
	
	if (hasTexCoords)
	{
		resultVbo.setDataArrayTexCoord(tcoordVboDataArray, vboMemManager);
	}

	return resultVbo;
};

'use strict';


/**
 * Vertex Matrix (Array of VertexList)
 * @see Vertex
 * @see VertexList
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class VertexMatrix
 */
var VertexMatrix = function() 
{
	if (!(this instanceof VertexMatrix)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * VertexList Array
	 * @instance
	 * @type {Array.<VertexList>}
	 */
	this.vertexListsArray = [];
	// SCTRATXH.

	/**
	 * All Vertex array
	 * @instance
	 * @type {Array.<Vertex>}
	 */
	this.totalVertexArraySC = [];
};

/**
 * delete all vertex.
 */
VertexMatrix.prototype.deleteObjects = function() 
{
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		this.vertexListsArray[i].deleteObjects();
		this.vertexListsArray[i] = undefined;
	}
	this.vertexListsArray = undefined;
};

/**
 * add vertex list and return.
 * @returns {VertexList}}
 */
VertexMatrix.prototype.newVertexList = function() 
{
	var vertexList = new VertexList();
	this.vertexListsArray.push(vertexList);
	return vertexList;
};

/**
 * get vertex list
 * @param {Number }idx
 * @returns {VertextList|undefined} if invalid idx, return undefined
 */
VertexMatrix.prototype.getVertexList = function(idx) 
{
	if (idx >= 0 && idx < this.vertexListsArray.length) 
	{
		return this.vertexListsArray[idx];
	}
	else 
	{
		return undefined;
	}
};

/**
 * copy from another vertex matrix.
 * @param {VertexMatrix} vertexMatrix Required.
 */
VertexMatrix.prototype.copyFrom = function(vertexMatrix) 
{
	if (vertexMatrix === undefined)
	{ return; }
	
	var vertexList, myVertexList;
	var vertexListsCount = vertexMatrix.vertexListsArray.length;
	for (var i=0; i<vertexListsCount; i++)
	{
		vertexList = vertexMatrix.getVertexList(i);
		myVertexList = this.newVertexList();
		myVertexList.copyFrom(vertexList);
	}
};

/**
 * get bounding box this matrix.
 * init totalVertexArraySC and get bounding box
 * @param {BoundingBox} resultBox if this is undefined, set new BoundingBox instance.
 * @returns {BoundingBox}
 */
VertexMatrix.prototype.getBoundingBox = function(resultBox) 
{
	if (resultBox === undefined) { resultBox = new BoundingBox(); }
	
	this.totalVertexArraySC.length = 0;
	this.totalVertexArraySC = this.getTotalVertexArray(this.totalVertexArraySC);
	for (var i = 0, totalVertexCount = this.totalVertexArraySC.length; i < totalVertexCount; i++) 
	{
		if (i === 0) { resultBox.init(this.totalVertexArraySC[i].point3d); }
		else { resultBox.addPoint(this.totalVertexArraySC[i].point3d); }
	}
	return resultBox;
};

/**
 * set vertex index number in list
 * mIdxInList is maybe wrong. 
 * 
 * @see Atmosphere
 */
VertexMatrix.prototype.setVertexIdxInList = function() 
{
	var idxInList = 0;
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		var vtxList = this.vertexListsArray[i];
		for (var j = 0, vertexCount = vtxList.vertexArray.length; j < vertexCount; j++) 
		{
			var vertex = vtxList.getVertex(j);
			vertex.mIdxInList = idxInList;
			idxInList++;
		}
	}
};

/**
 * get total vertex count
 * @returns {number}}
 */
VertexMatrix.prototype.getVertexCount = function() 
{
	var vertexCount = 0;
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		vertexCount += this.vertexListsArray[i].getVertexCount();
	}
	
	return vertexCount;
};

/**
 * get total vertex array.
 * @param {Array} resultTotalVertexArray 변수
 * @returns {Array.<Vertex>}
 */
VertexMatrix.prototype.getTotalVertexArray = function(resultTotalVertexArray) 
{
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		var vtxList = this.vertexListsArray[i];
		for (var j = 0, vertexCount = vtxList.vertexArray.length; j < vertexCount; j++) 
		{
			var vertex = vtxList.getVertex(j);
			resultTotalVertexArray.push(vertex);
		}
	}
	
	return resultTotalVertexArray;
};

/**
 * get vertex color float array.
 * @param {Float32Array} resultFloatArray if this is undefined, set new Float32Array instance. length = this.totalVertexArraySC.length*6
 * @returns {Float32Array}
 */
VertexMatrix.prototype.getVBOVertexColorFloatArray = function(resultFloatArray) 
{
	this.totalVertexArraySC.length = 0;
	this.totalVertexArraySC = this.getTotalVertexArray(this.totalVertexArraySC);
	
	var totalVertexCount = this.totalVertexArraySC.length;
	if (resultFloatArray === undefined) { resultFloatArray = new Float32Array(totalVertexCount * 6); }
	
	for (var i = 0; i < totalVertexCount; i++) 
	{
		var vertex = this.totalVertexArraySC[i];
		resultFloatArray[i*6] = vertex.point3d.x;
		resultFloatArray[i*6+1] = vertex.point3d.y;
		resultFloatArray[i*6+2] = vertex.point3d.z;
		
		resultFloatArray[i*6+3] = vertex.color4.r;
		resultFloatArray[i*6+4] = vertex.color4.g;
		resultFloatArray[i*6+5] = vertex.color4.b;
	}
	
	return resultFloatArray;
};

/**
 * get vertex color with alpha float array.
 * @param {Float32Array} resultFloatArray if this is undefined, set new Float32Array instance. length = this.totalVertexArraySC.length*7
 * @returns {Float32Array}
 */
VertexMatrix.prototype.getVBOVertexColorRGBAFloatArray = function(resultFloatArray) 
{
	this.totalVertexArraySC.length = 0;
	this.totalVertexArraySC = this.getTotalVertexArray(this.totalVertexArraySC);
	
	var totalVertexCount = this.totalVertexArraySC.length;
	if (resultFloatArray === undefined) { resultFloatArray = new Float32Array(totalVertexCount * 7); }
	
	for (var i = 0; i < totalVertexCount; i++) 
	{
		var vertex = this.totalVertexArraySC[i];
		resultFloatArray[i*7] = vertex.point3d.x;
		resultFloatArray[i*7+1] = vertex.point3d.y;
		resultFloatArray[i*7+2] = vertex.point3d.z;
		
		resultFloatArray[i*7+3] = vertex.color4.r;
		resultFloatArray[i*7+4] = vertex.color4.g;
		resultFloatArray[i*7+5] = vertex.color4.b;
		resultFloatArray[i*7+6] = vertex.color4.a;
	}
	
	return resultFloatArray;
};

/**
 * get vertex basic float array.
 * @param {Float32Array} resultFloatArray if this is undefined, set new Float32Array instance. length = this.totalVertexArraySC.length*3
 * @returns {Float32Array}
 */
VertexMatrix.prototype.getVBOVertexFloatArray = function(resultFloatArray) 
{
	this.totalVertexArraySC.length = 0;
	this.totalVertexArraySC = this.getTotalVertexArray(this.totalVertexArraySC);
	
	var totalVertexCount = this.totalVertexArraySC.length;
	if (resultFloatArray === undefined) { resultFloatArray = new Float32Array(totalVertexCount * 3); }
	
	for (var i = 0; i < totalVertexCount; i++) 
	{
		var vertex = this.totalVertexArraySC[i];
		resultFloatArray[i*3] = vertex.point3d.x;
		resultFloatArray[i*3+1] = vertex.point3d.y;
		resultFloatArray[i*3+2] = vertex.point3d.z;
	}
	
	return resultFloatArray;
};

/**
 * translate vertex in vertex matrix
 * @param {Number} dx
 * @param {Number} dy
 * @param {Number} dz
 */
VertexMatrix.prototype.translateVertices = function(dx, dy, dz) 
{
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		this.vertexListsArray[i].translateVertices(dx, dy, dz);
	}
};

/**
 * set TTrianglesMatrix using vertexMatrix.
 * OLD function. Used for shadow blending cube. OLD.
 * TTriangles provisional is in geometryUtils.	
 * condition: all the vertex lists must have the same number of vertex.
 * @param {TTrianglesMatrix} tTrianglesMatrix
 */
VertexMatrix.prototype.makeTTrianglesLateralSidesLOOP = function(tTrianglesMatrix) 
{
	// 
	var vtxList1;
	var vtxList2;
	var tTrianglesList;
	var tTriangle1;
	var tTriangle2;
	var vertexCount = 0;
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount-1; i++) 
	{
		vtxList1 = this.vertexListsArray[i];
		vtxList2 = this.vertexListsArray[i+1];
		tTrianglesList = tTrianglesMatrix.newTTrianglesList();
		
		vertexCount = vtxList1.vertexArray.length;
		for (var j = 0; j < vertexCount; j++) 
		{
			tTriangle1 = tTrianglesList.newTTriangle();
			tTriangle2 = tTrianglesList.newTTriangle();
			
			if (j === vertexCount-1) 
			{
				tTriangle1.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j), vtxList2.getVertex(0)); 
				tTriangle2.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(0), vtxList1.getVertex(0)); 
			}
			else 
			{
				tTriangle1.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j), vtxList2.getVertex(j+1)); 
				tTriangle2.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j+1), vtxList1.getVertex(j+1)); 
			}
		}
	}
};

/**
 * get vertex matrix. using data array.
 * @deprecated
 * @static
 * @param {Array.<Number>} positions3Array Required.
 * @param {Array.<Number>} normals3Array
 * @param {Array.<Number>} texCoords2Array
 * @param {Array.<Number>} colors4Array
 * @param {Number} numCols
 * @param {Number} numRows
 * @param {VertexMatrix} resultVertexMatrix if undefined, set new VertexMatrix instance.
 * @returns {VertexMatrix} 
 */
VertexMatrix.makeMatrixByDataArray = function(positions3Array, normals3Array, texCoords2Array, colors4Array, numCols, numRows, resultVertexMatrix) 
{
	if (positions3Array === undefined)
	{ return; }
	
	if (resultVertexMatrix === undefined)
	{ resultVertexMatrix = new VertexMatrix(); }
	
	var vertexList;
	var vertex;
	var px, py, pz;
	var nx, ny, nz;
	var tx, ty;
	var r, g, b, a;
	for (var r=0; r<numRows; r++)
	{
		vertexList = resultVertexMatrix.newVertexList();
		for (var c=0; c<numCols; c++)
		{
			vertex = vertexList.newVertex();
			px = positions3Array[c*3];
			py = positions3Array[c*3+1];
			pz = positions3Array[c*3+2];
			
			vertex.setPosition(px, py, pz);
			
			if (normals3Array)
			{
				nx = normals3Array[c*3];
				ny = normals3Array[c*3+1];
				nz = normals3Array[c*3+2];
				vertex.setNormal(nx, ny, nz);
			}
			
			if (texCoords2Array)
			{
				tx = texCoords2Array[c*2];
				ty = texCoords2Array[c*2+1];
				vertex.setTexCoord(tx, ty);
			}
			
			if (colors4Array)
			{
				r = colors4Array[c*4];
				g = colors4Array[c*4+1];
				b = colors4Array[c*4+2];
				a = colors4Array[c*4+3];
				vertex.setColorRGBA(r, g, b, a);
			}
		}
	}
	
	return resultVertexMatrix;
};

/**
 * make face array between two vertex lists.
 * condition: all the vertex lists must have the same number of vertex.
 *	 3   3-------------2  +   +-------------+  +   +-------------+  +   +-------------+
 *	 | \   \           |  | \   \           |  | \   \           |  | \   \           |
 *	 |   \   \  face_B |  |   \   \  face_B |  |   \   \  face_B |  |   \   \  face_B |
 *	 |     \   \       |  |     \   \       |  |     \   \       |  |     \   \       |
 *	 |       \   \     |  |       \   \     |  |       \   \     |  |       \   \     |
 *	 | face_A  \   \   |  | face_A  \   \   |  | face_A  \   \   |  | face_A  \   \   |
 *	 |           \   \ |  |           \   \ |  |           \   \ |  |           \   \ |
 *	 0-------------1   1  +-------------+   +  +-------------+   +  +-------------+   +
 *	
 *	 +   +-------------+  +   +-------------+  +   +-------------+  +   +-------------+
 *	 | \   \           |  | \   \           |  | \   \           |  | \   \           |
 *	 |   \   \  face_B |  |   \   \  face_B |  |   \   \  face_B |  |   \   \  face_B |
 *	 |     \   \       |  |     \   \       |  |     \   \       |  |     \   \       |
 *	 |       \   \     |  |       \   \     |  |       \   \     |  |       \   \     |
 *	 | face_A  \   \   |  | face_A  \   \   |  | face_A  \   \   |  | face_A  \   \   |
 *	 |           \   \ |  |           \   \ |  |           \   \ |  |           \   \ |
 *	 +-------------+   +  +-------------+   +  +-------------+   +  +-------------+   +
 * @static
 * @param {VertexList} vertexListDown Required.
 * @param {VertexList} vertexListUp
 * @param {Array.<Face>} resultFacesArray
 * @param {Boolean} bLoop
 * @param {Boolean} bClockWise
 * @returns {VertexMatrix} 
 */
VertexMatrix.makeFacesBetweenVertexLists = function(vertexListDown, vertexListUp, resultFacesArray, bLoop, bClockWise) 
{
	if (resultFacesArray === undefined)
	{ resultFacesArray = []; }
	
	var face_A, face_B;
	var hedge_A, hedge_B;
	var faceLast_B;
	var vertexCount = vertexListDown.vertexArray.length;
	var vertex_0, vertex_1, vertex_2, vertex_3;
	if (bClockWise === undefined)
	{ bClockWise = false; }
	
	var resultHalfEdgesArray_A = [];
	var resultHalfEdgesArray_B = [];
	var vtx0_idx, vtx1_idx, vtx2_idx, vtx3_idx;
	
	if (bClockWise)
	{
		for (var j = 0; j < vertexCount; j++) 
		{
			resultHalfEdgesArray_A.length = 0;
			resultHalfEdgesArray_B.length = 0;
			if (j < vertexCount-1) 
			{
				vertex_0 = vertexListDown.getVertex(j);
				vertex_1 = vertexListDown.getVertex(j+1);
				vertex_2 = vertexListUp.getVertex(j+1);
				vertex_3 = vertexListUp.getVertex(j);
				
				face_A = new Face();
				face_B = new Face();
				
				face_A.addVerticesArray([vertex_0, vertex_3, vertex_1]);
				//resultHalfEdgesArray_A = face_A.createHalfEdges(resultHalfEdgesArray_A);
				//hedge_A = resultHalfEdgesArray_A[1]; // Diagonal hedge of face_A.
				
				face_B.addVerticesArray([vertex_1, vertex_3, vertex_2]);
				//resultHalfEdgesArray_B = face_B.createHalfEdges(resultHalfEdgesArray_B);
				//hedge_B = resultHalfEdgesArray_B[2]; // Diagonal hedge of face_B.
				
				// Now, set twins between face_A & face_B.
				//hedge_A.setTwin(hedge_B);
				resultFacesArray.push(face_A);
				resultFacesArray.push(face_B);
			}
			else 
			{
				if (bLoop !== undefined && bLoop === true)
				{
					vertex_0 = vertexListDown.getVertex(j);
					vertex_1 = vertexListDown.getVertex(0);
					vertex_2 = vertexListUp.getVertex(0);
					vertex_3 = vertexListUp.getVertex(j);
					
					face_A = new Face();
					face_B = new Face();
					
					face_A.addVerticesArray([vertex_0, vertex_3, vertex_1]);
					//resultHalfEdgesArray_A = face_A.createHalfEdges(resultHalfEdgesArray_A);
					//hedge_A = resultHalfEdgesArray_A[1]; // Diagonal hedge of face_A.
					
					face_B.addVerticesArray([vertex_1, vertex_3, vertex_2]);
					//resultHalfEdgesArray_B = face_B.createHalfEdges(resultHalfEdgesArray_B);
					//hedge_B = resultHalfEdgesArray_B[2]; // Diagonal hedge of face_B.
					
					// Now, set twins between face_A & face_B.
					//hedge_A.setTwin(hedge_B);
					resultFacesArray.push(face_A);
					resultFacesArray.push(face_B);
				}
			}
			
			if (faceLast_B === undefined)
			{ faceLast_B = face_B; }
			else 
			{
				//face_A.setTwinFace(faceLast_B);
				faceLast_B = face_B;
			}
			
			
		}
	}
	else
	{
		for (var j = 0; j < vertexCount; j++) 
		{
			resultHalfEdgesArray_A.length = 0;
			resultHalfEdgesArray_B.length = 0;

			if (j < vertexCount - 1) 
			{
				vertex_0 = vertexListDown.getVertex(j);
				vertex_1 = vertexListDown.getVertex(j+1);
				vertex_2 = vertexListUp.getVertex(j+1);
				vertex_3 = vertexListUp.getVertex(j);
				
				face_A = new Face();
				face_B = new Face();
				
				face_A.addVerticesArray([vertex_0, vertex_1, vertex_3]);
				//resultHalfEdgesArray_A = face_A.createHalfEdges(resultHalfEdgesArray_A);
				//hedge_A = resultHalfEdgesArray_A[1]; // Diagonal hedge of face_A.
				
				face_B.addVerticesArray([vertex_1, vertex_2, vertex_3]);
				//resultHalfEdgesArray_B = face_B.createHalfEdges(resultHalfEdgesArray_B);
				//hedge_B = resultHalfEdgesArray_B[2]; // Diagonal hedge of face_B.
				
				// Now, set twins between face_A & face_B.
				//hedge_A.setTwin(hedge_B);
				
				resultFacesArray.push(face_A);
				resultFacesArray.push(face_B);
			}
			else 
			{
				if (bLoop !== undefined && bLoop === true)
				{
					vertex_0 = vertexListDown.getVertex(j);
					vertex_1 = vertexListDown.getVertex(0);
					vertex_2 = vertexListUp.getVertex(0);
					vertex_3 = vertexListUp.getVertex(j);
					
					face_A = new Face();
					face_B = new Face();
					
					face_A.addVerticesArray([vertex_0, vertex_1, vertex_3]);
					//resultHalfEdgesArray_A = face_A.createHalfEdges(resultHalfEdgesArray_A);
					//hedge_A = resultHalfEdgesArray_A[1]; // Diagonal hedge of face_A.
					
					face_B.addVerticesArray([vertex_1, vertex_2, vertex_3]);
					//resultHalfEdgesArray_B = face_B.createHalfEdges(resultHalfEdgesArray_B);
					//hedge_B = resultHalfEdgesArray_B[2]; // Diagonal hedge of face_B.
					
					// Now, set twins between face_A & face_B.
					//hedge_A.setTwin(hedge_B);
					
					resultFacesArray.push(face_A);
					resultFacesArray.push(face_B);
				}
				
			}
			
			if (faceLast_B === undefined)
			{ faceLast_B = face_B; }
			else 
			{
				//face_A.setTwinFace(faceLast_B);
				faceLast_B = face_B;
			}
			
			
		}
	}
	
	return resultFacesArray;
};

/**
* make Surface
* condition: all the vertex lists must have the same number of vertex.
* @deprecated
* @static
* @param {VertexMatrix} vertexMatrix
* @param {Surface} resultSurface  if undefined, set new Surface instance.
* @param {Boolean} bLoop
* @param {Boolean} bClockWise
* @returns {Surface} 
*/
VertexMatrix.makeSurface = function(vertexMatrix, resultSurface, bLoop, bClockWise) 
{
	if (resultSurface === undefined)
	{ resultSurface = new Surface(); }
	
	var vtxList1;
	var vtxList2;
	var vertexListDown, vertexListUp;
	var resultFacesArray = [];
	var resultFacesArrayLast;
	var vertexCount = 0;
	var vertexListsCount = vertexMatrix.vertexListsArray.length;
	for (var i = 0; i <vertexListsCount-1; i++) 
	{
		vertexListDown = vertexMatrix.vertexListsArray[i];
		vertexListUp = vertexMatrix.vertexListsArray[i+1];
		resultFacesArray = VertexMatrix.makeFacesBetweenVertexLists(vertexListDown, vertexListUp, resultFacesArray, bLoop, bClockWise);
		/*
		if(resultFacesArrayLast === undefined)
			resultFacesArrayLast = resultFacesArray;
		else{
			Surface.setTwinsFacesBetweenFacesArrays_regularQuadGrid(resultFacesArray, resultFacesArrayLast);
			resultFacesArrayLast = resultFacesArray;
		}
		*/
		
		resultSurface.addFacesArray(resultFacesArray);
		
		resultFacesArray.length = 0;
	}
	
	return resultSurface;
};

/**
 * set TTrianglesMatrix using vertexMatrix.
 * OLD function. Used for shadow blending cube. OLD.
 * TTriangles provisional is in geometryUtils.	
 * condition: all the vertex lists must have the same number of vertex.
 * @deprecated
 * @param {TTrianglesMatrix} trianglesMatrix
 * @param {Boolean} bLoop if true, include last vertex triangle
 */
VertexMatrix.prototype.makeTrianglesLateralSides = function(trianglesMatrix, bLoop) 
{
	var vtxList1;
	var vtxList2;
	var trianglesList;
	var triangle1;
	var triangle2;
	var vertexCount = 0;
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount-1; i++) 
	{
		vtxList1 = this.vertexListsArray[i];
		vtxList2 = this.vertexListsArray[i+1];
		trianglesList = trianglesMatrix.newTrianglesList();
		
		vertexCount = vtxList1.vertexArray.length;
		for (var j = 0; j < vertexCount; j++) 
		{
			if (j === vertexCount-1) 
			{
				if (bLoop !== undefined && bLoop === true)
				{
					triangle1 = trianglesList.newTriangle();
					triangle2 = trianglesList.newTriangle();
					triangle1.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j), vtxList2.getVertex(0)); 
					triangle2.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(0), vtxList1.getVertex(0)); 
				}
			}
			else 
			{
				triangle1 = trianglesList.newTriangle();
				triangle2 = trianglesList.newTriangle();
				triangle1.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j), vtxList2.getVertex(j+1)); 
				triangle2.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j+1), vtxList1.getVertex(j+1)); 
			}
		}
	}
};

/**
* get index of array
* return col + row * numCols;
* @static
* @param {Number} numCols
* @param {Number} numRows not used.
* @param {Number} col
* @param {Number} row
* @returns {Number} 
*/
VertexMatrix.getIndexOfArray = function(numCols, numRows, col, row) 
{
	// static function.
	var idx = col + row * numCols;
	return idx;
};

/**
 * vertex point transform by matrix4
 * @param {Matrix4} transformMatrix
 * @see Matrix4#transformPoint3D
 */
VertexMatrix.prototype.transformPointsByMatrix4 = function(transformMatrix) 
{
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		var vtxList = this.vertexListsArray[i];
		vtxList.transformPointsByMatrix4(transformMatrix);
	}
};


'use strict';
/**
 * vertex profile. consist of outer Vertex ring and inner Vertex ring list.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class VtxProfile
 * 
 * @see VtxRing
 */
var VtxProfile = function() 
{
	if (!(this instanceof VtxProfile)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * outer VtxRing
	 * @type {VtxRing}
	 */
	this.outerVtxRing;

	/**
	 * inner VtxRingList
	 * @type {VtxRingList}
	 */
	this.innerVtxRingsList;
};

/**
 * delete all vertex.
 */
VtxProfile.prototype.deleteObjects = function()
{
	if (this.outerVtxRing !== undefined)
	{
		this.outerVtxRing.deleteObjects();
		this.outerVtxRing = undefined;
	}
	
	if (this.innerVtxRingsList !== undefined)
	{
		this.innerVtxRingsList.deleteObjects();
		this.innerVtxRingsList = undefined;
	}
};

/**
 * get inner vertex ring's count
 * @returns {Number} 
 */
VtxProfile.prototype.getInnerVtxRingsCount = function()
{
	if (this.innerVtxRingsList === undefined || this.innerVtxRingsList.getRingsCount === 0)
	{ return 0; }
	
	return this.innerVtxRingsList.getVtxRingsCount();
};

/**
 * get inner vertex ring
 * @param {Number} idx
 * @returns {VtxRing} 
 */
VtxProfile.prototype.getInnerVtxRing = function(idx)
{
	if (this.innerVtxRingsList === undefined || this.innerVtxRingsList.getRingsCount === 0)
	{ return undefined; }
	
	return this.innerVtxRingsList.getVtxRing(idx);
};

/**
 * set vertex index in list
 * 
 * @see VertexList#setIdxInList
 * @see VtxRingList#setVerticesIdxInList maybe error.
 */
VtxProfile.prototype.setVerticesIdxInList = function()
{
	if (this.outerVtxRing && this.outerVtxRing.vertexList)
	{
		this.outerVtxRing.vertexList.setIdxInList();
	}
	
	if (this.innerVtxRingsList)
	{
		this.innerVtxRingsList.setVerticesIdxInList();
	}
};

/**
 * vertex profile copy from another vertex profile.
 * @param {VtxProfile} vtxProfile
 */
VtxProfile.prototype.copyFrom = function(vtxProfile)
{
	if (vtxProfile.outerVtxRing)
	{
		if (this.outerVtxRing === undefined)
		{ this.outerVtxRing = new VtxRing(); }
		
		this.outerVtxRing.copyFrom(vtxProfile.outerVtxRing);
	}
	
	if (vtxProfile.innerVtxRingsList)
	{
		if (this.innerVtxRingsList === undefined)
		{ this.innerVtxRingsList = new VtxRingsList(); }
		
		this.innerVtxRingsList.copyFrom(vtxProfile.innerVtxRingsList);
	}
};

/**
 * vertex point translate.
 * @param {Number} dx
 * @param {Number} dy
 * @param {Number} dz
 * @see Point3D#add
 */
VtxProfile.prototype.translate = function(dx, dy, dz)
{
	if (this.outerVtxRing !== undefined)
	{ this.outerVtxRing.translate(dx, dy, dz); }
	
	if (this.innerVtxRingsList !== undefined)
	{ this.innerVtxRingsList.translate(dx, dy, dz); }
};

/**
 * vertex point transform by matrix4
 * @param {Matrix4} tMat4
 * @see Matrix4#transformPoint3D
 */
VtxProfile.prototype.transformPointsByMatrix4 = function(tMat4)
{
	if (this.outerVtxRing !== undefined)
	{ this.outerVtxRing.transformPointsByMatrix4(tMat4); }
	
	if (this.innerVtxRingsList !== undefined)
	{ this.innerVtxRingsList.transformPointsByMatrix4(tMat4); }
};

/**
 * get projected 2d profile.
 * Note: this makes a projected profile2d ONLY conformed by polyLines2D.
 * This function is used when necessary to tessellate this vtxProfile.
 * @param {Profile2D|undefined} resultProfile2d if undefined, set new Profile2D instance.
 * @returns {Profile2D} when this.outerVtxRing is undefined or normal is undefined. return original resultProfile2d.
 * 
 * @see VtxRing#calculatePlaneNormal
 * @see VtxRing#getProjectedPolyLineBasedRing2D
 */
VtxProfile.prototype.getProjectedProfile2D = function(resultProfile2d)
{
	if (this.outerVtxRing === undefined)
	{ return resultProfile2d; }
	
	// 1rst, calculate the normal of this vtxProfile. Use the this.outerVtxRing.
	// The normal is used co calculate the bestFace to project.
	var normal = this.outerVtxRing.calculatePlaneNormal(undefined);

	if (normal === undefined)
	{ return resultProfile2d; }
	
	if (resultProfile2d === undefined)
	{ resultProfile2d = new Profile2D(); }
	
	// OuterVtxRing.
	resultProfile2d.outerRing = this.outerVtxRing.getProjectedPolyLineBasedRing2D(resultProfile2d.outerRing, normal);
	
	// InnerVtxRings.
	if (this.innerVtxRingsList !== undefined)
	{
		var innerVtxRingsCount = this.innerVtxRingsList.getVtxRingsCount();
		var innerRingsList;
		if (innerVtxRingsCount > 0)
		{
			innerRingsList = resultProfile2d.getInnerRingsList();
		}
		
		for (var i=0; i<innerVtxRingsCount; i++)
		{
			var innerVtxRing = this.innerVtxRingsList.getVtxRing(i);
			var innerRing = innerVtxRing.getProjectedPolyLineBasedRing2D(undefined, normal);
			innerRingsList.addRing(innerRing);
		}
	}
	
	return resultProfile2d;
};

/**
 * use point3d array, set outerVtxRing's vertex list and indexrange.
 * @param {Array.<Point3D>} outerPoints3dArray Required.
 * @param {Array.<Array.<Point3D>>} innerPoints3dArrayArray deprecated.
 * 
 * @see VtxRing#makeByPoints3DArray
 */
VtxProfile.prototype.makeByPoints3DArray = function(outerPoints3dArray, innerPoints3dArrayArray)
{
	if (outerPoints3dArray === undefined)
	{ return; }
	
	// outer.
	if (this.outerVtxRing === undefined)
	{ this.outerVtxRing = new VtxRing(); }

	this.outerVtxRing.makeByPoints3DArray(outerPoints3dArray);
	
	// inners.
	// todo:
};

/**
 * use point3d array, update outerVtxRing's vertex list.
 * @param {Array.<Point3D>} point3dArray Required.
 * @param {Array.<Array.<Point3D>>} innerPoints3dArrayArray deprecated.
 * 
 * @see VtxRing#makeByPoints3DArray
 */
VtxProfile.prototype.updateByPoints3DArray = function(outerPoints3dArray, innerPoints3dArrayArray)
{
	if (outerPoints3dArray === undefined)
	{ return; }
	
	// outer.
	if (this.outerVtxRing === undefined)
	{ return; }

	this.outerVtxRing.updateByPoints3DArray(outerPoints3dArray);
	
	// inners.
	// todo:
};

/**
 * use Profile2D, make VtxProfile's outer vertex ring and inner vertex ring list. 
 * z is always 0.
 * @param {Profile2D} profile2d Required.
 * 
 * @see VtxRing#makeByPoint2DList
 */
VtxProfile.prototype.makeByProfile2D = function(profile2d)
{
	if (profile2d === undefined || profile2d.outerRing === undefined)
	{ return undefined; }
	
	var outerRing = profile2d.outerRing;
	if (outerRing.polygon === undefined)
	{ outerRing.makePolygon(); }
	
	// outer.
	if (this.outerVtxRing === undefined)
	{ this.outerVtxRing = new VtxRing(); }
	
	var z = 0;
	var outerPolygon = outerRing.polygon;
	var point2dList = outerPolygon.point2dList;
	this.outerVtxRing.makeByPoint2DList(point2dList, z);

	// inners.
	if (profile2d.innerRingsList === undefined)
	{ return; } 
	
	var innerRingsList = profile2d.innerRingsList;
	var innerRingsCount = innerRingsList.getRingsCount();
	
	if (innerRingsCount === 0)
	{ return; }
	
	if (this.innerVtxRingsList === undefined)
	{ this.innerVtxRingsList = new VtxRingsList(); }
	
	var innerRing;
	var innerPolygon;
	var innerVtxRing;
	
	for (var i=0; i<innerRingsCount; i++)
	{
		innerRing = innerRingsList.getRing(i);
		if (innerRing.polygon === undefined)
		{ innerRing.makePolygon(); }
		innerPolygon = innerRing.polygon;
		point2dList = innerPolygon.point2dList;
		
		innerVtxRing = this.innerVtxRingsList.newVtxRing();
		innerVtxRing.makeByPoint2DList(point2dList, z);
	}
};

/**
 * get all vertex in outer vertex ring and inner vertex ring list. 
 * @param {Array} resultVerticesArray
 * @returns {Array.<Vertex>|undefined}
 */
VtxProfile.prototype.getAllVertices = function(resultVerticesArray)
{
	if (this.outerVtxRing !== undefined)
	{ this.outerVtxRing.getAllVertices(resultVerticesArray); }
	
	if (this.innerVtxRingsList !== undefined)
	{ this.innerVtxRingsList.getAllVertices(resultVerticesArray); }
	
	return resultVerticesArray;
};

/**
 * get vertex intersected with plane. 
 * @static
 * @param {VtxProfile} vtxProfile if vtxProfile.outerVtxRing undefined, return resultvtxProfile.
 * @param {Plane} plane. 
 * @param {Point3D} projectionDirection projectionDirection must be unitary.
 * @param {VtxProfile} resultvtxProfile Optional. if undefined, set new VtxProfile instance.
 * @returns {VtxProfile} resultvtxProfile
 */
VtxProfile.getProjectedOntoPlane = function(vtxProfile, plane, projectionDirection, resultvtxProfile)
{
	if (vtxProfile.outerVtxRing === undefined)
	{ return resultvtxProfile; }
	
	if (resultvtxProfile === undefined)
	{ resultvtxProfile = new VtxProfile(); }
	
	// OuterVtxRing.
	resultvtxProfile.outerVtxRing = VtxRing.getProjectedOntoPlane(vtxProfile.outerVtxRing, plane, projectionDirection, resultvtxProfile.outerVtxRing);
				
	// InnerVtxRings.
	if (vtxProfile.innerVtxRingsList !== undefined)
	{
		resultvtxProfile.innerVtxRingsList = VtxRingsList.getProjectedOntoPlane(vtxProfile.innerVtxRingsList, plane, projectionDirection, resultvtxProfile.innerVtxRingsList);
	}
	
	return resultvtxProfile;
};




















































'use strict';
/**
* Vertex Profile List
* @exception {Error} Messages.CONSTRUCT_ERROR

* @class VtxProfilesList

* @param {number} x not used
* @param {number} y not used
*
* @see VtxProfile
*/
var VtxProfilesList = function(x, y) 
{
	if (!(this instanceof VtxProfilesList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * VtxProfile Array
	 * @type {Array.<VtxProfile>}
	 */
	this.vtxProfilesArray;

	
	/**
	 * convex index data array
	 * @type {Array.<Array.<IndexData>>}
	 */
	this.convexFacesIndicesData;
};


/**
 * delete vertex profile and convex array.
 */
VtxProfilesList.prototype.deleteObjects = function()
{
	if (this.vtxProfilesArray !== undefined)
	{
		var vtxProfilesCount = this.vtxProfilesArray.length;
		for (var i=0; i<vtxProfilesCount; i++)
		{
			this.vtxProfilesArray[i].deleteObjects();
			this.vtxProfilesArray[i] = undefined;
		}
		this.vtxProfilesArray = undefined;
	}
	
	if (this.convexFacesIndicesData !== undefined)
	{
		/*
		var idxDatasCount = this.convexFacesIndicesData.length;
		for(var i=0; i<idxDatasCount; i++)
		{
			for(var key in this.convexFacesIndicesData[i])
			{
				var value = this.convexFacesIndicesData[i][key];
				value.deleteObjects();
				value = undefined;
			}
			this.convexFacesIndicesData[i] = undefined;
		}
		*/
		this.convexFacesIndicesData = undefined;
	}
};

/**
 * 페이스 목록 생성 및 반환. 메쉬의 hedgelist 업데이트
 * 
 * @static
 * @param {VtxRing} bottomVtxRing
 * @param {VtxRing} topVtxRing
 * @param {Array.<Face>} resultFacesArray
 * @param {Mesh} resultMesh
 * @param {IndexRange} elemIndexRange
 * 
 * @see VtxProfilesList#getMesh
 * @see Mesh#getHalfEdgesList
 * @see Face#createHalfEdges
 * @see Face#setTwinFace
 * @see HalfEdgesList#addHalfEdgesArray
 */
VtxProfilesList.getLateralFaces = function(bottomVtxRing, topVtxRing, resultFacesArray, resultMesh, elemIndexRange)
{
	// This returns a lateral surface between "bottomVtxRing" & "topVtxRing" limited by "elemIndexRange".
	if (resultFacesArray === undefined)
	{ resultFacesArray = []; }
	
	var hedgesList = resultMesh.getHalfEdgesList();
	
	var strIdx, currIdx, endIdx, nextIdx;
	var vtx0, vtx1, vtx2, vtx3;
	var face, prevFace;
	var hedgesArray = [];
	currIdx = elemIndexRange.strIdx;
	while (currIdx !== elemIndexRange.endIdx)
	{
		nextIdx = bottomVtxRing.vertexList.getNextIdx(currIdx);
		
		face = new Face();
		resultFacesArray.push(face);
		face.vertexArray = [];
		
		vtx0 = bottomVtxRing.vertexList.getVertex(currIdx);
		vtx1 = bottomVtxRing.vertexList.getVertex(nextIdx);
		vtx2 = topVtxRing.vertexList.getVertex(nextIdx);
		vtx3 = topVtxRing.vertexList.getVertex(currIdx);
		Array.prototype.push.apply(face.vertexArray, [vtx0, vtx1, vtx2, vtx3]);
		
		// now create hedges of the face.
		hedgesArray.length = 0;
		hedgesArray = face.createHalfEdges(hedgesArray);
		hedgesList.addHalfEdgesArray(hedgesArray);
		
		if (prevFace !== undefined)
		{
			// set twins between face and prevFace.
			face.setTwinFace(prevFace);
		}
		prevFace = face;

		currIdx = nextIdx;
	}
	
	return resultFacesArray;
};

/**
 * VtxProfile 추가
 * @param {VtxProfile} vtxProfile
 */
VtxProfilesList.prototype.addVtxProfile = function(vtxProfile)
{
	if (this.vtxProfilesArray === undefined)
	{ this.vtxProfilesArray = []; }
	
	this.vtxProfilesArray.push(vtxProfile);
};

/**
 * VtxProfile 생성하여 vtxProfileArray에 추가 후 반환.
 * @returns {VtxProfile} vtxProfile
 */
VtxProfilesList.prototype.newVtxProfile = function()
{
	if (this.vtxProfilesArray === undefined)
	{ this.vtxProfilesArray = []; }
	
	var vtxProfile = new VtxProfile();
	this.vtxProfilesArray.push(vtxProfile);
	return vtxProfile;
};

/**
 * vtxProfileArray length 반환.
 * @returns {Number}
 */
VtxProfilesList.prototype.getVtxProfilesCount = function()
{
	if (this.vtxProfilesArray === undefined)
	{ return 0; }
	
	return this.vtxProfilesArray.length;
};

/**
 * 인덱스에 해당하는 vtxProfile 반환
 * @returns {VtxProfile}
 */
VtxProfilesList.prototype.getVtxProfile = function(idx)
{
	if (this.vtxProfilesArray === undefined)
	{ return undefined; }
	
	return this.vtxProfilesArray[idx];
};

/**
 * vtxProfileArray에 있는 모든 vertex를 배열에 담아 반환
 * @param {Array.<Vertex>|undefined} resultVerticesArray 비어있을 시 배열 초기화.
 * @returns {Array.<Vertex>}
 */
VtxProfilesList.prototype.getAllVertices = function(resultVerticesArray)
{
	// collect all vertices of all vtxProfiles.
	if (resultVerticesArray === undefined)
	{ resultVerticesArray = []; }
	
	var vtxProfile;
	var vtxProfilesCount = this.getVtxProfilesCount();
	for (var i=0; i<vtxProfilesCount; i++)
	{
		vtxProfile = this.getVtxProfile(i);
		resultVerticesArray = vtxProfile.getAllVertices(resultVerticesArray);
	}
	
	return resultVerticesArray;
};

/**
 * vtxProfileList로 부터 Mesh 생성 후 반환
 * @param {Mesh} resultMesh 비어있을 시 new Mesh 인스턴스 선언.
 * @param {Boolean} bIncludeBottomCap Mesh의 바닥 surface 추가 유무, true 일시 getTransversalSurface
 * @param {Boolean} bIncludeTopCap Mesh의 위쪽(뚜껑) surface 추가 유무, true 일시 getTransversalSurface
 * @param {Boolean} bLoop 기본값은 false. true로 선언 시, bIncludeBottomCap, bIncludeTopCap 는 false로 변경
 * @returns {Mesh}
 * 
 * @see VtxProfilesList#getTransversalSurface
 */
VtxProfilesList.prototype.getMesh = function(resultMesh, bIncludeBottomCap, bIncludeTopCap, bLoop)
{
	// face's vertex order.
	// 3-------2
	// |       |
	// |       |
	// |       |
	// 0-------1
	
	if (this.vtxProfilesArray === undefined)
	{ return resultTriangleMatrix; }

	if (bLoop === undefined)
	{ bLoop = false; }
	
	if (bLoop === true)
	{
		// To make a safe mesh, if loop, then there are no caps in the extrems.
		bIncludeBottomCap = false;
		bIncludeTopCap = false;
	}
	
	// outerLateral.
	var vtxProfilesCount = this.getVtxProfilesCount();
	
	if (vtxProfilesCount < 2)
	{ return resultTriangleMatrix; }
	
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }
	
	if (resultMesh.vertexList === undefined)
	{ resultMesh.vertexList = new VertexList(); }
	
	// 1rst, get all vertices and put it into the resultMesh.
	resultMesh.vertexList.vertexArray = this.getAllVertices(resultMesh.vertexList.vertexArray);
		
	var bottomVtxProfile, topVtxProfile;

	bottomVtxProfile = this.getVtxProfile(0);
	var outerVtxRing = bottomVtxProfile.outerVtxRing;
	var elemIndexRange;
	var bottomVtxRing, topVtxRing;
	var elemIndicesCount;
	var strIdx, currIdx, endIdx, nextIdx;
	var vtx0, vtx1, vtx2, vtx3;
	var face, surface;
	var k;
	var facesArray = [];
	var prevFacesArray;
	var elemsCount = outerVtxRing.elemsIndexRangesArray.length;
	
	for (var i=0; i<elemsCount; i++)
	{
		surface = resultMesh.newSurface();
		prevFacesArray = undefined;
		elemIndexRange = outerVtxRing.getElementIndexRange(i);
		for (var j=0; j<vtxProfilesCount; j++)
		{
			if (j === vtxProfilesCount-1 )
			{
				if (bLoop)
				{
					bottomVtxProfile = this.getVtxProfile(j);
					topVtxProfile = this.getVtxProfile(0);
				}
				else { break; }
			}
			else 
			{
				bottomVtxProfile = this.getVtxProfile(j);
				topVtxProfile = this.getVtxProfile(j+1);
			}
			
			bottomVtxRing = bottomVtxProfile.outerVtxRing;
			topVtxRing = topVtxProfile.outerVtxRing;
			
			facesArray.length = 0;
			facesArray = VtxProfilesList.getLateralFaces(bottomVtxRing, topVtxRing, facesArray, resultMesh, elemIndexRange);
			surface.addFacesArray(facesArray);
			
			if (prevFacesArray !== undefined && prevFacesArray.length > 0)
			{
				// set twins between "prevFacesArray" & "facesArray".
				var currFace, prevFace;
				var facesCount = facesArray.length;
				for (var k=0; k<facesCount; k++)
				{
					currFace = facesArray[k];
					prevFace = prevFacesArray[k];
					currFace.setTwinFace(prevFace);
				}
			}
			
			prevFacesArray = [];
			Array.prototype.push.apply(prevFacesArray, facesArray);
		}
	}
	
	// Inner laterals.
	var innerVtxRing;
	var innerRinsCount = bottomVtxProfile.getInnerVtxRingsCount();
	for (var k=0; k<innerRinsCount; k++)
	{
		innerVtxRing = bottomVtxProfile.getInnerVtxRing(k);
		elemsCount = innerVtxRing.elemsIndexRangesArray.length;
		for (var i=0; i<elemsCount; i++)
		{
			surface = resultMesh.newSurface();
			prevFacesArray = undefined;
			elemIndexRange = innerVtxRing.getElementIndexRange(i);
			for (var j=0; j<vtxProfilesCount; j++)
			{
				if (j === vtxProfilesCount-1 )
				{
					if (bLoop)
					{
						bottomVtxProfile = this.getVtxProfile(j);
						topVtxProfile = this.getVtxProfile(0);
					}
					else { break; }
				}
				else 
				{
					bottomVtxProfile = this.getVtxProfile(j);
					topVtxProfile = this.getVtxProfile(j+1);
				}

				bottomVtxRing = bottomVtxProfile.getInnerVtxRing(k);
				topVtxRing = topVtxProfile.getInnerVtxRing(k);
				
				facesArray.length = 0;
				facesArray = VtxProfilesList.getLateralFaces(bottomVtxRing, topVtxRing, facesArray, resultMesh, elemIndexRange);
				surface.addFacesArray(facesArray);
				
				if (prevFacesArray !== undefined && prevFacesArray.length>0)
				{
					// set twins between "prevFacesArray" & "facesArray".
					var currFace, prevFace;
					var facesCount = facesArray.length;
					for (var a=0; a<facesCount; a++)
					{
						currFace = facesArray[a];
						prevFace = prevFacesArray[a];
						currFace.setTwinFace(prevFace);
					}
				}
				
				prevFacesArray = [];
				Array.prototype.push.apply(prevFacesArray, facesArray);
				
			}
		}
	}
	
	// Caps (bottom and top).
	if (this.convexFacesIndicesData === undefined)
	{ 
		// Calculate the convexFacesIndicesData.
		var vtxProfileFirst = this.getVtxProfile(0);
		var profile2d = vtxProfileFirst.getProjectedProfile2D(profile2d);
		this.convexFacesIndicesData = profile2d.getConvexFacesIndicesData(this.convexFacesIndicesData);
	}
	
	var resultSurface;
	
	// Top profile.**
	// in this case, there are a surface with multiple convex faces.
	if (bIncludeTopCap === undefined || bIncludeTopCap === true)
	{
		topVtxProfile = this.getVtxProfile(vtxProfilesCount-1);
		resultSurface = resultMesh.newSurface();
		resultSurface = VtxProfilesList.getTransversalSurface(topVtxProfile, this.convexFacesIndicesData, resultSurface);
	}

	// Bottom profile.**
	if (bIncludeBottomCap === undefined || bIncludeBottomCap === true)
	{
		bottomVtxProfile = this.getVtxProfile(0);
		resultSurface = resultMesh.newSurface();
		resultSurface = VtxProfilesList.getTransversalSurface(bottomVtxProfile, this.convexFacesIndicesData, resultSurface);
		
		// in bottomSurface inverse sense of faces.
		resultSurface.reverseSense();
	}
	
	return resultMesh;
};

/**
 * 위쪽이나 아랫쪽 surface 생성.
 * @static
 * @param {VtxProfile} vtxProfile
 * @param {Array.<IndexData>} convexFacesIndicesData
 * @param {Surface} resultSurface 비어있을 시 Surface 인스턴스 선언.
 * @returns {Surface}
 */
VtxProfilesList.getTransversalSurface = function(vtxProfile, convexFacesIndicesData, resultSurface)
{
	if (resultSurface === undefined)
	{ resultSurface = new Surface(); }
	 
	var currRing;
	var currVtxRing;
	var faceIndicesData;
	var indexData;
	var ringIdx, vertexIdx;
	var indicesCount;
	var face;
	var vertex;
	var convexFacesCount = convexFacesIndicesData.length;
	for (var i=0; i<convexFacesCount; i++)
	{
		face = resultSurface.newFace();
		face.vertexArray = [];
			
		faceIndicesData = convexFacesIndicesData[i];
		indicesCount = faceIndicesData.length;
		for (var j=0; j<indicesCount; j++)
		{
			indexData = faceIndicesData[j];
			ringIdx = indexData.ownerIdx;
			vertexIdx = indexData.idxInList;
			
			if (ringIdx === -1)
			{
				// is the outerRing.
				currVtxRing = vtxProfile.outerVtxRing;
			}
			else 
			{
				currVtxRing = vtxProfile.innerVtxRingsList.getVtxRing(ringIdx);
			}
			
			vertex = currVtxRing.vertexList.getVertex(vertexIdx);
			face.vertexArray.push(vertex);
		}
	}
	
	return resultSurface;
};

/**
 * profile2d와 경로 point3d 리스트를 이용하여 vtxProfile 생성 후 vtxProfilesArray에 추가
 * @method VtxProfilesList.makeLoft
 * @param {Profile2D} profile2d
 * @param {Points3DList} pathPoints3dList
 * @param {Boolean} bLoop 기본값은 false.
 * 
 * @see Point3DList#getBisectionPlane
 * @see Point3DList#getSegment3D
 */
VtxProfilesList.prototype.makeLoft = function(profile2d, pathPoints3dList, bLoop)
{
	// 1rst, make the base vtxProfile.
	// if want caps in the extruded mesh, must calculate "ConvexFacesIndicesData" of the profile2d before creating vtxProfiles.
	this.convexFacesIndicesData = profile2d.getConvexFacesIndicesData(undefined);
	
	// create vtxProfiles.
	// make the base-vtxProfile.
	var baseVtxProfile = new VtxProfile();
	baseVtxProfile.makeByProfile2D(profile2d);
	
	// Now, transform the baseVtxProfile to coplanar into the 1rstPlane.
	if (bLoop === undefined) { bLoop = false; } // Is important to set "bLoop" = false to obtain a perpendicular plane respect to the segment.
	var bisectionPlane1rst = pathPoints3dList.getBisectionPlane(0, undefined, bLoop);
	var point3d1rst = pathPoints3dList.getPoint(0);
	var tMatrix = bisectionPlane1rst.getRotationMatrix(undefined);
	tMatrix.setTranslation(point3d1rst.x, point3d1rst.y, point3d1rst.z);
	
	// Now rotate&translate vtxProfile onto the bisectionPlane1rst.
	baseVtxProfile.transformPointsByMatrix4(tMatrix);
	
	// Now, project the vtxProfile onto the bisectionPlanes of each vertex.
	var pathPoint3d;
	var bisectionPlane;
	var segment3d;
	var projectionDirection;
	var pathPointsCount = pathPoints3dList.getPointsCount();
	for (var i=0; i<pathPointsCount; i++)
	{
		pathPoint3d = pathPoints3dList.getPoint(i);
		bisectionPlane = pathPoints3dList.getBisectionPlane(i, undefined, bLoop);
		if (i === 0)
		{
			segment3d = pathPoints3dList.getSegment3D(i, undefined, bLoop);
		}
		else
		{ segment3d = pathPoints3dList.getSegment3D(i-1, undefined, bLoop); }
		
		projectionDirection = segment3d.getDirection(undefined);
		
		var projectedVtxProfile = VtxProfile.getProjectedOntoPlane(baseVtxProfile, bisectionPlane, projectionDirection, undefined);
		this.addVtxProfile(projectedVtxProfile);
		// finally update the baseVtxProfile.
		baseVtxProfile = projectedVtxProfile;
	}
};

























































'use strict';

/**
 * vertex ring.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class VtxRing
 * 
 */
var VtxRing = function() 
{
	if (!(this instanceof VtxRing)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * vertex list
	 * @type {VertexList}
	 */
	this.vertexList;

	/**
	 * indexRange array
	 * @type {Array.<IndexRange>}
	 */
	this.elemsIndexRangesArray;
};

/**
 * delete all vertex and element index ranges.
 */
VtxRing.prototype.deleteObjects = function()
{
	if (this.vertexList !== undefined)
	{
		this.vertexList.deleteObjects();
		this.vertexList = undefined;
	}
	
	if (this.elemsIndexRangesArray !== undefined)
	{
		this.deleteElementIndexRanges();
	}
};

/**
 * delete all element index ranges.
 */
VtxRing.prototype.deleteElementIndexRanges = function()
{
	if (this.elemsIndexRangesArray === undefined)
	{ return; }
	
	var indexRangesCount = this.elemsIndexRangesArray.length;
	for (var i=0; i<indexRangesCount; i++)
	{
		this.elemsIndexRangesArray[i].deleteObjects();
		this.elemsIndexRangesArray[i] = undefined;
	}
	
	this.elemsIndexRangesArray = undefined;
};

/**
 * add new index range and return.
 * @returns {IndexRange}
 */
VtxRing.prototype.newElementIndexRange = function()
{
	if (this.elemsIndexRangesArray === undefined)
	{ this.elemsIndexRangesArray = []; }
	
	var indexRange = new IndexRange();
	this.elemsIndexRangesArray.push(indexRange);
	return indexRange;
};

/**
 * get IndexRange
 * @param {number}
 * @returns {IndexRange|undefined}
 */
VtxRing.prototype.getElementIndexRange = function(idx)
{
	if (this.elemsIndexRangesArray === undefined)
	{ return undefined; }
	
	return this.elemsIndexRangesArray[idx];
};

/**
 * get all vertex. 
 * @param {Array} resultVerticesArray
 * @returns {Array.<Vertex>|undefined} if this.vertexList is undefined or this.vertexList.vertexArray is undefined, return resultVerticesArray.
 */
VtxRing.prototype.getAllVertices = function(resultVerticesArray)
{
	if (this.vertexList === undefined || this.vertexList.vertexArray === undefined)
	{ return resultVerticesArray; }
	
	if (resultVerticesArray === undefined)
	{ resultVerticesArray = []; }
	
	resultVerticesArray.push.apply(resultVerticesArray, this.vertexList.vertexArray);
	
	return resultVerticesArray;
};

/**
 * vertex ring copy from another vertex ring.
 * @param {VtxRing} vtxRing
 */
VtxRing.prototype.copyFrom = function(vtxRing)
{
	if (vtxRing.vertexList !== undefined)
	{
		if (this.vertexList === undefined)
		{ this.vertexList = new VertexList(); }
		
		this.vertexList.copyFrom(vtxRing.vertexList);
	}
	
	if (vtxRing.elemsIndexRangesArray !== undefined)
	{
		if (this.elemsIndexRangesArray === undefined)
		{ this.elemsIndexRangesArray = []; }
		
		var indexRange, myIndexRange;
		var indexRangesCount = vtxRing.elemsIndexRangesArray.length;
		for (var i=0; i<indexRangesCount; i++)
		{
			indexRange = vtxRing.elemsIndexRangesArray[i];
			myIndexRange = this.newElementIndexRange();
			myIndexRange.copyFrom(indexRange);
		}
	}
};

/**
 * vertex point translate.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @see Point3D#add
 */
VtxRing.prototype.translate = function(x, y, z)
{
	if (this.vertexList !== undefined)
	{
		this.vertexList.translateVertices(x, y, z);
	}
};

/**
 * vertex point transform by matrix4
 * @param {Matrix4} tMat4
 * @see Matrix4#transformPoint3D
 */
VtxRing.prototype.transformPointsByMatrix4 = function(tMat4)
{
	if (this.vertexList !== undefined)
	{
		this.vertexList.transformPointsByMatrix4(tMat4);
	}
};

/**
 * get projected poly line. this line based ring2d.
 * @param {Ring2D|undefined} resultRing2d if undefined, set new Ring2D instance.
 * @param {Point3D} normal
 * @returns {Ring2D}
 * 
 * @see VertexList#getProjectedPoints2DArray
 */
VtxRing.prototype.getProjectedPolyLineBasedRing2D = function(resultRing2d, normal)
{
	// This function returns a ring2d made by polylines2d.
	if (this.vertexList === undefined)
	{ return resultRing2d; }
	
	if (resultRing2d === undefined)
	{ resultRing2d = new Ring2D(); }
	
	var points2dArray = [];
	points2dArray = VertexList.getProjectedPoints2DArray(this.vertexList.vertexArray, normal, points2dArray);
	
	var polyLine2d = resultRing2d.newElement("POLYLINE");
	polyLine2d.point2dArray = points2dArray;
	
	return resultRing2d;
};

/**
 * use point3d array, set VtxRing's vertex list and indexrange.
 * @param {Array.<Point3D>} point3dArray Required.
 * 
 * @see VertexList#copyFromPoint3DArray
 */
VtxRing.prototype.makeByPoints3DArray = function(point3dArray)
{
	if (point3dArray === undefined)
	{ return; }
	
	if (this.vertexList === undefined)
	{ this.vertexList = new VertexList(); }
	
	this.vertexList.copyFromPoint3DArray(point3dArray);
	this.calculateElementsIndicesRange();
};

/**
 * use point3d array, update VtxRing's vertex list.
 * @param {Array.<Point3D>} point3dArray Required.
 * 
 * @see VertexList#copyFromPoint3DArray
 */
VtxRing.prototype.updateByPoints3DArray = function(point3dArray)
{
	// Note: point3dCount must be equal to this.verticesCount.
	if (point3dArray === undefined)
	{ return; }
	
	if (this.vertexList === undefined)
	{ this.vertexList = new VertexList(); }

	var vertex;
	var point3d;
	var position;
	var points3dCount = point3dArray.length;
	for (var i=0; i<points3dCount; i++)
	{
		point3d = point3dArray[i]; // the original point3d.
		vertex = this.vertexList.getVertex(i);
		if (vertex === undefined)
		{ vertex = this.vertexList.newVertex(); }
		
		if (vertex.point3d === undefined)
		{ vertex.point3d = new Point3D(); }
		
		vertex.point3d.set(point3d.x, point3d.y, point3d.z);
	}
	
	this.vertexList.copyFromPoint3DArray(point3dArray);
	
	// Do no modify elementsIndexRanges.
	//this.calculateElementsIndicesRange();
};

/**
 * use point2d array, update VtxRing's vertex list and indexrange.
 * @param {Point2DList} point2dArray Required.
 * @param {number} z altitude. default is zero.
 * @see VertexList#copyFromPoint3DArray
 */
VtxRing.prototype.makeByPoint2DList = function(point2dList, z)
{
	if (point2dList === undefined)
	{ return; }
	
	if (z === undefined)
	{ z = 0; }
	
	if (this.vertexList === undefined)
	{ this.vertexList = new VertexList(); }
	
	this.vertexList.copyFromPoint2DList(point2dList, z);
	this.calculateElementsIndicesRange();
};

/**
 * calculate plane normal.
 * Note: this ring must be planar (or almost planar).
 * @param {Point3D} resultPlaneNormal not use.
 * @returns {Point3D} planeNormal
 * @see Face#calculatePlaneNormal
 */
VtxRing.prototype.calculatePlaneNormal = function(resultPlaneNormal)
{
	var planeNormal = Face.calculatePlaneNormal(this.vertexList.vertexArray, undefined);
	return planeNormal;
};

/**
 * calculate elements indices range.
 */
VtxRing.prototype.calculateElementsIndicesRange = function()
{
	if (this.vertexList === undefined)
	{ return false; }

	// 1rst, delete all existent indexRanges.
	this.deleteElementIndexRanges();
	this.elemsIndexRangesArray = [];
	
	var vertex;
	var idxRange = undefined;
	var vertexType;
	var vertexCount = this.vertexList.getVertexCount();
	for (var i=0; i<vertexCount; i++)
	{
		vertex = this.vertexList.getVertex(i);
		vertexType = vertex.vertexType;
		
		//if(vertexType === undefined && i===0)
		//{
		//	var prevIdx = this.vertexList.getPrevIdx(i);
		//	var prevVertex = this.vertexList.getVertex(prevIdx);
		//	vertexType = prevVertex.vertexType;
		//}
		
		if (vertexType && vertexType === 1)
		{
			if (idxRange !== undefined)
			{
				idxRange.endIdx = i;
			}
			if (i !== vertexCount)
			{
				idxRange = this.newElementIndexRange();
				idxRange.strIdx = i;
			}
		}
	}
	
	if (idxRange !== undefined)
	{ idxRange.endIdx = 0; }
};

/**
 * get vertex intersected with plane. 
 * @static
 * @param {VtxRing} vtxRing if vtxRing's vertexList undefined, return resultVtxRing.
 * @param {Plane} plane. 
 * @param {Point3D} projectionDirection projectionDirection must be unitary.
 * @param {VtxRing} resultVtxRing Optional. if undefined, set new VtxRing instance.
 * @returns {VtxRing} resultVertex
 */
VtxRing.getProjectedOntoPlane = function(vtxRing, plane, projectionDirection, resultVtxRing)
{
	if (vtxRing.vertexList === undefined)
	{ return resultRing2d; }
	
	if (resultVtxRing === undefined)
	{ resultVtxRing = new VtxRing(); }

	resultVtxRing.vertexList = VertexList.getProjectedOntoPlane(vtxRing.vertexList, plane, projectionDirection, resultVtxRing.vertexList);
	resultVtxRing.calculateElementsIndicesRange();
	return resultVtxRing;
};














































'use strict';
/**
 * vertex ring list.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class VtxRing
 * 
 */
var VtxRingsList = function() 
{
	if (!(this instanceof VtxRingsList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * vertex list.
	 * @type {Array.<VtxRing>}
	 */
	this.vtxRingsArray;
};

/**
 * delete all vertex and element index ranges.
 */
VtxRingsList.prototype.deleteObjects = function()
{
	if (this.vtxRingsArray !== undefined)
	{
		var vtxRingsCount = this.vtxRingsArray.length;
		for (var i=0; i<vtxRingsCount; i++)
		{
			this.vtxRingsArray[i].deleteObjects();
			this.vtxRingsArray[i] = undefined;
		}
		this.vtxRingsArray = undefined;
	}
};


/**
 * get vtxRing count.
 * @returns {Number} 
 */
VtxRingsList.prototype.getVtxRingsCount = function()
{
	if (this.vtxRingsArray === undefined)
	{ return 0; }
	
	return this.vtxRingsArray.length;
};

/**
 * get vtxRing.
 * @param {Number} idx.
 * @returns {VtxRing|undefined} 
 */
VtxRingsList.prototype.getVtxRing = function(idx)
{
	if (this.vtxRingsArray === undefined)
	{ return undefined; }
	
	return this.vtxRingsArray[idx];
};

/**
 * add new vtxRing and return.
 * @returns {IndexRange}
 */
VtxRingsList.prototype.newVtxRing = function()
{
	if (this.vtxRingsArray === undefined)
	{ this.vtxRingsArray = []; }
	
	var vtxRing = new VtxRing();
	this.vtxRingsArray.push(vtxRing);
	return vtxRing;
};

/**
 * vertex ring list copy from another vertex ring list.
 * @param {VtxRingList} vtxRingList
 */
VtxRingsList.prototype.copyFrom = function(vtxRingsList)
{
	if (vtxRingsList === undefined)
	{ return; }
	
	if (this.vtxRingsArray === undefined)
	{ this.vtxRingsArray = []; }
	
	var vtxRing;
	var vtxRingsCount = vtxRingsList.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		vtxRing = this.newVtxRing();
		vtxRing.copyFrom(vtxRingsList.getVtxRing(i));
	}
};

/**
 * vertex point translate.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @see Point3D#add
 */
VtxRingsList.prototype.translate = function(x, y, z)
{
	var vtxRingsCount = this.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		this.vtxRingsArray[i].translate(x, y, z);
	}
};

/**
 * vertex point transform by matrix4
 * @param {Matrix4} tMat4
 * @see Matrix4#transformPoint3D
 */
VtxRingsList.prototype.transformPointsByMatrix4 = function(tMat4)
{
	var vtxRingsCount = this.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		this.vtxRingsArray[i].transformPointsByMatrix4(tMat4);
	}
};

/**
 * get all vertex. 
 * @param {Array} resultVerticesArray
 * @returns {Array.<Vertex>|undefined} if this.vtxRingsArray is undefined, return resultVerticesArray.
 */
VtxRingsList.prototype.getAllVertices = function(resultVerticesArray)
{
	if (this.vtxRingsArray === undefined)
	{ return resultVerticesArray; }
	
	var vtxRingsCount = this.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		this.vtxRingsArray[i].getAllVertices(resultVerticesArray);
	}
	
	return resultVerticesArray;
};

/**
 * set vertex idx in list.
 * @deprecated Must no use. and VtxRing has no setVerticesIdxInList method.
 */
VtxRingsList.prototype.setVerticesIdxInList = function()
{
	if (this.vtxRingsArray === undefined)
	{ return; }
	
	var vtxRingsCount = this.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		this.vtxRingsArray[i].setVerticesIdxInList();
	}
};

/**
 * get vertex intersected with plane. 
 * @static
 * @param {VtxRingList} vtxRingList if vtxRingList undefined, return resultVtxRingList.
 * @param {Plane} plane. 
 * @param {Point3D} projectionDirection projectionDirection must be unitary.
 * @param {VtxRingList} resultVtxRingList Optional. if undefined, set new VtxRingList instance.
 * @returns {VtxRingList} resultVtxRingList
 */
VtxRingsList.getProjectedOntoPlane = function(vtxRingList, plane, projectionDirection, resultVtxRingList)
{
	if (vtxRingList === undefined)
	{ return resultVtxRingList; }
	
	if (resultVtxRingList === undefined)
	{ resultVtxRingList = new VtxRingsList(); }
	
	var vtxRing, projectedVtxRing;;
	var vtxRingsCount = vtxRingList.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		vtxRing = vtxRingList.getVtxRing(i);
		projectedVtxRing = resultVtxRingList.newVtxRing();
		projectedVtxRing = VtxRing.getProjectedOntoPlane(vtxRing, plane, projectionDirection, projectedVtxRing);
	}
	
	return resultVtxRingList;
};



















































'use strict';

/**
 * Vertex segment.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class VtxSegment
 * 
 * @param {Vertex} startVertex Optional. start vertex.
 * @param {Vertex} endVertex Optional. end vertex.
 */
var VtxSegment = function(startVertex, endVertex) 
{
	if (!(this instanceof VtxSegment)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * start vertex.
	 * @type {Vertex}
	 */
	this.startVertex;

	/**
	 * end vertex.
	 * @type {Vertex}
	 */
	this.endVertex;
	
	if (startVertex)
	{ this.startVertex = startVertex; }
	
	if (endVertex)
	{ this.endVertex = endVertex; }
};

/**
 * set start, end vertex.
 * @param {Vertex} startVertex 
 * @param {Vertex} endVertex
 */
VtxSegment.prototype.setVertices = function(startVertex, endVertex)
{
	this.startVertex = startVertex;
	this.endVertex = endVertex;
};

/**
 * get direction between start vertex and end vertex.
 * @param {Point3d} resultDirection if undefined , set new Point3D instance.
 * @returns {Point3d} resultDirection
 */
VtxSegment.prototype.getDirection = function(resultDirection)
{
	// the direction is an unitary vector.
	var resultDirection = this.getVector();
	
	if (resultDirection === undefined)
	{ return undefined; }
	
	resultDirection.unitary();
	return resultDirection;
};

/**
 * get vector point between start vertex and end vertex.
 * @param {Point3d} resultVector if undefined , set new Point3D instance.
 * @returns {Point3d} resultVector
 */
VtxSegment.prototype.getVector = function(resultVector)
{
	if (this.startVertex === undefined || this.endVertex === undefined)
	{ return undefined; }
	
	var startPoint = this.startVertex.point3d;
	var endPoint = this.endVertex.point3d;
	
	if (startPoint === undefined || endPoint === undefined)
	{ return undefined; }
	
	resultVector = startPoint.getVectorToPoint(endPoint, resultVector);
	return resultVector;
};

/**
 * get line between start vertex and end vertex.
 * @param {Line} resultLine if undefined , set new Line instance.
 * @returns {Line} resultLine
 */
VtxSegment.prototype.getLine = function(resultLine)
{
	if (resultLine === undefined)
	{ resultLine = new Line(); }
	
	var dir = this.getDirection(); // unitary direction.
	var strPoint = this.startVertex.point3d;
	resultLine.setPointAndDir(strPoint.x, strPoint.y, strPoint.z, dir.x, dir.y, dir.z);
	return resultLine;
};

/**
 * get squared length.
 * @returns {Number} squared length
 * 
 * @see Point3D#squareDistToPoint
 */
VtxSegment.prototype.getSquaredLength = function()
{
	return this.startVertex.point3d.squareDistToPoint(this.endVertex.point3d);
};

/**
 * get length. 
 * @returns {Number} square root of squared length
 */
VtxSegment.prototype.getLength = function()
{
	return Math.sqrt(this.getSquaredLength());
};

/**
 * get intersection info with point. 
 * @param {Point3D} point
 * @param {Number} error default is 10E-8.
 * @returns {Number} Constant.INTERSECTION_*
 * Constant.INTERSECTION_OUTSIDE = 0
 * Constant.INTERSECTION_INTERSECT= 1
 * Constant.INTERSECTION_INSIDE = 2
 * Constant.INTERSECTION_POINT_A = 3
 * Constant.INTERSECTION_POINT_B = 4
 * 
 * @see Constant
 * @see Line#isCoincidentPoint
 * @see Point3D#distToPoint
 */
VtxSegment.prototype.intersectionWithPoint = function(point, error)
{
	// check if the point intersects the vtxSegment's line.
	var line = this.getLine();
	
	if (error === undefined)
	{ error = 10E-8; }
	
	if (!line.isCoincidentPoint(point, error))
	{ return Constant.INTERSECTION_OUTSIDE; } // no intersection.
	
	// now, check if is inside of the segment or if is coincident with any vertex of segment.
	var distA = this.startVertex.point3d.distToPoint(point);
	var distB = this.endVertex.point3d.distToPoint(point);
	var distTotal = this.getLength();
	
	if (distA < error)
	{ return Constant.INTERSECTION_POINT_A; }
	
	if (distB < error)
	{ return Constant.INTERSECTION_POINT_B; }
	
	if (distA> distTotal || distB> distTotal)
	{
		return Constant.INTERSECTION_OUTSIDE;
	}
	
	if (Math.abs(distA + distB - distTotal) < error)
	{ return Constant.INTERSECTION_INSIDE; }	
};
















































'use strict';

/**
 * 메세지
 * 
 * @class
 */
var Message = function(i18next, message) 
{
	this.handle  = i18next;
	this.message = message || MessageSource;
};

/**
 * 메세지 클래스 초기화
 *
 * @param {Function} callback
 */
Message.prototype.init = function (callback)
{
	var h = this.handle;
	this.handle.use(i18nextXHRBackend)
		.use(i18nextBrowserLanguageDetector)
		.init({
			// Useful for debuging, displays which key is missing
			debug: false,

			detection: {
				// keys or params to lookup language from
				lookupQuerystring  : 'lang',
				lookupCookie       : 'i18nextLang',
				lookupLocalStorage : 'i18nextLang',
			},
    
			// If translation key is missing, which lang use instead
			fallbackLng: 'en',

			resources: this.message,

			// all, languageOnly
			load: "languageOnly",

			ns        : ['common'],
			// Namespace to use by default, when not indicated
			defaultNS : 'common',
    
			keySeparator     : ".",
			nsSeparator      : ":",
			pluralSeparator  : "_",
			contextSeparator : "_"

		}, function(err, t)
		{
			console.log("detected user language: " + h.language);
			console.log("loaded languages: " + h.languages.join(', '));
			h.changeLanguage(h.languages[0]);
			callback(err, t);
		});
};

/**
 * 메세지 핸들러를 가져온다.
 *
 * @returns {i18next} message handler
 */
Message.prototype.getHandle = function ()
{
	return this.handle;
};

/**
 * 메세지를 가져온다.
 *
 * @returns {Object} message
 */
Message.prototype.getMessage = function ()
{
	return this.message;
};

'use strict';
var MessageSource = {};
MessageSource.en = {
  "common": {
    "welcome" : "Welcome",
    "error": {
        "title" : "Error",
        "construct" : {
            "create" : "This object should be created using new."
        }
    }
  }
};
MessageSource.ko = {
    "common": {
      "welcome" : "환영합니다.",
      "error": {
          "title" : "오류",
          "construct" : {
              "create" : "이 객체는 new 를 사용하여 생성해야 합니다."
          }
      }
    }
  };

'use strict';

/**
 * This class contains the current objects that are rendering. 
 * @class CurrentObjectsRendering
 */
var CurrentObjectsRendering = function() 
{
	if (!(this instanceof CurrentObjectsRendering)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// General objects rendering, as currNode, currBuilding, currOctree, currRefObject.
	// This class contains the current objects that are rendering. 
	
	/**
	 * The current node that is in rendering process.
	 * @type {Node}
	 * @default undefined
	 */
	this.curNode = undefined;
	
	/**
	 * The current building that is in rendering process.
	 * @type {NeoBuilding}
	 * @default undefined
	 */
	this.curBuilding = undefined;
	
	/**
	 * The current octree (octree of a building) that is in rendering process.
	 * @type {Octree}
	 * @default undefined
	 */
	this.curOctree = undefined;
	
	/**
	 * The current object that is in rendering process.
	 * @type {NeoReference}
	 * @default undefined
	 */
	this.curObject = undefined;
};


/**
 * This class manages the rendering of all classes.
 * @class Renderer
 */
var Renderer = function(manoManager) 
{
	if (!(this instanceof Renderer)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * The current objects that is in rendering process.
	 * @type {CurrentObjectsRendering}
	 * @default CurrentObjectsRendering
	 */
	this.currentObjectsRendering = new CurrentObjectsRendering();
	
	/**
	 * This parameter indicates that if is using normals in the shader.
	 * @type {Boolean}
	 * @default true
	 */
	this.renderNormals = true;
	
	/**
	 * This parameter indicates that if is using textures in the shader.
	 * @type {Boolean}
	 * @default true
	 */
	this.renderTexture = true;
	
	/**
	 * The main mago3d class. This object manages the main pipe-line of the Mago3D.
	 * @type {ManoManager}
	 * @default ManoManager
	 */
	this.magoManager = manoManager;
};

/**
 * This function renders all nodes of "visibleNodesArray".
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Array} visibleNodesArray Array that contains the nodes to render.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 * @param {PostFxShader} shader The PostFxShader class object.
 * @param {Boolean} renderTexture This parameter indicates that if is using textures in the shader.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {Number} maxSizeToRender This parameter limites the minimum size in the rendering process.
 * @param {Number} refMatrixIdxKey Indicates the references transformation matrix index.
 */
Renderer.prototype.renderNodes = function(gl, visibleNodesArray, magoManager, shader, renderTexture, renderType, maxSizeToRender, refMatrixIdxKey) 
{
	var node;
	var rootNode;
	var geoLocDataManager;
	var neoBuilding;
	var minSize = 0.0;
	var lowestOctreesCount;
	var lowestOctree;
	var isInterior = false; // no used.
	
	// set webgl options.
	gl.enable(gl.DEPTH_TEST);
	if (MagoConfig.getPolicy().geo_cull_face_enable === "true") 
	{
		gl.enable(gl.CULL_FACE);
	}
	else 
	{
		gl.disable(gl.CULL_FACE);
	}

	gl.enable(gl.CULL_FACE);
	gl.frontFace(gl.CCW);
	
	if (renderType === 2)
	{
		shader.disableVertexAttribArray(shader.texCoord2_loc);
		shader.disableVertexAttribArray(shader.normal3_loc);
	}
	if (renderType === 0)
	{
		shader.disableVertexAttribArray(shader.texCoord2_loc);
		shader.disableVertexAttribArray(shader.normal3_loc);
		shader.disableVertexAttribArray(shader.color4_loc);
	}
	
	var flipYTexCoord = false;
	
	// do render.
	var nodesCount = visibleNodesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		node = visibleNodesArray[i];
		node.renderContent(magoManager, shader, renderType, refMatrixIdxKey);
	}
};

/**
 * This function returns the vertices count recommended to render for determined distance to camera.
 * @param {Number} distToCam WebGL Rendering Context.
 * @param {Number} realPointsCount The real current points count.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 */
Renderer.prototype.getPointsCountForDistance = function(distToCam, realPointsCount, magoManager) 
{
	var vertices_count = realPointsCount;
	var pCloudSettings = magoManager.magoPolicy.getPointsCloudSettings();
		
	if (distToCam <= 10)
	{
		// Render all points.
	}
	else if (distToCam < 100)
	{
		vertices_count =  Math.floor(pCloudSettings.MaxPerUnitPointsRenderDistToCam100m * realPointsCount);
	}
	else if (distToCam < 200)
	{
		vertices_count = Math.floor(pCloudSettings.MaxPerUnitPointsRenderDistToCam200m * realPointsCount);
	}
	else if (distToCam < 400)
	{
		vertices_count = Math.floor(pCloudSettings.MaxPerUnitPointsRenderDistToCam400m * realPointsCount);
	}
	else if (distToCam < 800)
	{
		vertices_count = Math.floor(pCloudSettings.MaxPerUnitPointsRenderDistToCam800m * realPointsCount);
	}
	else if (distToCam < 1600)
	{
		vertices_count = Math.floor(pCloudSettings.MaxPerUnitPointsRenderDistToCam1600m * realPointsCount);
	}
	else
	{
		vertices_count = Math.floor(pCloudSettings.MaxPerUnitPointsRenderDistToCamMoreThan1600m * realPointsCount);
	}
	
	return vertices_count;
};

/**
 * This function renders the pCloud object. The pCloud object is "Lego" class.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Lego} pCloud The points cloud data to render.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 * @param {PostFxShader} shader The PostFxShader class object.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {Number} distToCam The current distance to camera.
 */
Renderer.prototype.renderPCloud = function(gl, pCloud, magoManager, shader, renderType, distToCam) 
{
	// Note: "pCloud" is "Lego" class.
	if (pCloud.vbo_vicks_container.vboCacheKeysArray.length === 0) 
	{
		return;
	}
	gl.frontFace(gl.CCW);
	
	var vbo_vicky = pCloud.vbo_vicks_container.vboCacheKeysArray[0]; // there are only one.
	var vertices_count = vbo_vicky.vertexCount;
	
	if (vertices_count === 0) 
	{ return; }
	
	var pointsCountToDraw = this.getPointsCountForDistance(distToCam, vertices_count, magoManager);
	
	if (magoManager.isCameraMoving)// && !isInterior && magoManager.isCameraInsideBuilding)
	{
		pointsCountToDraw = Math.floor(pointsCountToDraw/5);
	}

	if (pointsCountToDraw <= 0)
	{ return; }

	if (renderType === 0) // depth.
	{
		// 1) Position.
		if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }
		
		gl.drawArrays(gl.POINTS, 0, pointsCountToDraw);
	}
	else if (renderType === 1) // color.
	{
		if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }

		if (!vbo_vicky.bindDataColor(shader, magoManager.vboMemoryManager))
		{ return false; }
		
		gl.drawArrays(gl.POINTS, 0, pointsCountToDraw);
		
	}
	
	
};

/**
 * This function renders the neoBuildings as points-cloud projects.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Array} visibleNodesArray Array that contains the nodes to render.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 * @param {PostFxShader} shader The PostFxShader class object.
 * @param {Boolean} renderTexture This parameter indicates that if is using textures in the shader.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 */
Renderer.prototype.renderNeoBuildingsPCloud = function(gl, visibleNodesArray, magoManager, shader, renderTexture, renderType) 
{
	var node;
	var rootNode;
	var geoLocDataManager;
	var neoBuilding;
	var lowestOctreesCount;
	var lowestOctree;
	var lastExtureId;
	
	// Do some gl settings.
	//gl.uniform1i(shader.bUse1Color_loc, false);
	gl.uniform1f(shader.fixPointSize_loc, 1.0);
	gl.uniform1i(shader.bUseFixPointSize_loc, false);
	
	var nodesCount = visibleNodesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		node = visibleNodesArray[i];
		
		rootNode = node.getRoot();
		geoLocDataManager = rootNode.data.geoLocDataManager;
		neoBuilding = node.data.neoBuilding;
		
		if (neoBuilding === undefined)
		{ continue; }
		
		if (neoBuilding.octree === undefined)
		{ continue; }

		var projectDataType = neoBuilding.metaData.projectDataType;
		
		var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
		gl.uniform3fv(shader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
		gl.uniform3fv(shader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);
		
		if (projectDataType !== undefined && projectDataType === 5)
		{
			if (magoManager.myCameraRelative === undefined)
			{ magoManager.myCameraRelative = new Camera(); }

			var relativeCam = magoManager.myCameraRelative;
			relativeCam.frustum.copyParametersFrom(magoManager.myCameraSCX.bigFrustum);
			relativeCam = buildingGeoLocation.getTransformedRelativeCamera(magoManager.sceneState.camera, relativeCam);
			relativeCam.calculateFrustumsPlanes();
			var renderType = renderType;// testing.
			var bPrepareData = true;
			
			neoBuilding.octree.test__renderPCloud(magoManager, neoBuilding, renderType, shader, relativeCam, bPrepareData);
		}
	}
	
	shader.disableVertexAttribArrayAll();
};

/**
 * This function enables the webgl stencil-test option.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 */
Renderer.prototype.enableStencilBuffer = function(gl)
{
	// Active stencil if the object is selected.
	gl.enable(gl.STENCIL_TEST);
	
	gl.stencilFunc(gl.ALWAYS, 1, 1);
	// (stencil-fail: replace), (stencil-pass & depth-fail: replace), (stencil-pass & depth-pass: replace).
	//gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);
	gl.stencilOp(gl.KEEP, gl.REPLACE, gl.REPLACE);
	gl.enable(gl.POLYGON_OFFSET_FILL);
};

/**
 * This function disables the webgl stencil-test option.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 */
Renderer.prototype.disableStencilBuffer = function(gl)
{
	gl.disable(gl.STENCIL_TEST);
	gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
	gl.disable(gl.POLYGON_OFFSET_FILL);
};

/**
 * This function renders provisional ParametricMesh objects that has no self render function.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {ParametricMesh} renderable ParametricMesh type object to render.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 * @param {PostFxShader} shader The PostFxShader class object.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {Boolean} bRenderLines Optional boolean. Indicates if render edges.
 */
Renderer.prototype.renderObject = function(gl, renderable, magoManager, shader, renderType, bRenderLines)
{
	// This function actually is used for axis (origin) object.
	var vbo_vicks_container = renderable.getVboKeysContainer();
	
	if (vbo_vicks_container === undefined)
	{ return; }
	
	if (vbo_vicks_container.vboCacheKeysArray.length === 0) 
	{ return; }
	

	if (bRenderLines === undefined)
	{ bRenderLines = false; }


	var vbosCount = vbo_vicks_container.getVbosCount();
	for (var i=0; i<vbosCount; i++)
	{
		// 1) Position.
		var vbo_vicky = vbo_vicks_container.vboCacheKeysArray[i]; // there are only one.

		var vertices_count = vbo_vicky.vertexCount;
		if (vertices_count === 0) 
		{ return; }

		if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }

		if (renderType === 1) // ssao.
		{
			if (!vbo_vicky.bindDataNormal(shader, magoManager.vboMemoryManager))
			{ return false; }

			if (!vbo_vicky.bindDataColor(shader, magoManager.vboMemoryManager))
			{ return false; }
			
			// TexCoords todo:
		}
		
		if (bRenderLines === false)
		{
			if (vbo_vicky.indicesCount > 0)
			{
				if (!vbo_vicky.bindDataIndice(shader, magoManager.vboMemoryManager))
				{ return false; }

				gl.drawElements(gl.TRIANGLES, vbo_vicky.indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.
			}
			else 
			{
				gl.drawArrays(gl.TRIANGLES, 0, vertices_count);
			}
		}
		else 
		{
			gl.drawArrays(gl.LINE_STRIP, 0, vertices_count);
			//gl.drawArrays(gl.TRIANGLES, 0, vertices_count);
		}
	}
};


/**
 * This function renders provisional ParametricMesh objects that has no self render function.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {VisibleObjectsController} visibleObjControlerNodes This object contains visible objects for the camera frustum.
 */
Renderer.prototype.renderGeometryDepth = function(gl, renderType, visibleObjControlerNodes) 
{
	var currentShader;
	var shaderProgram;
	var renderTexture = false;
	
	var magoManager = this.magoManager;
	
	// Test Modeler Rendering.********************************************************************
	// Test Modeler Rendering.********************************************************************
	// Test Modeler Rendering.********************************************************************
	if (magoManager.modeler !== undefined)
	{
		currentShader = magoManager.postFxShadersManager.getShader("modelRefDepth"); 
		currentShader.resetLastBuffersBinded();
		shaderProgram = currentShader.program;

		currentShader.useProgram();
		currentShader.enableVertexAttribArray(currentShader.position3_loc);
		currentShader.disableVertexAttribArray(currentShader.texCoord2_loc);
		currentShader.disableVertexAttribArray(currentShader.normal3_loc);
		currentShader.disableVertexAttribArray(currentShader.color4_loc);

		currentShader.bindUniformGenerals();

		var refTMatrixIdxKey = 0;
		var minSizeToRender = 0.0;
		var renderType = 0;
		var refMatrixIdxKey =0; // provisionally set this var here.***
		magoManager.modeler.render(magoManager, currentShader, renderType);

		currentShader.disableVertexAttribArrayAll();
		gl.useProgram(null);

	}
	
	var nodesLOD0Count = visibleObjControlerNodes.currentVisibles0.length;
	var nodesLOD2Count = visibleObjControlerNodes.currentVisibles2.length;
	var nodesLOD3Count = visibleObjControlerNodes.currentVisibles3.length;
	if (nodesLOD0Count > 0 || nodesLOD2Count > 0 || nodesLOD3Count > 0)
	{
		currentShader = magoManager.postFxShadersManager.getShader("modelRefDepth"); 
		currentShader.resetLastBuffersBinded();
		shaderProgram = currentShader.program;

		currentShader.useProgram();
		currentShader.enableVertexAttribArray(currentShader.position3_loc);
		currentShader.disableVertexAttribArray(currentShader.texCoord2_loc);
		currentShader.disableVertexAttribArray(currentShader.normal3_loc);
		currentShader.disableVertexAttribArray(currentShader.color4_loc);
		currentShader.bindUniformGenerals();

		// RenderDepth for all buildings.***
		var refTMatrixIdxKey = 0;
		var minSize = 0.0;

		magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles0, magoManager, currentShader, renderTexture, renderType, minSize, 0, refTMatrixIdxKey);
		//magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles2, magoManager, currentShader, renderTexture, renderType, minSize, 0, refTMatrixIdxKey);
		//magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles3, magoManager, currentShader, renderTexture, renderType, minSize, 0, refTMatrixIdxKey);
		
		currentShader.disableVertexAttribArray(currentShader.position3_loc); 
		gl.useProgram(null);
	}
	
	// PointsCloud.****************************************************************************************
	// PointsCloud.****************************************************************************************
	var nodesPCloudCount = magoManager.visibleObjControlerNodes.currentVisiblesAux.length;
	if (nodesPCloudCount > 0)
	{
		currentShader = magoManager.postFxShadersManager.getShader("pointsCloudDepth");
		currentShader.useProgram();
		
		currentShader.resetLastBuffersBinded();

		currentShader.enableVertexAttribArray(currentShader.position3_loc);
		currentShader.disableVertexAttribArray(currentShader.color4_loc);
		currentShader.disableVertexAttribArray(currentShader.normal3_loc); // provisionally has no normals.***
		currentShader.disableVertexAttribArray(currentShader.texCoord2_loc); // provisionally has no texCoords.***
		
		currentShader.bindUniformGenerals();
		
		// Test to load pCloud.***
		if (magoManager.visibleObjControlerPCloudOctrees === undefined)
		{ magoManager.visibleObjControlerPCloudOctrees = new VisibleObjectsController(); }
		magoManager.visibleObjControlerPCloudOctrees.clear();

		magoManager.renderer.renderNeoBuildingsPCloud(gl, magoManager.visibleObjControlerNodes.currentVisiblesAux, magoManager, currentShader, renderTexture, renderType); 
		currentShader.disableVertexAttribArrayAll();
		
		gl.useProgram(null);
		
		// Load pCloud data.***
		var visiblesSortedOctreesArray = magoManager.visibleObjControlerPCloudOctrees.currentVisibles0;
		var octreesCount = visiblesSortedOctreesArray.length;

		var loadCount = 0;
		if (!magoManager.isCameraMoving && !magoManager.mouseLeftDown && !magoManager.mouseMiddleDown)
		{
			for (var i=0; i<octreesCount; i++)
			{
				var octree = visiblesSortedOctreesArray[i];
				if (octree.preparePCloudData(magoManager))
				{
					loadCount++;
				}
				
				if (loadCount > 1)
				{ break; }
			}
		}

	}
	
	// Render cuttingPlanes of temperaturalayers if exist.***
	if (magoManager.weatherStation)
	{ magoManager.weatherStation.test_renderCuttingPlanes(magoManager, renderType); }
	
	// tin terrain.***
	if (magoManager.tinTerrainManager !== undefined)
	{
		var bDepth = true;
		magoManager.tinTerrainManager.render(magoManager, bDepth);
		gl.useProgram(null);
	}
	
	// Test.***
	var selGeneralObjects = magoManager.selectionManager.getSelectionCandidatesFamily("general");
	if (selGeneralObjects)
	{
		var currObjectSelected = selGeneralObjects.currentSelected;
		if (currObjectSelected)
		{
			// check if is a cuttingPlane.***
			if (currObjectSelected instanceof CuttingPlane)
			{
				// Test. Render depth only for the selected object.***************************
				magoManager.test_renderDepth_objectSelected(currObjectSelected);
			}
		}
	}
};

/**
 * This function renders provisional ParametricMesh objects that has no self render function.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {VisibleObjectsController} visibleObjControlerNodes This object contains visible objects for the camera frustum.
 */
Renderer.prototype.renderGeometry = function(gl, renderType, visibleObjControlerNodes) 
{
	gl.frontFace(gl.CCW);	
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	gl.enable(gl.CULL_FACE);
	
	var currentShader;
	var shaderProgram;
	var neoBuilding;
	var node;
	var rootNode;
	var geoLocDataManager;
	var magoManager = this.magoManager;

	var renderTexture = false;
	
	if (renderType === 0 ) 
	{
		gl.disable(gl.BLEND);
		magoManager.renderer.renderGeometryDepth(gl, renderType, visibleObjControlerNodes);
		
		// Draw the axis.***
		if (magoManager.magoPolicy.getShowOrigin() && magoManager.nodeSelected !== undefined)
		{
			node = magoManager.nodeSelected;
			var nodes = [node];
			
			this.renderAxisNodes(nodes, renderType);
		}
	}
	if (renderType === 1) 
	{
		var textureAux1x1 = magoManager.texturesManager.getTextureAux1x1();
		var noiseTexture = magoManager.texturesManager.getNoiseTexture4x4();
		
		// Test Modeler Rendering.********************************************************************
		// Test Modeler Rendering.********************************************************************
		// Test Modeler Rendering.********************************************************************
		if (magoManager.modeler !== undefined)
		{

			currentShader = magoManager.postFxShadersManager.getShader("modelRefSsao"); 
			currentShader.useProgram();
			gl.uniform1i(currentShader.bApplySsao_loc, false); // apply ssao default.***
			
			gl.uniform1i(currentShader.bApplySpecularLighting_loc, true);
			gl.enableVertexAttribArray(currentShader.texCoord2_loc);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.enableVertexAttribArray(currentShader.normal3_loc);
			if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
			
			currentShader.bindUniformGenerals();
			gl.uniform1i(currentShader.textureFlipYAxis_loc, magoManager.sceneState.textureFlipYAxis);

			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
			gl.activeTexture(gl.TEXTURE2); 
			gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
			currentShader.last_tex_id = textureAux1x1;
			
			
			var refTMatrixIdxKey = 0;
			var minSizeToRender = 0.0;
			var renderType = 1;
			var refMatrixIdxKey =0; // provisionally set magoManager var here.***
			magoManager.modeler.render(magoManager, currentShader, renderType);
			
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, null);
			
			currentShader.disableVertexAttribArrayAll();
			gl.useProgram(null);

		}
		
		// check changesHistory.
		magoManager.checkChangesHistoryMovements(visibleObjControlerNodes.currentVisibles0);
		magoManager.checkChangesHistoryColors(visibleObjControlerNodes.currentVisibles0);
		
		magoManager.checkChangesHistoryMovements(visibleObjControlerNodes.currentVisibles2);
		magoManager.checkChangesHistoryColors(visibleObjControlerNodes.currentVisibles2);
		
		magoManager.checkChangesHistoryMovements(visibleObjControlerNodes.currentVisibles3);
		magoManager.checkChangesHistoryColors(visibleObjControlerNodes.currentVisibles3);
			
		// ssao render.************************************************************************************************************
		var nodesLOD0Count = visibleObjControlerNodes.currentVisibles0.length;
		var nodesLOD2Count = visibleObjControlerNodes.currentVisibles2.length;
		var nodesLOD3Count = visibleObjControlerNodes.currentVisibles3.length;
		if (nodesLOD0Count > 0 || nodesLOD2Count > 0 || nodesLOD3Count > 0)
		{
			gl.enable(gl.BLEND);
			currentShader = magoManager.postFxShadersManager.getShader("modelRefSsao"); 
			currentShader.useProgram();
			var bApplySsao = true;
			gl.uniform1i(currentShader.bApplySsao_loc, bApplySsao); // apply ssao default.***
			
			gl.uniform1i(currentShader.bApplySpecularLighting_loc, true);
			gl.enableVertexAttribArray(currentShader.texCoord2_loc);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.enableVertexAttribArray(currentShader.normal3_loc);
			if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
			
			currentShader.bindUniformGenerals();
			gl.uniform1f(currentShader.externalAlpha_loc, 1.0);
			gl.uniform1i(currentShader.textureFlipYAxis_loc, magoManager.sceneState.textureFlipYAxis);

			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
			gl.activeTexture(gl.TEXTURE2); 
			gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
			currentShader.last_tex_id = textureAux1x1;
			
			
			var refTMatrixIdxKey = 0;
			var minSizeToRender = 0.0;
			var renderType = 1;
			var refMatrixIdxKey =0; // provisionally set magoManager var here.***
			magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles0, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
			
			bApplySsao = false;
			gl.uniform1i(currentShader.bApplySsao_loc, bApplySsao); 

			magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles2, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
			magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles3, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
			
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, null);
			
			currentShader.disableVertexAttribArrayAll();
			gl.useProgram(null);
		}
		
		// If there are an object selected, then there are a stencilBuffer.******************************************
		if (magoManager.nodeSelected) // if there are an object selected then there are a building selected.***
		{
			if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.OBJECT && magoManager.objectSelected)
			{
				node = magoManager.nodeSelected;
				var geoLocDataManager = node.getNodeGeoLocDataManager();
				neoBuilding = magoManager.buildingSelected;
				var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
				var neoReferencesMotherAndIndices = magoManager.octreeSelected.neoReferencesMotherAndIndices;
				var glPrimitive = gl.POINTS;
				glPrimitive = gl.TRIANGLES;
				var maxSizeToRender = 0.0;
				var refMatrixIdxKey = 0;
				
				// do as the "getSelectedObjectPicking".**********************************************************
				currentShader = magoManager.postFxShadersManager.getModelRefSilhouetteShader(); // silhouette shader.***
				currentShader.useProgram();
				
				currentShader.enableVertexAttribArray(currentShader.position3_loc);
				currentShader.disableVertexAttribArray(currentShader.texCoord2_loc);
				currentShader.disableVertexAttribArray(currentShader.normal3_loc);
				currentShader.disableVertexAttribArray(currentShader.color4_loc);
				
				buildingGeoLocation.bindGeoLocationUniforms(gl, currentShader);

				gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, magoManager.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
				gl.uniformMatrix4fv(currentShader.ModelViewMatrixRelToEye_loc, false, magoManager.sceneState.modelViewRelToEyeMatrix._floatArrays);
				gl.uniform3fv(currentShader.cameraPosHIGH_loc, magoManager.sceneState.encodedCamPosHigh);
				gl.uniform3fv(currentShader.cameraPosLOW_loc, magoManager.sceneState.encodedCamPosLow);
				
				// do the colorCoding render.***
				
				gl.uniform4fv(currentShader.color4Aux_loc, [0.0, 1.0, 0.0, 1.0]);
				gl.uniform2fv(currentShader.screenSize_loc, [magoManager.sceneState.drawingBufferWidth, magoManager.sceneState.drawingBufferHeight]);
				gl.uniformMatrix4fv(currentShader.ProjectionMatrix_loc, false, magoManager.sceneState.projectionMatrix._floatArrays);
				
				gl.enable(gl.STENCIL_TEST);
				gl.disable(gl.POLYGON_OFFSET_FILL);
				gl.disable(gl.CULL_FACE);
				gl.disable(gl.DEPTH_TEST);
				gl.depthRange(0, 0);
				
				gl.stencilFunc(gl.EQUAL, 0, 1);
				gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
					
				//glPrimitive = gl.POINTS;
				glPrimitive = gl.TRIANGLES;
				//gl.polygonMode( gl.FRONT_AND_BACK, gl.LINE );
				var localRenderType = 0; // only need positions.***
				var minSizeToRender = 0.0;
				var offsetSize = 3/1000;
				
				gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [offsetSize, offsetSize]);
				magoManager.objectSelected.render(magoManager, neoBuilding, localRenderType, renderTexture, currentShader, refMatrixIdxKey, minSizeToRender);
				gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [-offsetSize, offsetSize]);
				magoManager.objectSelected.render(magoManager, neoBuilding, localRenderType, renderTexture, currentShader, refMatrixIdxKey, minSizeToRender);
				gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [offsetSize, -offsetSize]);
				magoManager.objectSelected.render(magoManager, neoBuilding, localRenderType, renderTexture, currentShader, refMatrixIdxKey, minSizeToRender);
				gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [-offsetSize, -offsetSize]);
				magoManager.objectSelected.render(magoManager, neoBuilding, localRenderType, renderTexture, currentShader, refMatrixIdxKey, minSizeToRender);
				
				gl.enable(gl.DEPTH_TEST);// return to the normal state.***
				gl.disable(gl.STENCIL_TEST);
				gl.depthRange(0, 1);// return to the normal value.***
				//gl.disableVertexAttribArray(currentShader.position3_loc);
				currentShader.disableVertexAttribArrayAll();
				
				gl.useProgram(null);
			}
			
			// new. Render the silhouette by lod3 or lod4 or lod5 mesh***
			if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected)
			{
				node = magoManager.nodeSelected;
				
				if (node !== undefined) // test code.***
				{
					var geoLocDataManager = node.getNodeGeoLocDataManager();
					neoBuilding = magoManager.buildingSelected;
					var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
				
					currentShader = magoManager.postFxShadersManager.getModelRefSilhouetteShader(); // silhouette shader.***
					currentShader.useProgram();

					gl.enableVertexAttribArray(currentShader.position3_loc);
					
					buildingGeoLocation.bindGeoLocationUniforms(gl, currentShader);

					gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, magoManager.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
					gl.uniformMatrix4fv(currentShader.ModelViewMatrixRelToEye_loc, false, magoManager.sceneState.modelViewRelToEyeMatrix._floatArrays);
					gl.uniform3fv(currentShader.cameraPosHIGH_loc, magoManager.sceneState.encodedCamPosHigh);
					gl.uniform3fv(currentShader.cameraPosLOW_loc, magoManager.sceneState.encodedCamPosLow);
					
					// do the colorCoding render.***
					
					gl.uniform4fv(currentShader.color4Aux_loc, [0.0, 1.0, 0.0, 1.0]);
					gl.uniform2fv(currentShader.screenSize_loc, [magoManager.sceneState.drawingBufferWidth, magoManager.sceneState.drawingBufferHeight]);
					gl.uniformMatrix4fv(currentShader.ProjectionMatrix_loc, false, magoManager.sceneState.projectionMatrix._floatArrays);
					
					gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
					
					gl.enable(gl.STENCIL_TEST);
					gl.disable(gl.POLYGON_OFFSET_FILL);
					gl.disable(gl.CULL_FACE);
					gl.disable(gl.DEPTH_TEST);
					gl.depthRange(0, 0);
					
					gl.stencilFunc(gl.EQUAL, 0, 1);
					gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
					//gl.stencilOp(gl.KEEP, gl.REPLACE, gl.REPLACE);
						
					//glPrimitive = gl.POINTS;
					glPrimitive = gl.TRIANGLES;
					gl.uniform1i(currentShader.refMatrixType_loc, 0); // 0 = identity matrix, there are not referencesMatrix.***
					//gl.polygonMode( gl.FRONT_AND_BACK, gl.LINE );
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					
					
					var refTMatrixIdxKey = 0;
					var minSizeToRender = 0.0;
					var renderType = 0;
					var refMatrixIdxKey =0; // provisionally set magoManager var here.***
					var offsetSize = 4/1000;

					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [offsetSize, offsetSize]);
					magoManager.renderer.renderNodes(gl, [node], magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [-offsetSize, offsetSize]);
					magoManager.renderer.renderNodes(gl, [node], magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [offsetSize, -offsetSize]);
					magoManager.renderer.renderNodes(gl, [node], magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [-offsetSize, -offsetSize]);
					magoManager.renderer.renderNodes(gl, [node], magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
					
					currentShader.disableVertexAttribArrayAll();
				}
				/*
				var geoLocDataManager = node.getNodeGeoLocDataManager();
				neoBuilding = magoManager.buildingSelected;
				var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
				//var neoReferencesMotherAndIndices = magoManager.octreeSelected.neoReferencesMotherAndIndices;
				var glPrimitive = gl.POINTS;
				glPrimitive = gl.TRIANGLES;
				var maxSizeToRender = 0.0;
				var refMatrixIdxKey = 0;
				var skinLego = neoBuilding.getCurrentSkin();
				if (skinLego !== undefined)
				{
					// do as the "getSelectedObjectPicking".**********************************************************
					currentShader = magoManager.postFxShadersManager.getModelRefSilhouetteShader(); // silhouette shader.***
					currentShader.useProgram();

					gl.enableVertexAttribArray(currentShader.position3_loc);
					
					buildingGeoLocation.bindGeoLocationUniforms(gl, currentShader);

					gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, magoManager.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
					gl.uniformMatrix4fv(currentShader.ModelViewMatrixRelToEye_loc, false, magoManager.sceneState.modelViewRelToEyeMatrix._floatArrays);
					gl.uniform3fv(currentShader.cameraPosHIGH_loc, magoManager.sceneState.encodedCamPosHigh);
					gl.uniform3fv(currentShader.cameraPosLOW_loc, magoManager.sceneState.encodedCamPosLow);
					
					// do the colorCoding render.***
					
					gl.uniform4fv(currentShader.color4Aux_loc, [0.0, 1.0, 0.0, 1.0]);
					gl.uniform2fv(currentShader.screenSize_loc, [magoManager.sceneState.drawingBufferWidth, magoManager.sceneState.drawingBufferHeight]);
					gl.uniformMatrix4fv(currentShader.ProjectionMatrix_loc, false, magoManager.sceneState.projectionMatrix._floatArrays);
					
					gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
					
					gl.enable(gl.STENCIL_TEST);
					gl.disable(gl.POLYGON_OFFSET_FILL);
					gl.disable(gl.CULL_FACE);
					gl.disable(gl.DEPTH_TEST);
					gl.depthRange(0, 0);
					
					gl.stencilFunc(gl.EQUAL, 0, 1);
					gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
					//gl.stencilOp(gl.KEEP, gl.REPLACE, gl.REPLACE);
						
					//glPrimitive = gl.POINTS;
					glPrimitive = gl.TRIANGLES;
					gl.uniform1i(currentShader.refMatrixType_loc, 0); // 0 = identity matrix, there are not referencesMatrix.***
					//gl.polygonMode( gl.FRONT_AND_BACK, gl.LINE );

					var offsetSize = 4/1000;
					var localRenderType = 0; // only need positions.***
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [offsetSize, offsetSize]);
					skinLego.render(magoManager, localRenderType, renderTexture, currentShader);
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [-offsetSize, offsetSize]);
					skinLego.render(magoManager, localRenderType, renderTexture, currentShader);
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [offsetSize, -offsetSize]);
					skinLego.render(magoManager, localRenderType, renderTexture, currentShader);
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [-offsetSize, -offsetSize]);
					skinLego.render(magoManager, localRenderType, renderTexture, currentShader);
					gl.enable(gl.DEPTH_TEST);// return to the normal state.***
					gl.disable(gl.STENCIL_TEST);
					gl.depthRange(0, 1);// return to the normal value.***
					gl.disableVertexAttribArray(currentShader.position3_loc);
					
					currentShader.disableVertexAttribArrayAll();
				}
				*/
			}
			
			// draw the axis.***
			if (magoManager.magoPolicy.getShowOrigin())
			{
				node = magoManager.nodeSelected;
				//var geoLocDataManager = node.getNodeGeoLocDataManager();
				var nodes = [node];
				
				this.renderAxisNodes(nodes, renderType);
			}
		}
		
		
		// 3) now render bboxes.*******************************************************************************************************************
		if (magoManager.magoPolicy.getShowBoundingBox())
		{
			var bRenderLines = true;
			this.renderBoundingBoxesNodes(magoManager.visibleObjControlerNodes.currentVisibles0, undefined, bRenderLines);
			this.renderBoundingBoxesNodes(magoManager.visibleObjControlerNodes.currentVisibles2, undefined, bRenderLines);
			this.renderBoundingBoxesNodes(magoManager.visibleObjControlerNodes.currentVisibles3, undefined, bRenderLines);
		}
		
		// 4) Render ObjectMarkers.********************************************************************************************************
		// 4) Render ObjectMarkers.********************************************************************************************************
		// 4) Render ObjectMarkers.********************************************************************************************************
		var objectsMarkersCount = magoManager.objMarkerManager.objectMarkerArray.length;
		if (objectsMarkersCount > 0)
		{
			// now repeat the objects markers for png images.***
			// Png for pin image 128x128.********************************************************************
			if (magoManager.pin.positionBuffer === undefined)
			{ magoManager.pin.createPinCenterBottom(gl); }
			
			currentShader = magoManager.postFxShadersManager.pngImageShader; // png image shader.***
			currentShader.resetLastBuffersBinded();
			
			shaderProgram = currentShader.program;
			
			gl.useProgram(shaderProgram);
			gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, magoManager.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
			gl.uniform3fv(currentShader.cameraPosHIGH_loc, magoManager.sceneState.encodedCamPosHigh);
			gl.uniform3fv(currentShader.cameraPosLOW_loc, magoManager.sceneState.encodedCamPosLow);
			gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, magoManager.sceneState.modelViewRelToEyeMatrixInv._floatArrays);
			
			gl.uniform1i(currentShader.textureFlipYAxis_loc, magoManager.sceneState.textureFlipYAxis); 
			// Tell the shader to get the texture from texture unit 0
			gl.uniform1i(currentShader.texture_loc, 0);
			gl.enableVertexAttribArray(currentShader.texCoord2_loc);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.activeTexture(gl.TEXTURE0);
			
			gl.depthRange(0, 0);
			//var context = document.getElementById('canvas2').getContext("2d");
			//var canvas = document.getElementById("magoContainer");
			
			gl.bindBuffer(gl.ARRAY_BUFFER, magoManager.pin.positionBuffer);
			gl.vertexAttribPointer(currentShader.position3_loc, 3, gl.FLOAT, false, 0, 0);
			gl.bindBuffer(gl.ARRAY_BUFFER, magoManager.pin.texcoordBuffer);
			gl.vertexAttribPointer(currentShader.texCoord2_loc, 2, gl.FLOAT, false, 0, 0);
			var j=0;
			for (var i=0; i<objectsMarkersCount; i++)
			{
				if (j>= magoManager.pin.texturesArray.length)
				{ j=0; }
				
				var currentTexture = magoManager.pin.texturesArray[j];
				var objMarker = magoManager.objMarkerManager.objectMarkerArray[i];
				var objMarkerGeoLocation = objMarker.geoLocationData;
				gl.bindTexture(gl.TEXTURE_2D, currentTexture.texId);
				gl.uniform3fv(currentShader.buildingPosHIGH_loc, objMarkerGeoLocation.positionHIGH);
				gl.uniform3fv(currentShader.buildingPosLOW_loc, objMarkerGeoLocation.positionLOW);

				gl.drawArrays(gl.TRIANGLES, 0, 6);
				
				j++;
			}
			gl.depthRange(0, 1);
			gl.useProgram(null);
			gl.bindTexture(gl.TEXTURE_2D, null);
			currentShader.disableVertexAttribArrayAll();
			
		}
		
		// test renders.***
		// render cctv.***
		/*
		magoManager.test_cctv();
		var cctvsCount = 0;
		if (magoManager.cctvList !== undefined)
		{
			cctvsCount = magoManager.cctvList.getCCTVCount();
		}
		if (cctvsCount > 0)
		{
			currentShader = magoManager.postFxShadersManager.getShader("modelRefSsao"); 
			magoManager.cctvList.render(magoManager, currentShader );
		}
		*/
		
		// PointsCloud.****************************************************************************************
		// PointsCloud.****************************************************************************************
		var nodesPCloudCount = magoManager.visibleObjControlerNodes.currentVisiblesAux.length;
		if (nodesPCloudCount > 0)
		{
			magoManager.sceneState.camera.setCurrentFrustum(0);
			var frustumIdx = magoManager.currentFrustumIdx;
			magoManager.sceneState.camera.frustum.near[0] = magoManager.sceneState.camera.frustumsArray[frustumIdx].near[0];
			magoManager.sceneState.camera.frustum.far[0] = magoManager.sceneState.camera.frustumsArray[frustumIdx].far[0];

					
			if (magoManager.pointsCloudSsao === undefined)
			{ magoManager.pointsCloudSsao = true; }
			
			if (magoManager.pointsCloudSsao)
			{ currentShader = magoManager.postFxShadersManager.getShader("pointsCloudSsao"); }
			else
			{ currentShader = magoManager.postFxShadersManager.getShader("pointsCloud"); }
			currentShader.useProgram();
			currentShader.resetLastBuffersBinded();
			currentShader.enableVertexAttribArray(currentShader.position3_loc);
			currentShader.enableVertexAttribArray(currentShader.color4_loc);
			currentShader.bindUniformGenerals();
			
			gl.uniform1f(currentShader.externalAlpha_loc, 1.0);
			var bApplySsao = true;
			gl.uniform1i(currentShader.bApplySsao_loc, bApplySsao); // apply ssao default.***
			
			if (magoManager.pointsCloudWhite !== undefined && magoManager.pointsCloudWhite)
			{
				gl.uniform1i(currentShader.bUse1Color_loc, true);
				gl.uniform4fv(currentShader.oneColor4_loc, [0.99, 0.99, 0.99, 1.0]); //.***
			}
			else 
			{
				gl.uniform1i(currentShader.bUse1Color_loc, false);
			}
	
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);
			
			// Test to load pCloud.***
			if (magoManager.visibleObjControlerPCloudOctrees === undefined)
			{ magoManager.visibleObjControlerPCloudOctrees = new VisibleObjectsController(); }
			
			magoManager.visibleObjControlerPCloudOctrees.clear();
			magoManager.renderer.renderNeoBuildingsPCloud(gl, magoManager.visibleObjControlerNodes.currentVisiblesAux, magoManager, currentShader, renderTexture, renderType); // lod0.***
			currentShader.disableVertexAttribArrayAll();
			
			gl.useProgram(null);

		}
		
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		currentShader = magoManager.postFxShadersManager.getShader("modelRefSsao"); 
		currentShader.disableVertexAttribArrayAll();
		
		currentShader = magoManager.postFxShadersManager.getShader("modelRefColorCoding");  // color selection shader.***
		currentShader.disableVertexAttribArrayAll();
		
		currentShader = magoManager.postFxShadersManager.getModelRefSilhouetteShader(); // silhouette shader.***
		currentShader.disableVertexAttribArrayAll();
		
		// Test TinTerrain.**************************************************************************
		// Test TinTerrain.**************************************************************************
		// render tiles, rendertiles.***
		
		if (magoManager.tinTerrainManager !== undefined)
		{
			var bDepthRender = false; // magoManager is no depth render.***
			magoManager.tinTerrainManager.render(magoManager, bDepthRender);
		}
		
		

	}
	
	currentShader = magoManager.postFxShadersManager.getShader("modelRefSsao"); 
	currentShader.disableVertexAttribArrayAll();
	
	currentShader = magoManager.postFxShadersManager.getShader("modelRefColorCoding");  // color selection shader.***
	currentShader.disableVertexAttribArrayAll();
	
	currentShader = magoManager.postFxShadersManager.getModelRefSilhouetteShader(); // silhouette shader.***
	currentShader.disableVertexAttribArrayAll();

	
	gl.disable(gl.BLEND);
	gl.depthRange(0.0, 1.0);	
};


/**
 * This function renders the axis coordinates of the nodes.
 * @param {Array} nodesArray Nodes that render the axis.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 */
Renderer.prototype.renderAxisNodes = function(nodesArray, renderType) 
{
	var magoManager = this.magoManager;
	
	if (magoManager.axisXYZ.vbo_vicks_container.vboCacheKeysArray.length === 0)
	{ 
		var mesh = magoManager.axisXYZ.makeMesh(30); 
		mesh.getVboTrianglesConvex(magoManager.axisXYZ.vbo_vicks_container, magoManager.vboMemoryManager);
	}
	
	var gl = magoManager.getGl();
	var color;
	var node;
	var currentShader;
	if (renderType === 0)
	{
		currentShader = magoManager.postFxShadersManager.getShader("modelRefDepth"); 
		gl.disable(gl.BLEND);
	}
	if (renderType === 1)
	{
		currentShader = magoManager.postFxShadersManager.getShader("modelRefSsao"); 
		gl.enable(gl.BLEND);
	}
	
	var noiseTexture = magoManager.texturesManager.getNoiseTexture4x4();
	
	// Test rendering by modelRefShader.****
	currentShader.useProgram();
	gl.uniform1i(currentShader.bApplySsao_loc, true); // apply ssao.***
	gl.uniform1i(currentShader.refMatrixType_loc, 0); // in magoManager case, there are not referencesMatrix.***
	gl.uniform1i(currentShader.colorType_loc, 1); // 0= oneColor, 1= attribColor, 2= texture.***
	
	// -------------------------------------
	
	currentShader.disableVertexAttribArray(currentShader.texCoord2_loc);
	
	var shaderProgram = currentShader.program;
	currentShader.bindUniformGenerals();
	gl.enableVertexAttribArray(currentShader.position3_loc);
		
	if (renderType === 1)
	{
		var textureAux1x1 = magoManager.texturesManager.getTextureAux1x1();
		
		// provisionally render all native projects.***
		gl.enableVertexAttribArray(currentShader.normal3_loc);
		gl.enableVertexAttribArray(currentShader.color4_loc);

		gl.uniform1i(currentShader.bUse1Color_loc, false);
		if (color)
		{
			gl.uniform4fv(currentShader.oneColor4_loc, [color.r, color.g, color.b, 1.0]); //.***
		}
		else 
		{
			gl.uniform4fv(currentShader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.***
		}
		
		gl.uniform1i(currentShader.bUseNormal_loc, true);

		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.***
		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
		gl.activeTexture(gl.TEXTURE2); 
		gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
	}
	
	var neoBuilding;
	var natProject, mesh;
	var geoLocDataManager;
	var buildingGeoLocation;
	var nodesCount = nodesArray.length;
	for (var b=0; b<nodesCount; b++)
	{
		node = nodesArray[b];
		neoBuilding = node.data.neoBuilding;

		gl.uniform3fv(currentShader.scale_loc, [1, 1, 1]); //.***
		var buildingGeoLocation = node.getNodeGeoLocDataManager().getCurrentGeoLocationData();
		
		buildingGeoLocation.bindGeoLocationUniforms(gl, currentShader);
		gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
		
		magoManager.renderer.renderObject(gl, magoManager.axisXYZ, magoManager, currentShader, renderType);
	}
	

	currentShader.disableVertexAttribArrayAll();
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.activeTexture(gl.TEXTURE2); 
	gl.bindTexture(gl.TEXTURE_2D, null);
	
	gl.disable(gl.BLEND);
};

/**
 * This function renders the bounding boxex of nodes included in nodesArray.
 * @param {Array} nodesArray Nodes that render the bbox.
 * @param {Color} color The color of the bounding box.
 * @param {Boolean} bRenderLines Parameter that indicates if render the edges of the bounding box.
 */
Renderer.prototype.renderBoundingBoxesNodes = function(nodesArray, color, bRenderLines) 
{
	var magoManager = this.magoManager;
	var gl = magoManager.getGl();
	
	if (nodesArray === undefined || nodesArray.length === 0)
	{ return; }
	
	if (magoManager.unitaryBoxSC === undefined)
	{
		magoManager.unitaryBoxSC = new BoxAux();
		magoManager.unitaryBoxSC.makeAABB(1.0, 1.0, 1.0); // make a unitary box.***
		magoManager.unitaryBoxSC.vBOVertexIdxCacheKey = magoManager.unitaryBoxSC.triPolyhedron.getVBOArrayModePosNorCol(magoManager.unitaryBoxSC.vBOVertexIdxCacheKey, magoManager.vboMemoryManager);
	}
	
	var node;
	var currentShader = magoManager.postFxShadersManager.getTriPolyhedronShader(); // box ssao.***
	var shaderProgram = currentShader.program;
	gl.enable(gl.BLEND);
	gl.frontFace(gl.CCW);
	gl.useProgram(shaderProgram);
	currentShader.disableVertexAttribArrayAll();

	gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, magoManager.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
	gl.uniformMatrix4fv(currentShader.modelViewMatrix4RelToEye_loc, false, magoManager.sceneState.modelViewRelToEyeMatrix._floatArrays); // original.***
	gl.uniformMatrix4fv(currentShader.modelViewMatrix4_loc, false, magoManager.sceneState.modelViewMatrix._floatArrays);
	gl.uniformMatrix4fv(currentShader.projectionMatrix4_loc, false, magoManager.sceneState.projectionMatrix._floatArrays);
	gl.uniform3fv(currentShader.cameraPosHIGH_loc, magoManager.sceneState.encodedCamPosHigh);
	gl.uniform3fv(currentShader.cameraPosLOW_loc, magoManager.sceneState.encodedCamPosLow);

	gl.uniform1f(currentShader.near_loc, magoManager.sceneState.camera.frustum.near);
	gl.uniform1f(currentShader.far_loc, magoManager.sceneState.camera.frustum.far);
	
	gl.uniform1i(currentShader.bApplySsao_loc, false);

	gl.uniformMatrix4fv(currentShader.normalMatrix4_loc, false, magoManager.sceneState.normalMatrix4._floatArrays);
	//-----------------------------------------------------------------------------------------------------------

	gl.uniform1i(currentShader.hasAditionalMov_loc, true);
	gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
	gl.uniform1i(currentShader.bScale_loc, true);
	var alfa = 1.0;
	gl.uniform1i(currentShader.bUse1Color_loc, true);
	if (color)
	{
		gl.uniform4fv(currentShader.oneColor4_loc, [color.r, color.g, color.b, alfa]); //.***
	}
	else 
	{
		gl.uniform4fv(currentShader.oneColor4_loc, [1.0, 0.0, 1.0, alfa]); //.***
	}

	gl.uniform1i(currentShader.depthTex_loc, 0);
	gl.uniform1i(currentShader.noiseTex_loc, 1);
	gl.uniform1i(currentShader.diffuseTex_loc, 2); // no used.***
	gl.uniform1f(currentShader.fov_loc, magoManager.sceneState.camera.frustum.fovyRad);	// "frustum._fov" is in radians.***
	gl.uniform1f(currentShader.aspectRatio_loc, magoManager.sceneState.camera.frustum.aspectRatio);
	gl.uniform1f(currentShader.screenWidth_loc, magoManager.sceneState.drawingBufferWidth);	
	gl.uniform1f(currentShader.screenHeight_loc, magoManager.sceneState.drawingBufferHeight);

	var noiseTexture = magoManager.texturesManager.getNoiseTexture4x4();
	gl.uniform2fv(currentShader.noiseScale2_loc, [magoManager.depthFboNeo.width/noiseTexture.width, magoManager.depthFboNeo.height/noiseTexture.height]);
	gl.uniform3fv(currentShader.kernel16_loc, magoManager.kernel);
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, noiseTexture);

	var neoBuilding;
	var bbox;
	var ssao_idx = 1;
	var nodesCount = nodesArray.length;
	for (var b=0; b<nodesCount; b++)
	{
		currentShader.resetLastBuffersBinded();
		
		node = nodesArray[b];
		neoBuilding = node.data.neoBuilding;
		bbox = node.getBBox();

		gl.uniform3fv(currentShader.scale_loc, [bbox.getXLength(), bbox.getYLength(), bbox.getZLength()]); //.***
		var buildingGeoLocation = node.getNodeGeoLocDataManager().getCurrentGeoLocationData();
		
		buildingGeoLocation.bindGeoLocationUniforms(gl, currentShader);

		magoManager.pointSC = bbox.getCenterPoint(magoManager.pointSC);
		gl.uniform3fv(currentShader.aditionalMov_loc, [magoManager.pointSC.x, magoManager.pointSC.y, magoManager.pointSC.z]); //.***
		//gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
		magoManager.renderer.renderObject(gl, magoManager.unitaryBoxSC, magoManager, currentShader, ssao_idx, bRenderLines);
	}

	currentShader.resetLastBuffersBinded();
	currentShader.disableVertexAttribArrayAll();
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.activeTexture(gl.TEXTURE2); 
	gl.bindTexture(gl.TEXTURE_2D, null);
	
	gl.disable(gl.BLEND);
};

/**
 * This function renders a quad fitted to the screen.
 */
Renderer.prototype.renderFilter = function() 
{
	var magoManager = this.magoManager;
	var gl = magoManager.getGl();
	
	if (magoManager.screenQuad === undefined)
	{
		var sceneState = magoManager.sceneState;
		var camera = magoManager.myCameraSCX;
		var frustum = camera.bigFrustum;
		
		var fovyRad = magoManager.sceneState.camera.frustum.fovyRad;
		var aspectRatio = frustum.aspectRatio[0];
		var halfHeight = frustum.tangentOfHalfFovy[0];
		var halfWidth = halfHeight * aspectRatio;
		
		var lb = new Point3D(-halfWidth, -halfHeight, -1.0); // leftBottom.***
		var rb = new Point3D(halfWidth, -halfHeight, -1.0); // rightBottom.***
		var ru = new Point3D(halfWidth, halfHeight, -1.0); // rightUp.***
		var lu = new Point3D(-halfWidth, halfHeight, -1.0); // leftUp.***
	
		var data = new Float32Array([lb.x, lb.y, lb.z,   rb.x, rb.y, rb.z,   lu.x, lu.y, lu.z,   
			rb.x, rb.y, rb.z,   ru.x, ru.y, ru.z,   lu.x, lu.y, lu.z]);
		magoManager.screenQuad = FBO.createBuffer(gl, data);
	}
	
	var shaderName = "filterSilhouette"; 
	var currentShader = magoManager.postFxShadersManager.getShader(shaderName); 
	currentShader.useProgram();
	gl.uniform1i(currentShader.bApplySsao_loc, true); // apply ssao default.***
	
	var noiseTexture = magoManager.texturesManager.getNoiseTexture4x4();
	
	gl.enable(gl.BLEND);
	gl.disable(gl.DEPTH_TEST);
	gl.enableVertexAttribArray(currentShader.position3_loc);
	
	currentShader.bindUniformGenerals();
	gl.uniform1i(currentShader.textureFlipYAxis_loc, magoManager.sceneState.textureFlipYAxis);

	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
	gl.activeTexture(gl.TEXTURE2); 
	//gl.bindTexture(gl.TEXTURE_2D, magoManager.textureAux_1x1);
	//currentShader.last_tex_id = magoManager.textureAux_1x1;
	
	// do render.***
	gl.bindBuffer(gl.ARRAY_BUFFER, magoManager.screenQuad);
	gl.vertexAttribPointer(currentShader.position3_loc, 3, gl.FLOAT, false, 0, 0);
	gl.drawArrays(gl.TRIANGLES, 0, 6);
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, null);
	//gl.activeTexture(gl.TEXTURE2);
	//gl.bindTexture(gl.TEXTURE_2D, null);
	
	gl.disable(gl.BLEND);
	gl.enable(gl.DEPTH_TEST);
	
	currentShader.disableVertexAttribArrayAll();
	gl.useProgram(null);
};

/**
 * Renders the current frustumVolumen with colorCoding for selection.
 * @param {VisibleObjectsControler} visibleObjControlerBuildings Contains the current visible objects clasified by LOD.
 */
Renderer.prototype.renderGeometryColorCoding = function(visibleObjControlerNodes) 
{
	var magoManager = this.magoManager;
	var gl = magoManager.getGl();
	var renderType = 2; // 0 = depthRender, 1= colorRender, 2 = selectionRender.***
	
	//if (magoManager.selectionFbo.dirty) // todo.
	{
		var refTMatrixIdxKey = 0;
		var renderTexture = false;

		var currentShader = magoManager.postFxShadersManager.getShader("modelRefColorCoding"); 
		currentShader.useProgram();
		currentShader.enableVertexAttribArray(currentShader.position3_loc);
		currentShader.disableVertexAttribArray(currentShader.texCoord2_loc);
		currentShader.disableVertexAttribArray(currentShader.normal3_loc);
		
		currentShader.bindUniformGenerals();
		
		gl.disable(gl.CULL_FACE);
		// do the colorCoding render.***
		var minSizeToRender = 0.0;
		var renderType = 2;
		magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles0, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
		magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles2, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
		magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles3, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);

		gl.enable(gl.CULL_FACE);
		currentShader.disableVertexAttribArray(currentShader.position3_loc);
		gl.useProgram(null);
		
		// Render cuttingPlanes of temperaturalayers if exist.***
		if (magoManager.weatherStation)
		{ magoManager.weatherStation.test_renderCuttingPlanes(magoManager, renderType); }
	}
	
	if (magoManager.magoPolicy.objectMoveMode === CODE.moveMode.GEOGRAPHICPOINTS)
	{
		// render geographicCoords of the modeler.***
		if (magoManager.modeler !== undefined)
		{
			var shader = magoManager.postFxShadersManager.getShader("modelRefColorCoding"); 
			shader.useProgram();
			shader.enableVertexAttribArray(shader.position3_loc);
			shader.disableVertexAttribArray(shader.texCoord2_loc);
			shader.disableVertexAttribArray(shader.normal3_loc);
		
			shader.bindUniformGenerals();
			
			gl.disable(gl.CULL_FACE);
			magoManager.modeler.render(magoManager, shader, renderType);
		}
	}
};


/**
 * Mago geometries generation test.***
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 */
Renderer.prototype.renderMagoGeometries = function(renderType) 
{
	var magoManager = this.magoManager;
	
	// 1rst, make the test object if no exist.***
	return;
	
	if (magoManager.nativeProjectsArray === undefined)
	{
		magoManager.nativeProjectsArray = [];
		var natProject = new MagoNativeProject();
		magoManager.nativeProjectsArray.push(natProject);
		
		var pMesh = natProject.newParametricMesh();
		
		pMesh.profile = new Profile2D(); // provisional.***
		var profileAux = pMesh.profile; // provisional.***
		
		profileAux.TEST__setFigureHole_2();
		//profileAux.TEST__setFigure_1();
		
		if (pMesh.vboKeyContainer === undefined)
		{ pMesh.vboKeyContainer = new VBOVertexIdxCacheKeysContainer(); }
		
		if (pMesh.vboKeyContainerEdges === undefined)
		{ pMesh.vboKeyContainerEdges = new VBOVertexIdxCacheKeysContainer(); }
		
		var bIncludeBottomCap, bIncludeTopCap;
		var extrusionVector, extrusionDist, extrudeSegmentsCount;
		/*
		extrudeSegmentsCount = 120;
		extrusionDist = 15.0;
		pMesh.extrude(profileAux, extrusionDist, extrudeSegmentsCount, extrusionVector);
		*/
		
		var revolveAngDeg, revolveSegmentsCount, revolveSegment2d;
		revolveAngDeg = 90.0;
		revolveSegment2d = new Segment2D();
		var strPoint2d = new Point2D(20, -10);
		var endPoint2d = new Point2D(20, 10);
		revolveSegment2d.setPoints(strPoint2d, endPoint2d);
		revolveSegmentsCount = 24;
		pMesh.revolve(profileAux, revolveAngDeg, revolveSegmentsCount, revolveSegment2d);
		
		bIncludeBottomCap = true;
		bIncludeTopCap = true;
		var mesh = pMesh.getSurfaceIndependentMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
		mesh.setColor(0.1, 0.5, 0.5, 1.0);

		mesh.getVbo(pMesh.vboKeyContainer, magoManager.vboMemoryManager);
		mesh.getVboEdges(pMesh.vboKeyContainerEdges, magoManager.vboMemoryManager);
		
		// Now, provisionally make a geoLocationData for the nativeProject.*************************************
		if (natProject.geoLocDataManager === undefined)
		{
			natProject.geoLocDataManager = new GeoLocationDataManager();
			var geoLoc = natProject.geoLocDataManager.newGeoLocationData("deploymentLoc"); 
			
			var longitude = 126.61120237344926;
			var latitude = 37.577213509597016;
			var altitude = 50;
			var heading = 0.0;
			var pitch = 0.0;
			var roll = 0.0;

			ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, heading, pitch, roll, geoLoc, magoManager);
		}
		
	}
	//---------------------------------------------------------------------------------------------------------------
	var gl = magoManager.sceneState.gl;
	var color;
	var node;
	var currentShader;
	if (renderType === 0)
	{
		currentShader = magoManager.postFxShadersManager.getShader("modelRefDepth"); 
		gl.disable(gl.BLEND);
	}
	if (renderType === 1)
	{
		currentShader = magoManager.postFxShadersManager.getShader("modelRefSsao"); 
		gl.enable(gl.BLEND);
	}
	
	
	// Test rendering by modelRefShader.****
	currentShader.useProgram();
	gl.uniform1i(currentShader.bApplySsao_loc, true); // apply ssao.***
	gl.uniform1i(currentShader.refMatrixType_loc, 0); // in magoManager case, there are not referencesMatrix.***
	gl.uniform1i(currentShader.colorType_loc, 1); // 0= oneColor, 1= attribColor, 2= texture.***
	gl.uniform1i(currentShader.bApplySpecularLighting_loc, true); // turn on/off specular lighting & normals.***
	
	// -------------------------------------
	
	currentShader.disableVertexAttribArray(currentShader.texCoord2_loc);
	
	var shaderProgram = currentShader.program;
	currentShader.bindUniformGenerals();
	gl.enableVertexAttribArray(currentShader.position3_loc);
		
	if (renderType === 1)
	{
		var textureAux1x1 = magoManager.texturesManager.getTextureAux1x1();
		var noiseTexture = magoManager.texturesManager.getNoiseTexture4x4();
		
		// provisionally render all native projects.***
		gl.enableVertexAttribArray(currentShader.normal3_loc);
		gl.enableVertexAttribArray(currentShader.color4_loc);

		gl.uniform1i(currentShader.bUse1Color_loc, false);
		if (color)
		{
			gl.uniform4fv(currentShader.oneColor4_loc, [color.r, color.g, color.b, 1.0]); //.***
		}
		else 
		{
			gl.uniform4fv(currentShader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.***
		}
		
		gl.uniform1i(currentShader.bUseNormal_loc, true);
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.***
		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
		gl.activeTexture(gl.TEXTURE2); 
		gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
	}
	
	var neoBuilding;
	var natProject, pMesh;
	var geoLocDataManager;
	var buildingGeoLocation;
	var bRenderLines = false;
	var nativeProjectsCount = magoManager.nativeProjectsArray.length;
	for (var i=0; i<nativeProjectsCount; i++)
	{
		natProject = magoManager.nativeProjectsArray[i];
		geoLocDataManager = natProject.geoLocDataManager;
		
		gl.uniform3fv(currentShader.scale_loc, [1, 1, 1]); //.***
		buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		buildingGeoLocation.bindGeoLocationUniforms(gl, currentShader);

		gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
		
		var meshesCount = natProject.getMeshesCount();
		for (var j=0; j<meshesCount; j++)
		{
			pMesh = natProject.getMesh(j);
			magoManager.renderer.renderObject(gl, pMesh, magoManager, currentShader, renderType, bRenderLines);
		}
	}
	
	if (currentShader)
	{
		if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
		if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
		if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
		if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
	}
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.activeTexture(gl.TEXTURE2); 
	gl.bindTexture(gl.TEXTURE_2D, null);
	
	gl.disable(gl.BLEND);
	
};






'use strict';

/**
 * This class contains the camera transformation matrices and other parameters that affects the scene.
 * @class SceneState
 */
var SceneState = function() 
{
	if (!(this instanceof SceneState)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.gl;

	// this contains the model matrices and camera position.
	this.modelViewProjRelToEyeMatrix = new Matrix4(); // created as identity matrix.
	this.modelViewRelToEyeMatrix = new Matrix4(); // created as identity matrix.
	this.modelViewRelToEyeMatrixInv = new Matrix4(); // created as identity matrix.
	this.modelViewMatrix = new Matrix4(); // created as identity matrix.
	this.modelViewMatrixInv = new Matrix4(); // created as identity matrix.
	this.projectionMatrix = new Matrix4(); // created as identity matrix.
	this.modelViewProjMatrix = new Matrix4(); // created as identity matrix.
	this.normalMatrix4 = new Matrix4(); // created as identity matrix.
	this.identityMatrix4 = new Matrix4(); // created as identity matrix.

	this.encodedCamPosHigh = new Float32Array([0.0, 0.0, 0.0]);
	this.encodedCamPosLow = new Float32Array([0.0, 0.0, 0.0]);
	
	this.camera = new Camera();
	this.drawingBufferWidth = new Int32Array([1000]);
	this.drawingBufferHeight = new Int32Array([1000]);
	this.mouseAction = new MouseAction();
	
	// lighting & ssao.
	this.ambientReflectionCoef = new Float32Array([0.45]); // 0.2.
	this.diffuseReflectionCoef = new Float32Array([0.75]); // 1.0
	this.specularReflectionCoef = new Float32Array([0.6]); // 0.7
	this.specularColor = new Float32Array([0.7, 0.7, 0.7]);
	this.ssaoRadius = new Float32Array([0.15]);
	this.shininessValue = new Float32Array([40.0]);
	this.ssaoNoiseScale2 = new Float32Array([1.0, 1.0]); // [this.depthFboNeo.width[0]/this.noiseTexture.width, this.depthFboNeo.height[0]/this.noiseTexture.height]
	this.ssaoKernel16 = new Float32Array([ 0.33, 0.0, 0.85,
		0.25, 0.3, 0.5,
		0.1, 0.3, 0.85,
		-0.15, 0.2, 0.85,
		-0.33, 0.05, 0.6,
		-0.1, -0.15, 0.85,
		-0.05, -0.32, 0.25,
		0.2, -0.15, 0.85,
		0.6, 0.0, 0.55,
		0.5, 0.6, 0.45,
		-0.01, 0.7, 0.35,
		-0.33, 0.5, 0.45,
		-0.45, 0.0, 0.55,
		-0.65, -0.5, 0.7,
		0.0, -0.5, 0.55,
		0.33, 0.3, 0.35]);
		
	this.ssaoSphereKernel32 = new Float32Array([ 0.33, 0.0, 0.85,
		0.25, 0.3, 0.5,
		0.1, 0.3, 0.85,
		-0.15, 0.2, 0.85,
		-0.33, 0.05, 0.6,
		-0.1, -0.15, 0.85,
		-0.05, -0.32, 0.25,
		0.2, -0.15, 0.85,
		0.6, 0.0, 0.55,
		0.5, 0.6, 0.45,
		-0.01, 0.7, 0.35,
		-0.33, 0.5, 0.45,
		-0.45, 0.0, 0.55,
		-0.65, -0.5, 0.7,
		0.0, -0.5, 0.55,
		0.33, 0.3, 0.35,
		
		 0.33, 0.0, -0.85,
		0.25, 0.3, -0.5,
		0.1, 0.3, -0.85,
		-0.15, 0.2, -0.85,
		-0.33, 0.05, -0.6,
		-0.1, -0.15, -0.85,
		-0.05, -0.32, -0.25,
		0.2, -0.15, -0.85,
		0.6, 0.0, -0.55,
		0.5, 0.6, -0.45,
		-0.01, 0.7, -0.35,
		-0.33, 0.5, -0.45,
		-0.45, 0.0, -0.55,
		-0.65, -0.5, -0.7,
		0.0, -0.5, -0.55,
		0.33, 0.3, -0.35]);
		
	this.bMust = false;
	
	// webWorldWind vars.
	this.dc;
	
	// insertIssue states.
	this.insertIssueState = 0; // 0 = no started. 1 = started.
	
	// provisionally.
	this.textureFlipYAxis = false;
	
	// mouse.
	this.mouseButton = -1;
	
};

/**
 * Returns the modelViewMatrixInverse.
 * @returns {Matrix4} modelViewMatrixInv.
 */
SceneState.prototype.getModelViewMatrixInv = function() 
{
	return this.modelViewMatrixInv;
};

































'use strict';

// NO USED.

/**
 * 어떤 일을 하고 있습니까?
 * @class Selection
 */
var Selection = function() 
{
	if (!(this instanceof Selection)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.drawing_height;
	this.drawing_width;
	this.GAIA_selectFrameBuffer;
	this.GAIA_selectRenderBuffer;
	this.GAIA_selectRttTexture;
	
	this.currentByteColorPicked = new Uint8Array(4);
	this.currentSelectedObj_idx = -1;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param drawingBufferWidth 변수
 * @param drawingBufferHeight 변수
 */
Selection.prototype.init = function(gl, drawingBufferWidth, drawingBufferHeight) 
{
	// http://www.webglacademy.com/courses.php?courses=0|1|20|2|3|4|23|5|6|7|10#10
	this.drawing_height = drawingBufferHeight;
	this.drawing_width = drawingBufferWidth;
	//this.lastCapturedColourMap = new Uint8Array(this.drawing_width * this.drawing_height * 4);
	this.GAIA_selectFrameBuffer = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, this.GAIA_selectFrameBuffer);
	
	this.GAIA_selectRenderBuffer = gl.createRenderbuffer();
	gl.bindRenderbuffer(gl.RENDERBUFFER, this.GAIA_selectRenderBuffer);
	gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.drawing_width, this.drawing_height);

	this.GAIA_selectRttTexture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, this.GAIA_selectRttTexture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.drawing_width, this.drawing_height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.GAIA_selectRttTexture, 0);
	gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.GAIA_selectRenderBuffer);
	
	// Finally...
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};
'use strict';

/**
 * SelectionCandidateFamily
 * 
 * @alias SelectionCandidateFamily
 * @class SelectionCandidateFamily
 */
var SelectionCandidateFamily = function() 
{
	if (!(this instanceof SelectionCandidateFamily)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.familyTypeName;
	this.candidatesMap = {};
	this.currentSelected;
};

/**
 */
SelectionCandidateFamily.prototype.setCandidate = function(idxKey, candidate)
{
	if (idxKey !== undefined && candidate)
	{
		this.candidatesMap[idxKey] = candidate;
	}
};

/**
 * SelectionCandidateFamily
 */
SelectionCandidateFamily.prototype.clearCandidate = function()
{
	this.candidatesMap = {};
	this.currentSelected = undefined;
};

/**
 * SelectionCandidateFamily
 */
SelectionCandidateFamily.prototype.clearCurrentSelected = function()
{
	this.currentSelected = undefined;
};

/**
 * SelectionCandidateFamily
 */
SelectionCandidateFamily.prototype.selectObject = function(idxKey)
{
	this.currentSelected = this.candidatesMap[idxKey];
	return this.currentSelected;
};

'use strict';

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
var SelectionManager = function() 
{
	if (!(this instanceof SelectionManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// Default f4d objectsMap.
	this.referencesMap = {};
	this.octreesMap = {};
	this.buildingsMap = {};
	this.nodesMap = {};
	
	this.currentReferenceSelected;
	this.currentOctreeSelected;
	this.currentBuildingSelected;
	this.currentNodeSelected;
	
	// Custom candidates.
	this.selCandidatesFamilyMap = {};
	
	// General candidates.
	this.selCandidatesMap = {};
	this.currentGeneralObjectSelected;
	
	// Parameter that indicates that we are rendering selected data structure.
	this.parentSelected = false;
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.newCandidatesFamily = function(candidatesFamilyTypeName)
{
	var selCandidate = new SelectionCandidateFamily();
	selCandidate.familyTypeName = candidatesFamilyTypeName;
	this.selCandidatesFamilyMap[candidatesFamilyTypeName] = selCandidate;
	return selCandidate;
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.getSelectionCandidatesFamily = function(familyName)
{
	return this.selCandidatesFamilyMap[familyName];
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.setCandidateCustom = function(idxKey, familyName, object)
{
	var selCandidatesFamily = this.getSelectionCandidatesFamily(familyName);
	if (selCandidatesFamily)
	{
		selCandidatesFamily.setCandidate(idxKey, object);
	}
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.setCandidateGeneral = function(idxKey, candidateObject)
{
	this.selCandidatesMap[idxKey] = candidateObject;
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.getCandidateGeneral = function(idxKey)
{
	return this.selCandidatesMap[idxKey];
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.getSelectedGeneral = function()
{
	return this.currentGeneralObjectSelected;
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.setCandidates = function(idxKey, reference, octree, building, node)
{
	if (reference)
	{
		this.referencesMap[idxKey] = reference;
	}
	
	if (octree)
	{
		this.octreesMap[idxKey] = octree;
	}
	
	if (building)
	{
		this.buildingsMap[idxKey] = building;
	}
	
	if (node)
	{
		this.nodesMap[idxKey] = node;
	}
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.clearCandidates = function()
{
	this.referencesMap = {};
	this.octreesMap = {};
	this.buildingsMap = {};
	this.nodesMap = {};
	
	for (var key in this.selCandidatesFamilyMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.selCandidatesFamilyMap, key))
		{
			var selCandidateFamily = this.selCandidatesFamilyMap[key];
			selCandidateFamily.clearCandidate();
		}

	}
	
	// General selection candidates map.
	this.selCandidatesMap = {};
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.selectObjects = function(idxKey)
{
	this.currentReferenceSelected = this.referencesMap[idxKey];
	this.currentOctreeSelected = this.octreesMap[idxKey];
	this.currentBuildingSelected = this.buildingsMap[idxKey];
	this.currentNodeSelected = this.nodesMap[idxKey];
	
	for (var key in this.selCandidatesFamilyMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.selCandidatesFamilyMap, key))
		{
			var selCandidateFamily = this.selCandidatesFamilyMap[key];
			selCandidateFamily.selectObject(idxKey);
		}
	}
	
	this.currentGeneralObjectSelected = this.selCandidatesMap[idxKey];
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.clearCurrents = function(idxKey)
{
	this.currentReferenceSelected = undefined;
	this.currentOctreeSelected = undefined;
	this.currentBuildingSelected = undefined;
	this.currentNodeSelected = undefined;
	
	for (var key in this.selCandidatesFamilyMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.selCandidatesFamilyMap, key))
		{
			var selCandidateFamily = this.selCandidatesFamilyMap[key];
			selCandidateFamily.clearCurrentSelected();
		}
	}
	
	this.currentGeneralObjectSelected = undefined;
};

'use strict';

/**
 * Network.
 * 
 * @alias Network
 * @class Network
 */
var Network = function(owner) 
{
	if (!(this instanceof Network)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.nodeOwner;
	if (owner)
	{ this.nodeOwner = owner; }
	
	this.id; // network id.
	this.nodesArray;
	this.edgesArray;
	this.spacesArray;
	
	this.attributes;
	this.edgesVboKeysContainer; // to draw edges with an unique vbo.
	this.nodesVboKeysContainer; // to draw nodes with an unique vbo.
	
	this.renderSpaces = true;
	this.spacesAlpha = 0.2;
};

/**
 * 
 */
Network.prototype.newNode = function()
{
	if (this.nodesArray === undefined)
	{ this.nodesArray = []; }
	
	var networkNode = new NetworkNode(this);
	this.nodesArray.push(networkNode);
	return networkNode;
};

/**
 * 
 */
Network.prototype.newEdge = function()
{
	if (this.edgesArray === undefined)
	{ this.edgesArray = []; }
	
	var networkEdge = new NetworkEdge(this);
	this.edgesArray.push(networkEdge);
	return networkEdge;
};

/**
 * 
 */
Network.prototype.newSpace = function()
{
	if (this.spacesArray === undefined)
	{ this.spacesArray = []; }
	
	var networkSpace = new NetworkSpace(this);
	this.spacesArray.push(networkSpace);
	return networkSpace;
};

/**
 * 
 */
Network.prototype.test__makeVbos = function(magoManager)
{
	// Here makes meshes and vbos.
	// For edges, make an unique vbo for faster rendering.
	var edgesCount = 0;
	if (this.edgesArray)
	{ edgesCount = this.edgesArray.length; }
	
	var pointsArray = [];
	
	for (var i=0; i<edgesCount; i++)
	{
		var edge = this.edgesArray[i];
		var vtxSegment = edge.vtxSegment;
		var point1 = vtxSegment.startVertex.point3d;
		var point2 = vtxSegment.endVertex.point3d;
		pointsArray.push(point1.x);
		pointsArray.push(point1.y);
		pointsArray.push(point1.z);
		
		pointsArray.push(point2.x);
		pointsArray.push(point2.y);
		pointsArray.push(point2.z);
	}
	
	if (this.edgesVboKeysContainer === undefined)
	{
		this.edgesVboKeysContainer = new VBOVertexIdxCacheKeysContainer();
	}
	
	var vboKey = this.edgesVboKeysContainer.newVBOVertexIdxCacheKey();
	
	var vboMemManager = magoManager.vboMemoryManager;
	var pointsCount = edgesCount * 2;
	var posByteSize = pointsCount * 3;
	var classifiedPosByteSize = vboMemManager.getClassifiedBufferSize(posByteSize);
	vboKey.posVboDataArray = new Float32Array(classifiedPosByteSize);
	vboKey.posVboDataArray.set(pointsArray);
	vboKey.posArrayByteSize = pointsArray.length;
	vboKey.segmentsCount = edgesCount;
	
};

/**
 * start rendering.
 * @param scene 변수
 * @param isLastFrustum 변수
 */
Network.prototype.parseTopologyData = function(magoManager, gmlDataContainer) 
{
	// gmlDataContainer.cellSpaceMembers
	// gmlDataContainer.edges
	// gmlDataContainer.nodes
	// cityGML Lower point (78.02094, -82.801873, 18).
	// cityGML Upper point (152.17466, 19.03087, 39).
	// cityGML Center point {x=115.09780549999999 y=-31.885501999999999 z=28.500000000000000 ...}
	
	var bbox = new BoundingBox();
	bbox.minX = gmlDataContainer.min_X;
	bbox.minY = gmlDataContainer.min_Y;
	bbox.minZ = gmlDataContainer.min_Z;
	bbox.maxX = gmlDataContainer.max_X;
	bbox.maxY = gmlDataContainer.max_Y;
	bbox.maxZ = gmlDataContainer.max_Z;
	
	//bbox.maxX = 56.19070816040039;
	//bbox.maxY = 71.51078033447266;
	//bbox.maxZ = 10.5;
	//bbox.minX = -379.18280029296875;
	//bbox.minY = -142.4878387451172;
	//bbox.minZ = -46.5;
	
	var offsetVector = new Point3D();
	var zOffset = 0.1;
	offsetVector.set(-115.0978055, 31.885502, -28.5); // cityGML ORIGINAL Center point inversed.
	
	var nodesMap = {};
	var nodesCount = gmlDataContainer.nodes.length;
	for (var i=0; i<nodesCount; i++)
	{
		var node = gmlDataContainer.nodes[i];
		var networkNode = this.newNode();
		networkNode.id = "#" + node.id;
		
		networkNode.position = new Point3D(node.coordinates[0], node.coordinates[1], node.coordinates[2]);
		networkNode.position.addPoint(offsetVector); // rest bbox centerPoint.
		networkNode.position.add(0.0, 0.0, zOffset); // aditional pos.
		networkNode.box = new Box(0.6, 0.6, 0.6);
		
		nodesMap[networkNode.id] = networkNode;
	}
	
	
	var cellSpaceMap = {};
	var cellSpacesCount = gmlDataContainer.cellSpaceMembers.length;
	for (var i=0; i<cellSpacesCount; i++)
	{
		var cellSpace = gmlDataContainer.cellSpaceMembers[i];
		var id = cellSpace.href;
		var networkSpace = this.newSpace();
		var mesh = new Mesh();
		networkSpace.mesh = mesh; // assign mesh to networkSpace provisionally.
		var vertexList = mesh.getVertexList();
		
		var surfacesMembersCount = cellSpace.surfaceMember.length;
		for (var j=0; j<surfacesMembersCount; j++)
		{
			var surface = mesh.newSurface();
			var face = surface.newFace();
			
			var coordinates = cellSpace.surfaceMember[j].coordinates;
			var coordinatedCount = coordinates.length;
			var pointsCount = coordinatedCount/3;
			
			for (var k=0; k<pointsCount; k++)
			{
				var x = coordinates[k * 3];
				var y = coordinates[k * 3 + 1];
				var z = coordinates[k * 3 + 2];
				
				var vertex = vertexList.newVertex();
				vertex.setPosition(x, y, z);
				vertex.point3d.addPoint(offsetVector); // rest bbox centerPoint.
				face.addVertex(vertex);
				
			}
			face.solveUroborus(); // Check & solve if the last point is coincident with the 1rst point.
			face.calculateVerticesNormals();
		}
		
		cellSpaceMap[cellSpace.href] = cellSpace;
	}
	
	var edgesCount = gmlDataContainer.edges.length;
	for (var i=0; i<edgesCount; i++)
	{
		var edge = gmlDataContainer.edges[i];
		var networkEdge = this.newEdge();
		
		var point1 = edge.stateMembers[0].coordinates;
		var point2 = edge.stateMembers[1].coordinates;
		var vertex1 = new Vertex();
		var vertex2 = new Vertex();
		vertex1.setPosition(point1[0], point1[1], point1[2]);
		vertex2.setPosition(point2[0], point2[1], point2[2]);
		vertex1.point3d.addPoint(offsetVector); // rest bbox centerPoint.
		vertex1.point3d.add(0.0, 0.0, zOffset); // aditional pos.
		vertex2.point3d.addPoint(offsetVector); // rest bbox centerPoint.
		vertex2.point3d.add(0.0, 0.0, zOffset); // aditional pos.
		var vtxSegment = new VtxSegment(vertex1, vertex2);
		networkEdge.vtxSegment = vtxSegment; // assign vtxSegment to networkEdge provisionally.
		
		var connect_1_id = edge.connects[0];
		var connect_2_id = edge.connects[1];
		
		networkEdge.strNodeId = connect_1_id;
		networkEdge.endNodeId = connect_2_id;
	}
	
	this.test__makeVbos(magoManager);
};

/**
 * 
 */
Network.prototype.renderColorCoding = function(magoManager, shader, renderType)
{
	// Provisional function.
	// render nodes & edges.
	var selectionColor = magoManager.selectionColor;
	//selectionColor.init(); 
	
	// Check if exist selectionFamilies.
	var selFamilyNameNodes = "networkNodes";
	var selManager = magoManager.selectionManager;
	var selCandidateNodes = selManager.getSelectionCandidatesFamily(selFamilyNameNodes);
	if (selCandidateNodes === undefined)
	{
		selCandidateNodes = selManager.newCandidatesFamily(selFamilyNameNodes);
	}
	
	var selFamilyNameEdges = "networkEdges";
	var selManager = magoManager.selectionManager;
	var selCandidateEdges = selManager.getSelectionCandidatesFamily(selFamilyNameEdges);
	if (selCandidateEdges === undefined)
	{
		selCandidateEdges = selManager.newCandidatesFamily(selFamilyNameEdges);
	}
	
	var vboMemManager = magoManager.vboMemoryManager;
	var gl = magoManager.sceneState.gl;
	var vboKey;
	
	shader.disableVertexAttribArray(shader.texCoord2_loc); 
	shader.enableVertexAttribArray(shader.normal3_loc); 
	gl.uniform1i(shader.hasTexture_loc, false); //.
	gl.uniform4fv(shader.oneColor4_loc, [0.8, 0.8, 0.8, 1.0]);
	
	if (!shader.last_isAditionalMovedZero)
	{
		gl.uniform1i(shader.hasAditionalMov_loc, false);
		gl.uniform3fv(shader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.
		shader.last_isAditionalMovedZero = true;
	}
	
	// Nodes.**
	var nodesCount = 0;
	if (this.nodesArray)
	{ nodesCount = this.nodesArray.length; }
	
	if (nodesCount > 0 )//&& !magoManager.isCameraMoving)
	{
		var refMatrixType = 1; // translation-type.
		gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
		//gl.uniform4fv(shader.oneColor4_loc, [0.3, 0.3, 0.9, 1.0]);
		var nodeMaster = this.nodesArray[0]; // render all with an unique box.
		for (var i=0; i<nodesCount; i++)
		{
			var node = this.nodesArray[i];
			
			// nodes has a position, so render a point or a box.
			gl.uniform3fv(shader.refTranslationVec_loc, [node.position.x, node.position.y, node.position.z]); 
			
			var selColor4 = selectionColor.getAvailableColor(undefined); // new.
			var idxKey = selectionColor.decodeColor3(selColor4.r, selColor4.g, selColor4.b);
			selManager.setCandidateCustom(idxKey, selFamilyNameNodes, node);
			gl.uniform4fv(shader.oneColor4_loc, [selColor4.r/255.0, selColor4.g/255.0, selColor4.b/255.0, 1.0]);

			nodeMaster.box.render(magoManager, shader, renderType);
			
		}
	}
	
	// Edges.**
	// Render with a unique vbo.
	if (this.edgesVboKeysContainer)
	{
		var vboKey = this.edgesVboKeysContainer.vboCacheKeysArray[0];
		if (vboKey.isReadyPositions(gl, vboMemManager))
		{ 
			shader.disableVertexAttribArray(shader.texCoord2_loc); 
			shader.disableVertexAttribArray(shader.normal3_loc); 
			refMatrixType = 0;
			gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
			
			// Positions.
			if (vboKey.meshVertexCacheKey !== shader.last_vboPos_binded)
			{
				gl.bindBuffer(gl.ARRAY_BUFFER, vboKey.meshVertexCacheKey);
				gl.vertexAttribPointer(shader.position3_loc, 3, gl.FLOAT, false, 0, 0);
				shader.last_vboPos_binded = vboKey.meshVertexCacheKey;
			}
				
			var edgesCount = this.edgesArray.length;
			for (var i=0; i<edgesCount; i++)
			{
				var edge = this.edgesArray[i];
				var selColor4 = selectionColor.getAvailableColor(undefined); // new.
				var idxKey = selectionColor.decodeColor3(selColor4.r, selColor4.g, selColor4.b);
				selManager.setCandidateCustom(idxKey, selFamilyNameEdges, edge);
				gl.uniform4fv(shader.oneColor4_loc, [selColor4.r/255.0, selColor4.g/255.0, selColor4.b/255.0, 1.0]);
				gl.drawArrays(gl.LINES, i*2, 2);
			}
		}
	}
	
};

/**
 * 
 */
Network.prototype.render = function(magoManager, shader, renderType)
{
	if (renderType === 2)
	{
		this.renderColorCoding(magoManager, shader, renderType);
		return;
	}
	
	// Check if ready smallBox and bigBox.
	var selectionColor = magoManager.selectionColor;
	selectionColor.init(); 
	
	// Check if exist selectionFamilies.
	var selFamilyNameNodes = "networkNodes";
	var selManager = magoManager.selectionManager;
	var selCandidateNodes = selManager.getSelectionCandidatesFamily(selFamilyNameNodes);
	if (selCandidateNodes === undefined)
	{
		selCandidateNodes = selManager.newCandidatesFamily(selFamilyNameNodes);
	}
	
	var selFamilyNameEdges = "networkEdges";
	var selManager = magoManager.selectionManager;
	var selCandidateEdges = selManager.getSelectionCandidatesFamily(selFamilyNameEdges);
	if (selCandidateEdges === undefined)
	{
		selCandidateEdges = selManager.newCandidatesFamily(selFamilyNameEdges);
	}
	
	// Provisional function.
	// render nodes & edges.
	var vboMemManager = magoManager.vboMemoryManager;
	var gl = magoManager.sceneState.gl;
	var vboKey;
	
	shader.disableVertexAttribArray(shader.texCoord2_loc); 
	shader.enableVertexAttribArray(shader.normal3_loc); 
	
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform4fv(shader.oneColor4_loc, [0.8, 0.8, 0.8, 1.0]);
	
	if (!shader.last_isAditionalMovedZero)
	{
		gl.uniform1i(shader.hasAditionalMov_loc, false);
		gl.uniform3fv(shader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.
		shader.last_isAditionalMovedZero = true;
	}
	
	// Nodes.**
	var nodesCount = 0;
	if (this.nodesArray)
	{ nodesCount = this.nodesArray.length; }
	
	if (nodesCount > 0 )//&& !magoManager.isCameraMoving)
	{
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		var refMatrixType = 1; // translation-type.
		gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
		gl.uniform4fv(shader.oneColor4_loc, [0.3, 0.3, 0.9, 1.0]);
		var nodeMaster = this.nodesArray[0]; // render all with an unique box.
		for (var i=0; i<nodesCount; i++)
		{
			var node = this.nodesArray[i];
			
			// check if is selected.
			if (node === selCandidateNodes.currentSelected)
			{
				gl.uniform4fv(shader.oneColor4_loc, [0.9, 0.5, 0.1, 1.0]);
			}
			
			// nodes has a position, so render a point or a box.
			gl.uniform3fv(shader.refTranslationVec_loc, [node.position.x, node.position.y, node.position.z]); 
			nodeMaster.box.render(magoManager, shader, renderType);
			
			// restore defaultColor.
			if (node === selCandidateNodes.currentSelected)
			{
				gl.uniform4fv(shader.oneColor4_loc, [0.3, 0.3, 0.9, 1.0]);
			}
		}
	}
	
	// Edges.**
	// Render with a unique vbo.
	if (this.edgesVboKeysContainer)
	{
		var vboKey = this.edgesVboKeysContainer.vboCacheKeysArray[0];
		if (vboKey.isReadyPositions(gl, vboMemManager))
		{ 
			shader.disableVertexAttribArray(shader.texCoord2_loc); 
			shader.disableVertexAttribArray(shader.normal3_loc); 
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			refMatrixType = 0;
			gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
			gl.uniform4fv(shader.oneColor4_loc, [0.1, 0.1, 0.6, 1.0]);
	
			// Positions.
			if (vboKey.meshVertexCacheKey !== shader.last_vboPos_binded)
			{
				gl.bindBuffer(gl.ARRAY_BUFFER, vboKey.meshVertexCacheKey);
				gl.vertexAttribPointer(shader.position3_loc, 3, gl.FLOAT, false, 0, 0);
				shader.last_vboPos_binded = vboKey.meshVertexCacheKey;
			}
			
			//gl.drawArrays(gl.LINES, 0, vboKey.segmentsCount*2);
			
			var edgesCount = this.edgesArray.length;
			for (var i=0; i<edgesCount; i++)
			{
				var edge = this.edgesArray[i];
				if (edge === selCandidateEdges.currentSelected)
				{
					gl.uniform4fv(shader.oneColor4_loc, [0.0, 1.0, 0.0, 1.0]);
				}
				gl.drawArrays(gl.LINES, i*2, 2);
				
				// restore default color.
				if (edge === selCandidateEdges.currentSelected)
				{
					gl.uniform4fv(shader.oneColor4_loc, [0.1, 0.1, 0.6, 1.0]);
				}
			}
		}
	}
	
	// Spaces.
	this.renderSpaces = magoManager.tempSettings.renderSpaces;
	this.spacesAlpha = magoManager.tempSettings.spacesAlpha;
	
	if (renderType === 1)
	{ shader.enableVertexAttribArray(shader.normal3_loc); } 
	
	if (this.renderSpaces)
	{
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		refMatrixType = 0;
		gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
		gl.uniform4fv(shader.oneColor4_loc, [0.8, 0.8, 0.8, this.spacesAlpha]);
		gl.enable(gl.BLEND);
		var spacesCount = 0;
		if (this.spacesArray)
		{ spacesCount = this.spacesArray.length; }
		
		for (var i=0; i<spacesCount; i++)
		{
			var space = this.spacesArray[i];
			space.mesh.render(magoManager, shader);
		}
		
		gl.disable(gl.BLEND);
	}
};







































'use strict';

/**
 * NetworkEdge.
 * 
 * @alias NetworkEdge
 * @class NetworkEdge
 */
var NetworkEdge = function(owner) 
{
	if (!(this instanceof NetworkEdge)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.networkOwner = owner;
	this.id;
	this.strNode;
	this.endNode;
	this.sense;
	this.attributes;
	
	// provisionally:
	this.strNodeId;
	this.endNodeId;
};
'use strict';

/**
 * NetworkNode.
 * 
 * @alias NetworkNode
 * @class NetworkNode
 */
var NetworkNode = function(owner) 
{
	if (!(this instanceof NetworkNode)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.networkOwner = owner;
	this.id;
	this.edgesArray;
	this.attributes;
	this.box;
	//this.mesh; // if display as a box, cilinder, etc.
};
'use strict';

/**
 * NetworkSpace.
 * 
 * @alias NetworkSpace
 * @class NetworkSpace
 */
var NetworkSpace = function(owner) 
{
	if (!(this instanceof NetworkSpace)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.networkOwner = owner;
	this.id;
	this.mesh;
	this.attributes;
	
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class AttribLocationState
 */
var AttribLocationState = function() 
{
	if (!(this instanceof AttribLocationState)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.attribLocationEnabled = false;
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class PostFxShader
 * @param gl 변수
 */
var PostFxShader = function(gl) 
{
	if (!(this instanceof PostFxShader)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name;
	this.attribLocationCacheObj = {}; // old.
	this.uniformsArrayGeneral = []; // this array has the same uniforms that "uniformsCacheObj".
	this.uniformsMapGeneral = {}; // this object has the same uniforms that "uniformsArray".
	
	this.uniformsArrayLocal = []; // this array has the same uniforms that "uniformsCacheObj".
	this.uniformsMapLocal = {}; // this object has the same uniforms that "uniformsArray".
	
	// No general objects.
	this.camera;
	
	// shader program.
	this.program;
	this.shader_vertex;
	this.shader_fragment;
	
	// current buffers binded.
	this.last_vboPos_binded;
	this.last_vboNor_binded;
	this.last_vboCol_binded;
	this.last_vboIdx_binded;
	this.last_tex_id;
	this.last_isAditionalMovedZero = false;
	this.last_vboTexCoord_binded; 
	
	// attribLocations state management.
	this.attribLocationStateArray = [];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.resetLastBuffersBinded = function()
{
	this.last_vboPos_binded = undefined;
	this.last_vboNor_binded = undefined;
	this.last_vboIdx_binded = undefined;
	this.last_vboTexCoord_binded = undefined; // no used.
	this.last_tex_id = undefined; // todo: must distinguish by channel.
	this.last_isAditionalMovedZero = false;
	
	this.disableVertexAttribArrayAll();
	
	if (this.attribLocationStateArray)
	{
		var attribLocsCount = this.attribLocationStateArray.length;
		for (var i=0; i<attribLocsCount; i++)
		{
			var attribLocationState = this.attribLocationStateArray[i];
			if (attribLocationState !== undefined)
			{
				attribLocationState.attribLocationEnabled = undefined;
				this.attribLocationStateArray[i] = undefined;
			}
		}
		this.attribLocationStateArray.length = 0;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.enableVertexAttribArray = function(attribLocation)
{
	if (attribLocation === undefined || attribLocation < 0)
	{ return; }
	
	var attribLocationState = this.attribLocationStateArray[attribLocation];
	if (attribLocationState === undefined)
	{
		attribLocationState = new AttribLocationState();
		this.attribLocationStateArray[attribLocation] = attribLocationState;
		attribLocationState.attribLocationEnabled = false;
	}

	if (!attribLocationState.attribLocationEnabled)
	{
		this.gl.enableVertexAttribArray(attribLocation);
		attribLocationState.attribLocationEnabled = true;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.disableVertexAttribArrayAll = function()
{
	var gl = this.gl;
	var vertexAttribsCount = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	for (var i = 0; i<vertexAttribsCount; i++)
	{ gl.disableVertexAttribArray(i); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.disableVertexAttribArray = function(attribLocation)
{
	if (attribLocation === undefined || attribLocation < 0)
	{ return; }
	
	var attribLocationState = this.attribLocationStateArray[attribLocation];
	if (attribLocationState === undefined)
	{
		attribLocationState = new AttribLocationState();
		this.attribLocationStateArray[attribLocation] = attribLocationState;
		attribLocationState.attribLocationEnabled = true;
	}

	if (attribLocationState.attribLocationEnabled)
	{
		this.gl.disableVertexAttribArray(attribLocation);
		attribLocationState.attribLocationEnabled = false;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.useProgram = function()
{
	var gl = this.gl;
	var currProgram = gl.getParameter(gl.CURRENT_PROGRAM);
	if (currProgram !== this.program)
	{
		gl.useProgram(this.program);
	}
	this.resetLastBuffersBinded();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.bindUniformGenerals = function()
{
	if (this.uniformsArrayGeneral === undefined)
	{ return; }
	
	var uniformsDataPairsCount = this.uniformsArrayGeneral.length;
	for (var i=0; i<uniformsDataPairsCount; i++)
	{
		this.uniformsArrayGeneral[i].bindUniform();
	}
	
	// Bind camera uniforms.
	if (this.camera)
	{ this.camera.bindCameraUniforms(this.gl, this); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.newUniformDataPair = function(uniformType, uniformName)
{
	var uniformDataPair;//
	if (uniformType === "Matrix4fv")
	{
		uniformDataPair = new UniformMatrix4fvDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec4fv")
	{
		uniformDataPair = new UniformVec4fvDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec3fv")
	{
		uniformDataPair = new UniformVec3fvDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec2fv")
	{
		uniformDataPair = new UniformVec2fvDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "1f")
	{
		uniformDataPair = new Uniform1fDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "1i")
	{
		uniformDataPair = new Uniform1iDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	
	return uniformDataPair;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.newUniformDataPairLocal = function(uniformType, uniformName)
{
	var uniformDataPair;//
	if (uniformType === "Matrix4fv")
	{
		uniformDataPair = new UniformMatrix4fvDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec4fv")
	{
		uniformDataPair = new UniformVec4fvDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec3fv")
	{
		uniformDataPair = new UniformVec3fvDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec2fv")
	{
		uniformDataPair = new UniformVec2fvDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "1f")
	{
		uniformDataPair = new Uniform1fDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "1i")
	{
		uniformDataPair = new Uniform1iDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	
	return uniformDataPair;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 */
PostFxShader.prototype.createUniformGenerals = function(gl, shader, sceneState)
{
	// Here create all generals uniforms, if exist, of the shader.
	var uniformDataPair;
	var uniformLocation;

	// 1. ModelViewProjectionMatrixRelToEye.              
	uniformLocation = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "mvpMat4RelToEye");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.modelViewProjRelToEyeMatrix._floatArrays;
	}
	
	// 1. ModelViewProjectionMatrix.
	uniformLocation = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrix");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "mvpMat4");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.modelViewProjMatrix._floatArrays;
	}
	
	// 2. modelViewMatrixRelToEye.
	uniformLocation = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "mvMat4RelToEye");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.modelViewRelToEyeMatrix._floatArrays;
	}
	
	// 3. modelViewMatrix.
	uniformLocation = gl.getUniformLocation(shader.program, "modelViewMatrix");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "modelViewMatrix");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.modelViewMatrix._floatArrays;
	}
	
	// 4. projectionMatrix.
	uniformLocation = gl.getUniformLocation(shader.program, "projectionMatrix");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "pMat4");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.projectionMatrix._floatArrays;
	}
	
	// 5. normalMatrix4.
	uniformLocation = gl.getUniformLocation(shader.program, "normalMatrix4");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "normalMat4");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.normalMatrix4._floatArrays;
	}
	
	// 6. encodedCameraPositionMCHigh.
	uniformLocation = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec3fv", "encodedCamPosHigh");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec3fv = sceneState.encodedCamPosHigh;
	}
	
	// 7. encodedCameraPositionMCLow.
	uniformLocation = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec3fv", "encodedCamPosLow");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec3fv = sceneState.encodedCamPosLow;
	}
	
	// 10. fovy.
	uniformLocation = gl.getUniformLocation(shader.program, "fov");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "fovyRad");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.camera.frustum.fovyRad;
	}
	
	// 11. aspectRatio.
	uniformLocation = gl.getUniformLocation(shader.program, "aspectRatio");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "aspectRatio");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.camera.frustum.aspectRatio;
	}
	
	// 12. drawBuffWidht.
	uniformLocation = gl.getUniformLocation(shader.program, "screenWidth");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "drawBuffWidht");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.drawingBufferWidth;
	}
	
	// 13. drawBuffHeight.
	uniformLocation = gl.getUniformLocation(shader.program, "screenHeight");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "drawBuffHeight");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.drawingBufferHeight;
	}
	
	// 14. depthTex.
	uniformLocation = gl.getUniformLocation(shader.program, "depthTex");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1i", "depthTex");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.intValue = 0;
	}
	
	// 15. noiseTex.
	uniformLocation = gl.getUniformLocation(shader.program, "noiseTex");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1i", "noiseTex");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.intValue = 1;
	}
	
	// 16. diffuseTex.
	uniformLocation = gl.getUniformLocation(shader.program, "diffuseTex");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1i", "diffuseTex");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.intValue = 2;
	}
	
	// 17. specularColor.
	uniformLocation = gl.getUniformLocation(shader.program, "specularColor");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec3fv", "specularColor");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec3fv = sceneState.specularColor;
	}
	
	// 18. ssaoRadius.
	uniformLocation = gl.getUniformLocation(shader.program, "radius");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "radius");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.ssaoRadius;
	}
	
	// 19. ambientReflectionCoef.
	uniformLocation = gl.getUniformLocation(shader.program, "ambientReflectionCoef");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "ambientReflectionCoef");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.ambientReflectionCoef;
	}
	
	// 20. diffuseReflectionCoef.
	uniformLocation = gl.getUniformLocation(shader.program, "diffuseReflectionCoef");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "diffuseReflectionCoef");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.diffuseReflectionCoef;
	}
	
	// 21. specularReflectionCoef.
	uniformLocation = gl.getUniformLocation(shader.program, "specularReflectionCoef");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "specularReflectionCoef");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.specularReflectionCoef;
	}
	
	// 22. shininessValue.
	uniformLocation = gl.getUniformLocation(shader.program, "shininessValue");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "shininessValue");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.shininessValue;
	}
	
	// 23. ssaoNoiseScale2.
	uniformLocation = gl.getUniformLocation(shader.program, "noiseScale");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec2fv", "ssaoNoiseScale2");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec2fv = sceneState.ssaoNoiseScale2;
	}
	
	// 24. ssaoKernel16.
	uniformLocation = gl.getUniformLocation(shader.program, "kernel");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec3fv", "ssaoKernel16");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec3fv = sceneState.ssaoKernel16;
	}
	
	// Set the camera.
	this.camera = sceneState.camera;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 */
PostFxShader.prototype.createUniformLocals = function(gl, shader, sceneState)
{
	// Here create all local uniforms, if exist, of the shader.
	var uniformDataPair;
	var uniformLocation;
	
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");
	
	shader.refMatrixType_loc = gl.getUniformLocation(shader.program, "refMatrixType");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.refTranslationVec_loc = gl.getUniformLocation(shader.program, "refTranslationVec");
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");
	
	shader.hasTexture_loc = gl.getUniformLocation(shader.program, "hasTexture");
	shader.textureFlipYAxis_loc = gl.getUniformLocation(shader.program, "textureFlipYAxis");
	shader.kernel16_loc = gl.getUniformLocation(shader.program, "kernel");
	shader.noiseScale2_loc = gl.getUniformLocation(shader.program, "noiseScale");
	
	// Attributtes.*
	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.normal3_loc = gl.getAttribLocation(shader.program, "normal");
	shader.color4_loc = gl.getAttribLocation(shader.program, "color4");
	
	shader.bUse1Color_loc = gl.getUniformLocation(shader.program, "bUse1Color");
	shader.oneColor4_loc = gl.getUniformLocation(shader.program, "oneColor4");
	shader.bApplySsao_loc = gl.getUniformLocation(shader.program, "bApplySsao");
	
	// compression data, for shaders with data compressed.
	// compressionMaxPoint & compressionMinPoint: for refObjects, this is the octree's size.
	shader.posDataByteSize_loc = gl.getUniformLocation(shader.program, "posDataByteSize");
	shader.texCoordByteSize_loc = gl.getUniformLocation(shader.program, "texCoordByteSize");
	shader.compressionMaxPoint_loc = gl.getUniformLocation(shader.program, "compressionMaxPoint");
	shader.compressionMinPoint_loc = gl.getUniformLocation(shader.program, "compressionMinPoint");
	
	shader.bApplySpecularLighting_loc = gl.getUniformLocation(shader.program, "bApplySpecularLighting");
	shader.colorType_loc = gl.getUniformLocation(shader.program, "colorType");
	shader.externalAlpha_loc = gl.getUniformLocation(shader.program, "externalAlpha");
	
	//uniform float fixPointSize;
	//uniform bool bUseFixPointSize;
	shader.fixPointSize_loc = gl.getUniformLocation(shader.program, "fixPointSize");
	shader.bUseFixPointSize_loc = gl.getUniformLocation(shader.program, "bUseFixPointSize");
	
	// Camera frustum near & far.
	// frustumNear.
	shader.frustumNear_loc = gl.getUniformLocation(shader.program, "near");

	// frustumFar.
	shader.frustumFar_loc = gl.getUniformLocation(shader.program, "far");
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class PostFxShadersManager
 */
var PostFxShadersManager = function() 
{
	if (!(this instanceof PostFxShadersManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl;
	this.pFx_shaders_array = []; // old.
	this.shadersMap = {};
	
	// preCreated shaders.
	this.modelRefShader;
	this.modelRefSilhouetteShader;
	this.lodBuildingShader;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShadersManager.prototype.newShader = function(shaderName)
{
	var shader = new PostFxShader(this.gl);
	shader.name = shaderName;
	this.shadersMap[shaderName] = shader;
	return shader;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param source 변수
 * @param type 변수
 * @param typeString 변수
 * @returns shader
 */
PostFxShadersManager.prototype.getShader = function(shaderName) 
{
	return this.shadersMap[shaderName];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param source 변수
 * @param type 변수
 * @param typeString 변수
 * @returns shader
 */
PostFxShadersManager.prototype.createShader = function(gl, source, type, typeString) 
{
	// Source from internet.
	var shader = gl.createShader(type);
	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) 
	{
		alert("ERROR IN "+typeString+ " SHADER : " + gl.getShaderInfoLog(shader));
		return false;
	}
	return shader;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createDefaultShaders = function(gl, sceneState) 
{
	this.pngImageShader = this.createPngImageShader(gl); // 13.
	this.modelRefSilhouetteShader = this.createSilhouetteShaderModelRef(gl); // 14.
	this.triPolyhedronShader = this.createSsaoShaderBox(gl); // 12.
	
	//this.invertedBoxShader = this.createInvertedBoxShader(gl); // TEST.
};

/**
 * 어떤 일을 하고 있습니까?
 */
PostFxShadersManager.prototype.getModelRefSilhouetteShader = function() 
{
	return this.modelRefSilhouetteShader;
};

/**
 * 어떤 일을 하고 있습니까?
 */
PostFxShadersManager.prototype.getTriPolyhedronDepthShader = function() 
{
	return this.triPolyhedronDepthShader;
};

/**
 * 어떤 일을 하고 있습니까?
 */
PostFxShadersManager.prototype.getTriPolyhedronShader = function() 
{
	return this.triPolyhedronShader;
};

/**
 * 어떤 일을 하고 있습니까?
 */
PostFxShadersManager.prototype.getInvertedBoxShader = function() 
{
	return this.invertedBoxShader;
};

// PNG images shader.
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createPngImageShader = function(gl) 
{
	// 13.
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var ssao_vs_source = ShaderSource.PngImageVS;
	var ssao_fs_source = ShaderSource.PngImageFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.texture_loc = gl.getUniformLocation(shader.program, "u_texture"); 
	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	
	shader.position3_loc = gl.getAttribLocation(shader.program, "a_position");
	shader.texCoord2_loc = gl.getAttribLocation(shader.program, "a_texcoord");
	
	shader.textureFlipYAxis_loc = gl.getUniformLocation(shader.program, "textureFlipYAxis");
	return shader;
	
};

// 14) Silhouette shader.
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createSilhouetteShaderModelRef = function(gl) 
{
	// 14.
	var shader = new PostFxShader(this.gl);
	shader.name = "SilhouetteShaderModelRef";
	this.pFx_shaders_array.push(undefined);

	var ssao_vs_source = ShaderSource.SilhouetteVS;
	var ssao_fs_source = ShaderSource.SilhouetteFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.refMatrixType_loc = gl.getUniformLocation(shader.program, "refMatrixType");
	shader.refTranslationVec_loc = gl.getUniformLocation(shader.program, "refTranslationVec");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");

	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	shader.color4Aux_loc = gl.getUniformLocation(shader.program, "vColor4Aux");
	shader.camSpacePixelTranslation_loc = gl.getUniformLocation(shader.program, "camSpacePixelTranslation");
	shader.screenSize_loc = gl.getUniformLocation(shader.program, "screenSize");
	shader.ProjectionMatrix_loc = gl.getUniformLocation(shader.program, "ProjectionMatrix");
	shader.ModelViewMatrixRelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewMatrixRelToEye");
	
	return shader;
};

// box Shader.
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createSsaoShaderBox = function(gl) 
{
	// 8.
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var ssao_vs_source = ShaderSource.BoxSsaoVS;
	var ssao_fs_source = ShaderSource.BoxSsaoFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.normalMatrix4_loc = gl.getUniformLocation(shader.program, "normalMatrix4");
	shader.projectionMatrix4_loc = gl.getUniformLocation(shader.program, "projectionMatrix");
	shader.modelViewMatrix4_loc = gl.getUniformLocation(shader.program, "modelViewMatrix");
	//shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.bUse1Color_loc = gl.getUniformLocation(shader.program, "bUse1Color");
	shader.oneColor4_loc = gl.getUniformLocation(shader.program, "oneColor4");
	shader.bUseNormal_loc = gl.getUniformLocation(shader.program, "bUseNormal");
	shader.bScale_loc = gl.getUniformLocation(shader.program, "bScale");
	shader.scale_loc = gl.getUniformLocation(shader.program, "scale");


	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	//shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.normal3_loc = gl.getAttribLocation(shader.program, "normal");
	shader.color4_loc = gl.getAttribLocation(shader.program, "color4");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.normal = gl.getAttribLocation(shader.program, "normal");
	shader.attribLocationCacheObj.color4 = gl.getAttribLocation(shader.program, "color4");

	//
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	// ssao uniforms.*
	shader.noiseScale2_loc = gl.getUniformLocation(shader.program, "noiseScale");
	shader.kernel16_loc = gl.getUniformLocation(shader.program, "kernel");

	// uniform values.
	shader.near_loc = gl.getUniformLocation(shader.program, "near");
	shader.far_loc = gl.getUniformLocation(shader.program, "far");
	shader.fov_loc = gl.getUniformLocation(shader.program, "fov");
	shader.aspectRatio_loc = gl.getUniformLocation(shader.program, "aspectRatio");

	shader.screenWidth_loc = gl.getUniformLocation(shader.program, "screenWidth");
	shader.screenHeight_loc = gl.getUniformLocation(shader.program, "screenHeight");

	shader.hasTexture_loc = gl.getUniformLocation(shader.program, "hasTexture");
	shader.color4Aux_loc = gl.getUniformLocation(shader.program, "vColor4Aux");

	// uniform samplers.
	shader.depthTex_loc = gl.getUniformLocation(shader.program, "depthTex");
	shader.noiseTex_loc = gl.getUniformLocation(shader.program, "noiseTex");
	shader.diffuseTex_loc = gl.getUniformLocation(shader.program, "diffuseTex");

	// ModelReference.*
	shader.useRefTransfMatrix_loc = gl.getUniformLocation(shader.program, "useRefTransfMatrix");
	shader.useTexture_loc = gl.getUniformLocation(shader.program, "useTexture");
	shader.invertNormals_loc  = gl.getUniformLocation(shader.program, "invertNormals");
	
	return shader;
};

// InvertedBox.
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createInvertedBoxShader = function(gl) 
{
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(undefined); // old.

	var ssao_vs_source = ShaderSource.InvertedBoxVS;
	var ssao_fs_source = ShaderSource.InvertedBoxFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh"); // sceneState.
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow"); // sceneState.
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye"); // sceneState.
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye"); // sceneState.
	shader.normalMatrix4_loc = gl.getUniformLocation(shader.program, "normalMatrix4"); // sceneState.
	shader.projectionMatrix4_loc = gl.getUniformLocation(shader.program, "projectionMatrix"); // sceneState.
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.refMatrixType_loc = gl.getUniformLocation(shader.program, "refMatrixType");
	shader.refTranslationVec_loc = gl.getUniformLocation(shader.program, "refTranslationVec");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.normal3_loc = gl.getAttribLocation(shader.program, "normal");
	
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.texCoord = gl.getAttribLocation(shader.program, "texCoord");
	shader.attribLocationCacheObj.normal = gl.getAttribLocation(shader.program, "normal");
	//
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	// ssao uniforms.*
	shader.noiseScale2_loc = gl.getUniformLocation(shader.program, "noiseScale");
	shader.kernel16_loc = gl.getUniformLocation(shader.program, "kernel");

	// uniform values.
	shader.near_loc = gl.getUniformLocation(shader.program, "near"); // sceneState.
	shader.far_loc = gl.getUniformLocation(shader.program, "far"); // sceneState.
	shader.fov_loc = gl.getUniformLocation(shader.program, "fov"); // sceneState.
	shader.aspectRatio_loc = gl.getUniformLocation(shader.program, "aspectRatio"); // sceneState.

	shader.screenWidth_loc = gl.getUniformLocation(shader.program, "screenWidth"); // sceneState.
	shader.screenHeight_loc = gl.getUniformLocation(shader.program, "screenHeight"); // sceneState.
	
	shader.shininessValue_loc = gl.getUniformLocation(shader.program, "shininessValue");

	shader.hasTexture_loc = gl.getUniformLocation(shader.program, "hasTexture");
	shader.color4Aux_loc = gl.getUniformLocation(shader.program, "vColor4Aux");
	shader.textureFlipYAxis_loc = gl.getUniformLocation(shader.program, "textureFlipYAxis");

	// uniform samplers.
	shader.depthTex_loc = gl.getUniformLocation(shader.program, "depthTex");
	shader.noiseTex_loc = gl.getUniformLocation(shader.program, "noiseTex");
	shader.diffuseTex_loc = gl.getUniformLocation(shader.program, "diffuseTex"); 
	
	// lighting.
	shader.specularColor_loc = gl.getUniformLocation(shader.program, "specularColor");
	shader.ssaoRadius_loc = gl.getUniformLocation(shader.program, "radius");  

	shader.ambientReflectionCoef_loc = gl.getUniformLocation(shader.program, "ambientReflectionCoef");
	shader.diffuseReflectionCoef_loc = gl.getUniformLocation(shader.program, "diffuseReflectionCoef");
	shader.specularReflectionCoef_loc = gl.getUniformLocation(shader.program, "specularReflectionCoef");
	
	return shader;
};
'use strict';
var ShaderSource = {};
ShaderSource.BlendingCubeFS = "	precision lowp float;\n\
	varying vec4 vColor;\n\
\n\
	void main()\n\
    {\n\
		gl_FragColor = vColor;\n\
	}";
ShaderSource.BlendingCubeVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
attribute vec4 color;\n\
varying vec4 vColor;\n\
\n\
void main()\n\
{\n\
    vec3 highDifference = -encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = position.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(position.xyz, 1.0);\n\
\n\
    vColor=color;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}";
ShaderSource.BlurFS = "#ifdef GL_ES\n\
    precision highp float;\n\
    #endif\n\
uniform sampler2D colorTex;\n\
uniform vec2 texelSize;\n\
varying vec2 vTexCoord; 	 	\n\
\n\
void main()\n\
{\n\
    vec3 result = vec3(0.0);\n\
    for (int i = 0; i < 4; ++i) {\n\
        for (int j = 0; j < 4; ++j) {\n\
            vec2 offset = vec2(texelSize.x * float(j), texelSize.y * float(i));\n\
            result += texture2D(colorTex, vTexCoord + offset).rgb;\n\
        }\n\
    }\n\
            \n\
    gl_FragColor.rgb = vec3(result * 0.0625); \n\
    gl_FragColor.a = 1.0;\n\
}\n\
";
ShaderSource.BlurVS = "attribute vec4 position;\n\
attribute vec2 texCoord;\n\
\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 modelViewMatrix;  \n\
\n\
varying vec2 vTexCoord;\n\
\n\
void main()\n\
{	\n\
    vTexCoord = texCoord;\n\
    \n\
    gl_Position = projectionMatrix * modelViewMatrix * position;\n\
}\n\
";
ShaderSource.BoxSsaoFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool hasTexture;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform vec3 kernel[16];   \n\
uniform vec4 vColor4Aux;\n\
uniform bool bUseNormal;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
\n\
const int kernelSize = 16;  \n\
const float radius = 0.5;      \n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{                          \n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{ \n\
	vec4 textureColor;\n\
	textureColor = vcolor4;  \n\
	if(bUseNormal)\n\
    {\n\
		vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
		float linearDepth = getDepth(screenPos);          \n\
		vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
		vec3 normal2 = vNormal;   \n\
				\n\
		vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
		vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
		vec3 bitangent = cross(normal2, tangent);\n\
		mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
		\n\
		float occlusion = 0.0;\n\
		for(int i = 0; i < kernelSize; ++i)\n\
		{    	 \n\
			vec3 sample = origin + (tbn * kernel[i]) * radius;\n\
			vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
			offset.xy /= offset.w;\n\
			offset.xy = offset.xy * 0.5 + 0.5;        \n\
			float sampleDepth = -sample.z/far;\n\
			float depthBufferValue = getDepth(offset.xy);				              \n\
			float range_check = abs(linearDepth - depthBufferValue)+radius*0.998;\n\
			if (range_check < radius*1.001 && depthBufferValue <= sampleDepth)\n\
			{\n\
				occlusion +=  1.0;\n\
			}\n\
			\n\
		}   \n\
			\n\
		occlusion = 1.0 - occlusion / float(kernelSize);\n\
									\n\
		vec3 lightPos = vec3(10.0, 10.0, 10.0);\n\
		vec3 L = normalize(lightPos);\n\
		float DiffuseFactor = dot(normal2, L);\n\
		float NdotL = abs(DiffuseFactor);\n\
		vec3 diffuse = vec3(NdotL);\n\
		vec3 ambient = vec3(1.0);\n\
		gl_FragColor.rgb = vec3((textureColor.xyz)*vLightWeighting * occlusion); \n\
		gl_FragColor.a = 1.0; \n\
	}\n\
	else\n\
	{\n\
		gl_FragColor.rgb = vec3(textureColor.xyz); \n\
		gl_FragColor.a = 1.0; \n\
	}	\n\
}\n\
";
ShaderSource.BoxSsaoVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec4 color4;\n\
\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 normalMatrix4;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec4 oneColor4;\n\
uniform bool bUse1Color;\n\
uniform bool bUseNormal;\n\
uniform vec3 scale;\n\
uniform bool bScale;\n\
\n\
varying vec3 vNormal;\n\
varying vec2 vTexCoord;  \n\
varying vec3 uAmbientColor;\n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
\n\
void main()\n\
{	\n\
    vec4 position2 = vec4(position.xyz, 1.0);\n\
    if(bScale)\n\
    {\n\
        position2.x *= scale.x;\n\
        position2.y *= scale.y;\n\
        position2.z *= scale.z;\n\
    }\n\
    vec4 rotatedPos = buildingRotMatrix * vec4(position2.xyz + aditionalPosition.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    if(bUseNormal)\n\
    {\n\
		vec4 rotatedNormal = buildingRotMatrix * vec4(normal.xyz, 1.0);\n\
		vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
		uAmbientColor = vec3(0.8, 0.8, 0.8);\n\
		vec3 uLightingDirection = vec3(0.5, 0.5, 0.5);\n\
		vec3 directionalLightColor = vec3(0.6, 0.6, 0.6);\n\
		vNormal = (normalMatrix4 * vec4(rotatedNormal.x, rotatedNormal.y, rotatedNormal.z, 1.0)).xyz;\n\
		float directionalLightWeighting = max(dot(vNormal, uLightingDirection), 0.0);\n\
		vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
	}\n\
    if(bUse1Color)\n\
    {\n\
        vcolor4 = oneColor4;\n\
    }\n\
    else\n\
    {\n\
        vcolor4 = color4;\n\
    }\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.CloudFS = "precision lowp float;\n\
varying vec3 vColor;\n\
\n\
void main()\n\
{\n\
    gl_FragColor = vec4(vColor, 1.);\n\
}";
ShaderSource.CloudVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 cloudPosHIGH;\n\
uniform vec3 cloudPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
attribute vec3 color;\n\
varying vec3 vColor;\n\
\n\
void main()\n\
{\n\
    vec3 objPosHigh = cloudPosHIGH;\n\
    vec3 objPosLow = cloudPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
    vColor=color;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}";
ShaderSource.ColorFS = "precision mediump float;\n\
uniform int byteColor_r;\n\
uniform int byteColor_g;\n\
uniform int byteColor_b;\n\
\n\
void main()\n\
{\n\
    float byteMaxValue = 255.0;\n\
\n\
    gl_FragColor = vec4(float(byteColor_r)/byteMaxValue, float(byteColor_g)/byteMaxValue, float(byteColor_b)/byteMaxValue, 1);\n\
}\n\
";
ShaderSource.ColorSelectionSsaoFS = "precision highp float;\n\
uniform vec4 oneColor4;\n\
\n\
void main()\n\
{          \n\
    gl_FragColor = oneColor4;\n\
}\n\
";
ShaderSource.ColorSelectionSsaoVS = "attribute vec3 position;\n\
\n\
uniform mat4 buildingRotMatrix;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 RefTransfMatrix;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec3 refTranslationVec;\n\
uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
\n\
void main()\n\
{\n\
    vec4 rotatedPos;\n\
	if(refMatrixType == 0)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 1)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 2)\n\
	{\n\
		rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    gl_PointSize = 10.0;\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.ColorVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform mat4 RefTransfMatrix;\n\
\n\
void main()\n\
{\n\
    vec4 rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}\n\
";
ShaderSource.draw_frag = "precision mediump float;\n\
\n\
uniform sampler2D u_wind;\n\
uniform vec2 u_wind_min;\n\
uniform vec2 u_wind_max;\n\
uniform bool u_flipTexCoordY_windMap;\n\
uniform bool u_colorScale;\n\
\n\
varying vec2 v_particle_pos;\n\
\n\
void main() {\n\
	vec2 windMapTexCoord = v_particle_pos;\n\
	if(u_flipTexCoordY_windMap)\n\
	{\n\
		windMapTexCoord.y = 1.0 - windMapTexCoord.y;\n\
	}\n\
    vec2 velocity = mix(u_wind_min, u_wind_max, texture2D(u_wind, windMapTexCoord).rg);\n\
    float speed_t = length(velocity) / length(u_wind_max);\n\
\n\
	\n\
	if(u_colorScale)\n\
	{\n\
		speed_t *= 1.5;\n\
		if(speed_t > 1.0)speed_t = 1.0;\n\
		float b = 1.0 - speed_t;\n\
		float g;\n\
		if(speed_t > 0.5)\n\
		{\n\
			g = 2.0-2.0*speed_t;\n\
		}\n\
		else{\n\
			g = 2.0*speed_t;\n\
		}\n\
		float r = speed_t;\n\
		gl_FragColor = vec4(r,g,b,1.0);\n\
	}\n\
	else{\n\
		float intensity = speed_t*3.0;\n\
		if(intensity > 1.0)\n\
			intensity = 1.0;\n\
		gl_FragColor = vec4(intensity,intensity,intensity,1.0);\n\
	}\n\
}\n\
";
ShaderSource.draw_vert = "precision mediump float;\n\
\n\
attribute float a_index;\n\
\n\
uniform sampler2D u_particles;\n\
uniform float u_particles_res;\n\
\n\
varying vec2 v_particle_pos;\n\
\n\
void main() {\n\
    vec4 color = texture2D(u_particles, vec2(\n\
        fract(a_index / u_particles_res),\n\
        floor(a_index / u_particles_res) / u_particles_res));\n\
\n\
    // decode current particle position from the pixel's RGBA value\n\
    v_particle_pos = vec2(\n\
        color.r / 255.0 + color.b,\n\
        color.g / 255.0 + color.a);\n\
\n\
    gl_PointSize = 1.0;\n\
    gl_Position = vec4(2.0 * v_particle_pos.x - 1.0, 1.0 - 2.0 * v_particle_pos.y, 0, 1);\n\
}\n\
";
ShaderSource.draw_vert3D = "precision mediump float;\n\
\n\
	// This shader draws windParticles in 3d directly from positions on u_particles image.***\n\
attribute float a_index;\n\
\n\
uniform sampler2D u_particles;\n\
uniform float u_particles_res;\n\
uniform mat4 ModelViewProjectionMatrix;\n\
\n\
varying vec2 v_particle_pos;\n\
\n\
#define M_PI 3.1415926535897932384626433832795\n\
vec4 geographicToWorldCoord(float lonDeg, float latDeg, float alt)\n\
{\n\
	// defined in the LINZ standard LINZS25000 (Standard for New Zealand Geodetic Datum 2000)\n\
	// https://www.linz.govt.nz/data/geodetic-system/coordinate-conversion/geodetic-datum-conversions/equations-used-datum\n\
	// a = semi-major axis.\n\
	// e2 = firstEccentricitySquared.\n\
	// v = a / sqrt(1 - e2 * sin2(lat)).\n\
	// x = (v+h)*cos(lat)*cos(lon).\n\
	// y = (v+h)*cos(lat)*sin(lon).\n\
	// z = [v*(1-e2)+h]*sin(lat).\n\
	float degToRadFactor = M_PI/180.0;\n\
	float equatorialRadius = 6378137.0; // meters.\n\
	float firstEccentricitySquared = 6.69437999014E-3;\n\
	float lonRad = lonDeg * degToRadFactor;\n\
	float latRad = latDeg * degToRadFactor;\n\
	float cosLon = cos(lonRad);\n\
	float cosLat = cos(latRad);\n\
	float sinLon = sin(lonRad);\n\
	float sinLat = sin(latRad);\n\
	float a = equatorialRadius;\n\
	float e2 = firstEccentricitySquared;\n\
	float v = a/sqrt(1.0 - e2 * sinLat * sinLat);\n\
	float h = alt;\n\
	\n\
	vec4 resultCartesian = vec4((v+h)*cosLat*cosLon, (v+h)*cosLat*sinLon, (v*(1.0-e2)+h)*sinLat, 1.0);\n\
	return resultCartesian;\n\
}\n\
\n\
void main() {\n\
    vec4 color = texture2D(u_particles, vec2(\n\
        fract(a_index / u_particles_res),\n\
        floor(a_index / u_particles_res) / u_particles_res));\n\
\n\
    // decode current particle position from the pixel's RGBA value\n\
    v_particle_pos = vec2(\n\
        color.r / 255.0 + color.b,\n\
        color.g / 255.0 + color.a);\n\
\n\
    gl_PointSize = 1.0;\n\
    vec4 pos2d = vec4(2.0 * v_particle_pos.x - 1.0, 1.0 - 2.0 * v_particle_pos.y, 0, 1);\n\
	\n\
	// Now, must calculate geographic coords of the pos2d.***\n\
	float longitudeDeg = -180.0 + pos2d.x * 360.0;\n\
	float latitudeDeg = 90.0 - pos2d.y * 180.0;\n\
	float altitude = 0.0;\n\
	// Now, calculate worldPosition of the geographicCoords (lon, lat, alt).***\n\
	vec4 worldPos = geographicToWorldCoord(longitudeDeg, latitudeDeg, altitude);\n\
	\n\
	// Now calculate the position on camCoord.***\n\
	\n\
	gl_Position = ModelViewProjectionMatrix * worldPos;\n\
}";
ShaderSource.filterSilhouetteFS = "precision mediump float;\n\
\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform mat4 projectionMatrix;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform vec3 kernel[16];   \n\
\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform bool bApplySsao;\n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{\n\
	float occlusion = 0.0;\n\
	vec3 normal2 = vec3(0.0, 0.0, 1.0);\n\
	float radiusAux = radius * 5.0;\n\
	if(bApplySsao)\n\
	{          \n\
		vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
		float linearDepth = getDepth(screenPos); \n\
		vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
\n\
		vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
		vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
		vec3 bitangent = cross(normal2, tangent);\n\
		mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
		\n\
		for(int i = 0; i < kernelSize; ++i)\n\
		{    	 \n\
			//vec3 sample = origin + (tbn * kernel[i]) * radiusAux;\n\
			vec3 sample = origin + (kernel[i]) * radiusAux;\n\
			vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
			offset.xy /= offset.w;\n\
			offset.xy = offset.xy * 0.5 + 0.5;        \n\
			float sampleDepth = -sample.z/far;\n\
			if(sampleDepth > 0.49)\n\
				continue;\n\
			float depthBufferValue = getDepth(offset.xy);\n\
			float range_check = abs(linearDepth - depthBufferValue)+radiusAux*0.998;\n\
			if (range_check > radius*1.001 && depthBufferValue <= sampleDepth)\n\
			{\n\
				occlusion +=  1.0;\n\
			}\n\
		}   \n\
		\n\
		if(occlusion > float(kernelSize)*0.4)\n\
		{\n\
			occlusion = occlusion / float(kernelSize);\n\
		}\n\
		else{\n\
			occlusion = 0.0;\n\
		}\n\
		//occlusion = 1.0 - occlusion / float(kernelSize);\n\
	}\n\
	else{\n\
		occlusion = 0.0;\n\
	}\n\
\n\
    vec4 finalColor;\n\
	finalColor = vec4(1.0, 1.0, 1.0, occlusion*0.9);\n\
    gl_FragColor = finalColor; \n\
}\n\
";
ShaderSource.InvertedBoxFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool hasTexture;\n\
uniform bool textureFlipYAxis;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform float shininessValue;\n\
uniform vec3 kernel[16];   \n\
uniform vec4 vColor4Aux;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
\n\
varying vec3 diffuseColor;\n\
uniform vec3 specularColor;\n\
varying vec3 vertexPos;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform float ambientReflectionCoef;\n\
uniform float diffuseReflectionCoef;  \n\
uniform float specularReflectionCoef; \n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{          \n\
    vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
    float linearDepth = getDepth(screenPos);          \n\
    vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
\n\
    vec3 normal2 = vNormal;\n\
            \n\
    vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
    vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
    vec3 bitangent = cross(normal2, tangent);\n\
    mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
    \n\
    float occlusion = 0.0;\n\
    for(int i = 0; i < kernelSize; ++i)\n\
    {    	 \n\
        vec3 sample = origin + (tbn * kernel[i]) * radius;\n\
        vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
        offset.xy /= offset.w;\n\
        offset.xy = offset.xy * 0.5 + 0.5;        \n\
        float sampleDepth = -sample.z/far;\n\
		if(sampleDepth > 0.49)\n\
			continue;\n\
        float depthBufferValue = getDepth(offset.xy);				              \n\
        float range_check = abs(linearDepth - depthBufferValue)+radius*0.998;\n\
        if (range_check < radius*1.001 && depthBufferValue <= sampleDepth)\n\
        {\n\
            occlusion +=  1.0;\n\
        }\n\
    }   \n\
        \n\
    occlusion = 1.0 - occlusion / float(kernelSize);\n\
\n\
    vec3 lightPos = vec3(20.0, 60.0, 20.0);\n\
    vec3 L = normalize(lightPos - vertexPos);\n\
    float lambertian = max(dot(normal2, L), 0.0);\n\
    float specular = 0.0;\n\
    if(lambertian > 0.0)\n\
    {\n\
        vec3 R = reflect(-L, normal2);      // Reflected light vector\n\
        vec3 V = normalize(-vertexPos); // Vector to viewer\n\
        \n\
        // Compute the specular term\n\
        float specAngle = max(dot(R, V), 0.0);\n\
        specular = pow(specAngle, shininessValue);\n\
    }\n\
	\n\
	if(lambertian < 0.5)\n\
    {\n\
		lambertian = 0.5;\n\
	}\n\
\n\
    vec4 textureColor;\n\
    if(hasTexture)\n\
    {\n\
        if(textureFlipYAxis)\n\
        {\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, 1.0 - vTexCoord.t));\n\
        }\n\
        else{\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
        }\n\
		\n\
        if(textureColor.w == 0.0)\n\
        {\n\
            discard;\n\
        }\n\
    }\n\
    else{\n\
        textureColor = vColor4Aux;\n\
    }\n\
	\n\
	vec3 ambientColor = vec3(textureColor.x, textureColor.y, textureColor.z);\n\
\n\
    gl_FragColor = vec4((ambientReflectionCoef * ambientColor + diffuseReflectionCoef * lambertian * textureColor.xyz + specularReflectionCoef * specular * specularColor)*vLightWeighting * occlusion, 1.0); \n\
}\n\
";
ShaderSource.InvertedBoxVS = "	attribute vec3 position;\n\
	attribute vec3 normal;\n\
	attribute vec2 texCoord;\n\
	\n\
	uniform mat4 buildingRotMatrix; \n\
	uniform mat4 projectionMatrix;  \n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 modelViewMatrixRelToEye; \n\
	uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
	uniform mat4 RefTransfMatrix;\n\
	uniform mat4 normalMatrix4;\n\
	uniform vec3 buildingPosHIGH;\n\
	uniform vec3 buildingPosLOW;\n\
	uniform vec3 encodedCameraPositionMCHigh;\n\
	uniform vec3 encodedCameraPositionMCLow;\n\
	uniform vec3 aditionalPosition;\n\
	uniform vec3 refTranslationVec;\n\
	uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
\n\
	varying vec3 vNormal;\n\
	varying vec2 vTexCoord;  \n\
	varying vec3 uAmbientColor;\n\
	varying vec3 vLightWeighting;\n\
	varying vec3 vertexPos;\n\
	\n\
	void main()\n\
    {	\n\
		vec4 rotatedPos;\n\
		mat3 currentTMat;\n\
		if(refMatrixType == 0)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 1)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 2)\n\
		{\n\
			rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(RefTransfMatrix);\n\
		}\n\
\n\
		vec3 objPosHigh = buildingPosHIGH;\n\
		vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
		vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
		vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
		vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
		vertexPos = vec3(modelViewMatrixRelToEye * pos4);\n\
		vec3 rotatedNormal = currentTMat * normal;\n\
		vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
		uAmbientColor = vec3(0.8);\n\
		vec3 uLightingDirection = vec3(0.6, 0.6, 0.6);\n\
		vec3 directionalLightColor = vec3(0.7, 0.7, 0.7);\n\
		vNormal = (normalMatrix4 * vec4(rotatedNormal.x, rotatedNormal.y, rotatedNormal.z, 1.0)).xyz;\n\
		vTexCoord = texCoord;\n\
		float directionalLightWeighting = max(dot(vNormal, uLightingDirection), 0.0);\n\
		vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
\n\
        gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
	}\n\
";
ShaderSource.ModelRefSsaoFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool textureFlipYAxis;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform float shininessValue;\n\
uniform vec3 kernel[16];   \n\
uniform vec4 oneColor4;\n\
varying vec4 aColor4; // color from attributes\n\
uniform bool bApplyScpecularLighting;\n\
uniform highp int colorType; // 0= oneColor, 1= attribColor, 2= texture.\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
\n\
varying vec3 diffuseColor;\n\
uniform vec3 specularColor;\n\
varying vec3 vertexPos;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform float ambientReflectionCoef;\n\
uniform float diffuseReflectionCoef;  \n\
uniform float specularReflectionCoef; \n\
varying float applySpecLighting;\n\
uniform bool bApplySsao;\n\
uniform float externalAlpha;\n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{\n\
	float occlusion = 0.0;\n\
	vec3 normal2 = vNormal;\n\
	if(bApplySsao)\n\
	{          \n\
		vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
		float linearDepth = getDepth(screenPos);          \n\
		vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
\n\
		vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
		vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
		vec3 bitangent = cross(normal2, tangent);\n\
		mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
		\n\
		for(int i = 0; i < kernelSize; ++i)\n\
		{    	 \n\
			vec3 sample = origin + (tbn * kernel[i]) * radius;\n\
			vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
			offset.xy /= offset.w;\n\
			offset.xy = offset.xy * 0.5 + 0.5;        \n\
			float sampleDepth = -sample.z/far;\n\
			if(sampleDepth > 0.49)\n\
				continue;\n\
			float depthBufferValue = getDepth(offset.xy);				              \n\
			float range_check = abs(linearDepth - depthBufferValue)+radius*0.998;\n\
			if (range_check < radius*1.001 && depthBufferValue <= sampleDepth)\n\
			{\n\
				occlusion +=  1.0;\n\
			}\n\
		}   \n\
			\n\
		occlusion = 1.0 - occlusion / float(kernelSize);\n\
	}\n\
	else{\n\
		occlusion = 1.0;\n\
	}\n\
\n\
    // Do specular lighting.***\n\
	float lambertian;\n\
	float specular;\n\
		\n\
	if(applySpecLighting> 0.0)\n\
	{\n\
		vec3 lightPos = vec3(20.0, 60.0, 200.0);\n\
		vec3 L = normalize(lightPos - vertexPos);\n\
		lambertian = max(dot(normal2, L), 0.0);\n\
		specular = 0.0;\n\
		if(lambertian > 0.0)\n\
		{\n\
			vec3 R = reflect(-L, normal2);      // Reflected light vector\n\
			vec3 V = normalize(-vertexPos); // Vector to viewer\n\
			\n\
			// Compute the specular term\n\
			float specAngle = max(dot(R, V), 0.0);\n\
			specular = pow(specAngle, shininessValue);\n\
		}\n\
		\n\
		if(lambertian < 0.5)\n\
		{\n\
			lambertian = 0.5;\n\
		}\n\
	}\n\
\n\
    vec4 textureColor;\n\
    if(colorType == 2)\n\
    {\n\
        if(textureFlipYAxis)\n\
        {\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, 1.0 - vTexCoord.t));\n\
        }\n\
        else{\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
        }\n\
		\n\
        if(textureColor.w == 0.0)\n\
        {\n\
            discard;\n\
        }\n\
    }\n\
    else if(colorType == 0)\n\
	{\n\
        textureColor = oneColor4;\n\
    }\n\
	else if(colorType == 1)\n\
	{\n\
        textureColor = aColor4;\n\
    }\n\
	\n\
	vec3 ambientColor = vec3(textureColor.x, textureColor.y, textureColor.z);\n\
	float alfa = textureColor.w * externalAlpha;\n\
\n\
    vec4 finalColor;\n\
	if(applySpecLighting> 0.0)\n\
	{\n\
		finalColor = vec4((ambientReflectionCoef * ambientColor + diffuseReflectionCoef * lambertian * textureColor.xyz + specularReflectionCoef * specular * specularColor)*vLightWeighting * occlusion, alfa); \n\
	}\n\
	else{\n\
		finalColor = vec4((textureColor.xyz) * occlusion, alfa);\n\
	}\n\
    gl_FragColor = finalColor; \n\
}";
ShaderSource.ModelRefSsaoVS = "	attribute vec3 position;\n\
	attribute vec3 normal;\n\
	attribute vec2 texCoord;\n\
	attribute vec4 color4;\n\
	\n\
	uniform mat4 buildingRotMatrix; \n\
	uniform mat4 projectionMatrix;  \n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 modelViewMatrixRelToEye; \n\
	uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
	uniform mat4 RefTransfMatrix;\n\
	uniform mat4 normalMatrix4;\n\
	uniform vec3 buildingPosHIGH;\n\
	uniform vec3 buildingPosLOW;\n\
	uniform vec3 encodedCameraPositionMCHigh;\n\
	uniform vec3 encodedCameraPositionMCLow;\n\
	uniform vec3 aditionalPosition;\n\
	uniform vec3 refTranslationVec;\n\
	uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
	uniform bool bApplySpecularLighting;\n\
	uniform highp int colorType; // 0= oneColor, 1= attribColor, 2= texture.\n\
\n\
	varying vec3 vNormal;\n\
	varying vec2 vTexCoord;  \n\
	varying vec3 uAmbientColor;\n\
	varying vec3 vLightWeighting;\n\
	varying vec3 vertexPos;\n\
	varying float applySpecLighting;\n\
	varying vec4 aColor4; // color from attributes\n\
	\n\
	void main()\n\
    {	\n\
		vec4 rotatedPos;\n\
		mat3 currentTMat;\n\
		if(refMatrixType == 0)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 1)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 2)\n\
		{\n\
			rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(RefTransfMatrix);\n\
		}\n\
\n\
		vec3 objPosHigh = buildingPosHIGH;\n\
		vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
		vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
		vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
		vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
		//vertexPos = vec3(modelViewMatrixRelToEye * pos4);\n\
		vec3 rotatedNormal = currentTMat * normal;\n\
		vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
		uAmbientColor = vec3(0.8);\n\
		vec3 uLightingDirection = vec3(0.6, 0.6, 0.6);\n\
		vec3 directionalLightColor = vec3(0.7, 0.7, 0.7);\n\
		vNormal = (normalMatrix4 * vec4(rotatedNormal.x, rotatedNormal.y, rotatedNormal.z, 1.0)).xyz;\n\
		vTexCoord = texCoord;\n\
		float directionalLightWeighting = max(dot(vNormal, uLightingDirection), 0.0);\n\
		vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
		\n\
		if(bApplySpecularLighting)\n\
			applySpecLighting = 1.0;\n\
		else\n\
			applySpecLighting = -1.0;\n\
\n\
        gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
		\n\
		if(colorType == 1)\n\
			aColor4 = color4;\n\
	}";
ShaderSource.PngImageFS = "precision mediump float;\n\
varying vec2 v_texcoord;\n\
uniform bool textureFlipYAxis;\n\
uniform sampler2D u_texture;\n\
\n\
void main()\n\
{\n\
    vec4 textureColor;\n\
    if(textureFlipYAxis)\n\
    {\n\
        textureColor = texture2D(u_texture, vec2(v_texcoord.s, 1.0 - v_texcoord.t));\n\
    }\n\
    else\n\
    {\n\
        textureColor = texture2D(u_texture, v_texcoord);\n\
    }\n\
    if(textureColor.w < 0.1)\n\
    {\n\
        discard;\n\
    }\n\
\n\
    gl_FragColor = textureColor;\n\
}";
ShaderSource.PngImageVS = "attribute vec3 a_position;\n\
attribute vec2 a_texcoord;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
varying vec2 v_texcoord;\n\
\n\
void main()\n\
{\n\
    vec4 position2 = vec4(a_position.xyz, 1.0);\n\
    vec4 rotatedPos = buildingRotMatrix * vec4(position2.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
    v_texcoord = a_texcoord;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.PointCloudDepthVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform mat4 buildingRotMatrix;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform float near;\n\
uniform float far;\n\
uniform bool bPositionCompressed;\n\
uniform vec3 minPosition;\n\
uniform vec3 bboxSize;\n\
attribute vec4 color4;\n\
uniform bool bUse1Color;\n\
uniform vec4 oneColor4;\n\
uniform float fixPointSize;\n\
uniform bool bUseFixPointSize;\n\
varying vec4 vColor;\n\
//varying float glPointSize;\n\
varying float depth;  \n\
\n\
void main()\n\
{\n\
	vec3 realPos;\n\
	vec4 rotatedPos;\n\
	if(bPositionCompressed)\n\
	{\n\
		float maxShort = 65535.0;\n\
		realPos = vec3(float(position.x)/maxShort*bboxSize.x + minPosition.x, float(position.y)/maxShort*bboxSize.y + minPosition.y, float(position.z)/maxShort*bboxSize.z + minPosition.z);\n\
	}\n\
	else\n\
	{\n\
		realPos = position;\n\
	}\n\
	rotatedPos = buildingRotMatrix * vec4(realPos.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
	\n\
    if(bUse1Color)\n\
	{\n\
		vColor=oneColor4;\n\
	}\n\
	else\n\
		vColor=color4;\n\
	\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
	float z_b = gl_Position.z/gl_Position.w;\n\
	float z_n = 2.0 * z_b - 1.0;\n\
    float z_e = 2.0 * near * far / (far + near - z_n * (far - near));\n\
	gl_PointSize = 1.0 + 40.0/z_e; // Original.***\n\
	if(gl_PointSize > 10.0)\n\
		gl_PointSize = 10.0;\n\
	if(gl_PointSize < 2.0)\n\
		gl_PointSize = 2.0;\n\
		\n\
	depth = (modelViewMatrixRelToEye * pos).z/far; // original.***\n\
}";
ShaderSource.PointCloudFS = "	precision lowp float;\n\
	varying vec4 vColor;\n\
\n\
	void main()\n\
    {\n\
		gl_FragColor = vColor;\n\
	}";
ShaderSource.PointCloudSsaoFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform mat4 projectionMatrix;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform vec3 kernel[16];   \n\
uniform vec4 oneColor4;\n\
varying vec4 aColor4; // color from attributes\n\
varying vec4 vColor;\n\
varying float glPointSize;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform bool bApplySsao;\n\
uniform float externalAlpha;\n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{\n\
	float occlusion = 0.0;\n\
	if(bApplySsao)\n\
	{          \n\
		vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);\n\
		float linearDepth = getDepth(screenPos);\n\
		vec3 origin = getViewRay(screenPos) * linearDepth;\n\
		float radiusAux = glPointSize/1.9;\n\
		radiusAux = 1.5;\n\
		vec2 screenPosAdjacent;\n\
		\n\
		for(int j = 0; j < 1; ++j)\n\
		{\n\
			radiusAux = 1.5 *(float(j)+1.0);\n\
			for(int i = 0; i < 8; ++i)\n\
			{    	 \n\
				if(i == 0)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x - radiusAux)/ screenWidth, (gl_FragCoord.y - radiusAux) / screenHeight);\n\
				else if(i == 1)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x)/ screenWidth, (gl_FragCoord.y - radiusAux) / screenHeight);\n\
				else if(i == 2)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x + radiusAux)/ screenWidth, (gl_FragCoord.y - radiusAux) / screenHeight);\n\
				else if(i == 3)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x + radiusAux)/ screenWidth, (gl_FragCoord.y) / screenHeight);\n\
				else if(i == 4)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x + radiusAux)/ screenWidth, (gl_FragCoord.y + radiusAux) / screenHeight);\n\
				else if(i == 5)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x)/ screenWidth, (gl_FragCoord.y + radiusAux) / screenHeight);\n\
				else if(i == 6)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x - radiusAux)/ screenWidth, (gl_FragCoord.y + radiusAux) / screenHeight);\n\
				else if(i == 7)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x - radiusAux)/ screenWidth, (gl_FragCoord.y) / screenHeight);\n\
				float depthBufferValue = getDepth(screenPosAdjacent);\n\
				float range_check = abs(linearDepth - depthBufferValue)*far;\n\
				if (range_check > 1.5 && depthBufferValue > linearDepth)\n\
				{\n\
					if (range_check < 20.0)\n\
						occlusion +=  1.0;\n\
				}\n\
			}   \n\
		}   \n\
			\n\
		if(occlusion > 6.0)\n\
			occlusion = 8.0;\n\
		//else occlusion = 0.0;\n\
		occlusion = 1.0 - occlusion / 8.0;\n\
	}\n\
	else{\n\
		occlusion = 1.0;\n\
	}\n\
\n\
    vec4 finalColor;\n\
	finalColor = vec4((vColor.xyz) * occlusion, externalAlpha);\n\
	//finalColor = vec4(vec3(0.8, 0.8, 0.8) * occlusion, externalAlpha);\n\
    gl_FragColor = finalColor; \n\
}";
ShaderSource.PointCloudVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform mat4 buildingRotMatrix;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform float near;\n\
uniform float far;\n\
uniform bool bPositionCompressed;\n\
uniform vec3 minPosition;\n\
uniform vec3 bboxSize;\n\
attribute vec4 color4;\n\
uniform bool bUse1Color;\n\
uniform vec4 oneColor4;\n\
uniform float fixPointSize;\n\
uniform bool bUseFixPointSize;\n\
varying vec4 vColor;\n\
varying float glPointSize;\n\
\n\
void main()\n\
{\n\
	vec3 realPos;\n\
	vec4 rotatedPos;\n\
	if(bPositionCompressed)\n\
	{\n\
		float maxShort = 65535.0;\n\
		realPos = vec3(float(position.x)/maxShort*bboxSize.x + minPosition.x, float(position.y)/maxShort*bboxSize.y + minPosition.y, float(position.z)/maxShort*bboxSize.z + minPosition.z);\n\
	}\n\
	else\n\
	{\n\
		realPos = position;\n\
	}\n\
	rotatedPos = buildingRotMatrix * vec4(realPos.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
	\n\
    if(bUse1Color)\n\
	{\n\
		vColor=oneColor4;\n\
	}\n\
	else\n\
		vColor=color4;\n\
	\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
	float z_b = gl_Position.z/gl_Position.w;\n\
	float z_n = 2.0 * z_b - 1.0;\n\
    float z_e = 2.0 * near * far / (far + near - z_n * (far - near));\n\
	gl_PointSize = 1.0 + 40.0/z_e; // Original.***\n\
	if(gl_PointSize > 10.0)\n\
		gl_PointSize = 10.0;\n\
	if(gl_PointSize < 2.0)\n\
		gl_PointSize = 2.0;\n\
		\n\
	glPointSize = gl_PointSize;\n\
}";
ShaderSource.quad_vert = "precision mediump float;\n\
\n\
attribute vec2 a_pos;\n\
\n\
varying vec2 v_tex_pos;\n\
\n\
void main() {\n\
    v_tex_pos = a_pos;\n\
    gl_Position = vec4(1.0 - 2.0 * a_pos, 0, 1);\n\
}\n\
";
ShaderSource.RenderShowDepthFS = "#ifdef GL_ES\n\
precision highp float;\n\
#endif\n\
uniform float near;\n\
uniform float far;\n\
\n\
varying float depth;  \n\
\n\
vec4 packDepth(const in float depth)\n\
{\n\
    const vec4 bit_shift = vec4(16777216.0, 65536.0, 256.0, 1.0);\n\
    const vec4 bit_mask  = vec4(0.0, 0.00390625, 0.00390625, 0.00390625); \n\
    vec4 res = fract(depth * bit_shift);\n\
    res -= res.xxyz * bit_mask;\n\
    return res;  \n\
}\n\
\n\
void main()\n\
{     \n\
    gl_FragData[0] = packDepth(-depth);\n\
}";
ShaderSource.RenderShowDepthVS = "attribute vec3 position;\n\
\n\
uniform mat4 buildingRotMatrix; \n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 RefTransfMatrix;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform float near;\n\
uniform float far;\n\
uniform vec3 aditionalPosition;\n\
uniform vec3 refTranslationVec;\n\
uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
\n\
varying float depth;\n\
  \n\
void main()\n\
{	\n\
	vec4 rotatedPos;\n\
\n\
	if(refMatrixType == 0)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 1)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 2)\n\
	{\n\
		rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    //linear depth in camera space (0..far)\n\
    depth = (modelViewMatrixRelToEye * pos4).z/far; // original.***\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
	gl_PointSize = 2.0;\n\
}";
ShaderSource.screen_frag = "precision mediump float;\n\
\n\
uniform sampler2D u_screen;\n\
uniform float u_opacity;\n\
\n\
varying vec2 v_tex_pos;\n\
\n\
void main() {\n\
    vec4 color = texture2D(u_screen, 1.0 - v_tex_pos);\n\
    // a hack to guarantee opacity fade out even with a value close to 1.0\n\
    gl_FragColor = vec4(floor(255.0 * color * u_opacity) / 255.0);\n\
}\n\
";
ShaderSource.SilhouetteFS = "precision highp float;\n\
uniform vec4 vColor4Aux;\n\
\n\
void main()\n\
{          \n\
    gl_FragColor = vColor4Aux;\n\
}";
ShaderSource.SilhouetteVS = "attribute vec3 position;\n\
\n\
uniform mat4 buildingRotMatrix; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 ModelViewMatrixRelToEye;\n\
uniform mat4 ProjectionMatrix;\n\
uniform mat4 RefTransfMatrix;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec3 refTranslationVec;\n\
uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
uniform vec2 camSpacePixelTranslation;\n\
uniform vec2 screenSize;    \n\
varying vec2 camSpaceTranslation;\n\
\n\
void main()\n\
{    \n\
    vec4 rotatedPos;\n\
	if(refMatrixType == 0)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 1)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 2)\n\
	{\n\
		rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    vec4 camSpacePos = ModelViewMatrixRelToEye * pos4;\n\
    vec4 translationVec = ProjectionMatrix * vec4(camSpacePixelTranslation.x*(-camSpacePos.z), camSpacePixelTranslation.y*(-camSpacePos.z), 0.0, 1.0);\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
    gl_Position += translationVec;  \n\
}";
ShaderSource.StandardFS = "precision lowp float;\n\
varying vec3 vColor;\n\
\n\
void main()\n\
{\n\
    gl_FragColor = vec4(vColor, 1.);\n\
}";
ShaderSource.StandardVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform mat4 RefTransfMatrix;\n\
attribute vec3 color;\n\
varying vec3 vColor;\n\
\n\
void main()\n\
{\n\
    vec4 rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
 \n\
    vColor=color;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}";
ShaderSource.Test_QuadFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
 \n\
uniform sampler2D diffuseTex;  \n\
varying vec2 vTexCoord; \n\
void main()\n\
{          \n\
    vec4 textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
    gl_FragColor = textureColor; \n\
}\n\
";
ShaderSource.Test_QuadVS = "attribute vec3 position;\n\
attribute vec2 texCoord;\n\
\n\
uniform sampler2D diffuseTex;\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 normalMatrix4;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
\n\
varying vec3 vNormal;\n\
varying vec2 vTexCoord;   \n\
\n\
void main()\n\
{	\n\
    vec4 rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
	\n\
    vTexCoord = texCoord;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.TextureA1FS = "precision mediump float;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
uniform sampler2D uSampler;\n\
\n\
void main()\n\
{\n\
    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n\
}\n\
";
ShaderSource.TextureA1VS = "attribute vec3 position;\n\
attribute vec4 aVertexColor;\n\
attribute vec2 aTextureCoord;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
\n\
void main()\n\
{\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
 \n\
    vColor=aVertexColor;\n\
    vTextureCoord = aTextureCoord;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}";
ShaderSource.TextureFS = "precision mediump float;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
uniform sampler2D uSampler;\n\
\n\
void main()\n\
{\n\
    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n\
}";
ShaderSource.TextureNormalFS = "	precision mediump float;\n\
	varying vec4 vColor;\n\
	varying vec2 vTextureCoord;\n\
	uniform sampler2D uSampler;\n\
	varying vec3 vLightWeighting;\n\
\n\
	void main()\n\
    {\n\
		vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n\
        \n\
		gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);\n\
	}\n\
";
ShaderSource.TextureNormalVS = "attribute vec3 position;\n\
attribute vec4 aVertexColor;\n\
attribute vec2 aTextureCoord;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
attribute vec3 aVertexNormal;\n\
varying vec3 uAmbientColor;\n\
varying vec3 vLightWeighting;\n\
uniform mat3 uNMatrix;\n\
\n\
void main()\n\
{\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    vColor = aVertexColor;\n\
    vTextureCoord = aTextureCoord;\n\
    \n\
    vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
    uAmbientColor = vec3(0.7, 0.7, 0.7);\n\
    vec3 uLightingDirection = vec3(0.8, 0.2, -0.9);\n\
    vec3 directionalLightColor = vec3(0.4, 0.4, 0.4);\n\
    vec3 transformedNormal = uNMatrix * aVertexNormal;\n\
    float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);\n\
    vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}\n\
";
ShaderSource.TextureVS = "attribute vec3 position;\n\
attribute vec4 aVertexColor;\n\
attribute vec2 aTextureCoord;\n\
uniform mat4 Mmatrix;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
\n\
void main()\n\
{\n\
    vec4 rotatedPos = Mmatrix * vec4(position.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
    vColor=aVertexColor;\n\
    vTextureCoord = aTextureCoord;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
    \n\
}";
ShaderSource.TinTerrainFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool hasTexture;\n\
uniform bool textureFlipYAxis;\n\
uniform bool bIsMakingDepth;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform float shininessValue;\n\
uniform vec3 kernel[16];   \n\
uniform vec4 vColor4Aux;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
\n\
varying vec3 diffuseColor;\n\
uniform vec3 specularColor;\n\
varying vec3 vertexPos;\n\
varying float depthValue;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform float ambientReflectionCoef;\n\
uniform float diffuseReflectionCoef;  \n\
uniform float specularReflectionCoef; \n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
} \n\
\n\
vec4 packDepth(const in float depth)\n\
{\n\
    const vec4 bit_shift = vec4(16777216.0, 65536.0, 256.0, 1.0);\n\
    const vec4 bit_mask  = vec4(0.0, 0.00390625, 0.00390625, 0.00390625); \n\
    vec4 res = fract(depth * bit_shift);\n\
    res -= res.xxyz * bit_mask;\n\
    return res;  \n\
}               \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}\n\
\n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{           \n\
	if(bIsMakingDepth)\n\
	{\n\
		gl_FragColor = packDepth(-depthValue);\n\
	}\n\
	else{\n\
		vec4 textureColor;\n\
		if(hasTexture)\n\
		{\n\
			if(textureFlipYAxis)\n\
			{\n\
				textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, 1.0 - vTexCoord.t));\n\
			}\n\
			else{\n\
				textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
			}\n\
			\n\
			if(textureColor.w == 0.0)\n\
			{\n\
				discard;\n\
			}\n\
		}\n\
		else{\n\
			textureColor = vColor4Aux;\n\
		}\n\
		//vec3 ambientColor = vec3(textureColor.x, textureColor.y, textureColor.z);\n\
		gl_FragColor = vec4(textureColor.xyz, 1.0); \n\
	}\n\
}";
ShaderSource.TinTerrainVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec4 color4;\n\
attribute vec2 texCoord;\n\
\n\
uniform sampler2D diffuseTex;\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 ModelViewProjectionMatrix;\n\
uniform mat4 normalMatrix4;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec4 oneColor4;\n\
uniform bool bUse1Color;\n\
uniform bool hasTexture;\n\
uniform bool bIsMakingDepth;\n\
uniform float near;\n\
uniform float far;\n\
\n\
varying vec3 vNormal;\n\
varying vec2 vTexCoord;   \n\
varying vec3 uAmbientColor;\n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
varying vec3 vertexPos;\n\
varying float depthValue;\n\
\n\
void main()\n\
{	\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
	if(bIsMakingDepth)\n\
	{\n\
		depthValue = (modelViewMatrixRelToEye * pos4).z/far;\n\
	}\n\
	else\n\
	{\n\
		vTexCoord = texCoord;\n\
	}\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
	\n\
}";
ShaderSource.update_frag = "precision highp float;\n\
\n\
uniform sampler2D u_particles;\n\
uniform sampler2D u_wind;\n\
uniform vec2 u_wind_res;\n\
uniform vec2 u_wind_min;\n\
uniform vec2 u_wind_max;\n\
uniform float u_rand_seed;\n\
uniform float u_speed_factor;\n\
uniform float u_drop_rate;\n\
uniform float u_drop_rate_bump;\n\
uniform bool u_flipTexCoordY_windMap;\n\
\n\
varying vec2 v_tex_pos;\n\
\n\
// pseudo-random generator\n\
const vec3 rand_constants = vec3(12.9898, 78.233, 4375.85453);\n\
float rand(const vec2 co) {\n\
    float t = dot(rand_constants.xy, co);\n\
    return fract(sin(t) * (rand_constants.z + t));\n\
}\n\
\n\
// wind speed lookup; use manual bilinear filtering based on 4 adjacent pixels for smooth interpolation\n\
vec2 lookup_wind(const vec2 uv) {\n\
    // return texture2D(u_wind, uv).rg; // lower-res hardware filtering\n\
    vec2 px = 1.0 / u_wind_res;\n\
    vec2 vc = (floor(uv * u_wind_res)) * px;\n\
    vec2 f = fract(uv * u_wind_res);\n\
    vec2 tl = texture2D(u_wind, vc).rg;\n\
    vec2 tr = texture2D(u_wind, vc + vec2(px.x, 0)).rg;\n\
    vec2 bl = texture2D(u_wind, vc + vec2(0, px.y)).rg;\n\
    vec2 br = texture2D(u_wind, vc + px).rg;\n\
    return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n\
}\n\
\n\
void main() {\n\
    vec4 color = texture2D(u_particles, v_tex_pos);\n\
    vec2 pos = vec2(\n\
        color.r / 255.0 + color.b,\n\
        color.g / 255.0 + color.a); // decode particle position from pixel RGBA\n\
	vec2 windMapTexCoord = pos;\n\
	if(u_flipTexCoordY_windMap)\n\
	{\n\
		windMapTexCoord.y = 1.0 - windMapTexCoord.y;\n\
	}\n\
    vec2 velocity = mix(u_wind_min, u_wind_max, lookup_wind(windMapTexCoord));\n\
    float speed_t = length(velocity) / length(u_wind_max);\n\
\n\
    // take EPSG:4236 distortion into account for calculating where the particle moved\n\
    float distortion = cos(radians(pos.y * 180.0 - 90.0));\n\
    vec2 offset = vec2(velocity.x / distortion, -velocity.y) * 0.0001 * u_speed_factor;\n\
\n\
    // update particle position, wrapping around the date line\n\
    pos = fract(1.0 + pos + offset);\n\
\n\
    // a random seed to use for the particle drop\n\
    vec2 seed = (pos + v_tex_pos) * u_rand_seed;\n\
\n\
    // drop rate is a chance a particle will restart at random position, to avoid degeneration\n\
    float drop_rate = u_drop_rate + speed_t * u_drop_rate_bump;\n\
    float drop = step(1.0 - drop_rate, rand(seed));\n\
\n\
    vec2 random_pos = vec2(\n\
        rand(seed + 1.3),\n\
        rand(seed + 2.1));\n\
    pos = mix(pos, random_pos, drop);\n\
\n\
    // encode the new particle position back into RGBA\n\
    gl_FragColor = vec4(\n\
        fract(pos * 255.0),\n\
        floor(pos * 255.0) / 255.0);\n\
}";
ShaderSource.vol_fs = "#ifdef GL_ES\n\
precision highp float;\n\
#endif\n\
\n\
//---------------------------------------------------------\n\
// MACROS\n\
//---------------------------------------------------------\n\
\n\
#define EPS       0.0001\n\
#define PI        3.14159265\n\
#define HALFPI    1.57079633\n\
#define ROOTTHREE 1.73205081\n\
\n\
#define EQUALS(A,B) ( abs((A)-(B)) < EPS )\n\
#define EQUALSZERO(A) ( ((A)<EPS) && ((A)>-EPS) )\n\
\n\
\n\
//---------------------------------------------------------\n\
// CONSTANTS\n\
//---------------------------------------------------------\n\
\n\
// 32 48 64 96 128\n\
#define MAX_STEPS 64\n\
\n\
#define LIGHT_NUM 2\n\
//#define uTMK 20.0\n\
#define TM_MIN 0.05\n\
\n\
\n\
//---------------------------------------------------------\n\
// SHADER VARS\n\
//---------------------------------------------------------\n\
\n\
varying vec2 vUv;\n\
varying vec3 vPos0; // position in world coords\n\
varying vec3 vPos1; // position in object coords\n\
varying vec3 vPos1n; // normalized 0 to 1, for texture lookup\n\
\n\
uniform vec3 uOffset; // TESTDEBUG\n\
\n\
uniform vec3 uCamPos;\n\
\n\
uniform vec3 uLightP[LIGHT_NUM];  // point lights\n\
uniform vec3 uLightC[LIGHT_NUM];\n\
\n\
uniform vec3 uColor;      // color of volume\n\
uniform sampler2D uTex;   // 3D(2D) volume texture\n\
uniform vec3 uTexDim;     // dimensions of texture\n\
\n\
uniform float uTMK;\n\
\n\
float gStepSize;\n\
float gStepFactor;\n\
\n\
\n\
//---------------------------------------------------------\n\
// PROGRAM\n\
//---------------------------------------------------------\n\
\n\
// TODO: convert world to local volume space\n\
vec3 toLocal(vec3 p) {\n\
  return p + vec3(0.5);\n\
}\n\
\n\
float sampleVolTex(vec3 pos) {\n\
  pos = pos + uOffset; // TESTDEBUG\n\
  \n\
  // note: z is up in 3D tex coords, pos.z is tex.y, pos.y is zSlice\n\
  float zSlice = (1.0-pos.y)*(uTexDim.z-1.0);   // float value of slice number, slice 0th to 63rd\n\
  \n\
  // calc pixels from top of texture\n\
  float fromTopPixels =\n\
    floor(zSlice)*uTexDim.y +   // offset pix from top of tex, from upper slice  \n\
    pos.z*(uTexDim.y-1.0) +     // y pos in pixels, range 0th to 63rd pix\n\
    0.5;  // offset to center of cell\n\
    \n\
  // calc y tex coords of two slices\n\
  float y0 = min( (fromTopPixels)/(uTexDim.y*uTexDim.z), 1.0);\n\
  float y1 = min( (fromTopPixels+uTexDim.y)/(uTexDim.y*uTexDim.z), 1.0);\n\
    \n\
  // get (bi)linear interped texture reads at two slices\n\
  float z0 = texture2D(uTex, vec2(pos.x, y0)).g;\n\
  float z1 = texture2D(uTex, vec2(pos.x, y1)).g;\n\
  \n\
  // lerp them again (thus trilinear), using remaining fraction of zSlice\n\
  return mix(z0, z1, fract(zSlice));\n\
}\n\
\n\
// accumulate density by ray marching\n\
float getDensity(vec3 ro, vec3 rd) {\n\
  vec3 step = rd*gStepSize;\n\
  vec3 pos = ro;\n\
  \n\
  float density = 0.0;\n\
  \n\
  for (int i=0; i<MAX_STEPS; ++i) {\n\
    density += (1.0-density) * sampleVolTex(pos) * gStepFactor;\n\
    //density += sampleVolTex(pos);\n\
    \n\
    pos += step;\n\
    \n\
    if (density > 0.95 ||\n\
      pos.x > 1.0 || pos.x < 0.0 ||\n\
      pos.y > 1.0 || pos.y < 0.0 ||\n\
      pos.z > 1.0 || pos.z < 0.0)\n\
      break;\n\
  }\n\
  \n\
  return density;\n\
}\n\
\n\
// calc transmittance\n\
float getTransmittance(vec3 ro, vec3 rd) {\n\
  vec3 step = rd*gStepSize;\n\
  vec3 pos = ro;\n\
  \n\
  float tm = 1.0;\n\
  \n\
  for (int i=0; i<MAX_STEPS; ++i) {\n\
    tm *= exp( -uTMK*gStepSize*sampleVolTex(pos) );\n\
    \n\
    pos += step;\n\
    \n\
    if (tm < TM_MIN ||\n\
      pos.x > 1.0 || pos.x < 0.0 ||\n\
      pos.y > 1.0 || pos.y < 0.0 ||\n\
      pos.z > 1.0 || pos.z < 0.0)\n\
      break;\n\
  }\n\
  \n\
  return tm;\n\
}\n\
\n\
vec4 raymarchNoLight(vec3 ro, vec3 rd) {\n\
  vec3 step = rd*gStepSize;\n\
  vec3 pos = ro;\n\
  \n\
  vec3 col = vec3(0.0);\n\
  float tm = 1.0;\n\
  \n\
  for (int i=0; i<MAX_STEPS; ++i) {\n\
    float dtm = exp( -uTMK*gStepSize*sampleVolTex(pos) );\n\
    tm *= dtm;\n\
    \n\
    col += (1.0-dtm) * uColor * tm;\n\
    \n\
    pos += step;\n\
    \n\
    if (tm < TM_MIN ||\n\
      pos.x > 1.0 || pos.x < 0.0 ||\n\
      pos.y > 1.0 || pos.y < 0.0 ||\n\
      pos.z > 1.0 || pos.z < 0.0)\n\
      break;\n\
  }\n\
  \n\
  float alpha = 1.0-tm;\n\
  return vec4(col/alpha, alpha);\n\
}\n\
\n\
vec4 raymarchLight(vec3 ro, vec3 rd) {\n\
  vec3 step = rd*gStepSize;\n\
  vec3 pos = ro;\n\
  \n\
  \n\
  vec3 col = vec3(0.0);   // accumulated color\n\
  float tm = 1.0;         // accumulated transmittance\n\
  \n\
  for (int i=0; i<MAX_STEPS; ++i) {\n\
    // delta transmittance \n\
    float dtm = exp( -uTMK*gStepSize*sampleVolTex(pos) );\n\
    tm *= dtm;\n\
    \n\
    // get contribution per light\n\
    for (int k=0; k<LIGHT_NUM; ++k) {\n\
      vec3 ld = normalize( toLocal(uLightP[k])-pos );\n\
      float ltm = getTransmittance(pos,ld);\n\
      \n\
      col += (1.0-dtm) * uColor*uLightC[k] * tm * ltm;\n\
    }\n\
    \n\
    pos += step;\n\
    \n\
    if (tm < TM_MIN ||\n\
      pos.x > 1.0 || pos.x < 0.0 ||\n\
      pos.y > 1.0 || pos.y < 0.0 ||\n\
      pos.z > 1.0 || pos.z < 0.0)\n\
      break;\n\
  }\n\
  \n\
  float alpha = 1.0-tm;\n\
  return vec4(col/alpha, alpha);\n\
}\n\
\n\
void main() {\n\
  // in world coords, just for now\n\
  vec3 ro = vPos1n;\n\
  vec3 rd = normalize( ro - toLocal(uCamPos) );\n\
  //vec3 rd = normalize(ro-uCamPos);\n\
  \n\
  // step_size = root_three / max_steps ; to get through diagonal  \n\
  gStepSize = ROOTTHREE / float(MAX_STEPS);\n\
  gStepFactor = 32.0 * gStepSize;\n\
  \n\
  gl_FragColor = raymarchLight(ro, rd);\n\
  //gl_FragColor = vec4(uColor, getDensity(ro,rd));\n\
  //gl_FragColor = vec4(vec3(sampleVolTex(pos)), 1.0);\n\
  //gl_FragColor = vec4(vPos1n, 1.0);\n\
  //gl_FragColor = vec4(uLightP[0], 1.0);\n\
}";
ShaderSource.vol_vs = "attribute vec3 aPosition;\n\
\n\
uniform sampler2D diffuseTex;\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
\n\
varying vec3 vNormal;\n\
varying vec3 vPosObjectCoord;\n\
varying vec3 vPosCameraCoord;\n\
varying vec3 vPosWorldCoord;\n\
\n\
// Render a fullScreen quad (2 triangles).***\n\
void main()\n\
{\n\
	vec4 rotatedPos = buildingRotMatrix * vec4(position.xyz + aditionalPosition.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
	\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}";
ShaderSource.wgs84_volumFS = "precision mediump float;\n\
\n\
#define M_PI 3.1415926535897932384626433832795\n\
\n\
uniform sampler2D volumeTex;\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixInv;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
\n\
uniform float screenWidth;    \n\
uniform float screenHeight;\n\
uniform float aspectRatio;\n\
uniform float far;\n\
uniform float fovyRad;\n\
uniform float tanHalfFovy;\n\
\n\
// volume tex definition.***\n\
uniform int texNumCols;\n\
uniform int texNumRows;\n\
uniform int texNumSlices;\n\
uniform int numSlicesPerStacks;\n\
uniform int slicesNumCols;\n\
uniform int slicesNumRows;\n\
uniform float maxLon;\n\
uniform float minLon;\n\
uniform float maxLat;\n\
uniform float minLat;\n\
uniform float maxAlt;\n\
uniform float minAlt;\n\
uniform vec4 cuttingPlanes[6];   \n\
uniform int cuttingPlanesCount;\n\
\n\
uniform float maxValue;\n\
uniform float minValue;\n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
	float hfar = 2.0 * tanHalfFovy * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
} \n\
\n\
float squaredLength(vec3 point1, vec3 point2)\n\
{\n\
	float a = point1.x - point2.x;\n\
	float b = point1.y - point2.y;\n\
	float c = point1.z - point2.z;\n\
	\n\
	float sqDist = a*a + b*b + c*c;\n\
	return sqDist;\n\
}\n\
\n\
void intersectionLineSphere(float radius, vec3 rayPos, vec3 rayDir, out int intersectType, out vec3 nearIntersectPos, out vec3 farIntersectPos)\n\
{\n\
	// line: (x, y, z) = x1 + t(x2 - x1), y1 + t(y2 - y1), z1 + t(z2 - z1)\n\
	// sphere: (x - x3)^2 + (y - y3)^2 + (z - z3)^2 = r^2, where x3, y3, z3 is the center of the sphere.\n\
	\n\
	// line:\n\
	vec3 p1 = rayPos;\n\
	vec3 lineDir = rayDir;\n\
	float dist = 1000.0;// any value is ok.***\n\
	vec3 p2 = vec3(p1.x + lineDir.x * dist, p1.y + lineDir.y * dist, p1.z + lineDir.z * dist);\n\
	float x1 = p1.x;\n\
	float y1 = p1.y;\n\
	float z1 = p1.z;\n\
	float x2 = p2.x;\n\
	float y2 = p2.y;\n\
	float z2 = p2.z;\n\
\n\
	// sphere:\n\
	float x3 = 0.0;\n\
	float y3 = 0.0;\n\
	float z3 = 0.0;\n\
	float r = radius;\n\
	\n\
	// resolve:\n\
	float x21 = (x2-x1);\n\
	float y21 = (y2-y1);\n\
	float z21 = (z2-z1);\n\
	\n\
	float a = x21*x21 + y21*y21 + z21*z21;\n\
	\n\
	float x13 = (x1-x3);\n\
	float y13 = (y1-y3);\n\
	float z13 = (z1-z3);\n\
	\n\
	float b = 2.0*(x21 * x13 + y21 * y13 + z21 * z13);\n\
	\n\
	float c = x3*x3 + y3*y3 + z3*z3 + x1*x1 + y1*y1 + z1*z1 - 2.0*(x3*x1 + y3*y1+ z3*z1) - r*r;\n\
	\n\
	float discriminant = b*b - 4.0*a*c;\n\
	\n\
	if (discriminant < 0.0)\n\
	{\n\
		// no intersection.***\n\
		intersectType = 0;\n\
	}\n\
	else if (discriminant == 0.0)\n\
	{\n\
		// this is tangent.***\n\
		intersectType = 1;\n\
		\n\
		float t1 = (-b)/(2.0*a);\n\
		nearIntersectPos = vec3(x1 + (x2 - x1)*t1, y1 + (y2 - y1)*t1, z1 + (z2 - z1)*t1);\n\
	}\n\
	else\n\
	{\n\
		intersectType = 2;\n\
		\n\
		// find the nearest to p1.***\n\
		float sqrtDiscriminant = sqrt(discriminant);\n\
		float t1 = (-b + sqrtDiscriminant)/(2.0*a);\n\
		float t2 = (-b - sqrtDiscriminant)/(2.0*a);\n\
		\n\
		// solution 1.***\n\
		vec3 intersectPoint1 = vec3(x1 + (x2 - x1)*t1, y1 + (y2 - y1)*t1, z1 + (z2 - z1)*t1);\n\
		vec3 intersectPoint2 = vec3(x1 + (x2 - x1)*t2, y1 + (y2 - y1)*t2, z1 + (z2 - z1)*t2);\n\
		\n\
		float dist1 = squaredLength(p1,intersectPoint1);\n\
		float dist2 = squaredLength(p1,intersectPoint2);\n\
		\n\
		// nearIntersectPos, out vec3 farIntersectPos\n\
		if (dist1 < dist2)\n\
		{\n\
			nearIntersectPos = intersectPoint1;\n\
			farIntersectPos = intersectPoint2;\n\
		}\n\
		else\n\
		{\n\
			nearIntersectPos = intersectPoint2;\n\
			farIntersectPos = intersectPoint1;\n\
		}\n\
	}\n\
}\n\
\n\
float atan2(float y, float x) \n\
{\n\
	if(x > 0.0)\n\
	{\n\
		return atan(y/x);\n\
	}\n\
	else if(x < 0.0)\n\
	{\n\
		if(y >= 0.0)\n\
		{\n\
			return atan(y/x) + M_PI;\n\
		}\n\
		else{\n\
			return atan(y/x) - M_PI;\n\
		}\n\
	}\n\
	else if(x == 0.0)\n\
	{\n\
		if(y>0.0)\n\
		{\n\
			return M_PI/2.0;\n\
		}\n\
		else if(y<0.0)\n\
		{\n\
			return -M_PI/2.0;\n\
		}\n\
		else{\n\
			return 0.0; // return undefined.***\n\
		}\n\
	}\n\
}\n\
\n\
void cartesianToGeographicWgs84(vec3 point, out vec3 result) \n\
{\n\
	// From WebWorldWind.***\n\
	// According to H. Vermeille, An analytical method to transform geocentric into geodetic coordinates\n\
	// http://www.springerlink.com/content/3t6837t27t351227/fulltext.pdf\n\
	\n\
	float firstEccentricitySquared = 6.69437999014E-3;\n\
	float equatorialRadius = 6378137.0;\n\
\n\
	// wwwind coord type.***\n\
	// X = point.z;\n\
	// Y = point.x;\n\
	// Z = point.y;\n\
\n\
	// magoWorld coord type.***\n\
	float X = point.x;\n\
	float Y = point.y;\n\
	float Z = point.z;\n\
	float XXpYY = X * X + Y * Y;\n\
	float sqrtXXpYY = sqrt(XXpYY);\n\
	float a = equatorialRadius;\n\
	float ra2 = 1.0 / (a * a);\n\
	float e2 = firstEccentricitySquared;\n\
	float e4 = e2 * e2;\n\
	float p = XXpYY * ra2;\n\
	float q = Z * Z * (1.0 - e2) * ra2;\n\
	float r = (p + q - e4) / 6.0;\n\
	float h;\n\
	float phi;\n\
	float u;\n\
	float evoluteBorderTest = 8.0 * r * r * r + e4 * p * q;\n\
	float rad1;\n\
	float rad2;\n\
	float rad3;\n\
	float atanAux;\n\
	float v;\n\
	float w;\n\
	float k;\n\
	float D;\n\
	float sqrtDDpZZ;\n\
	float e;\n\
	float lambda;\n\
	float s2;\n\
	float cbrtFac = 1.0/3.0;\n\
\n\
	if (evoluteBorderTest > 0.0 || q != 0.0) \n\
	{\n\
		if (evoluteBorderTest > 0.0) \n\
		{\n\
			// Step 2: general case\n\
			rad1 = sqrt(evoluteBorderTest);\n\
			rad2 = sqrt(e4 * p * q);\n\
\n\
			// 10*e2 is my arbitrary decision of what Vermeille means by near... the cusps of the evolute.\n\
			if (evoluteBorderTest > 10.0 * e2) \n\
			{\n\
				rad3 = pow((rad1 + rad2) * (rad1 + rad2), cbrtFac);\n\
				u = r + 0.5 * rad3 + 2.0 * r * r / rad3;\n\
			}\n\
			else \n\
			{\n\
				u = r + 0.5 * pow((rad1 + rad2) * (rad1 + rad2), cbrtFac)\n\
					+ 0.5 * pow((rad1 - rad2) * (rad1 - rad2), cbrtFac);\n\
			}\n\
		}\n\
		else \n\
		{\n\
			// Step 3: near evolute\n\
			rad1 = sqrt(-evoluteBorderTest);\n\
			rad2 = sqrt(-8.0 * r * r * r);\n\
			rad3 = sqrt(e4 * p * q);\n\
			atanAux = 2.0 * atan2(rad3, rad1 + rad2) / 3.0;\n\
\n\
			u = -4.0 * r * sin(atanAux) * cos(M_PI / 6.0 + atanAux);\n\
		}\n\
\n\
		v = sqrt(u * u + e4 * q);\n\
		w = e2 * (u + v - q) / (2.0 * v);\n\
		k = (u + v) / (sqrt(w * w + u + v) + w);\n\
		D = k * sqrtXXpYY / (k + e2);\n\
		sqrtDDpZZ = sqrt(D * D + Z * Z);\n\
\n\
		h = (k + e2 - 1.0) * sqrtDDpZZ / k;\n\
		phi = 2.0 * atan2(Z, sqrtDDpZZ + D);\n\
	}\n\
	else \n\
	{\n\
		// Step 4: singular disk\n\
		rad1 = sqrt(1.0 - e2);\n\
		rad2 = sqrt(e2 - p);\n\
		e = sqrt(e2);\n\
\n\
		h = -a * rad1 * rad2 / e;\n\
		phi = rad2 / (e * rad2 + rad1 * sqrt(p));\n\
	}\n\
\n\
	// Compute lambda\n\
	s2 = sqrt(2.0);\n\
	if ((s2 - 1.0) * Y < sqrtXXpYY + X) \n\
	{\n\
		// case 1 - -135deg < lambda < 135deg\n\
		lambda = 2.0 * atan2(Y, sqrtXXpYY + X);\n\
	}\n\
	else if (sqrtXXpYY + Y < (s2 + 1.0) * X) \n\
	{\n\
		// case 2 - -225deg < lambda < 45deg\n\
		lambda = -M_PI * 0.5 + 2.0 * atan2(X, sqrtXXpYY - Y);\n\
	}\n\
	else \n\
	{\n\
		// if (sqrtXXpYY-Y<(s2=1)*X) {  // is the test, if needed, but it's not\n\
		// case 3: - -45deg < lambda < 225deg\n\
		lambda = M_PI * 0.5 - 2.0 * atan2(X, sqrtXXpYY + Y);\n\
	}\n\
\n\
	float factor = 180.0 / M_PI;\n\
	result = vec3(factor * lambda, factor * phi, h); // (longitude, latitude, altitude).***\n\
}\n\
\n\
bool isPointRearCamera(vec3 point, vec3 camPos, vec3 camDir)\n\
{\n\
	bool isRear = false;\n\
	float lambdaX = 10.0;\n\
	float lambdaY = 10.0;\n\
	float lambdaZ = 10.0;\n\
	if(abs(camDir.x) > 0.0000001)\n\
	{\n\
		float lambdaX = (point.x - camPos.x)/camDir.x;\n\
	}\n\
	else if(abs(camDir.y) > 0.0000001)\n\
	{\n\
		float lambdaY = (point.y - camPos.y)/camDir.y;\n\
	}\n\
	else if(abs(camDir.z) > 0.0000001)\n\
	{\n\
		float lambdaZ = (point.z - camPos.z)/camDir.z;\n\
	}\n\
	\n\
	if(lambdaZ < 0.0 || lambdaY < 0.0 || lambdaX < 0.0)\n\
			isRear = true;\n\
		else\n\
			isRear = false;\n\
	return isRear;\n\
}\n\
\n\
float distPointToPlane(vec3 point, vec4 plane)\n\
{\n\
	return (point.x*plane.x + point.y*plane.y + point.z*plane.z + plane.w);\n\
}\n\
\n\
bool getValue(vec3 geoLoc, out vec4 value)\n\
{\n\
	// geoLoc = (longitude, latitude, altitude).***\n\
	float lon = geoLoc.x;\n\
	float lat = geoLoc.y;\n\
	float alt = geoLoc.z;\n\
	\n\
	// 1rst, check if geoLoc intersects the volume.***\n\
	// Note: minLon, maxLon, minLat, maxLat, minAlt & maxAlt are uniforms.***\n\
	if(lon < minLon || lon > maxLon)\n\
		return false;\n\
	else if(lat < minLat || lat > maxLat)\n\
		return false;\n\
	else if(alt < minAlt || alt > maxAlt)\n\
		return false;\n\
		\n\
	float lonRange = maxLon - minLon;\n\
	float latRange = maxLat - minLat;\n\
	float altRange = maxAlt - minAlt;\n\
	float col = (lon - minLon)/lonRange * float(slicesNumCols); \n\
	float row = (lat - minLat)/latRange * float(slicesNumRows); \n\
	float slice = (alt - minAlt)/altRange * float(texNumSlices); // slice if texture has only one stack.***\n\
	float sliceDown = floor(slice);\n\
	float sliceUp = ceil(slice);\n\
	float sliceDownDist = slice - sliceDown;\n\
	//slice = 18.0; // test. force slice to nearest to ground.***\n\
	\n\
	float stackDown = floor(sliceDown/float(numSlicesPerStacks));\n\
	float realSliceDown = sliceDown - stackDown * float(numSlicesPerStacks);\n\
	float tx = stackDown * float(slicesNumCols) + col;\n\
	float ty = realSliceDown * float(slicesNumRows) + row;\n\
	vec2 texCoord = vec2(tx/float(texNumCols), ty/float(texNumRows));\n\
	vec4 valueDown = texture2D(volumeTex, texCoord);\n\
	\n\
	if(sliceDown < float(texNumSlices-1))\n\
	{\n\
		float stackUp = floor(sliceUp/float(numSlicesPerStacks));\n\
		float realSliceUp = sliceUp - stackUp * float(numSlicesPerStacks);\n\
		float tx2 = stackUp * float(slicesNumCols) + col;\n\
		float ty2 = realSliceUp * float(slicesNumRows) + row;\n\
		vec2 texCoord2 = vec2(tx2/float(texNumCols), ty2/float(texNumRows));\n\
		vec4 valueUp = texture2D(volumeTex, texCoord2);\n\
		value = valueDown*(1.0-sliceDownDist)+valueUp*(sliceDownDist);\n\
	}\n\
	else{\n\
		value = valueDown;\n\
	}\n\
	//if((value.r * (maxValue - minValue)) > maxValue * 0.3)\n\
	//	return true;\n\
	//else return false;\n\
	return true;\n\
}\n\
\n\
void main() {\n\
	vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);\n\
	float linearDepth = 1.0; // the quad is 1m of dist of the camera.***          \n\
    vec3 rayCamCoord = getViewRay(screenPos) * linearDepth;  \n\
	rayCamCoord = normalize(rayCamCoord);\n\
	\n\
	vec3 camTarget = rayCamCoord * 10000.0;\n\
	vec4 camPosWorld = vec4(encodedCameraPositionMCHigh + encodedCameraPositionMCLow, 1.0);\n\
	vec4 camTargetWorld = modelViewMatrixInv * vec4(camTarget.xyz, 1.0);\n\
	vec3 camDirWorld = camTargetWorld.xyz - camPosWorld.xyz;\n\
	camDirWorld = normalize(camDirWorld);\n\
\n\
	// now, must find sampling points.***\n\
	int intersectType = 0;\n\
	vec3 nearP;\n\
	vec3 farP;\n\
	float radius = 6378137.0 + maxAlt; // equatorial radius.***\n\
	//radius = 6250000.0 + maxAlt; // test radius.***\n\
	\n\
	intersectionLineSphere(radius, camPosWorld.xyz, camDirWorld, intersectType, nearP, farP);\n\
	\n\
	if(intersectType == 0)\n\
	{\n\
		discard;\n\
	}\n\
		\n\
	if(intersectType == 1)\n\
	{\n\
		// provisionally discard.***\n\
		discard;	\n\
	}\n\
	\n\
	// check if nearP is rear of the camera.***\n\
	if(isPointRearCamera(nearP, camPosWorld.xyz, camDirWorld.xyz))\n\
	{\n\
		nearP = vec3(camPosWorld.xyz);\n\
	}\n\
	float dist = distance(nearP, farP);\n\
	float testDist = dist;\n\
	if(dist > 1500000.0)\n\
		testDist = 1500000.0;\n\
	\n\
	// now calculate the geographicCoords of 2 points.***\n\
	// now, depending the dist(nearP, endPoint), determine numSmples.***\n\
	// provisionally take 16 samples.***\n\
	float numSamples = 512.0;\n\
	vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\
	float alpha = 0.8/numSamples;\n\
	float tempRange = maxValue - minValue;\n\
	vec4 value;\n\
	float totalValue = 0.0;\n\
	int sampledsCount = 0;\n\
	int intAux = 0;\n\
	float increDist = testDist / numSamples;\n\
	int c = 0;\n\
	bool isPointRearPlane = true;\n\
	for(int i=0; i<512; i++)\n\
	{\n\
		vec3 currGeoLoc;\n\
		vec3 currPosWorld = vec3(nearP.x + camDirWorld.x * increDist*float(c), nearP.y + camDirWorld.y * increDist*float(c), nearP.z + camDirWorld.z * increDist*float(c));\n\
		// Check if the currPosWorld is in front or rear of planes (if exist planes).***\n\
		int planesCounter = 0;\n\
		for(int j=0; j<6; j++)\n\
		{\n\
			if(planesCounter == cuttingPlanesCount)\n\
				break;\n\
			\n\
			vec4 plane = cuttingPlanes[j];\n\
			float dist = distPointToPlane(currPosWorld, plane);\n\
			if(dist > 0.0)\n\
			{\n\
				isPointRearPlane = false;\n\
				break;\n\
			}\n\
			else{\n\
				isPointRearPlane = true;\n\
			}\n\
			planesCounter++;\n\
		}\n\
		\n\
		\n\
		if(isPointRearPlane)\n\
		{\n\
			cartesianToGeographicWgs84(currPosWorld, currGeoLoc);\n\
			if(getValue(currGeoLoc, value))\n\
			{\n\
				float realValue = value.r * tempRange + minValue*255.0;\n\
				totalValue += (value.r);\n\
				sampledsCount += 1;\n\
			}\n\
		}\n\
		if(sampledsCount >= 1)\n\
		{\n\
			break;\n\
		}\n\
		c++;\n\
	}\n\
	if(sampledsCount == 0)\n\
	{\n\
		discard;\n\
	}\n\
	float fValue = totalValue/numSamples;\n\
	fValue = totalValue;\n\
	if(fValue > 1.0)\n\
	{\n\
		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\
		return;\n\
	}\n\
	float b = 1.0 - fValue;\n\
	float g;\n\
	if(fValue > 0.5)\n\
	{\n\
		g = 2.0-2.0*fValue;\n\
	}\n\
	else{\n\
		g = 2.0*fValue;\n\
	}\n\
	float r = fValue;\n\
	color += vec4(r,g,b,0.8);\n\
	gl_FragColor = color;\n\
}";
ShaderSource.wgs84_volumVS = "precision mediump float;\n\
\n\
attribute vec3 position;\n\
uniform mat4 projectionMatrix;\n\
\n\
void main()\n\
{	\n\
	vec4 pos = projectionMatrix * vec4(position.xyz, 1.0);\n\
    gl_Position = pos;\n\
}";

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Uniform1fDataPair
 * @param gl 변수
 */
var Uniform1fDataPair = function(gl, uniformName) 
{
	if (!(this instanceof Uniform1fDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.floatValue; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
Uniform1fDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform1f(this.uniformLocation, this.floatValue[0]);
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Uniform1iDataPair
 * @param gl 변수
 */
var Uniform1iDataPair = function(gl, uniformName) 
{
	if (!(this instanceof Uniform1iDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.intValue; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
Uniform1iDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform1i(this.uniformLocation, this.intValue);
};
'use strict';


/**
 * 어떤 일을 하고 있습니까?
 * @class UniformMatrix4fvDataPair
 * @param gl 변수
 */
var UniformMatrix4fvDataPair = function(gl, uniformName) 
{
	if (!(this instanceof UniformMatrix4fvDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.matrix4fv; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
UniformMatrix4fvDataPair.prototype.bindUniform = function() 
{
	this.gl.uniformMatrix4fv(this.uniformLocation, false, this.matrix4fv);
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class UniformVec2fvDataPair
 * @param gl 변수
 */
var UniformVec2fvDataPair = function(gl, uniformName) 
{
	if (!(this instanceof UniformVec2fvDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.vec2fv; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
UniformVec2fvDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform2fv(this.uniformLocation, this.vec2fv);
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class UniformVec3fvDataPair
 * @param gl 변수
 */
var UniformVec3fvDataPair = function(gl, uniformName) 
{
	if (!(this instanceof UniformVec3fvDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.vec3fv; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
UniformVec3fvDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform3fv(this.uniformLocation, this.vec3fv);
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class UniformVec4fvDataPair
 * @param gl 변수
 */
var UniformVec4fvDataPair = function(gl, uniformName) 
{
	if (!(this instanceof UniformVec4fvDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.vec4fv; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
UniformVec4fvDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform4fv(this.uniformLocation, this.vec4fv);
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class ByteColor
 */
var ByteColor = function() 
{
	if (!(this instanceof ByteColor)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.ByteR = 0;
	this.ByteG = 0;
	this.ByteB = 0;
	this.ByteAlfa = 255;
};

/**
 * 어떤 일을 하고 있습니까?
 */
ByteColor.prototype.destroy = function() 
{
	this.ByteR = null;
	this.ByteG = null;
	this.ByteB = null;
	this.ByteAlfa = null;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param byteRed 변수
 * @param byteGreen 변수
 * @param byteBlue 변수
 */
ByteColor.prototype.set = function(byteRed, byteGreen, byteBlue) 
{
	this.ByteR = byteRed;
	this.ByteG = byteGreen;
	this.ByteB = byteBlue;
};

'use strict';

/**
 * Returns the first parameter if not undefined, otherwise the second parameter.
 * Useful for setting a default value for a parameter.
 *
 * @exports defaultValue
 *
 * @param {*} a
 * @param {*} b
 * @returns {*} Returns the first parameter if not undefined, otherwise the second parameter.
 *
 * @example
 * param = defaultValue(param, 'default');
 * 
 * @copyright https://github.com/AnalyticalGraphicsInc/cesium
 */
function defaultValue(a, b) 
{
	if (a !== undefined && a !== null) 
	{
		return a;
	}
	return b;
}
'use strict';

/**
 * @exports defined
 *
 * @param {*} value The object.
 * @returns {Boolean} Returns true if the object is defined, returns false otherwise.
 *
 * @example
 * if (Cesium.defined(positions)) {
 *      doSomething();
 * } else {
 *      doSomethingElse();
 * }
 */
function defined(value) 
{
	return value !== undefined && value !== null;
}
'use strict';

/**
 * ManagerUtils does some calculations about coordinates system of different earth coords.
 * 
 * @class ManagerUtils
 * @constructor 
 */
var ManagerUtils = function() 
{
	
	
};

/**
 * world coordinate to geographic coordinate.
 * @param {Point3D} point world coordinate.
 * @param {GeographicCoord|undefined} resultGeographicCoord Optional. result geographicCoord. if undefined, create GeographicCoord instance.
 * @param {MagoManager} magoManager worldwind mode removed, this args is not need. 
 * @returns {GeographicCoord} geographic coordinate object.
 */
ManagerUtils.pointToGeographicCoord = function(point, resultGeographicCoord, magoManager) 
{
	if (resultGeographicCoord === undefined)
	{ resultGeographicCoord = new GeographicCoord(); }
	
	var cartographic = Globe.CartesianToGeographicWgs84(point.x, point.y, point.z, cartographic);
	resultGeographicCoord.setLonLatAlt(cartographic.longitude, cartographic.latitude, cartographic.altitude);
	
	return resultGeographicCoord;
};

/**
 * geographic coordinate to world coordinate.
 * @param {number} longitude longitude.
 * @param {number} latitude latitude.
 * @param {number} altitude altitude.
 * @param {Point3D|undefined} resultWorldPoint Optional. result worldCoord. if undefined, create Point3D instance.
 * @param {MagoManager} magoManager worldwind mode removed, this args is not need. 
 * @returns {Point3D} world coordinate object.
 */
ManagerUtils.geographicCoordToWorldPoint = function(longitude, latitude, altitude, resultWorldPoint, magoManager) 
{
	if (resultWorldPoint === undefined)
	{ resultWorldPoint = new Point3D(); }

	var cartesian = Globe.geographicToCartesianWgs84(longitude, latitude, altitude, undefined);
	resultWorldPoint.set(cartesian[0], cartesian[1], cartesian[2]);
	
	return resultWorldPoint;
};

/**
 * when node mapping type is boundingboxcenter, set pivotPointTraslation and create pivotPoint at geoLocationData
 * this function NO modifies the geographic coords.
 * "newPivotPoint" is in buildingCoords.
 * "newPivotPoint" is the desired position of the new origen of coords, for example:
 * in a building you can desire the center of the bbox as the origin of the coords.
 * @param {GeoLocationData} geoLocationData. Required.
 * @param {Point3D} newPivotPoint newPivotPoint.
 */
ManagerUtils.translatePivotPointGeoLocationData = function(geoLocationData, newPivotPoint) 
{
	if (geoLocationData === undefined)
	{ return; }

	var rawTranslation = new Point3D();
	rawTranslation.set(-newPivotPoint.x, -newPivotPoint.y, -newPivotPoint.z);

	geoLocationData.pivotPointTraslation = rawTranslation;
	geoLocationData.doEffectivePivotPointTranslation();
};

/**
 * this function calculates the transformation matrix for (x, y, z) coordinate, that has NO heading, pitch or roll rotations.
 * @param {Point3D} worldPosition worldPosition.
 * @param {Matrix4|undefined} resultGeoLocMatrix. Optional. result geolocation matrix. if undefined, create Matrix4 instance.
 * @returns {Matrix4} resultGeoLocMatrix. this matrix has NO heading, pitch or roll rotations.
 */
ManagerUtils.calculateGeoLocationMatrixAtWorldPosition = function(worldPosition, resultGeoLocMatrix, magoManager) 
{
	if (resultGeoLocMatrix === undefined)
	{ resultGeoLocMatrix = new Matrix4(); }

	if (magoManager.globe === undefined)
	{ magoManager.globe = new Globe(); }
	magoManager.globe.transformMatrixAtCartesianPointWgs84(worldPosition.x, worldPosition.y, worldPosition.z, resultGeoLocMatrix._floatArrays);
	
	return resultGeoLocMatrix;
};

/**
 * this function calculates the transformation matrix for (longitude, latitude, altitude) coordinate, that has NO heading, pitch or roll rotations.
 * @param {number} longitude longitude.
 * @param {number} latitude latitude.
 * @param {number} altitude altitude.
 * @param {Matrix4|undefined} resultGeoLocMatrix. Optional. result geolocation matrix. if undefined, create Matrix4 instance.
 * @returns {Matrix4} resultGeoLocMatrix. this matrix has NO heading, pitch or roll rotations.
 */
ManagerUtils.calculateGeoLocationMatrixAtLonLatAlt = function(longitude, latitude, altitude, resultGeoLocMatrix, magoManager) 
{
	if (resultGeoLocMatrix === undefined)
	{ resultGeoLocMatrix = new Matrix4(); }
	
	var worldPosition = this.geographicCoordToWorldPoint(longitude, latitude, altitude, worldPosition, magoManager);
	resultGeoLocMatrix = ManagerUtils.calculateGeoLocationMatrixAtWorldPosition(worldPosition, resultGeoLocMatrix, magoManager);
	
	return resultGeoLocMatrix;
};

/**
 * This function calculates the "resultGeoLocMatrix" & "resultTransformMatrix".
 * @param {Point3D} worldPosition worldPosition.
 * @param {number} heading heading.
 * @param {number} pitch pitch.
 * @param {number} roll roll.
 * @param {Matrix4|undefined} resultGeoLocMatrix. Optional. result geolocation matrix. if undefined, create Matrix4 instance. this transformMatrix without the heading, pitch, roll rotations.
 * @param {Matrix4|undefined} resultTransformMatrix. Optional. result transform matrix. if undefined, create Matrix4 instance. this matrix including the heading, pitch, roll rotations.
 * @returns {Matrix4} resultTransformMatrix.
 */
ManagerUtils.calculateTransformMatrixAtWorldPosition = function(worldPosition, heading, pitch, roll, resultGeoLocMatrix, resultTransformMatrix, magoManager) 
{
	var xRotMatrix = new Matrix4();  // created as identity matrix.
	var yRotMatrix = new Matrix4();  // created as identity matrix.
	var zRotMatrix = new Matrix4();  // created as identity matrix.
	
	if (heading !== undefined && heading !== 0)
	{ zRotMatrix.rotationAxisAngDeg(heading, 0.0, 0.0, 1.0); }

	if (pitch !== undefined && pitch !== 0)
	{ xRotMatrix.rotationAxisAngDeg(pitch, 1.0, 0.0, 0.0); }

	if (roll !== undefined && roll !== 0)
	{ yRotMatrix.rotationAxisAngDeg(roll, 0.0, 1.0, 0.0); }

	if (resultGeoLocMatrix === undefined)
	{ resultGeoLocMatrix = new Matrix4(); }  // created as identity matrix.
	
	if (resultTransformMatrix === undefined)
	{ resultTransformMatrix = new Matrix4(); }  // created as identity matrix.

	// 1rst, calculate the transformation matrix for the location.
	resultGeoLocMatrix = ManagerUtils.calculateGeoLocationMatrixAtWorldPosition(worldPosition, resultGeoLocMatrix, magoManager);
	
	resultTransformMatrix.copyFromMatrix4(resultGeoLocMatrix);
	var zRotatedTMatrix;
	var zxRotatedTMatrix;
	var zxyRotatedTMatrix;

	zRotatedTMatrix = zRotMatrix.getMultipliedByMatrix(resultTransformMatrix, zRotatedTMatrix);
	zxRotatedTMatrix = xRotMatrix.getMultipliedByMatrix(zRotatedTMatrix, zxRotatedTMatrix);
	zxyRotatedTMatrix = yRotMatrix.getMultipliedByMatrix(zxRotatedTMatrix, zxyRotatedTMatrix);
	
	resultTransformMatrix = zxyRotatedTMatrix;
	return resultTransformMatrix;
};

/**
 * This function calculates all data and matrices for the location(longitude, latitude, altitude) and rotation(heading, pitch, roll).
 * @param {number} longitude Required. longitude.
 * @param {number} latitude Required. latitude.
 * @param {number} altitude altitude.
 * @param {number} heading heading. Unit is degree.
 * @param {number} pitch pitch. Unit is degree.
 * @param {number} roll roll. Unit is degree.
 * @param {GeoLocationData|undefined} resultGeoLocationData Optional. result geolocation matrix. if undefined, create GeoLocationData instance.
 * @param {MagoManager} magoManager for magoManager.globe
 * @returns {GeoLocationData} resultGeoLocationData.
 */
ManagerUtils.calculateGeoLocationData = function(longitude, latitude, altitude, heading, pitch, roll, resultGeoLocationData, magoManager) 
{
	if (resultGeoLocationData === undefined)
	{ resultGeoLocationData = new GeoLocationData(); }

	// 0) Position.**
	if (resultGeoLocationData.geographicCoord === undefined)
	{ resultGeoLocationData.geographicCoord = new GeographicCoord(); }

	if (longitude !== undefined)
	{ resultGeoLocationData.geographicCoord.longitude = longitude; }
	else 
	{ longitude = resultGeoLocationData.geographicCoord.longitude; }

	if (latitude !== undefined)
	{ resultGeoLocationData.geographicCoord.latitude = latitude; }
	else 
	{ latitude = resultGeoLocationData.geographicCoord.latitude; }

	if (altitude !== undefined)
	{ resultGeoLocationData.geographicCoord.altitude = altitude; }
	else 
	{ altitude = resultGeoLocationData.geographicCoord.altitude; }

	if (heading !== undefined)
	{ resultGeoLocationData.heading = heading; }

	if (pitch !== undefined)
	{ resultGeoLocationData.pitch = pitch; }

	if (roll !== undefined)
	{ resultGeoLocationData.roll = roll; }

	if (resultGeoLocationData.geographicCoord.longitude === undefined || resultGeoLocationData.geographicCoord.latitude === undefined)
	{ return; }
	
	if (magoManager.configInformation === undefined)
	{ return; }

	resultGeoLocationData.position = this.geographicCoordToWorldPoint(longitude, latitude, altitude, resultGeoLocationData.position, magoManager);

	// High and Low values of the position.**
	if (resultGeoLocationData.positionHIGH === undefined)
	{ resultGeoLocationData.positionHIGH = new Float32Array([0.0, 0.0, 0.0]); }
	if (resultGeoLocationData.positionLOW === undefined)
	{ resultGeoLocationData.positionLOW = new Float32Array([0.0, 0.0, 0.0]); }
	this.calculateSplited3fv([resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z], resultGeoLocationData.positionHIGH, resultGeoLocationData.positionLOW);

	// Determine the elevation of the position.**
	//var cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
	//var height = cartographic.height;
	// End Determine the elevation of the position.-------------------------------------------------------
	if (resultGeoLocationData.tMatrix === undefined)
	{ resultGeoLocationData.tMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.tMatrix.Identity(); }

	if (resultGeoLocationData.geoLocMatrix === undefined)
	{ resultGeoLocationData.geoLocMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.geoLocMatrix.Identity(); }

	if (resultGeoLocationData.rotMatrix === undefined)
	{ resultGeoLocationData.rotMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.rotMatrix.Identity(); }

	// Set inverseMatrices as undefined.
	resultGeoLocationData.tMatrixInv = undefined; // reset. is calculated when necessary.
	resultGeoLocationData.rotMatrixInv = undefined; // reset. is calculated when necessary.
	resultGeoLocationData.geoLocMatrixInv = undefined; // reset. is calculated when necessary.

	// 1rst, calculate the transformation matrix for the location.
	resultGeoLocationData.tMatrix = ManagerUtils.calculateTransformMatrixAtWorldPosition(resultGeoLocationData.position, resultGeoLocationData.heading, resultGeoLocationData.pitch, resultGeoLocationData.roll, 
		resultGeoLocationData.geoLocMatrix, resultGeoLocationData.tMatrix, magoManager);
	resultGeoLocationData.rotMatrix.copyFromMatrix4(resultGeoLocationData.tMatrix);
	resultGeoLocationData.rotMatrix._floatArrays[12] = 0;
	resultGeoLocationData.rotMatrix._floatArrays[13] = 0;
	resultGeoLocationData.rotMatrix._floatArrays[14] = 0;
	
	// finally assing the pivotPoint.
	if (resultGeoLocationData.pivotPoint === undefined)
	{ resultGeoLocationData.pivotPoint = new Point3D(); }

	resultGeoLocationData.pivotPoint.set(resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z);
	resultGeoLocationData.doEffectivePivotPointTranslation();
	
	return resultGeoLocationData;
};

/**
 * This function calculates geolocation data use pixel point(calculated world point). 
 * When use Object Marker, this function called.
 * @param {number} absoluteX absoluteX.
 * @param {number} absoluteY absoluteY.
 * @param {number} absoluteZ absoluteZ.
 * @param {GeoLocationData|undefined} resultGeoLocationData Optional. result geolocation matrix. if undefined, create GeoLocationData instance.
 * @param {MagoManager} magoManager
 * @returns {GeoLocationData} resultGeoLocationData.
 */
ManagerUtils.calculateGeoLocationDataByAbsolutePoint = function(absoluteX, absoluteY, absoluteZ, resultGeoLocationData, magoManager) 
{
	if (resultGeoLocationData === undefined)
	{ resultGeoLocationData = new GeoLocationData(); }

	// 0) Position.**
	if (resultGeoLocationData.geographicCoord === undefined)
	{ resultGeoLocationData.geographicCoord = new GeographicCoord(); }
	
	if (magoManager.configInformation === undefined)
	{ return; }
	
	if (resultGeoLocationData.position === undefined)
	{ resultGeoLocationData.position = new Point3D(); }
		
	resultGeoLocationData.position.x = absoluteX;
	resultGeoLocationData.position.y = absoluteY;
	resultGeoLocationData.position.z = absoluteZ;
	
	//추후에 세슘의존성 버리는 코드로 대체 가능해 보임. 손수석님과 검토 필요.
	if (magoManager.configInformation.geo_view_library === Constant.CESIUM)
	{
		// *if this in Cesium:
		//resultGeoLocationData.position = Cesium.Cartesian3.fromDegrees(resultGeoLocationData.geographicCoord.longitude, resultGeoLocationData.geographicCoord.latitude, resultGeoLocationData.geographicCoord.altitude);
		// must find cartographic data.
		var cartographic = new Cesium.Cartographic();
		var cartesian = new Cesium.Cartesian3();
		cartesian.x = absoluteX;
		cartesian.y = absoluteY;
		cartesian.z = absoluteZ;
		cartographic = Cesium.Cartographic.fromCartesian(cartesian, magoManager.scene._globe._ellipsoid, cartographic);
		resultGeoLocationData.geographicCoord.longitude = cartographic.longitude * 180.0/Math.PI;
		resultGeoLocationData.geographicCoord.latitude = cartographic.latitude * 180.0/Math.PI;
		resultGeoLocationData.geographicCoord.altitude = cartographic.height;
	}

	// High and Low values of the position.**
	if (resultGeoLocationData.positionHIGH === undefined)
	{ resultGeoLocationData.positionHIGH = new Float32Array([0.0, 0.0, 0.0]); }
	if (resultGeoLocationData.positionLOW === undefined)
	{ resultGeoLocationData.positionLOW = new Float32Array([0.0, 0.0, 0.0]); }
	this.calculateSplited3fv([resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z], resultGeoLocationData.positionHIGH, resultGeoLocationData.positionLOW);

	// Determine the elevation of the position.**
	//var cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
	//var height = cartographic.height;
	// End Determine the elevation of the position.-------------------------------------------------------
	if (resultGeoLocationData.tMatrix === undefined)
	{ resultGeoLocationData.tMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.tMatrix.Identity(); }

	if (resultGeoLocationData.geoLocMatrix === undefined)
	{ resultGeoLocationData.geoLocMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.geoLocMatrix.Identity(); }

	if (resultGeoLocationData.geoLocMatrixInv === undefined)
	{ resultGeoLocationData.geoLocMatrixInv = new Matrix4(); }
	else
	{ resultGeoLocationData.geoLocMatrixInv.Identity(); }

	//---------------------------------------------------------

	if (resultGeoLocationData.tMatrixInv === undefined)
	{ resultGeoLocationData.tMatrixInv = new Matrix4(); }
	else
	{ resultGeoLocationData.tMatrixInv.Identity(); }

	if (resultGeoLocationData.rotMatrix === undefined)
	{ resultGeoLocationData.rotMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.rotMatrix.Identity(); }

	if (resultGeoLocationData.rotMatrixInv === undefined)
	{ resultGeoLocationData.rotMatrixInv = new Matrix4(); }
	else
	{ resultGeoLocationData.rotMatrixInv.Identity(); }

	var xRotMatrix = new Matrix4();  // created as identity matrix.
	var yRotMatrix = new Matrix4();  // created as identity matrix.
	var zRotMatrix = new Matrix4();  // created as identity matrix.

	if (resultGeoLocationData.heading !== undefined && resultGeoLocationData.heading !== 0)
	{
		zRotMatrix.rotationAxisAngDeg(resultGeoLocationData.heading, 0.0, 0.0, -1.0);
	}

	if (resultGeoLocationData.pitch !== undefined && resultGeoLocationData.pitch !== 0)
	{
		xRotMatrix.rotationAxisAngDeg(resultGeoLocationData.pitch, -1.0, 0.0, 0.0);
	}

	if (resultGeoLocationData.roll !== undefined && resultGeoLocationData.roll !== 0)
	{
		yRotMatrix.rotationAxisAngDeg(resultGeoLocationData.roll, 0.0, -1.0, 0.0);
	}
	
	if (magoManager.configInformation.geo_view_library === Constant.CESIUM)
	{
		// *if this in Cesium:
		Cesium.Transforms.eastNorthUpToFixedFrame(resultGeoLocationData.position, undefined, resultGeoLocationData.tMatrix._floatArrays);
		resultGeoLocationData.geoLocMatrix.copyFromMatrix4(resultGeoLocationData.tMatrix);// "geoLocMatrix" is the pure transformation matrix, without heading or pitch or roll.

		var zRotatedTMatrix = zRotMatrix.getMultipliedByMatrix(resultGeoLocationData.tMatrix, zRotatedTMatrix);
		var zxRotatedTMatrix = xRotMatrix.getMultipliedByMatrix(zRotatedTMatrix, zxRotatedTMatrix);
		var zxyRotatedTMatrix = yRotMatrix.getMultipliedByMatrix(zxRotatedTMatrix, zxyRotatedTMatrix);
		resultGeoLocationData.tMatrix = zxyRotatedTMatrix;
		
		// test.
		//var yRotatedTMatrix = yRotMatrix.getMultipliedByMatrix(resultGeoLocationData.tMatrix, yRotatedTMatrix);
		//var yxRotatedTMatrix = xRotMatrix.getMultipliedByMatrix(yRotatedTMatrix, yxRotatedTMatrix);
		//var yxzRotatedTMatrix = zRotMatrix.getMultipliedByMatrix(yxRotatedTMatrix, yxzRotatedTMatrix);
		//resultGeoLocationData.tMatrix = yxzRotatedTMatrix;
		// end test.---

		resultGeoLocationData.rotMatrix.copyFromMatrix4(resultGeoLocationData.tMatrix);
		resultGeoLocationData.rotMatrix._floatArrays[12] = 0;
		resultGeoLocationData.rotMatrix._floatArrays[13] = 0;
		resultGeoLocationData.rotMatrix._floatArrays[14] = 0;

		// now, calculates the inverses.
		Cesium.Matrix4.inverse(resultGeoLocationData.tMatrix._floatArrays, resultGeoLocationData.tMatrixInv._floatArrays);
		Cesium.Matrix4.inverse(resultGeoLocationData.rotMatrix._floatArrays, resultGeoLocationData.rotMatrixInv._floatArrays);
		Cesium.Matrix4.inverse(resultGeoLocationData.geoLocMatrix._floatArrays, resultGeoLocationData.geoLocMatrixInv._floatArrays);
	}

	// finally assing the pivotPoint.
	if (resultGeoLocationData.pivotPoint === undefined)
	{ resultGeoLocationData.pivotPoint = new Point3D(); }

	resultGeoLocationData.pivotPoint.set(resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z);

	return resultGeoLocationData;
};

/**
 * 자릿수가 긴 숫자를 나머지와 몫으로 분리. gl에서는 float형밖에 처리 불가.
 * @example <caption>Example usage of calculateSplitedValues</caption>
 * ManagerUtils.calculateSplitedValues(4049653.5985745606, new SplitValue());
 * resultSplitValue.high = 3997696; // Math.floor(4049653.5985745606 / 65536.0) * 65536.0;
 * resultSplitValue.low = 51957.5985745606 // 4049653.5985745606 - 3997696;
 * @param {number} value Required. coordinate x or y or z.
 * @param {SplitValue} resultSplitValue Optional. result split value. if undefined, create SplitValue instance.
 * @returns {SplitValue} resultSplitValue.
 */
ManagerUtils.calculateSplitedValues = function(value, resultSplitValue)
{
	if (resultSplitValue === undefined)
	{ resultSplitValue = new SplitValue(); }

	var doubleHigh;
	if (value >= 0.0) 
	{
		doubleHigh = Math.floor(value / 65536.0) * 65536.0; //unsigned short max
		resultSplitValue.high = doubleHigh;
		resultSplitValue.low = value - doubleHigh;
	}
	else 
	{
		doubleHigh = Math.floor(-value / 65536.0) * 65536.0;
		resultSplitValue.high = -doubleHigh;
		resultSplitValue.low = value + doubleHigh;
	}

	return resultSplitValue;
};

/**
 * 자릿수가 긴 숫자를 나머지(low)와 몫(high)으로 분리한 결과를 각각 배열로 생성. gl에서는 float형밖에 처리 불가.
 * @param {Point3D} point3fv Required.
 * @param {Float32Array} resultSplitPoint3fvHigh Optional. result split high value array. if undefined, set new Float32Array(3).
 * @param {Float32Array} resultSplitPoint3fvLow Optional. result split low value array. if undefined, set new Float32Array(3).
 * 
 * @see ManagerUtils#calculateSplitedValues
 */
ManagerUtils.calculateSplited3fv = function(point3fv, resultSplitPoint3fvHigh, resultSplitPoint3fvLow)
{
	if (point3fv === undefined)
	{ return undefined; }

	if (resultSplitPoint3fvHigh === undefined) // delete unnecesary. agree
	{ resultSplitPoint3fvHigh = new Float32Array(3); }// delete unnecesary. agree

	if (resultSplitPoint3fvLow === undefined)// delete unnecesary. agree
	{ resultSplitPoint3fvLow = new Float32Array(3); }// delete unnecesary. agree

	var posSplitX = new SplitValue();
	posSplitX = this.calculateSplitedValues(point3fv[0], posSplitX);
	var posSplitY = new SplitValue();
	posSplitY = this.calculateSplitedValues(point3fv[1], posSplitY);
	var posSplitZ = new SplitValue();
	posSplitZ = this.calculateSplitedValues(point3fv[2], posSplitZ);

	resultSplitPoint3fvHigh[0] = posSplitX.high;
	resultSplitPoint3fvHigh[1] = posSplitY.high;
	resultSplitPoint3fvHigh[2] = posSplitZ.high;

	resultSplitPoint3fvLow[0] = posSplitX.low;
	resultSplitPoint3fvLow[1] = posSplitY.low;
	resultSplitPoint3fvLow[2] = posSplitZ.low;
};

/**
 * Calculates the pixel linear depth value.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} pixelX Screen x position of the pixel.
 * @param {Number} pixelY Screen y position of the pixel.
 * @param {FBO} depthFbo Depth frameBuffer object.
 * @param {MagoManager} magoManager Mago3D main manager.
 * @returns {Number} linearDepth Returns the linear depth [0.0, 1.0] ranged value.
 */
ManagerUtils.calculatePixelLinearDepth = function(gl, pixelX, pixelY, depthFbo, magoManager) 
{
	if (depthFbo === undefined)
	{ depthFbo = magoManager.depthFboNeo; }
	
	if (depthFbo) 
	{
		depthFbo.bind(); 
	}

	// Now, read the pixel and find the pixel position.
	var depthPixels = new Uint8Array(4 * 1 * 1); // 4 x 1x1 pixel.
	gl.readPixels(pixelX, magoManager.sceneState.drawingBufferHeight - pixelY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, depthPixels);
	
	var zDepth = depthPixels[0]/(256.0*256.0*256.0) + depthPixels[1]/(256.0*256.0) + depthPixels[2]/256.0 + depthPixels[3]; // 0 to 256 range depth.
	var linearDepth = zDepth / 256.0; // LinearDepth. Convert to [0.0, 1.0] range depth.
	return linearDepth;
};

/**
 * Calculates the pixel position in camera coordinates.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} pixelX Screen x position of the pixel.
 * @param {Number} pixelY Screen y position of the pixel.
 * @param {Point3D} resultPixelPos The result of the calculation.
 * @param {MagoManager} magoManager Mago3D main manager.
 * @returns {Point3D} resultPixelPos The result of the calculation.
 */
ManagerUtils.calculatePixelPositionCamCoord = function(gl, pixelX, pixelY, resultPixelPos, depthFbo, frustumFar, magoManager) 
{
	if (frustumFar === undefined)
	{ frustumFar = magoManager.sceneState.camera.frustum.far; }
	
	var linearDepth = ManagerUtils.calculatePixelLinearDepth(gl, pixelX, pixelY, depthFbo, magoManager);
	var realZDepth = linearDepth*frustumFar; // original.

	// now, find the 3d position of the pixel in camCoord.*
	magoManager.resultRaySC = ManagerUtils.getRayCamSpace(pixelX, pixelY, magoManager.resultRaySC, magoManager);
	if (resultPixelPos === undefined)
	{ resultPixelPos = new Point3D(); }
	
	resultPixelPos.set(magoManager.resultRaySC[0] * realZDepth, magoManager.resultRaySC[1] * realZDepth, magoManager.resultRaySC[2] * realZDepth);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	return resultPixelPos;
};

/**
 * Calculates the cameraCoord position in world coordinates.
 * @param {Point3D} cameraCoord Camera coordinate position.
 * @param {MagoManager} magoManager Mago3D main manager.
 * @returns {Point3D} resultPixelPos The result of the calculation.
 */
ManagerUtils.cameraCoordPositionToWorldCoord = function(camCoordPos, resultWorldPos, magoManager) 
{
	// now, must transform this pixelCamCoord to world coord.
	var mv_inv = magoManager.sceneState.getModelViewMatrixInv();
	if (resultWorldPos === undefined)
	{ var resultWorldPos = new Point3D(); }
	resultWorldPos = mv_inv.transformPoint3D(camCoordPos, resultWorldPos);
	return resultWorldPos;
};

/**
 * Calculates the pixel position in world coordinates.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} pixelX Screen x position of the pixel.
 * @param {Number} pixelY Screen y position of the pixel.
 * @param {Point3D} resultPixelPos The result of the calculation.
 * @param {MagoManager} magoManager Mago3D main manager.
 * @returns {Point3D} resultPixelPos The result of the calculation.
 */
ManagerUtils.calculatePixelPositionWorldCoord = function(gl, pixelX, pixelY, resultPixelPos, depthFbo, frustumFar, magoManager) 
{
	var pixelPosCamCoord = new Point3D();
	
	if (frustumFar === undefined)
	{ frustumFar = magoManager.sceneState.camera.frustum.far; }
	
	if (depthFbo === undefined)
	{ depthFbo = magoManager.depthFboNeo; }
	
	pixelPosCamCoord = ManagerUtils.calculatePixelPositionCamCoord(gl, pixelX, pixelY, pixelPosCamCoord, depthFbo, frustumFar, magoManager);

	if (resultPixelPos === undefined)
	{ var resultPixelPos = new Point3D(); }

	resultPixelPos = ManagerUtils.cameraCoordPositionToWorldCoord(pixelPosCamCoord, resultPixelPos, magoManager);
	return resultPixelPos;
};

/**
 * Calculates a world coordinate point to screen coordinate.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} worldCoordX x value of the point in world coordinate.
 * @param {Number} worldCoordY y value of the point in world coordinate.
 * @param {Number} worldCoordZ z value of the point in world coordinate.
 * @param {Point3D} resultPixelPos The result of the calculation.
 * @param {MagoManager} magoManager Mago3D main manager.
 * @returns {Point3D} resultPixelPos The result of the calculation.
 */
ManagerUtils.calculateWorldPositionToScreenCoord = function(gl, worldCoordX, worldCoordY, worldCoordZ, resultScreenCoord, magoManager)
{
	if (resultScreenCoord === undefined)
	{ resultScreenCoord = new Point3D(); }
	
	if (magoManager.pointSC === undefined)
	{ magoManager.pointSC = new Point3D(); }
	
	if (magoManager.pointSC2 === undefined)
	{ magoManager.pointSC2 = new Point3D(); }
	
	magoManager.pointSC.set(worldCoordX, worldCoordY, worldCoordZ);
	
	// calculate the position in camera coords.
	var pointSC2 = magoManager.pointSC2;
	var sceneState = magoManager.sceneState;
	pointSC2 = sceneState.modelViewMatrix.transformPoint3D(magoManager.pointSC, pointSC2);
	
	// now calculate the position in screen coords.
	var zDist = pointSC2.z;
	if (zDist > 0)
	{
		// the worldPoint is rear the camera.
		resultScreenCoord.set(-1, -1, 0);
		return resultScreenCoord;
	}
	
	// now calculate the width and height of the plane in zDist.
	//var fovyRad = sceneState.camera.frustum.fovyRad;
	
	var planeHeight = sceneState.camera.frustum.tangentOfHalfFovy*zDist*2;
	var planeWidth = planeHeight * sceneState.camera.frustum.aspectRatio; 
	var pixelX = -pointSC2.x * sceneState.drawingBufferWidth / planeWidth;
	var pixelY = -(pointSC2.y) * sceneState.drawingBufferHeight / planeHeight;

	pixelX += sceneState.drawingBufferWidth / 2;
	pixelY += sceneState.drawingBufferHeight / 2;
	pixelY = sceneState.drawingBufferHeight - pixelY;
	resultScreenCoord.set(pixelX, pixelY, 0);
	
	return resultScreenCoord;
};

/**
 * Calculates the direction vector of a ray that starts in the camera position and
 * continues to the pixel position in camera space.
 * @param {Number} pixelX Screen x position of the pixel.
 * @param {Number} pixelY Screen y position of the pixel.
 * @param {Float32Array(3)} resultRay Result of the calculation.
 * @returns {Float32Array(3)} resultRay Result of the calculation.
 */
ManagerUtils.getRayCamSpace = function(pixelX, pixelY, resultRay, magoManager) 
{
	// in this function "ray" is a vector.
	var sceneState = magoManager.sceneState;
	var frustum_far = 1.0; // unitary frustum far.
	var frustum = sceneState.camera.frustum;
	var aspectRatio = frustum.aspectRatio;
	var tangentOfHalfFovy = frustum.tangentOfHalfFovy; 
	
	var hfar = 2.0 * tangentOfHalfFovy * frustum_far; //var hfar = 2.0 * Math.tan(fovy/2.0) * frustum_far;
	var wfar = hfar * aspectRatio;
	var mouseX = pixelX;
	var mouseY = sceneState.drawingBufferHeight - pixelY;
	if (resultRay === undefined) 
	{ resultRay = new Float32Array(3); }
	resultRay[0] = wfar*((mouseX/sceneState.drawingBufferWidth) - 0.5);
	resultRay[1] = hfar*((mouseY/sceneState.drawingBufferHeight) - 0.5);
	resultRay[2] = - frustum_far;
	return resultRay;
};

/**
 * Calculates the direction vector of a ray that starts in the camera position and
 * continues to the pixel position in world space.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} pixelX Screen x position of the pixel.
 * @param {Number} pixelY Screen y position of the pixel.
 * @returns {Line} resultRay
 */
ManagerUtils.getRayWorldSpace = function(gl, pixelX, pixelY, resultRay, magoManager) 
{
	// in this function the "ray" is a line.
	if (resultRay === undefined) 
	{ resultRay = new Line(); }
	
	// world ray = camPos + lambda*camDir.
	var camPos = magoManager.sceneState.camera.position;
	var rayCamSpace = new Float32Array(3);
	rayCamSpace = ManagerUtils.getRayCamSpace(pixelX, pixelY, rayCamSpace, magoManager);
	
	if (magoManager.pointSC === undefined)
	{ magoManager.pointSC = new Point3D(); }
	
	var pointSC = magoManager.pointSC;
	var pointSC2 = magoManager.pointSC2;
	
	pointSC.set(rayCamSpace[0], rayCamSpace[1], rayCamSpace[2]);

	// now, must transform this posCamCoord to world coord.
	pointSC2 = magoManager.sceneState.modelViewMatrixInv.rotatePoint3D(pointSC, pointSC2); // rayWorldSpace.
	pointSC2.unitary(); // rayWorldSpace.
	resultRay.setPointAndDir(camPos.x, camPos.y, camPos.z,       pointSC2.x, pointSC2.y, pointSC2.z);// original.

	return resultRay;
};






























































'use strict';
/**
 * 어떤 일을 하고 있습니까?
 * @class TTriangle
 */
var TTriangle = function() 
{
	if (!(this instanceof TTriangle)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.mVertex1;
	this.mVertex2;
	this.mVertex3;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param vtx1 변수
 * @param vtx2 변수
 * @param vtx3 변수
 */
TTriangle.prototype.setVertices = function(vtx1, vtx2, vtx3) 
{
	this.mVertex1 = vtx1;
	this.mVertex2 = vtx2;
	this.mVertex3 = vtx3;
};

/**
 * 어떤 일을 하고 있습니까?
 */
TTriangle.prototype.invert = function() 
{
	var vertexAux = this.mVertex2;
	this.mVertex2 = this.mVertex3;
	this.mVertex3 = vertexAux;
};
'use strict';
/**
 * 어떤 일을 하고 있습니까?
 * @class TTrianglesList
 */
var TTrianglesList = function() 
{
	if (!(this instanceof TTrianglesList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.tTrianglesArray = [];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns tTri
 */
TTrianglesList.prototype.newTTriangle = function() 
{
	var tTri = new TTriangle();
	this.tTrianglesArray.push(tTri);
	return tTri;
};

/**
 * 어떤 일을 하고 있습니까?
 */
TTrianglesList.prototype.invertTrianglesSense= function() 
{
	for (var i = 0, triCount = this.tTrianglesArray.length; i < triCount; i++) 
	{
		this.tTrianglesArray[i].invert();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns tTrianglesArray[idx]
 */
TTrianglesList.prototype.getTTriangle = function(idx) 
{
	if (idx >= 0 && idx < this.tTrianglesArray.length) 
	{
		return this.tTrianglesArray[idx];
	}
	else
	{
		return undefined;
	}
};


'use strict';
/**
 * 어떤 일을 하고 있습니까?
 * @class TTrianglesMatrix
 */
var TTrianglesMatrix = function() 
{
	if (!(this instanceof TTrianglesMatrix)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.tTrianglesListsArray = [];
	// SCRATX.
	this.totalTTrianglesArraySC = [];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns tTrianglesList
 */
TTrianglesMatrix.prototype.newTTrianglesList = function() 
{
	var tTrianglesList = new TTrianglesList();
	this.tTrianglesListsArray.push(tTrianglesList);
	return tTrianglesList;
};

/**
 * 어떤 일을 하고 있습니까?
 */
TTrianglesMatrix.prototype.invertTrianglesSense = function() 
{
	for (var i = 0, tTriListsCount = this.tTrianglesListsArray.length; i < tTriListsCount; i++) 
	{
		this.tTrianglesListsArray[i].invertTrianglesSense();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param resultTotalTTrianglesArray 변수
 * @returns resultTotalTTrianglesArray
 */
TTrianglesMatrix.prototype.getTotalTTrianglesArray = function(resultTotalTTrianglesArray) 
{
	for (var i = 0, tTriListsCount = this.tTrianglesListsArray.length; i < tTriListsCount; i++) 
	{
		for (var j = 0, tTrianglesCount = this.tTrianglesListsArray[i].tTrianglesArray.length; j < tTrianglesCount; j++) 
		{
			var tTriangle = this.tTrianglesListsArray[i].getTTriangle(j);
			resultTotalTTrianglesArray.push(tTriangle);
		}
	}

	return resultTotalTTrianglesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns shortArray
 */
TTrianglesMatrix.prototype.getVBOIndicesShortArray = function() 
{
	this.totalTTrianglesArraySC.length = 0;
	this.totalTTrianglesArraySC = this.getTotalTTrianglesArray(this.totalTTrianglesArraySC);

	var tTriangle;
	var tTrianglesCount = this.totalTTrianglesArraySC.length;
	var shortArray = new Uint16Array(tTrianglesCount * 3);
	for (var i = 0; i < tTrianglesCount; i++) 
	{
		tTriangle = this.totalTTrianglesArraySC[i];
		shortArray[i*3] = tTriangle.mVertex1.mIdxInList;
		shortArray[i*3+1] = tTriangle.mVertex2.mIdxInList;
		shortArray[i*3+2] = tTriangle.mVertex3.mIdxInList;
	}

	return shortArray;
};



/**
  * A module containing Data from IndoorGML.</br>
  * This module contains the variables required to navigate in 3D buildings built in DisplayHelper and
  * the functions required for parsing that variables from json object.</br>
  * Unlike existing maps, the indoor space viewer is restricted due to the spatial factor of the wall.</br>
  * With this in mind, this module ensures that the user moves only on the network defined in the GML file
  * to limit unusual behavior such as user penetration through the wall.</br>
  * @module GMLDataContainer
  */

  'use strict';


  /**
   * Create new GMLDataContainer
   * @alias module:GMLDataContainer
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  function GMLDataContainer(jsonresponse, gmlVersion) {

    /**
     * JSON object parsed from inputed json data file.</br>
     * Inputed json data file is converted from IndoorGML file.</br>
     * You can convert IndoorGML to json through 'gmlToJson' in our git hub project.
     */
    this.jsonresponse = jsonresponse;

    /**
     * This value appears in the IndoorGML document <State>.</br>
     * Within the topographic space layer, a state can be associated with a room, corridor, door, etc.</br>
     * And this may be an isolated node, i.e. not connected to another State.
     */
    this.nodes = [];

    /**
     * This value appears in the IndoorGML document <Transition>.</br>
     * And Transition is an edge that represents the adjacency or connectivity relationships among nodes representing space objects in primal space.</br>
     * Transition always connects two States.
     */
    this.edges = [];

    /**
     * In IndoorGML, CellSpaceis a base class for representing the indoor space.</br>
     * Each CellSpace is associated with a geometry object which can be represented as several geometry primitive types such as 2D and 3D.</br>
     * In short, <State> and <Transition> are responsible for the relationship between the spaces, and <CellSpace> is about the geometry that constitutes the space.
     */
    this.cellSpaceMembers = [];

    /**
     * CellSpaceBoundary is used to semantically describe the boundary of each geographical feature in space.</br>
     * You can notice that if you visualize geometry of this it look like door or something connecting one space to other.</br>
     * In this project we don't need to use this value because we can distinguish door from description of cellSpaceMembers.
     */
    this.cellSpaceBoundaryMembers = [];

    /**
     * The maximum x coordinate. This value will used for calculating center x coordinate of building.
     */
    this.max_X = 0;

    /**
     * The maximum y coordinate. This value will used for calculating center y coordinate of building.
     */
    this.max_Y = 0;

    /**
     * The maximum z coordinate. This value will used for calculating center z coordinate of building.
     */
    this.max_Z = 0;



    /**
     * The maximum x coordinate. This value will used for calculating center x coordinate of building.
     */
    this.min_X = 0;

    /**
     * The maximum y coordinate. This value will used for calculating center y coordinate of building.
     */
    this.min_Y = 0;

    /**
     * The maximum z coordinate. This value will used for calculating center z coordinate of building.
     */
    this.min_Z = 0;



    /**
     * The Center X coordinate of building.
     */
    this.center_X = 0;

    /**
     * The Center Y coordinate of building.
     */
    this.center_Y = 0;


    /** The object onto which to store the transformation result. */
    this.ENU = new Cesium.Matrix4();

    this.jsonParsor;

    this.parsingJson(jsonresponse, gmlVersion);
    this.setCenter();
  }



  /**
   * Parse the data(nodes, edges, cellSpace, cellSpaceBoundary ) required to produce the viewer in the JSON object.
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  GMLDataContainer.prototype.parsingJson = function(jsonresponse, gmlVersion) {

    if(gmlVersion == "1.0.1"){
      this.jsonParsor = new JsonParsor_1_0_1(jsonresponse);
    }
    else if(gmlVersion == "1.0.3"){
      this.jsonParsor = new JsonParsor_1_0_3(jsonresponse);
    }
    else{
      alert(gmlVersion + " is not a vailid version!");
    }

    this.nodes = this.jsonParsor.parsingNodeData(jsonresponse);
    this.edges = this.jsonParsor.parsingEdgeData(jsonresponse);
    this.cellSpaceMembers = this.jsonParsor.parsingCellSpaceMember(jsonresponse);

    this.max_X = this.jsonParsor.getMaxX();
    this.max_Y = this.jsonParsor.getMaxY();
    this.max_Z = this.jsonParsor.getMaxZ();
    this.min_X = this.jsonParsor.getMinX();
    this.min_Y = this.jsonParsor.getMinY();
    this.min_Z = this.jsonParsor.getMinZ();
    // this.cellSpaceBoundaryMembers = this.parsingCellSpaceBoundaryMember(jsonresponse);

  };


  /**
   * Calculate the central coordinates of the building.
   */
  GMLDataContainer.prototype.setCenter = function() {
    this.center_X = (this.min_X + this.max_X) / 2;
    this.center_Y = (this.min_Y + this.max_Y) / 2;
  }



  /**
   * When the inputted coordinates differs from the actual world, this tries to rotate the building to reduce the gap.
   * @param {Cesium.Viewer} viewer
   * @param {Cesium.Cartesian3} position position on actual world
   * @param {number} angle angle for rotate
   */
  GMLDataContainer.prototype.rotateBuilding = function(viewer, position, angle) {

    var ellipsoid = viewer.scene.globe.ellipsoid;

    /** Rotation matrix */
    var orientation = new Cesium.Matrix4(Math.cos(angle), -Math.sin(angle), 0, 0,
      Math.sin(angle), Math.cos(angle), 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1);


    this.rotateCellSpaceMember(orientation, position, ellipsoid);
    this.rotateCellSpaceBoundaryMembers(orientation, position, ellipsoid);
    this.rotateNodes(orientation);
    this.rotateEdges(orientation);

  }



  /**
   * Rotate nodes
   * @param {Cesium.Matrix4} orientation rotation matrix for rotation
   */
  GMLDataContainer.prototype.rotateNodes = function(orientation) {

    var nodesLen = this.nodes.length;

    /** Applying translation and rotation to the nodes */
    for (var i = 0; i < nodesLen; i++) {

      /** Translating coordinates + converting the result to Cartesian3 */
      var offset = new Cesium.Cartesian3(this.nodes[i].coordinates[0] - this.center_X,
        this.nodes[i].coordinates[1] - this.center_Y,
        this.nodes[i].coordinates[2] - this.min_Z);

      /** Applying rotation to the offset */
      var finalPos = Cesium.Matrix4.multiplyByPoint(orientation, offset, new Cesium.Cartesian3());

      /** Report offset to the actual position of LWM */
      var new_coord = Cesium.Matrix4.multiplyByPoint(this.ENU, finalPos, finalPos);

      /** Replacing the old coordinates by the new ones */
      this.nodes[i].coordinates[0] = new_coord.x;
      this.nodes[i].coordinates[1] = new_coord.y;
      this.nodes[i].coordinates[2] = new_coord.z;
    }
  }



  /**
   * Rotate edges
   * @param {Cesium.Matrix4} orientation rotation matrix for rotation
   */
  GMLDataContainer.prototype.rotateEdges = function(orientation) {

    /** Applying translation and rotation to the edges */
    for (var i = 0; i < this.edges.length; i++) {

      for (var j = 0; j < this.edges[i].stateMembers.length; j++) {

        var offset = new Cesium.Cartesian3(this.edges[i].stateMembers[j].coordinates[0] - this.center_X,
          this.edges[i].stateMembers[j].coordinates[1] - this.center_Y,
          this.edges[i].stateMembers[j].coordinates[2] - this.min_Z);

        var finalPos = Cesium.Matrix4.multiplyByPoint(orientation, offset, new Cesium.Cartesian3());

        var new_coord = Cesium.Matrix4.multiplyByPoint(this.ENU, finalPos, finalPos);

        this.edges[i].stateMembers[j].coordinates[0] = new_coord.x;
        this.edges[i].stateMembers[j].coordinates[1] = new_coord.y;
        this.edges[i].stateMembers[j].coordinates[2] = new_coord.z;
      }
    }
  }



  /**
   * Rotate cellSpaceMembers
   * @param {Cesium.Matrix4} orientation rotation matrix for rotation
   * @param {Cesium.Cartesian3} position position on actual world
   * @param {Cesium.Ellipsoid} ellipsoid
   */
  GMLDataContainer.prototype.rotateCellSpaceMember = function(orientation, position, ellipsoid) {

    Cesium.Transforms.eastNorthUpToFixedFrame(position, ellipsoid, this.ENU);

    /** Applying translation and rotation to coordinates */
    for (var i = 0; i < this.cellSpaceMembers.length; i++) {

      var csmLen = this.cellSpaceMembers[i].surfaceMember.length;

      for (var j = 0; j < csmLen; j++) {
        var smLen = this.cellSpaceMembers[i].surfaceMember[j].coordinates.length;

        for (var k = 0; k < smLen; k += 3) {

          /** Translating coordinates + converting the result to Cartesian3 */
          var offset = new Cesium.Cartesian3(this.cellSpaceMembers[i].surfaceMember[j].coordinates[k] - this.center_X,
            this.cellSpaceMembers[i].surfaceMember[j].coordinates[k + 1] - this.center_Y,
            this.cellSpaceMembers[i].surfaceMember[j].coordinates[k + 2] - this.min_Z);

          /** Applying rotation to the offset */
          var finalPos = Cesium.Matrix4.multiplyByPoint(orientation, offset, new Cesium.Cartesian3());

          /** Report offset to the actual position of LWM */
          var new_coord = Cesium.Matrix4.multiplyByPoint(this.ENU, finalPos, finalPos);

          /** Replacing the old coordinates by the new ones */
          this.cellSpaceMembers[i].surfaceMember[j].coordinates[k] = new_coord.x;
          this.cellSpaceMembers[i].surfaceMember[j].coordinates[k + 1] = new_coord.y;
          this.cellSpaceMembers[i].surfaceMember[j].coordinates[k + 2] = new_coord.z;
        }
      }
    }
  }



  /**
   * Rotate cellSpaceBoundaryMembers
   * @param {Cesium.Matrix4} orientation rotation matrix for rotation
   * @param {Cesium.Cartesian3} position position on actual world
   * @param {Cesium.Ellipsoid} ellipsoid
   */
  GMLDataContainer.prototype.rotateCellSpaceBoundaryMembers = function(orientation, position, ellipsoid) {

    Cesium.Transforms.eastNorthUpToFixedFrame(position, ellipsoid, this.ENU);

    /** Applying translation and rotation to coordinates */
    for (var i = 0; i < this.cellSpaceBoundaryMembers.length; i++) {

      var csmLen = this.cellSpaceBoundaryMembers[i].surfaceMember.length;

      for (var j = 0; j < csmLen; j++) {
        var smLen = this.cellSpaceBoundaryMembers[i].surfaceMember[j].coordinates.length;

        for (var k = 0; k < smLen; k += 3) {

          /** Translating coordinates + converting the result to Cartesian3 */
          var offset = new Cesium.Cartesian3(this.cellSpaceBoundaryMembers[i].surfaceMember[j].coordinates[k] - this.center_X,
            this.cellSpaceBoundaryMembers[i].surfaceMember[j].coordinates[k + 1] - this.center_Y,
            this.cellSpaceBoundaryMembers[i].surfaceMember[j].coordinates[k + 2] - this.min_Z);

          /** Applying rotation to the offset */
          var finalPos = Cesium.Matrix4.multiplyByPoint(orientation, offset, new Cesium.Cartesian3());

          /** Report offset to the actual position of LWM */
          var new_coord = Cesium.Matrix4.multiplyByPoint(this.ENU, finalPos, finalPos);

          /** Replacing the old coordinates by the new ones */
          this.cellSpaceBoundaryMembers[i].surfaceMember[j].coordinates[k] = new_coord.x;
          this.cellSpaceBoundaryMembers[i].surfaceMember[j].coordinates[k + 1] = new_coord.y;
          this.cellSpaceBoundaryMembers[i].surfaceMember[j].coordinates[k + 2] = new_coord.z;
        }
      }
    }
  }




/**
  * @module JsonParsor_1_0_1
  */

  'use strict';


  /**
   * @alias module:JsonParsor_1_0_1
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  function JsonParsor_1_0_1(jsonresponse) {

    /**
     * JSON object parsed from inputed json data file.</br>
     * Inputed json data file is converted from IndoorGML file.</br>
     * You can convert IndoorGML to json through 'gmlToJson' in our git hub project.
     */
    this.jsonresponse = jsonresponse;

    /**
     * The maximum x coordinate. This value will used for calculating center x coordinate of building.
     */
    this.max_X = 0;

    /**
     * The maximum y coordinate. This value will used for calculating center y coordinate of building.
     */
    this.max_Y = 0;

    /**
     * The maximum z coordinate. This value will used for calculating center z coordinate of building.
     */
    this.max_Z = 0;



    /**
     * The maximum x coordinate. This value will used for calculating center x coordinate of building.
     */
    this.min_X = 0;

    /**
     * The maximum y coordinate. This value will used for calculating center y coordinate of building.
     */
    this.min_Y = 0;

    /**
     * The maximum z coordinate. This value will used for calculating center z coordinate of building.
     */
    this.min_Z = 0;

  }


  /**
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_1.prototype.parsingNodeData = function(jsonresponse) {

    var nodes = [];

    /** Extracting state members */
    var sm = jsonresponse.value.multiLayeredGraph.spaceLayers["0"].spaceLayerMember["0"].spaceLayer.nodes["0"].stateMember;
    var smLen = sm.length;

    for (var j = 0; j < smLen; j++) {

      var coordinates = sm[j].state.geometry.point.pos.value;
      var stateMemberObject = new StateMember(coordinates);

      /** Adding the state member to the nodes array */
      nodes.push(stateMemberObject);
    }

    return nodes;
  };



  /**
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_1.prototype.parsingEdgeData = function(jsonresponse) {

    var edges = [];

    /** Extracting transition members */
    var tm = jsonresponse.value.multiLayeredGraph.spaceLayers["0"].spaceLayerMember["0"].spaceLayer.edges["0"].transitionMember;

    /** Loop through transition Members and extracting connection, description and state members of each transition member */
    for (var i = 0; i < tm.length; i++) {

      /** Array of connections of a transition member */
      var connects = [];

      /** Getting the href of each connection */
      for (var j = 0; j < tm[i].transition.connects.length; j++) {
        connects.push(tm[i].transition.connects[j].href);
      }

      /** Description of a transition member */
      var description;
      if (tm[i].transition.description != null) {
        description = tm[i].transition.description.value;
      }


      /** Array of state members */
      var stateMembers = [];

      /** Getting coordinates of each state member */
      for (var k = 0; k < tm[i].transition.geometry.abstractCurve.value.posOrPointPropertyOrPointRep.length; k++) {
        /** Creating a state member instance*/

        var coordinates = tm[i].transition.geometry.abstractCurve.value.posOrPointPropertyOrPointRep[k].value.value;
        var smObject = new StateMember(coordinates);


        // smObject.coordinates.push(coordinates[0], coordinates[1], coordinates[2]);
        stateMembers.push(smObject);
      }


      /** Creating a transition member instance */
      var transitionMemberObject = new TransitionMember(connects, description, stateMembers);


      /** Adding the transition member to edges array */
      edges.push(transitionMemberObject);
    }

    return edges;
  };



  /**
   * Abstract cellSpaceMember data from JSON object and save it as cellSpaceMembers
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_1.prototype.parsingCellSpaceMember = function(jsonresponse) {

    var cellSpaceMembers = [];

    var cellSpaceMemberLen = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceMember.length;

    for (var i = 0; i < cellSpaceMemberLen; i++) {

      /** Cell space member */
      var csm = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceMember[i];

      /** Extracting the description of the cell space member */
      var description = "";
      if (csm.abstractFeature.value.description != null) {
        description = csm.abstractFeature.value.description.value;
      }

      var id = "";
      if (csm.abstractFeature.value.id != null) {
        id = csm.abstractFeature.value.id;
      }

      /** Extracting the href of the cell space member */
      var href = "";
      if (csm.abstractFeature.value.duality.href != null) {
        href = csm.abstractFeature.value.duality.href;
      }


      /** Creating an instance of the cell space member */
      var csmObject = new CellSpaceMember(description, href, id, []);

      /** Number of surface members */
      if (csm.abstractFeature.value.geometry3D != null) {
        csmObject.surfaceMember = this.getCsmSurfaceMemberFromGeometry3D(csm);
      } else if (csm.abstractFeature.value.geometry2D != null) {
        csmObject.surfaceMember = this.getCsmSurfaceMemberFromGeometry2D(csm);
      }


      /** Filling the array with the cell space member instancesBut the problem with outline has not been solved yet. */
      cellSpaceMembers.push(csmObject);
    }

    return cellSpaceMembers;
  };



  /**
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_1.prototype.parsingCellSpaceBoundaryMember = function(jsonresponse) {
    var cellSpaceBoundaryMembers = [];
    var cellSpaceBoundaryMemberLen = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceBoundaryMember.length;

    for (var i = 0; i < cellSpaceBoundaryMemberLen; i++) {

      var csbm = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceBoundaryMember[i];

      var description = "";
      if (csbm.abstractFeature.value.description != null) {
        description = csbm.abstractFeature.value.description.value;
      }

      var id = "";
      if (csbm.abstractFeature.value.id != null) {
        id = csbm.abstractFeature.value.id;
      }

      /** Extracting the href of the cell space member */
      var href = "";
      if (csbm.abstractFeature.value.duality != null) {
        href = csbm.abstractFeature.value.duality.href;
      }

      /** Creating an instance of the cell space member */
      var csbmObject = new CellSpaceMember(description, href, id, []);

      /** Number of surface members */
      if (csbm.abstractFeature.value.geometry3D != null) {
        csbmObject.surfaceMember = this.getCsbmSurfaceMemberFromGeometry3D(csbm);
      }

      cellSpaceBoundaryMembers.push(csbmObject);
    }

    return cellSpaceBoundaryMembers;
  };



  /**
   * Extract surfaceMember of cellSpaceMember from the JSON object when the surface of the given GML file is configured with geometry3D.
   * @param {Object} csm CellSpaceMember, cellSpaceMember part of jsonresponse.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_1.prototype.getCsmSurfaceMemberFromGeometry3D = function(csm) {
    /** get surface MemberLen */
    var surfaceMemberLen = csm.abstractFeature.value.geometry3D.abstractSolid.value.exterior.shell.surfaceMember.length;

    var surfaceMembers = [];

    /** Loop through the surface members and creating instances */
    for (var j = 0; j < surfaceMemberLen; j++) {

      /** Surface member */
      var sm = csm.abstractFeature.value.geometry3D.abstractSolid.value.exterior.shell.surfaceMember[j];

      /** Creating an instance of the surface member */
      var smObject = new SurfaceMember([]);

      /** Number of coordinates of the surface member */
      var coordLen = sm.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep.length;

      var value = sm.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep;

      /** Loop through the coordinates of a surfaceMember */
      for (var k = 0; k < coordLen; k++) {
        smObject = this.abstractCoordinate(value[k].value.value, smObject);
      }

      /** Adding the surface member to the corresponding cell space member */
      surfaceMembers.push(smObject);
    }
    return surfaceMembers;
  }



  /**
   * Extract surfaceMember of cellSpaceMember from the JSON object when the surface of the given GML file is configured with geometry2D.
   * @param {Object} csm CellSpaceMember, cellSpaceMember part of jsonresponse.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_1.prototype.getCsmSurfaceMemberFromGeometry2D = function(csm) {

    var surfaceMembers = [];

    /** abstractRing */
    var ar = csm.abstractFeature.value.geometry2D.abstractSurface.value.exterior.abstractRing;

    /** Creating an instance of abstractRing */
    var arObject = new SurfaceMember([]);

    /** Number of coordinates of the surface member */
    var coordLen = ar.value.posOrPointPropertyOrPointRep.length;

    /** Loop through the coordinates of a surfaceMember */
    for (var i = 0; i < coordLen; i++) {
      arObject = this.abstractCoordinate(ar.value.posOrPointPropertyOrPointRep[i].value.value, arObject);
    }

    surfaceMembers.push(arObject);

    return surfaceMembers;
  }



  /**
   * Extract surfaceMember of cellSpaceBoundaryMember from the JSON object when the surface of the given GML file is configured with geometry3D.
   * @param {Object} csm cellSpaceBoundaryMember, cellSpaceBoundaryMember part of jsonresponse.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_1.prototype.getCsbmSurfaceMemberFromGeometry3D = function(csbm) {

    var smObject = new SurfaceMember([]);

    var surfaceMembers = [];

    if (csbm.abstractFeature.value.geometry3D.abstractSurface.value.exterior != null) {

      var coordLen = csbm.abstractFeature.value.geometry3D.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep.length;
      for (var k = 0; k < coordLen; k++) {
        smObject = this.abstractCoordinate(csbm.abstractFeature.value.geometry3D.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep[k].value.value, smObject);
      }
    }

    surfaceMembers.push(smObject);

    return surfaceMembers;
  }



  /**
   * Abstract coordinates from value and save it in object.coordinates
   * @param {Array} value array of coordinates.
   * @param {SurfaceMember} object The coordinates obtained from value are stored in object.coordinates.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_1.prototype.abstractCoordinate = function(value, object) {

    /** Extracting X */
    var X = value[0];
    object.coordinates.push(X);


    /** Test if X is maximum or minimum */
    if (X > this.max_X) {
      this.max_X = X;
    } else if (X < this.min_X) {
      this.min_X = X;
    }

    /** Extracting Y */
    var Y = value[1];
    object.coordinates.push(Y);

    if (Y > this.max_Y) {
      this.max_Y = Y;
    } else if (Y < this.min_Y) {
      this.min_Y = Y;
    }

    /** Extracting Z */
    var Z = value[2];
    object.coordinates.push(Z);

    if (Z > this.max_Z) {
      this.max_Z = Z;
    } else if (Z < this.min_Z) {
      this.min_Z = Z;
    }

    return object;
  }

  JsonParsor_1_0_1.prototype.getMaxX = function(){
    return this.max_X;
  }

  JsonParsor_1_0_1.prototype.getMaxY = function(){
    return this.max_Y;
  }

  JsonParsor_1_0_1.prototype.getMaxZ = function(){
    return this.max_Z;
  }

  JsonParsor_1_0_1.prototype.getMinX = function(){
    return this.min_X;
  }

  JsonParsor_1_0_1.prototype.getMinY = function(){
    return this.min_Y;
  }

  JsonParsor_1_0_1.prototype.getMinZ = function(){
    return this.min_Z;
  }



/**
  * @module JsonParsor_1_0_3
  */

  'use strict';


  /**
   * @alias module:JsonParsor_1_0_3
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  function JsonParsor_1_0_3(jsonresponse) {

    /**
     * JSON object parsed from inputed json data file.</br>
     * Inputed json data file is converted from IndoorGML file.</br>
     * You can convert IndoorGML to json through 'gmlToJson' in our git hub project.
     */
    this.jsonresponse = jsonresponse;

    /**
     * The maximum x coordinate. This value will used for calculating center x coordinate of building.
     */
    this.max_X = 0;

    /**
     * The maximum y coordinate. This value will used for calculating center y coordinate of building.
     */
    this.max_Y = 0;

    /**
     * The maximum z coordinate. This value will used for calculating center z coordinate of building.
     */
    this.max_Z = 0;



    /**
     * The maximum x coordinate. This value will used for calculating center x coordinate of building.
     */
    this.min_X = 0;

    /**
     * The maximum y coordinate. This value will used for calculating center y coordinate of building.
     */
    this.min_Y = 0;

    /**
     * The maximum z coordinate. This value will used for calculating center z coordinate of building.
     */
    this.min_Z = 0;

  }


  /**
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_3.prototype.parsingNodeData = function(jsonresponse) {

    var nodes = [];

    /** Extracting state members */
    var sm = jsonresponse.value.multiLayeredGraph.multiLayeredGraph.spaceLayers["0"].spaceLayerMember["0"].spaceLayer.nodes["0"].stateMember;
    var smLen = sm.length;

    for (var j = 0; j < smLen; j++) {

      var coordinates = sm[j].state.geometry.point.pos.value;
      var stateMemberObject = new StateMember(coordinates);
	  
	  // Son 20181121.*******************************************
	  stateMemberObject.id = sm[j].state.id;
	  // End Son 20181121.---------------------------------------

      /** Adding the state member to the nodes array */
      nodes.push(stateMemberObject);
    }

    return nodes;
  };



  /**
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_3.prototype.parsingEdgeData = function(jsonresponse) {

    var edges = [];

    /** Extracting transition members */
    var tm = jsonresponse.value.multiLayeredGraph.multiLayeredGraph.spaceLayers["0"].spaceLayerMember["0"].spaceLayer.edges["0"].transitionMember;

    /** Loop through transition Members and extracting connection, description and state members of each transition member */
    for (var i = 0; i < tm.length; i++) {

      /** Array of connections of a transition member */
      var connects = [];

      /** Getting the href of each connection */
      for (var j = 0; j < tm[i].transition.connects.length; j++) {
        connects.push(tm[i].transition.connects[j].href);
      }

      /** Description of a transition member */
      var description;
      if (tm[i].transition.description != null) {
        description = tm[i].transition.description.value;
      }


      /** Array of state members */
      var stateMembers = [];

      /** Getting coordinates of each state member */
      for (var k = 0; k < tm[i].transition.geometry.abstractCurve.value.posOrPointPropertyOrPointRep.length; k++) {
        /** Creating a state member instance*/

        var coordinates = tm[i].transition.geometry.abstractCurve.value.posOrPointPropertyOrPointRep[k].value.value;
        var smObject = new StateMember(coordinates);

		// Son 20181121.*******************************************
		//smObject.id = tm[i].transition.id;
		// End Son 20181121.---------------------------------------

        // smObject.coordinates.push(coordinates[0], coordinates[1], coordinates[2]);
        stateMembers.push(smObject);
      }


      /** Creating a transition member instance */
      var transitionMemberObject = new TransitionMember(connects, description, stateMembers);


      /** Adding the transition member to edges array */
      edges.push(transitionMemberObject);
    }

    return edges;
  };



  /**
   * Abstract cellSpaceMember data from JSON object and save it as cellSpaceMembers
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_3.prototype.parsingCellSpaceMember = function(jsonresponse) {

    var cellSpaceMembers = [];

    var cellSpaceMemberLen = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceMember.length;

    for (var i = 0; i < cellSpaceMemberLen; i++) {

      /** Cell space member */
      var csm = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceMember[i];

      /** Extracting the description of the cell space member */
      var description = "";
      if (csm.cellSpace.description != null) {
        description = csm.cellSpace.description.value;
      }

      var id = "";
      if (csm.cellSpace.id != null) {
        id = csm.cellSpace.id;
      }

      /** Extracting the href of the cell space member */
      var href = "";
      if (csm.cellSpace.duality.href != null) {
        href = csm.cellSpace.duality.href;
      }


      /** Creating an instance of the cell space member */
      var csmObject = new CellSpaceMember(description, href, id, []);

      /** Number of surface members */
      if (csm.cellSpace.cellSpaceGeometry.geometry3D != null) {
        csmObject.surfaceMember = this.getCsmSurfaceMemberFromGeometry3D(csm);
      } else if (csm.cellSpace.cellSpaceGeometry.geometry2D != null) {
        csmObject.surfaceMember = this.getCsmSurfaceMemberFromGeometry2D(csm);
      }


      /** Filling the array with the cell space member instancesBut the problem with outline has not been solved yet. */
      cellSpaceMembers.push(csmObject);
    }

    return cellSpaceMembers;
  };



  /**
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_3.prototype.parsingCellSpaceBoundaryMember = function(jsonresponse) {
    var cellSpaceBoundaryMembers = [];
    var cellSpaceBoundaryMemberLen = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceBoundaryMember.length;

    for (var i = 0; i < cellSpaceBoundaryMemberLen; i++) {

      var csbm = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceBoundaryMember[i];

      var description = "";
      if (csbm.cellSpaceBoundary.description != null) {
        description = csbm.cellSpaceBoundary.description.value;
      }

      var id = "";
      if (csbm.cellSpaceBoundary.id != null) {
        id = csbm.cellSpaceBoundary.id;
      }

      /** Extracting the href of the cell space member */
      var href = "";
      if (csbm.cellSpaceBoundary.duality != null) {
        href = csbm.cellSpaceBoundary.duality.href;
      }

      /** Creating an instance of the cell space member */
      var csbmObject = new CellSpaceMember(description, href, id, []);

      /** Number of surface members */
      if (csbm.cellSpaceBoundary.cellSpaceBoundaryGeometry.geometry3D != null) {
        csbmObject.surfaceMember = this.getCsbmSurfaceMemberFromGeometry3D(csbm);
      }

      cellSpaceBoundaryMembers.push(csbmObject);
    }

    return cellSpaceBoundaryMembers;
  };



  /**
   * Extract surfaceMember of cellSpaceMember from the JSON object when the surface of the given GML file is configured with geometry3D.
   * @param {Object} csm CellSpaceMember, cellSpaceMember part of jsonresponse.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_3.prototype.getCsmSurfaceMemberFromGeometry3D = function(csm) {
    /** get surface MemberLen */
    var surfaceMemberLen = csm.cellSpace.cellSpaceGeometry.geometry3D.abstractSolid.value.exterior.shell.surfaceMember.length;

    var surfaceMembers = [];

    /** Loop through the surface members and creating instances */
    for (var j = 0; j < surfaceMemberLen; j++) {

      /** Surface member */
      var sm = csm.cellSpace.cellSpaceGeometry.geometry3D.abstractSolid.value.exterior.shell.surfaceMember[j];

      /** Creating an instance of the surface member */
      var smObject = new SurfaceMember([]);

      /** Number of coordinates of the surface member */
      var coordLen = sm.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep.length;

      var value = sm.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep;

      /** Loop through the coordinates of a surfaceMember */
      for (var k = 0; k < coordLen; k++) {
        smObject = this.abstractCoordinate(value[k].value.value, smObject);
      }

      /** Adding the surface member to the corresponding cell space member */
      surfaceMembers.push(smObject);
    }
    return surfaceMembers;
  }



  /**
   * Extract surfaceMember of cellSpaceMember from the JSON object when the surface of the given GML file is configured with geometry2D.
   * @param {Object} csm CellSpaceMember, cellSpaceMember part of jsonresponse.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_3.prototype.getCsmSurfaceMemberFromGeometry2D = function(csm) {

    var surfaceMembers = [];

    /** abstractRing */
    var ar = csm.cellSpace.cellSpaceGeometry.geometry2D.abstractSurface.value.exterior.abstractRing;

    /** Creating an instance of abstractRing */
    var arObject = new SurfaceMember([]);

    /** Number of coordinates of the surface member */
    var coordLen = ar.value.posOrPointPropertyOrPointRep.length;

    /** Loop through the coordinates of a surfaceMember */
    for (var i = 0; i < coordLen; i++) {
      arObject = this.abstractCoordinate(ar.value.posOrPointPropertyOrPointRep[i].value.value, arObject);
    }

    surfaceMembers.push(arObject);

    return surfaceMembers;
  }



  /**
   * Extract surfaceMember of cellSpaceBoundaryMember from the JSON object when the surface of the given GML file is configured with geometry3D.
   * @param {Object} csm cellSpaceBoundaryMember, cellSpaceBoundaryMember part of jsonresponse.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_3.prototype.getCsbmSurfaceMemberFromGeometry3D = function(csbm) {

    var smObject = new SurfaceMember([]);

    var surfaceMembers = [];

    if (csbm.cellSpaceBoundary.cellSpaceBoundaryGeometry.geometry3D.abstractSurface.value.exterior != null) {

      var coordLen = csbm.cellSpaceBoundary.cellSpaceBoundaryGeometry.geometry3D.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep.length;
      for (var k = 0; k < coordLen; k++) {
        smObject = this.abstractCoordinate(csbm.cellSpaceBoundary.cellSpaceBoundaryGeometry.geometry3D.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep[k].value.value, smObject);
      }
    }

    surfaceMembers.push(smObject);

    return surfaceMembers;
  }



  /**
   * Abstract coordinates from value and save it in object.coordinates
   * @param {Array} value array of coordinates.
   * @param {SurfaceMember} object The coordinates obtained from value are stored in object.coordinates.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_3.prototype.abstractCoordinate = function(value, object) {

    /** Extracting X */
    var X = value[0];
    object.coordinates.push(X);


    /** Test if X is maximum or minimum */
    if (X > this.max_X) {
      this.max_X = X;
    } else if (X < this.min_X) {
      this.min_X = X;
    }

    /** Extracting Y */
    var Y = value[1];
    object.coordinates.push(Y);

    if (Y > this.max_Y) {
      this.max_Y = Y;
    } else if (Y < this.min_Y) {
      this.min_Y = Y;
    }

    /** Extracting Z */
    var Z = value[2];
    object.coordinates.push(Z);

    if (Z > this.max_Z) {
      this.max_Z = Z;
    } else if (Z < this.min_Z) {
      this.min_Z = Z;
    }

    return object;
  }

  JsonParsor_1_0_3.prototype.getMaxX = function(){
    return this.max_X;
  }

  JsonParsor_1_0_3.prototype.getMaxY = function(){
    return this.max_Y;
  }

  JsonParsor_1_0_3.prototype.getMaxZ = function(){
    return this.max_Z;
  }

  JsonParsor_1_0_3.prototype.getMinX = function(){
    return this.min_X;
  }

  JsonParsor_1_0_3.prototype.getMinY = function(){
    return this.min_Y;
  }

  JsonParsor_1_0_3.prototype.getMinZ = function(){
    return this.min_Z;
  }





    'use strict';

    /**
     * Objects storing CellSpaceMember in IndoorGML
     * @exports CellSpaceMember
     * @constructor
     * @param {string} description description of CellSpaceMember
     * @param {string} href href of CellSpaceMember
     * @param {string} id id of CellSpaceMember
     * @param {Array} surfaceMember Array of {@link SurfaceMember}
     */
    function CellSpaceMember(description, href, id, surfaceMember) {

      /** Description contains information about section and floor ... etc */
    	this.description = description;

      /** Duality.</br> This will work as a key of cell that distinguse one cell to this other. */
    	this.href = href;

    	this.id = id;

      /** Array of surface members */
    	this.surfaceMember = surfaceMember;

      /**
       * This means what role it plays.</br>
       * This value will be parsed from description.</br>
       * If description doesn't mention usage, this remains empty.
       */
      this.usage = "";
      if(description.indexOf("Usage=") != -1){
        var usageStart = description.indexOf("Usage=") + 6;
        this.usage = description.substring(usageStart, description.indexOf(":", usageStart));
      }

      /**
       * This is the section value to which the current cell belongs.</br>
       * This value will be parsed from description.</br>
       * If description doesn't mention section, this remains empty.</br>
       * You can change this value to information about the cells that your IndoorGML file contains.
       */
      this.section = "";
      if(description.indexOf("Section=") != -1){
        var sectionStart = description.indexOf("Section=") + 8;
        this.section = description.substring(sectionStart, description.indexOf(":", sectionStart));
      }

      /**
       * This is the floor value to which the current cell belongs.</br>
       * This value will be parsed from description.</br>
       * If description doesn't mention floor, this remains empty.</br>
       * You can change this value to information about the cells that your IndoorGML file contains.
       */
      this.floor = "";
      if(description.indexOf("Floor=") != -1){
        var floorStart = description.indexOf("Floor=") + 6;
        this.floor = description.substring(floorStart);
      }
    }



    'use strict';

    /**
     * State Member Class. This can be thought of as simply a node.
     * @exports StateMember
     * @constructor
     */
    function StateMember(coordinates) {

      /** Array of coordinates*/
      this.coordinates = coordinates;
      
    }




    'use strict';

    /**
     * Objects storing CellSpaceMember in IndoorGML.
     * Creating the surfaceMember Class.
     * @exports SurfaceMember
     * @constructor
     * @param {Coordinate} coordinates
     */
    function SurfaceMember(coordinates) {

      /** Array of surfaceMember coordinates */
      this.coordinates = coordinates;

    }




    'use strict';


    /**
     * Transition member Class. This can be thought of as simply a edge.
     * @exports TransitionMember
     * @constructor
     */
    function TransitionMember(connects, description, coordinates) {

      /**
       * Array of href.</br>
       * This means two nodes constituting an edge.
       */
      this.connects = connects;

      /**
       * information about section and floor...etc
       */
      this.description = description;

      /** Array of state members, each state member has X,Y,Z coordinates */
      this.stateMembers = coordinates;

      if(description != null){

        /**
         * This means what role it plays.</br>
         * This value will be parsed from description.</br>
         * If description doesn't mention usage, this remains empty.
         */
        this.usage = "";
        if(description.indexOf("Usage=") != -1){
          var usageStart = description.indexOf("Usage=") + 6;
          this.usage = description.substring(usageStart, description.indexOf(":", usageStart));
        }


        /**
         * This is the section value to which the current cell belongs.</br>
         * This value will be parsed from description.</br>
         * If description doesn't mention section, this remains empty.</br>
         * You can change this value to information about the cells that your IndoorGML file contains.
         */
        this.section = "";
        if(description.indexOf("Section=") != -1){
          var sectionStart = description.indexOf("Section=") + 8;
          this.section = description.substring(sectionStart, description.indexOf(":", sectionStart));
        }


        /**
         * This is the floor value to which the current cell belongs.</br>
         * This value will be parsed from description.</br>
         * If description doesn't mention floor, this remains empty.</br>
         * You can change this value to information about the cells that your IndoorGML file contains.
         */
        this.floor = "";
        if(description.indexOf("Floor=") != -1){
          var floorStart = description.indexOf("Floor=") + 6;
          this.floor = description.substring(floorStart);
        }

      }
    }



	var _mago3d = {
		VERSION: '2.0',
	};
	_mago3d['ColorAPI'] = ColorAPI;
	_mago3d['DrawAPI'] = DrawAPI;
	_mago3d['LocationAndRotationAPI'] = LocationAndRotationAPI;
	_mago3d['LodAPI'] = LodAPI;
	_mago3d['AnimationData'] = AnimationData;
	_mago3d['AnimationManager'] = AnimationManager;
	_mago3d['Atmosphere'] = Atmosphere;
	_mago3d['BoundingBox'] = BoundingBox;
	_mago3d['BoundingSphere'] = BoundingSphere;
	_mago3d['Box'] = Box;
	_mago3d['BuildingSeed'] = BuildingSeed;
	_mago3d['BuildingSeedList'] = BuildingSeedList;
	_mago3d['Camera'] = Camera;
	_mago3d['CCTV'] = CCTV;
	_mago3d['CCTVList'] = CCTVList;
	_mago3d['Color'] = Color;
	_mago3d['FBO'] = FBO;
	_mago3d['FileRequestControler'] = FileRequestControler;
	_mago3d['FirstPersonView'] = FirstPersonView;
	_mago3d['Frustum'] = Frustum;
	_mago3d['FrustumVolumeControl'] = FrustumVolumeControl;
	_mago3d['GeographicCoord'] = GeographicCoord;
	_mago3d['GeographicCoordsList'] = GeographicCoordsList;
	_mago3d['GeographicExtent'] = GeographicExtent;
	_mago3d['GeoLocationData'] = GeoLocationData;
	_mago3d['GeoLocationDataManager'] = GeoLocationDataManager;
	_mago3d['Globe'] = Globe;
	_mago3d['MagoManager'] = MagoManager;
	_mago3d['ManagerFactory'] = ManagerFactory;
	_mago3d['Matrix4'] = Matrix4;
	_mago3d['Message'] = Message;
	_mago3d['MouseAction'] = MouseAction;
	_mago3d['ObjectMarker'] = ObjectMarker;
	_mago3d['OcclusionCullingOctree'] = OcclusionCullingOctree;
	_mago3d['OcclusionCullingOctreeCell'] = OcclusionCullingOctreeCell;
	_mago3d['Pin'] = Pin;
	_mago3d['Plane'] = Plane;
	_mago3d['Quaternion'] = Quaternion;
	_mago3d['SelectionColor'] = SelectionColor;
	_mago3d['SmartTile'] = SmartTile;
	_mago3d['SmartTileManager'] = SmartTileManager;
	_mago3d['Sphere'] = Sphere;
	_mago3d['SplitValue'] = SplitValue;
	_mago3d['TerranTile'] = TerranTile;
	_mago3d['Texture'] = Texture;
	_mago3d['TexturesManager'] = TexturesManager;
	_mago3d['TriPolyhedron'] = TriPolyhedron;
	_mago3d['TriSurface'] = TriSurface;
	_mago3d['VboBuffer'] = VboBuffer;
	_mago3d['VBOKeysNation'] = VBOKeysNation;
	_mago3d['VBOKeysStore'] = VBOKeysStore;
	_mago3d['VBOKeysWorld'] = VBOKeysWorld;
	_mago3d['VBOMemoryManager'] = VBOMemoryManager;
	_mago3d['VBOVertexIdxCacheKey'] = VBOVertexIdxCacheKey;
	_mago3d['VBOVertexIdxCacheKeysContainer'] = VBOVertexIdxCacheKeysContainer;
	_mago3d['VisibleObjectsController'] = VisibleObjectsController;
	_mago3d['API'] = API;
	_mago3d['ChangeHistory'] = ChangeHistory;
	_mago3d['CODE'] = CODE;
	_mago3d['Constant'] = Constant;
	_mago3d['MagoConfig'] = MagoConfig;
	_mago3d['Policy'] = Policy;
	_mago3d['Accessor'] = Accessor;
	_mago3d['Block'] = Block;
	_mago3d['BlocksArrayPartition'] = BlocksArrayPartition;
	_mago3d['BlocksList'] = BlocksList;
	_mago3d['HierarchyManager'] = HierarchyManager;
	_mago3d['InspectorBox'] = InspectorBox;
	_mago3d['Lego'] = Lego;
	_mago3d['LoadQueue'] = LoadQueue;
	_mago3d['LodBuildingData'] = LodBuildingData;
	_mago3d['MetaData'] = MetaData;
	_mago3d['ModelReferencedGroup'] = ModelReferencedGroup;
	_mago3d['NeoBuilding'] = NeoBuilding;
	_mago3d['NeoBuildingsList'] = NeoBuildingsList;
	_mago3d['NeoReference'] = NeoReference;
	_mago3d['NeoReferencesMotherAndIndices'] = NeoReferencesMotherAndIndices;
	_mago3d['NeoSimpleBuilding'] = NeoSimpleBuilding;
	_mago3d['NeoTexture'] = NeoTexture;
	_mago3d['Node'] = Node;
	_mago3d['Octree'] = Octree;
	_mago3d['ParseQueue'] = ParseQueue;
	_mago3d['ProcessQueue'] = ProcessQueue;
	_mago3d['ProjectTree'] = ProjectTree;
	_mago3d['ReaderWriter'] = ReaderWriter;
	_mago3d['TinTerrain'] = TinTerrain;
	_mago3d['TinTerrainManager'] = TinTerrainManager;
	_mago3d['Arc2D'] = Arc2D;
	_mago3d['AxisXYZ'] = AxisXYZ;
	_mago3d['BoundingRectangle'] = BoundingRectangle;
	_mago3d['BoxAux'] = BoxAux;
	_mago3d['Circle2D'] = Circle2D;
	_mago3d['CuttingPlane'] = CuttingPlane;
	_mago3d['Ellipsoid'] = Ellipsoid;
	_mago3d['Excavation'] = Excavation;
	_mago3d['Face'] = Face;
	_mago3d['HalfEdge'] = HalfEdge;
	_mago3d['HalfEdgesList'] = HalfEdgesList;
	_mago3d['IndexData'] = IndexData;
	_mago3d['IndexRange'] = IndexRange;
	_mago3d['Intersect'] = Intersect;
	_mago3d['Line'] = Line;
	_mago3d['Line2D'] = Line2D;
	_mago3d['MagoNativeProject'] = MagoNativeProject;
	_mago3d['MagoWorld'] = MagoWorld;
	_mago3d['Mesh'] = Mesh;
	_mago3d['Modeler'] = Modeler;
	_mago3d['ParametricMesh'] = ParametricMesh;
	_mago3d['PlaneGrid'] = PlaneGrid;
	_mago3d['Point2D'] = Point2D;
	_mago3d['Point2DList'] = Point2DList;
	_mago3d['Point3D'] = Point3D;
	_mago3d['Point3DList'] = Point3DList;
	_mago3d['Point4D'] = Point4D;
	_mago3d['Polygon2D'] = Polygon2D;
	_mago3d['PolyLine2D'] = PolyLine2D;
	_mago3d['PolyLine3D'] = PolyLine3D;
	_mago3d['Profile2D'] = Profile2D;
	_mago3d['Profiles2DList'] = Profiles2DList;
	_mago3d['Rectangle2D'] = Rectangle2D;
	_mago3d['Ring2D'] = Ring2D;
	_mago3d['Ring2DList'] = Ring2DList;
	_mago3d['RingType'] = RingType;
	_mago3d['Segment2D'] = Segment2D;
	_mago3d['Segment3D'] = Segment3D;
	_mago3d['Star2D'] = Star2D;
	_mago3d['StaticModel'] = StaticModel;
	_mago3d['Surface'] = Surface;
	_mago3d['Triangle'] = Triangle;
	_mago3d['TrianglesList'] = TrianglesList;
	_mago3d['TrianglesMatrix'] = TrianglesMatrix;
	_mago3d['Tunnel'] = Tunnel;
	_mago3d['Vertex'] = Vertex;
	_mago3d['VertexList'] = VertexList;
	_mago3d['VertexMatrix'] = VertexMatrix;
	_mago3d['VtxProfile'] = VtxProfile;
	_mago3d['VtxProfilesList'] = VtxProfilesList;
	_mago3d['VtxRing'] = VtxRing;
	_mago3d['VtxRingsList'] = VtxRingsList;
	_mago3d['VtxSegment'] = VtxSegment;
	_mago3d['Message'] = Message;
	_mago3d['MessageSource'] = MessageSource;
	_mago3d['Renderer'] = Renderer;
	_mago3d['SceneState'] = SceneState;
	_mago3d['Selection'] = Selection;
	_mago3d['SelectionCandidateFamily'] = SelectionCandidateFamily;
	_mago3d['SelectionManager'] = SelectionManager;
	_mago3d['AttribLocationState'] = AttribLocationState;
	_mago3d['PostFxShader'] = PostFxShader;
	_mago3d['PostFxShadersManager'] = PostFxShadersManager;
	_mago3d['ShaderSource'] = ShaderSource;
	_mago3d['Uniform1fDataPair'] = Uniform1fDataPair;
	_mago3d['Uniform1iDataPair'] = Uniform1iDataPair;
	_mago3d['UniformMatrix4fvDataPair'] = UniformMatrix4fvDataPair;
	_mago3d['UniformVec2fvDataPair'] = UniformVec2fvDataPair;
	_mago3d['UniformVec3fvDataPair'] = UniformVec3fvDataPair;
	_mago3d['UniformVec4fvDataPair'] = UniformVec4fvDataPair;
	_mago3d['Network'] = Network;
	_mago3d['NetworkEdge'] = NetworkEdge;
	_mago3d['NetworkNode'] = NetworkNode;
	_mago3d['NetworkSpace'] = NetworkSpace;
	_mago3d['ByteColor'] = ByteColor;
	_mago3d['defaultValue'] = defaultValue;
	_mago3d['defined'] = defined;
	_mago3d['ManagerUtils'] = ManagerUtils;
	_mago3d['TTriangle'] = TTriangle;
	_mago3d['TTrianglesList'] = TTrianglesList;
	_mago3d['TTrianglesMatrix'] = TTrianglesMatrix;
	_mago3d['GMLDataContainer'] = GMLDataContainer;
	_mago3d['JsonParsor_1_0_1'] = JsonParsor_1_0_1;
	_mago3d['JsonParsor_1_0_3'] = JsonParsor_1_0_3;
	_mago3d['CellSpaceMember'] = CellSpaceMember;
	_mago3d['StateMember'] = StateMember;
	_mago3d['SurfaceMember'] = SurfaceMember;
	_mago3d['TransitionMember'] = TransitionMember;
	return _mago3d;
})();
